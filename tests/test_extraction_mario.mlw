module M

  use import int.Int
  use import seq.Seq

  let function f (y: int) (x: int) : int
    requires { x >= 0 }
    ensures  { result >= 0 }
  = x

  let g (ghost z: int) (x: int) : int
    requires { x > 0 }
    ensures  { result > 0 }
  = let y = x in
    y

  type t 'a 'b 'c 'd

  type list 'a = Nil | Cons 'a (list 'a)

  type btree 'a = E | N (btree 'a) 'a (btree 'a)

  type ntree 'a = Empty | Node 'a (list 'a)

  type list_int = list int

  type cursor 'a = {
    collection : list 'a;
    index      : int;
    mutable index2     : int;
    ghost mutable v : seq 'a;
  }

  let update (c: cursor int) : unit
  = let t = ghost c.v <- empty in t; ()

  exception Empty (list int, int)
  exception Out_of_bounds int

  let rec length (l: list 'a) : int
    variant  { l }
  = match l with
    | Nil -> 0
    | Cons _ r -> 1 + length r
    end

  let t (x:int) : int
    requires { false }
  = absurd

  let a () : unit
  = assert { true }

end

(*
 * Local Variables:
 * compile-command: "make -C .. -j3; ../bin/why3extract -D ../drivers/c.drv -o extract test_extraction_mario.mlw"
 * End:
 *)