theory PowerValue

   function pow_of2 (i:int) : int 

   axiom pow_of2_value:   	 
	pow_of2 0  =   		        1 /\
	pow_of2 1  =                    2 /\
	pow_of2 2  =                    4 /\
	pow_of2 3  =                    8 /\
	pow_of2 4  =                   16 /\
	pow_of2 5  =                   32 /\
	pow_of2 6  =                   64 /\
	pow_of2 7  =                  128 /\
	pow_of2 8  =                  256 /\
	pow_of2 9  =                  512 /\
	pow_of2 10 =                 1024 /\
	pow_of2 11 =                 2048 /\
	pow_of2 12 =                 4096 /\
	pow_of2 13 =                 8192 /\
	pow_of2 14 =                16384 /\
	pow_of2 15 =                32768 /\
	pow_of2 16 =                65536 /\
	pow_of2 17 =               131072 /\
	pow_of2 18 =               262144 /\
	pow_of2 19 =               524288 /\
	pow_of2 20 =              1048576 /\
	pow_of2 21 =              2097152 /\
	pow_of2 22 =              4194304 /\
	pow_of2 23 =              8388608 /\
	pow_of2 24 =             16777216 /\
	pow_of2 25 =             33554432 /\
	pow_of2 26 =             67108864 /\
	pow_of2 27 =            134217728 /\
	pow_of2 28 =            268435456 /\
	pow_of2 29 =            536870912 /\
	pow_of2 30 =           1073741824 /\
	pow_of2 31 =           2147483648 /\
	pow_of2 32 =           4294967296 /\
	pow_of2 33 =           8589934592 /\
	pow_of2 34 =          17179869184 /\
	pow_of2 35 =          34359738368 /\
	pow_of2 36 =          68719476736 /\
	pow_of2 37 =         137438953472 /\
	pow_of2 38 =         274877906944 /\
	pow_of2 39 =         549755813888 /\
	pow_of2 40 =        1099511627776 /\
	pow_of2 41 =        2199023255552 /\
	pow_of2 42 =        4398046511104 /\
	pow_of2 43 =        8796093022208 /\
	pow_of2 44 =       17592186044416 /\
	pow_of2 45 =       35184372088832 /\
	pow_of2 46 =       70368744177664 /\
	pow_of2 47 =      140737488355328 /\
	pow_of2 48 =      281474976710656 /\
	pow_of2 49 =      562949953421312 /\
	pow_of2 50 =     1125899906842624 /\
	pow_of2 51 =     2251799813685248 /\
	pow_of2 52 =     4503599627370496 /\
	pow_of2 53 =     9007199254740992 /\
	pow_of2 54 =    18014398509481984 /\
	pow_of2 55 =    36028797018963968 /\
	pow_of2 56 =    72057594037927936 /\
	pow_of2 57 =   144115188075855872 /\
	pow_of2 58 =   288230376151711744 /\
	pow_of2 59 =   576460752303423488 /\
	pow_of2 60 =  1152921504606846976 /\
	pow_of2 61 =  2305843009213693952 /\
	pow_of2 62 =  4611686018427387904 /\
	pow_of2 63 =  9223372036854775808 

end

theory BitVector

  use export bool.Bool
  use import int.Int
  use import PowerValue
  function size : int

  type bv

  function nth bv int: bool

  function bvzero : bv
  axiom Nth_zero:
    forall n:int. 0 <= n < size -> nth bvzero n = False

  function bvone : bv
  axiom Nth_one:
    forall n:int. 0 <= n < size -> nth bvone n = True

  predicate eq (v1 v2 : bv) =
    forall n:int. 0 <= n < size -> nth v1 n = nth v2 n

  axiom extensionality:
    forall v1 v2 : bv. eq v1 v2 -> v1 = v2

  function bw_and (v1 v2 : bv) : bv
  axiom Nth_bw_and:
    forall v1 v2:bv, n:int. 0 <= n < size ->
      nth (bw_and v1 v2) n = andb (nth v1 n) (nth v2 n)

  function bw_or (v1 v2 : bv) : bv
  axiom Nth_bw_or:
    forall v1 v2:bv, n:int. 0 <= n < size ->
      nth (bw_or v1 v2) n = orb (nth v1 n) (nth v2 n)

  function bw_xor (v1 v2 : bv) : bv
  axiom Nth_bw_xor:
    forall v1 v2:bv, n:int. 0 <= n < size ->
      nth (bw_xor v1 v2) n = xorb (nth v1 n) (nth v2 n)

  axiom Nth_bw_xor_v1true:
    forall v1 v2:bv, n:int. 0 <= n < size /\ nth v1 n = True->
      nth (bw_xor v1 v2) n = notb (nth v2 n)
  axiom Nth_bw_xor_v1false:
    forall v1 v2:bv, n:int. 0 <= n < size /\ nth v1 n = False->
      nth (bw_xor v1 v2) n = nth v2 n

  axiom Nth_bw_xor_v2true:
    forall v1 v2:bv, n:int. 0 <= n < size /\ nth v2 n = True->
      nth (bw_xor v1 v2) n = notb (nth v1 n)
  axiom Nth_bw_xor_v2false:
    forall v1 v2:bv, n:int. 0 <= n < size /\ nth v2 n = False->
      nth (bw_xor v1 v2) n = nth v1 n


  function bw_not (v : bv) : bv
  axiom Nth_bw_not:
    forall v:bv, n:int. 0 <= n < size ->
      nth (bw_not v) n = notb (nth v n)

  (* logical shift right *)
  function lsr bv int : bv

  axiom lsr_nth_low:
    forall b:bv, n s:int.
      0 <= n < size -> 0 <= s ->
        n+s < size -> nth (lsr b s) n = nth b (n+s)

  axiom lsr_nth_high:
    forall b:bv, n s:int.
      0 <= n < size -> 0 <= s ->
        n+s >= size -> nth (lsr b s) n = False

  (* arithmetic shift right *)
  function asr bv int : bv

  axiom asr_nth_low:
    forall b:bv, n s:int.
      0 <= n < size -> 0 <= s ->
        n+s < size -> nth (asr b s) n = nth b (n+s)

  axiom asr_nth_high:
    forall b:bv, n s:int.
      0 <= n < size -> 0 <= s ->
        n+s >= size -> nth (asr b s) n = nth b (size-1)

  (* logical shift left *)
  function lsl bv int : bv

  axiom lsl_nth_high:
    forall b:bv, n s:int.
      0 <= n < size -> 0 <= s ->
        0 <= n-s -> nth (lsl b s) n = nth b (n-s)

  axiom lsl_nth_low:
    forall b:bv, n s:int.
      0 <= n < size -> 0 <= s ->
        0 > n-s -> nth (lsl b s) n = False

  (* conversion to/from integers *)

  function to_nat_aux bv int : int
    (* (to_nat_aux b i) returns the non-negative integer whose
       binary repr is b[size-1..i] *)

  axiom to_nat_aux_zero :
    forall b:bv, i:int.
      0 <= i < size ->
        nth b i = False ->
          to_nat_aux b i = 2 * to_nat_aux b (i+1)

  axiom to_nat_aux_one :
    forall b:bv, i:int.
      0 <= i < size ->
        nth b i = True ->
          to_nat_aux b i = 1 + 2 * to_nat_aux b (i+1)

  axiom to_nat_aux_high :
    forall b:bv, i:int.
      i >= size ->
        to_nat_aux b i = 0

  function to_nat (b:bv) : int = to_nat_aux b 0

  (* generalization : (to_nat_sub b j i) returns the non-negative number represented
     by b[j..i] *)

 function to_nat_sub bv int int : int
    (* (to_nat_sub b j i) returns the non-negative integer whose
       binary repr is b[j..i] *)

(*  axiom to_nat_sub_zero :
    forall b:bv, j i:int.
      0 <= i <= j ->
        nth b i = False ->
          to_nat_sub b j i = 2 * to_nat_sub b j (i+1)

  axiom to_nat_sub_one :
    forall b:bv, j i:int.
      0 <= i <= j ->
        nth b i = True ->
          to_nat_sub b j i = 1 + 2 * to_nat_sub b j (i+1)

  axiom to_nat_sub_high :
    forall b:bv, j i:int.
      i > j ->
        to_nat_sub b j i = 0
*)

  axiom to_nat_sub_zero :
    forall b:bv, j i:int.
      0 <= i <= j ->
        nth b j = False ->
          to_nat_sub b j i = to_nat_sub b (j-1) i

  axiom to_nat_sub_one :
    forall b:bv, j i:int.
      0 <= i <= j ->
        nth b j = True ->
          to_nat_sub b j i = (pow_of2 (j-i)) + to_nat_sub b (j-1) i

  axiom to_nat_sub_high :
    forall b:bv, j i:int.
      i > j ->
        to_nat_sub b j i = 0

  lemma to_nat_sub_low_true :
    forall b:bv, j:int.nth b j = True -> to_nat_sub b j j = 1

  lemma to_nat_sub_low_false :
    forall b:bv, j:int.nth b j = False -> to_nat_sub b j j = 0

  lemma to_nat_of_zero:
    forall b:bv, i j:int.
      (forall k:int. j >= k >= i -> nth b k = False) ->
      to_nat_sub b j i = 0

  lemma to_nat_of_one:
    forall b:bv, i j:int.
      (forall k:int. j >= k >= i -> nth b k = True) ->
      to_nat_sub b j i = pow_of2 (j-i+1) - 1

  lemma to_nat_sub_footprint: forall b1 b2:bv, j i:int.
    (forall k:int. i <= k <= j -> nth b1 k = nth b2 k) ->
    to_nat_sub b1 j i = to_nat_sub b2 j i

  (* 2-complement version *)

  function to_int_aux bv int : int
    (* (to_int_aux b i) returns the integer whose
       2-complement binary repr is b[size-1..i] *)

  axiom to_int_aux_zero :
    forall b:bv, i:int.
      0 <= i < size-1 ->
        nth b i = False ->
          to_int_aux b i = 2 * to_int_aux b (i+1)

  axiom to_int_aux_one :
    forall b:bv, i:int.
      0 <= i < size-1 ->
        nth b i = True ->
          to_int_aux b i = 1 + 2 * to_int_aux b (i+1)

  axiom to_int_aux_pos :
    forall b:bv. nth b (size-1) = False ->
         to_int_aux b (size-1) = 0

  axiom to_int_aux_neg :
    forall b:bv. nth b (size-1) = True ->
         to_int_aux b (size-1) = -1

  function to_int (b:bv) : int = to_int_aux b 0

  (* (from_uint n) returns the bitvector representing the non-negative
     integer n on size bits. *)
  function from_int (n:int) : bv

  use import int.EuclideanDivision

(*  axiom nth_from_int_high:
     forall n i:int. size>i > 0 -> nth (from_int n) i = nth (from_int (div n 2)) (i-1)
*)

  axiom nth_from_int_high_even:
     forall n i:int. size > i >= 0 /\ mod (div n (pow_of2 i)) 2 = 0 -> nth (from_int n) i = False

  axiom nth_from_int_high_odd:
     forall n i:int. size > i >= 0 /\ mod (div n (pow_of2 i)) 2 <> 0 -> nth (from_int n) i = True

  lemma nth_from_int_low_even:
    forall n:int. mod n 2 = 0 -> nth (from_int n) 0 = False

  lemma nth_from_int_low_odd:
    forall n:int. mod n 2 <> 0 -> nth (from_int n) 0 = True

  lemma nth_from_int_0:
     forall i:int. size > i >= 0 -> nth (from_int 0) i = False

end


theory BV32

  function size : int = 32

  clone export BitVector with function size = size

end


theory BV64

  function size : int = 64

  clone export BitVector with function size = size

end

theory TestNatSub

  use import BV64

  function b:bv = from_int 7

  lemma to_nat_sub_b: (to_nat_sub b 4 0) = 7

end

theory BV32_64

  use import int.Int

  use BV32
  use BV64

  function concat BV32.bv BV32.bv : BV64.bv

  axiom concat_low: forall b1 b2:BV32.bv.
    forall i:int. 0 <= i < 32 -> BV64.nth (concat b1 b2) i = BV32.nth b2 i

  axiom concat_high: forall b1 b2:BV32.bv.
    forall i:int. 32 <= i < 64 -> BV64.nth (concat b1 b2) i = BV32.nth b1 (i-32)

end

theory BV_double

  use import BV64
  use import real.RealInfix
  use import int.Int
  use import real.Power
  use import real.FromInt
  function double_of_bv64 (b:bv) : real

  (* TODO: axioms 

    real represented by bv =  sign . exp . mantissa

    sign on bit 63

    exp on bits 62..52 

    mantissa on bits 51..0

    si exp = 0 : zero or denormalized, we specify only zero

    si exp = 2047 : infinities or nan, we don't specify anything

    si  1 <= exp <= 2046 : the number represented is

      (-1)^sign * 2^(exp - bias) * (1 + mantissa * 2^(1-prec))

   where bias = 1023, prec = 53
   (e.g. the largest representable number is 2^(2046-1023) * (1+ (2^52-1)* 2^(-52))  =
        2^1023 * (1 + 1 - 2^-52) = 2^1024 - 2^(1023-52) = 2^1024 - 2^971 
)

  *)

  function exp (b:bv) : int = BV64.to_nat_sub b 62 52
  function mantissa (b:bv) : int= BV64.to_nat_sub b 51 0
  function sign (b:bv) : bool = BV64.nth b 63

  function sign_value(s:bool):real

  axiom sign_value_true:
  	sign_value(False) = 1.0

  axiom sign_value_false:
  	sign_value(True) = -.1.0

  axiom zero : forall b:bv.
     exp(b) = 0 /\ mantissa(b) = 0 -> double_of_bv64(b) = 0.0

  axiom sign_of_double_positive:
     forall b:bv. sign b = False -> double_of_bv64(b) >=. 0.0
  axiom sign_of_double_negative:
     forall b:bv. sign b = True -> double_of_bv64(b) <=. 0.0

  axiom double_of_bv64_value:
     forall b:bv. 0 < exp(b) < 2047 ->
       double_of_bv64(b) =  sign_value(sign(b)) *.
                            (pow 2.0 (from_int ((exp b) - 1023))) *.
                            (1.0 +. (from_int (mantissa b)) *. (pow 2.0 (-.52.0)))

  (* TODO *)

end

theory TestDouble

  use import BV64
  use import BV_double
  use import int.Int

  function one:bv = from_int 4607182418800017408 (* 1.0 *)

  lemma nth_one1: forall i:int. 0 <= i <= 51 -> nth one i = False
  lemma nth_one2: forall i:int. 52 <= i <= 61 -> nth one i = True
  lemma nth_one3: forall i:int. 62 <= i <= 63 -> nth one i = False

  lemma sign_one: sign(one) = False
  lemma exp_one: exp(one) = 1023
  lemma mantissa_one: mantissa(one) = 0

  lemma double_value_of_1: double_of_bv64(one) = 1.0

end


theory TestNegAsXOR

  use import BV64
  use import BV_double
  use import int.Int
  use import bool.Bool
  use import real.RealInfix

  function j : bv = from_int 0x8000000000000000

  lemma Nth_j: forall i:int. 0 <= i <= 62 -> nth j i = False

  lemma sign_of_j: sign(j) = True
  lemma mantissa_of_j: mantissa(j) = 0
  lemma exp_of_j: exp(j) = 0
  lemma int_of_bv: double_of_bv64(j) = 0.0

  lemma MainResultBits : forall x:bv. forall i:int. 0 <= i < 63 ->
     nth (bw_xor x j) i = nth x i

  lemma MainResultSign : forall x:bv. nth (bw_xor x j) 63 = notb (nth x 63)

  lemma Sign_of_xor_j : forall x:bv. sign(bw_xor x j) = notb (sign x)

  lemma Exp_of_xor_j : forall x:bv. exp(bw_xor x j) = exp(x)

  lemma Mantissa_of_xor_j : forall x:bv. mantissa(bw_xor x j) = mantissa(x)

  lemma MainResultZero : forall x:bv. 0 = exp(x) /\ mantissa(x) = 0 ->
     double_of_bv64 (bw_xor x j) = -. double_of_bv64 x

  lemma MainResult : forall x:bv. 0 < exp(x) < 2047 ->
     double_of_bv64 (bw_xor x j) = -. double_of_bv64 x


end

theory TestDoubleOfInt

  use BV32
  use BV64
  use BV32_64
  use import bool.Bool
  use import PowerValue
  use import BV_double
  use import real.RealInfix
  use import real.FromInt
  use import real.Power

  function j : BV32.bv = BV32.from_int 0x43300000

  function j' : BV32.bv = BV32.from_int 0x80000000

  function const : BV64.bv = BV32_64.concat j j'

  lemma sign_const: sign(const) = False
  lemma exp_const: exp(const) = 1075
  lemma mantissa_const: mantissa(const) = pow_of2 31

  function const_as_double : real = double_of_bv64 const

  clone import int.Exponentiation with type t = real

  lemma const_value0: const_as_double = 
    pow 2.0 (1075.0 -. 1023.0) *. (1.0 +. 2147483648.0 *. pow 2.0 (-.52.0))

  lemma const_value: const_as_double = pow 2.0 52.0 +. pow 2.0 31.0

  function double_of_int32 (i:int) : real =
     let var = BV32_64.concat j (BV32.bw_xor j' (BV32.from_int i)) in
     let v = double_of_bv64 var in
     v -. const_as_double

  lemma MainResult: forall i:int. double_of_int32 i = from_int i

end

theory TestBv32

  use import BV32
  use import int.Int

  goal Test1:
    let b = bw_and bvzero bvone in nth b 1 = False

  goal Test2:
    let b = lsr bvone 16 in nth b 15 = True

  goal Test3:
    let b = lsr bvone 16 in nth b 16 = False

  goal Test4:
    let b = asr bvone 16 in nth b 15 = True

  goal Test5:
    let b = asr bvone 16 in nth b 16 = True

  goal Test6:
    let b = asr (lsr bvone 1) 16 in nth b 16 = False

  goal to_nat_0x00000000:
    to_nat bvzero = 0

  goal to_nat_0x0000000F:
    to_nat (lsr bvone 28) = 15

  goal to_nat_0x0000001F:
    to_nat (lsr bvone 27) = 31

  goal to_nat_0x0000003F:
    to_nat (lsr bvone 26) = 63

  goal to_nat_0x0000007F:
    to_nat (lsr bvone 25) = 127

  goal to_nat_0x000000FF:
    to_nat (lsr bvone 24) = 255

  goal to_nat_0x000001FF:
    to_nat (lsr bvone 23) = 511

  goal to_nat_0x000003FF:
    to_nat (lsr bvone 22) = 1023

  goal to_nat_0x000007FF:
    to_nat (lsr bvone 21) = 2047

  goal to_nat_0x00000FFF:
    to_nat (lsr bvone 20) = 4095

  goal to_nat_0x00001FFF:
    to_nat (lsr bvone 19) = 8191

  goal to_nat_0x00003FFF:
    to_nat (lsr bvone 18) = 16383

  goal to_nat_0x00007FFF:
    to_nat (lsr bvone 17) = 32767

  goal to_nat_0x0000FFFF:
    to_nat (lsr bvone 16) = 65535

(*
  goal to_nat_smoke:
    to_nat (lsr bvone 16) = 65536
*)

  goal to_nat_0x0001FFFF:
    to_nat (lsr bvone 15) = 131071

  goal to_nat_0x0003FFFF:
    to_nat (lsr bvone 14) = 262143

  goal to_nat_0x0007FFFF:
    to_nat (lsr bvone 13) = 524287

  goal to_nat_0x000FFFFF:
    to_nat (lsr bvone 12) = 1048575

  goal to_nat_0x00FFFFFF:
    to_nat (lsr bvone 8) = 16777215

  goal to_nat_0xFFFFFFFF:
    to_nat bvone = 4294967295

  goal to_int_0x00000000:
    to_int bvzero = 0

  goal to_int_0xFFFFFFFF:
    to_int bvone = -1

  goal to_int_0x7FFFFFFF:
    to_int (lsr bvone 1) = 2147483647

  goal to_int_0x80000000:
    to_int (lsl bvone 31) = -2147483648

  goal to_int_0x0000FFFF:
    to_int (lsr bvone 16) = 65535

  goal to_int_smoke:
    to_int (lsr bvone 16) = 65536

end


(*
Local Variables:
compile-command: "why3ide bitvector1.why"
End:
*)
