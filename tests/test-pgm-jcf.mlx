
theory T
  type t = int
end

module M
  use import int.Int
  use import T
  function f (x: t) : t = x+1
  goal G: forall x: t. x=x

end

module N
  use import int.Int
  use import M
  goal G1: f 41 = 42

  type unit = ()

  type tree 'a = Node 'a (forest 'a) | Leaf
  with forest 'a = Cons (tree 'a) (forest 'a) | Nil

  type ref 'b = {| (* ghost *) mutable contents : 'b |}

  type myrec 'a = {| f1 : int ; ghost f2 : tree 'a |}

  exception Exit (tree int)

  type dref 'a = {| mutable dcontents : ref 'a |}

  let create_dref i = {| dcontents = {| contents = i |} |}

  let myfun r =
    let rec on_tree t = match t with
      | Node {| contents = v |} f -> v + on_forest f
      | Leaf -> raise (Exit Leaf)
    end with on_forest f = match f with
      | Cons t f -> let ee = Leaf in on_tree t + on_forest f + on_tree ee
      | Nil -> 1
    end
    in
    let dr = create_dref 0 in
    let or = dr.dcontents in
    let nr = {| contents = 1 |} in
    dr.dcontents <- nr;
    assert { r = r };
    try on_tree r with Exit -> 0 end
end

(*
Local Variables:
compile-command: "unset LANG; ../bin/why3ide test-pgm-jcf.mlx"
End:
*)
