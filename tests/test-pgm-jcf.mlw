
{ 
use import list.List
logic c : int
}

let p = c

(*
let rec mem (x:int) (l:int list) = 
  { true }
  match l with
  | Nil -> True
  | Cons (y, r) -> x = y || mem x r
  end
  { true }
*)

let p =
  let x = ref 0 in
  x := 1;
  assert { !x = 1 };
  label L:
  assume { at(!x, L) = 2 };
  absurd : int ref

let f (x : int ref) = 
  { !x >= 0 }
  (fun y -> { y >= 0 } y+1 { result > y }) 2
  { result > 0 and old(!x)>=0 }

parameter g : x:int -> y:int ref -> { true } int { result = x + old(!y) }

(*
Local Variables: 
compile-command: "unset LANG; make -C .. testl"
End: 
*)
