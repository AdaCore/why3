
(*
module MutualRec

  use import int.Int

  let rec f (x1 x2: int) : int variant { x1+x2 } =
    { x1 >= 0 && x2 >= 0 } if x1 <= 1 then 0 else g (x1-1) x2 { result = 0 }

  with g (y1: int) variant { y1 } =
    { y1 >= 0  }
    f (y1-1)
    { 0 = 0 }

end
*)

module M

  use import int.Int
  use import module ref.Ref

  let test1 () =
    let x = ref 0 in
    while !x = 0 do variant { !x } () done

(***
  use import option.Option

  val clear (o : option (ref int)) :
    {} unit writes (match o with Some r -> r end).contents { !r = 0 }
***)

  (* BUG: x escapes its scope (in the postcondition) => should be an error *)
  (* let scope (a: ref int) = let x = a in fun () -> {} x := 0 { !x = 0 } *)

(*   let foo (a: ref int) = let x = a in fun () -> {} x := 0 { !a = 0 } *)
(*   let test3 () = let x = ref 0 in begin foo x (); assert { !x = 0 } end *)

end

(*
Local Variables:
compile-command: "unset LANG; make -C .. testl-ide"
End:
*)
