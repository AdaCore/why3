module M

  use import int.Int
  use import module ref.Ref

  parameter r : ref int

  let test1 () =
    let x = ref 0 in
    let f (y: int) = {} x := !x + y { !x = old !x + y } in
    f 2;
    assert { !x = 2 }

  let rec test2 () =
    { }
    r := 0
    { !r = 0 }

  use import option.Option

  parameter clear (o : option (ref int)) :
    {} unit writes (match o with Some r -> r end).contents { !r = 0 }

  let test4 () =
    let r = ref 0 in
    let a = (r, 0) in
    incr_fst a;
    assert { !(fst a) = 1 }

  (* BUG: x escapes its scope (in the postcondition) => should be an error *)
  (* let scope (a: ref int) = let x = a in fun () -> {} x := 0 { !x = 0 } *)

  let foo (a: ref int) = let x = a in fun () -> {} x := 0 { !a = 0 }
  let test3 () = let x = ref 0 in begin foo x (); assert { !x = 0 } end

end

(***
module TestArray

  use import int.Int
  use import module array.Array

  (* TODO: update *)
  let f (x: array int) =
    { x.length = 2 }
    x[0] <- 1;
    x[1] <- 2
    { x[1] = 2 and x.length = 2 }

end
***)

(*
Local Variables:
compile-command: "unset LANG; make -C .. testl-ide"
End:
*)
