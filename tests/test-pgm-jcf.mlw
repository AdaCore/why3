
(**
module Alg

  type t = A

  let foo (x: t) = match x with A -> 0 end

end
**)

module M

  type pointer model int

  logic null : pointer

  parameter f : 'a -> 'a

  let foo () = f null

end

(**
module TestRef

  use import int.Int
  use import module stdlib.Ref

  let f1 (x : ref int) (y : ref int) =
     {}
     x := 1;
     y := 2
     { x = 1 and y = 2 }

  let f2 (x: ref int) = {} x := 1 { x=1 }

  let g (n: ref int) =
    n := 1;
    assert { n = 1 };
    n := 2;
    assert { n = 2 }

  parameter a : ref int

  parameter havoc : unit -> {} unit writes a {a=1}

  let foo () = { a=0 } havoc(); 1 { a=1 and result=1 }

  let bar () = { a=0 } a := 1 { a=1 }

  (* TODO: 
     le programme "let f n = n := 1" 
     provoque "undefined type variable" (la région) 
     problème : comment faire l'inférence du type de n
  *)

  type t2 = {| mutable fa : int; mutable fb : int |}
  parameter ft2 : x:t2 -> {} unit writes x.fa x.fb {}

end
**)

(**
module TestArray

  use import int.Int
  use import module stdlib.Array

  (* TODO: update *)
  let f (x: array int) = 
    { x.length = 2 } 
    set x 0 1; 
    set x 1 2
    { x[1] = 2 and x.length = 2 }

end
**)

module Q 

  use import list.List

  type queue model {| mutable contents : list int |}

end


(*
Local Variables: 
compile-command: "unset LANG; make -C .. testl-ide"
End: 
*)
