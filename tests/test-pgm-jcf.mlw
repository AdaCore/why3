
{ 
use import list.List
logic c : int
}

let p42 () = { wf_lt_int(4,3) } 1 { true }

exception Not_found
exception Found of int

let test_raise (x:bool) = raise Not_found : int 

let test (n:int) : int = 
  let rec is_even (x:int) = 
    {true} 
    is_even x
    {true}
  in
  is_even n

{ 
logic rel(int, int)
logic rel2(int, int)
}

let rec is_even (x:int) : bool variant {x} for rel = 
    {x>=1} 
    if x = 0 then True else not (is_odd (x-1))
    {true}

and is_odd (x:int) variant {x} for rel =
  if x = 0 then False else not (is_even (x-1))

let rec mem (x:int) (l:int list) = 
  { true }
  match l with
  | Nil -> True
  | Cons (y, r) -> x = y || mem x r
  end
  { true }

let p () =
  let x = ref 0 in
  x := 1;
  assert { !x = 1 };
  label L:
  assume { at(!x, L) = 2 };
  absurd : int ref

let f (x : int ref) = 
  { !x >= 0 }
  (fun y -> { y >= 0 } y+1 { result > y }) 2
  { result > 0 and old(!x)>=0 }

parameter g : x:int -> y:int ref -> { true } int { result = x + old(!y) }

parameter r : int ref

let foo () = g 2 r

let p12 () =
  let x = any int in
  x + any int
  
{ 
type 'a tree =
  | Empty
  | Node ('a, 'a forest)

type 'a forest =
  | Fnil
  | Fcons ('a tree, 'a forest)

logic tree_height('a tree) : int
logic forest_height('a forest) : int
}

let rec size_tree (t: 'a tree) variant {tree_height(t)} = match t with
  | Empty -> 0
  | Node (_, f) -> 1 + size_forest f
  end
and size_forest (f: 'a forest) variant {forest_height(f)} = match f with
  | Fnil -> 0
  | Fcons (t, f) -> size_tree t + size_forest f
  end


(*
Local Variables: 
compile-command: "unset LANG; make -C .. testl"
End: 
*)
