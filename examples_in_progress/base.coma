use int.Int
use int.ComputerDivision
use list.List
use list.SortedInt
use list.Permut
use list.Reverse
use list.Append

-------------------------------------------------------------------------------

-- let if (then) =
--     any as then -> then

let if {b: bool} (then) (else) =
    any as then -> {b} ! then
        |  else -> {not b} ! else

-- let ok [] =
--     f1 as f1     = f2 (g)
--        |  f2 (g) = g
--        |  f3 (g) = f1
--        as g      -> h
--        as h      -> any

let unList {l: list int} (onCons [] {h: int} {t: list int}) (onNil []) =
    any
    as oncons [] {h: int} {t: list int} -> { l = Cons h t } ! onCons {h} {t}
    as onnil  []                        -> { l =  Nil } ! onNil

let assign_int (&r : int) {v: int} (out [r]) =
    any as ret [r] -> { r = v } ! out

let halt [] = ? any

let assign_list (&r : list int) {v: list int} (out [r]) =
    any as ret [r] -> { r = v } ! out

-- uncomment â¤³ error
-- let nok [] =
--     any as f      -> h
--         |  g      -> g
--         as h      -> any

-------------------------------------------------------------------------------

-- (defun product (a) (b) (return (c))
--     assert (b >= 0) (!
--         loop
--         as loop))

let product {a b: int} (return {c: int}) =
    { b >= 0 } !
    (loop
     as loop [p q r] =
         ({ q >= 0 }{ p*q+r = a*b } !
          (if {q > 0} (next) (last)
           as last -> return {r}
           |  next ->
              (if {mod q 2 = 1} (write_r) (write_p)
               as write_r       -> assign_int &r {r + p} (write_p)
               as write_p [r]   -> assign_int &p {p + p} (write_q)
               as write_q [p r] -> assign_int &q {div q 2} (loop))))
     as &p: int = {a}
     |  &q: int = {b}
     |  &r: int = {0})
    as return {c: int} -> { c = a * b } ! return {c}

let test (&x &y &z: int) =
    ! if {x = 0} (out_x) (fun -> assign_int &x {0} (fun -> assign_int &x {0} (fun -> assign_int &x {0} (fun -> assign_int &x {0} (out_x)))))
      as out_x [x] =
        (if {y = 0} (out_y) (fun -> assign_int &y {0} (out_y))
         as out_y [y] =
            (if {z = 0} (out_z) (fun -> assign_int &z {0} (out_z))
             as out_z [z] = { x = y = z = 0 } halt))

-- let insert {x: int} {l: list int} (return {o: list int}) =
--     { sorted l }
--     ! unList {l}
--              (fun {h: int} {t: list int} ->
--                 if {x < h}
--                    (fun -> break {Cons x l})
--                    (fun -> insert {x} {t} (fun {r: list int} -> break {Cons h r})))
--              (fun -> break {Cons x Nil})
--     as break {r: list int} -> { sorted r && permut r (Cons x l) } ! return {r}

-- let postIncr (&r: int) =
--     (fun {v: int} ->
--         ! assign_int &r {r+1} (break)
--         as break [r] -> { r = v+1 } ! return {v}) {r}
--     as return [r] {p: int} -> any

-- let rev_append [] {l0 r0: list int} =
--   loop
--   as loop = { reverse l ++ r = reverse l0 ++ r0 }
--       ! unList {l} (fun {h: int} {t: list int} -> assign_list &r {Cons h r} (fun -> assign_list &l {t} (loop)))
--                    (out)
--   as out -> { r = reverse l0 ++ r0 } ? halt
--   as &r: list int = {r0}
--   as &l: list int = {l0}
