
use int.Int
use bintree.Tree
use bintree.Occ

let fail = {false} any

let if {b: bool} (then) (else) =
  any as then -> {b} ! then
      |  else -> {not b} ! else

let unTree {t: tree int} (onNode [] {v: int} {l r: tree int}) (onLeaf) =
  any as node {v: int} {l r: tree int} ->
           { t = Node l v r } ! onNode {v} {l} {r}
       | leaf -> { t = Empty } ! onLeaf

let remove_min {t: tree int} (return {m: int} {o: tree int}) =
  ({ t <> Empty } ! (unTree {t} (node) (fail)
  as node {x: int} {l r: tree int} ->
    if {l=Empty} (fun -> return {x} {r})
                  (fun -> remove_min {l}
                    (fun {m: int} {l': tree int} -> return {m} {Node l' x r}))))
  as return {m: int} {o: tree int} ->
    { forall x. mem x t <-> (x = m || mem x o)} ! return {m} {o}

let remove_root {t: tree int} (return {o: tree int}) =
  unTree {t}
  (fun {_x: int} {l r: tree int} ->
    (! if {r=Empty} (fun -> return {l})
                    (fun -> remove_min {r}
                      (fun {m: int} {r': tree int} -> return {Node l m r'})))
    as return {o: tree int} ->
      { forall x. mem x o <-> (mem x l || mem x r) } ! return {o}
  )
  (fail)

