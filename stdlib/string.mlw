module String

  use int.Int

  (** indexes for strings start at `0` *)

  (** type string is built-in *)

  (** UC refers to the code points from 0x00000 to 0x2FFFF (Unicode
  characters in Planes 0-2) *) (* CHECK *)

  constant empty : string = ""
  (** the empty string. *)

  function concat string string : string
  (** `concat s1 s2` returns the concatenation of `s1` and `s2`.  *)

  function length string : int
  (** `length s` returns the length of the string `s`. *)
  (* `length s` returns the number of UC characters in `s`. *)
  (* CHECK *)

  predicate lt string string
  (** `lt s1 s2` returns `True` iff `s1` is smaller than `s2` in the
  lexicographic order of UC *) (* CHECK UC *)

  predicate le string string
  (** `le s1 s2` returns `True` iff `s1` is smaller or equal to `s2`
  in the lexicographic order of UC *) (* CHECK UC *)

  function ([]) string int : string
  (** `s[i]` is:
       (1) `empty`, if either `i < 0` or `i >= length s`;
       (2) the string of length `1` containing the character of
           position `i` in string `s`, if `0 <= i < length s`. *)

  function substring string int int : string
  (** `substring s i x` is:
      (1) the `empty` string if `i < 0`, `i >= length s`, or `x <= 0`;
      (2) the substring of `s` starting at `i` and of length
          `min x (length s - i)`. *)

  predicate prefixof string string
  (** `prefixof s1 s2` is `True` iff `s1` is a prefix of `s2`. *)

  predicate suffixof string string
  (** `suffixof s1 s2` is `True` iff `s1` is a suffix of `s2`. *)

  predicate contains string string
  (** `contains s1 s2` is `True` iff `s1` contains `s2`. *)

  function indexof string string int : int
  (** `indexof s1 s2 i` is:
      (1) the first occurence of `s2` in `s1` after `i`, if
          `0 <= i <= length s1` (note: the result is `i`, if
          `s2 = empty` and `0 <= i <= length s1`);
      (2) `-1`, if `i < 0`, `i > length s1`, or `0 <= i <= length s1`
          and `s2` does not occur in `s1` after `i`.  *)

  function replace string string string : string
  (** `replace s1 s2 s3` is:
      (1) `concat s3 s1`, if `s2 = empty`;
      (2) the string obtained by replacing the first occurrence of `s2`
          (if any) by `s3` in `s1`. *)

  (* NOT IN SMT-LIB *)
  function replaceall string string string : string
  (** `replace s1 s2 s3` is:
      (1) `s1`, if `s2 = empty`;
      (2) the string obtained by replacing all occurences of `s2` by
          `s3` in `s1` *)

  (* TODO Below is still WORK IN PROGRESS *)

  predicate is_digit string (* NOT in z3/cvc4 *)
  (** `is_digit s` returns `True` iff `s` is of length `1` and
      corresponds to a decimal digit, that is, to a code point in the
      range 0x0030 ... 0x0039 *)

  function to_int string : int
  (** `to_int s` is:
      (1) an `int` consisting on the digits of `s`, if `s` is formed only
          by characters corresponding to digits, that is, to code points in
          the range 0x0030 ... 0x0039;
      (2) `-1`, if `s` contains a character that is not a digit. *)

  function from_int int : string
  (** `from_int i` is:
      (1) the corresponding string in the decimal notation if `i >= 0`;
      (2) `empty`, if `i < 0`. *)

end

module RegExpr

  use String as S

  type re
  (** type for regular expressions *)

  function to_re string : re
  (** string to regular expression injection *)

  predicate in_re string re
  (** regular expression membership *)

  function concat re re : re (* left assoc *)
  (** regular expressions concatenation *)

  function union re re : re (* left assoc *)
  (** regular expressions union *)

  function inter re re : re (* left assoc *) (* NOT SUPPORTED BY Z3 *)
  (** regular expressions intersection *)

  function star re : re
  (** Kleene closure *)

  function plus re : re
  (** Kleene cross *)
  (* forall re. plus re = concat re (star re) *)

  constant none : re
  (** the empty set of strings *)

  constant allchar : re
  (** the set of all strings of length 1 *)

  constant all : re = star allchar
  (** the set of all strings *)

  function opt re : re
  (** regular expression option *)
  (* forall re. opt re = union re (to_re "") *)

  function range string string : re
  (** `range s1 s2` is the set of singleton strings such that all
  element `s` of `range s1 s2` satisfies the condition `Str.<= s1 s`
  and `Str.<= s s2`. *)

  function power int re : re
  (** `power n r` is the `n`th power of `r`; `n` must be an
      integer literal. *)
  (* power 0 e = to_re ""
     power n e = concat e (power (n-1) e) *)

  function loop int int re : re
  (* loop n1 n2 r = if n1 > ne then none else
                    if n1 = n2 then power n1 r else
                    union (power n1 e) (loop (n1+1) n2 e) *)
  (* `n1` and `n2` must be literals. *)

end