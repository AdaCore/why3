module Tree

  use list.List

  type forest = list tree
  with tree   = Node int forest

end

module Size

  use Tree
  use list.List
  use int.Int

  let rec function size_forest (f: forest) : int
    ensures { result >= 0 }
  = match f with
    | Nil      -> 0
    | Cons t f -> size_tree t + size_forest f
    end
  with function size_tree (t: tree) : int
    ensures { result > 0 }
  = match t with
    | Node _ f -> 1 + size_forest f
    end

end


module Binom

  use int.Int

  let rec function comb (n k: int) : int
    requires { 0 <= k <= n }
    variant  { n }
    ensures  { result >= 1 }
  = if k = 0 || k = n then 1 else comb (n-1) k + comb (n-1) (k-1)


  let rec lemma prop1 (n k: int)
    requires { 0 <= k <= n }
    ensures  { comb n (n - k) = comb n k }
    variant  { n }
  = if 0 < k < n then (prop1 (n-1) k; prop1 (n-1) (k-1))

  let rec lemma prop2 (n k: int)
    requires { 1 <= k <= n }
    ensures  { k * comb n k = comb n (k - 1) * (n - k + 1) }
    variant  { n }
  = if k < n then prop2 (n-1) k;
    if 1 < k then prop2 (n-1) (k-1)

  let lemma prop3 (n : int)
    requires { 0 <= n }
    ensures  { comb n 0 = 1 }
  = ()

end

module Regexp

  type char

  type regexp =
    | Empty
    | Epsilon
    | Char    char
    | Alt     regexp regexp
    | Concat  regexp regexp
    | Star    regexp

  use export seq.Seq

  type word = seq char

  (** Inductive predicate `mem w r` means
      "word `w` belongs to the language of `r`". *)

  inductive mem (w: word) (r: regexp) =
    | mem_eps:
        mem empty Epsilon
    | mem_char:
        forall c: char. mem (singleton c) (Char c)
    | mem_altl:
        forall w: word, r1 r2: regexp. mem w r1 -> mem w (Alt r1 r2)
    | mem_altr:
        forall w: word, r1 r2: regexp. mem w r2 -> mem w (Alt r1 r2)
    | mem_concat:
        forall w1 w2: word, r1 r2: regexp.
        mem w1 r1 -> mem w2 r2 -> mem (w1 ++ w2) (Concat r1 r2)
    | mems1:
        forall r: regexp. mem empty (Star r)
    | mems2:
        forall w1 w2: word, r: regexp.
        mem w1 r -> mem w2 (Star r) -> mem (w1 ++ w2) (Star r)

  use int.Int

  lemma nul_interval : forall w: word. forall i: int.
    0 <= i <= length w -> w[i..i] == empty

  val predicate (===) (r1 r2: regexp)
    ensures { result <-> forall w: word. mem w r1 = mem w r2 }

  lemma mem_concat_eps : forall r: regexp.
    Concat Epsilon r === r === Concat r Epsilon

  lemma w0 : forall w: word. w == w[0..]

  lemma w1 : forall w: word. forall i: int.
    0 <= i < length w -> w[i..i+1] == singleton w[i]

  lemma unfold_star : forall r1 r2: regexp. forall w: word.
    mem w (Concat (Concat r1 (Star r1)) r2) ->
    mem w (Concat (Star r1) r2)

  (* lemma mem_char_ax2 : forall w: word. forall c: char. forall i:int.
    not w[i] = c <-> not (mem w[i..(i + 1)] (Char c)) *)

  (* lemma mem_cat_ax : forall w: word. forall i:int. forall r1 r2: regexp.
    0 <= i <= length w ->
    mem w[i..] (Concat r1 r2) ->
    exists j: int. i <= j <= length w /\ mem w[i..j] r1 *)

  (* lemma mem_cat_ax2 : forall w: word. forall r1 r2: regexp. forall i j:int.
    0 <= i <= j <= length w ->
    mem w[i..j] r1 ->
    mem w[j..]  r2 ->
    mem w[i..] (Concat r1 r2) *)

  lemma mem_stat_concat : forall w: word. forall r rk: regexp.
    mem w (Concat (Star r) rk) <->
      (mem w rk \/
       exists w1 w2: word.
         w1 <> empty   /\
         w1 ++ w2 = w  /\
         mem w1 r      /\
         mem w2 (Concat (Star r) rk))

  lemma mem_cat_char_ax : forall w: word. forall i: int. forall c: char. forall r: regexp.
    0 <= i < length w ->
    mem w[i..i+1] (Char c) ->
    mem w[i+1..]  r <->
      mem w[i..] (Concat (Char c) r)

  lemma concat_assoc : forall r1 r2 r3: regexp.
    Concat r1 (Concat r2 r3) === Concat (Concat r1 r2) r3

  lemma concat_split : forall w: word. forall r1 r2: regexp. forall i j k: int.
    0 <= i <= k <= j <= length w ->
      mem w[i..k] r1 ->
      mem w[k..j] r2 ->
      mem w[i..j] (Concat r1 r2)
end
