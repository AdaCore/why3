module Tree

  use list.List

  type forest = list tree
  with tree   = Node int forest

end

module Size

  use Tree
  use list.List
  use int.Int

  let rec function size_forest (f: forest) : int
    ensures { result >= 0 }
  = match f with
    | Nil      -> 0
    | Cons t f -> size_tree t + size_forest f
    end
  with function size_tree (t: tree) : int
    ensures { result > 0 }
  = match t with
    | Node _ f -> 1 + size_forest f
    end

end


module Binom

  use int.Int

  let rec function comb (n k: int) : int
    requires { 0 <= k <= n }
    variant  { n }
    ensures  { result >= 1 }
  = if k = 0 || k = n then 1 else comb (n-1) k + comb (n-1) (k-1)


  let rec lemma prop1 (n k: int)
    requires { 0 <= k <= n }
    ensures  { comb n (n - k) = comb n k }
    variant  { n }
  = if 0 < k < n then (prop1 (n-1) k; prop1 (n-1) (k-1))

  let rec lemma prop2 (n k: int)
    requires { 1 <= k <= n }
    ensures  { k * comb n k = comb n (k - 1) * (n - k + 1) }
    variant  { n }
  = if k < n then prop2 (n-1) k;
    if 1 < k then prop2 (n-1) (k-1)

  let lemma prop3 (n : int)
    requires { 0 <= n }
    ensures  { comb n 0 = 1 }
  = ()

end

module Regexp

  type char

  type regexp =
    | Empty
    | Epsilon
    | Char    char
    | Alt     regexp regexp
    | Concat  regexp regexp
    | Star    regexp

  use export seq.Seq

  type word = seq char

  (** Inductive predicate `mem w r` means
      "word `w` belongs to the language of `r`". *)

  inductive mem (w: word) (r: regexp) =
    | mem_eps:
        mem empty Epsilon
    | mem_char:
        forall c: char. mem (singleton c) (Char c)
    | mem_altl:
        forall w: word, r1 r2: regexp. mem w r1 -> mem w (Alt r1 r2)
    | mem_altr:
        forall w: word, r1 r2: regexp. mem w r2 -> mem w (Alt r1 r2)
    | mem_concat:
        forall w1 w2: word, r1 r2: regexp.
        mem w1 r1 -> mem w2 r2 -> mem (w1 ++ w2) (Concat r1 r2)
    | mems1:
        forall r: regexp. mem empty (Star r)
    | mems2:
        forall w1 w2: word, r: regexp.
        mem w1 r -> mem w2 (Star r) -> mem (w1 ++ w2) (Star r)

  axiom nul_interval : forall w: word. forall i: int. forall r:regexp.
    mem w[i..i] r <-> mem empty r

  axiom mem_concat_eps : forall w: word. forall r: regexp.
    mem w (Concat Epsilon r) <-> mem w r <-> mem w (Concat r Epsilon)

  axiom w0 : forall w: word. forall r:regexp. mem w r <-> mem w[0..] r

  use int.Int
  axiom mem_char_ax : forall w: word. forall c: char. forall i:int.
    0 <= i < length w ->
    w[i] = c <-> (mem w[i..(i + 1)] (Char c))

  axiom mem_char_ax2 : forall w: word. forall c: char. forall i:int.
    not w[i] = c <-> not (mem w[i..(i + 1)] (Char c))

  axiom mem_char_ax3 :
  forall w: word. forall i j:int. forall r: regexp.
    not mem w[i..j] r
    -> not exists r2: regexp. mem w[i..] (Concat r r2)

  axiom mem_cat_ax : forall w: word. forall r1 r2: regexp. forall i j:int.
  i <= j -> mem w[i..j] r1 ->
  mem w[j..]  r2 <->
    mem w[i..] (Concat r1 r2)

  axiom mem_cat_char_ax :
  forall w: word. forall i :int. forall c: char. forall r: regexp.
  mem w[i..(i+1)] (Char c) ->
  mem w[(i+1)..]  r <->
    mem w[i..] (Concat (Char c) r)

  axiom concat_assoc : forall r1 r2 r3: regexp. forall w: word.
    mem w (Concat r1 (Concat r2 r3)) <-> mem w (Concat (Concat r1 r2) r3)

  axiom concat_split :
    forall w: word. forall r1 r2: regexp. forall i j j1: int.
    0 <= i <= j1 <= j <= length w ->
      (mem w[i..j1] r1 /\ mem w[j1..j] r2)
      <-> (mem w[i..j] (Concat r1 r2))

  axiom unfold_star : forall r1 r2 r': regexp. forall w: word.
    r1 = Star r' ->
      mem w (Concat (Concat r' r1) r2) <-> mem w (Concat r1 r2)

end
