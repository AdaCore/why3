module Tree

  use list.List

  type forest = list tree
  with tree   = Node int forest

end

module Size

  use Tree
  use list.List
  use int.Int

  let rec function size_forest (f: forest) : int
    ensures { result >= 0 }
  = match f with
    | Nil      -> 0
    | Cons t f -> size_tree t + size_forest f
    end
  with function size_tree (t: tree) : int
    ensures { result > 0 }
  = match t with
    | Node _ f -> 1 + size_forest f
    end

end


module Binom

  use int.Int

  let rec function comb (n k: int) : int
    requires { 0 <= k <= n }
    variant  { n }
    ensures  { result >= 1 }
  = if k = 0 || k = n then 1 else comb (n-1) k + comb (n-1) (k-1)


  let rec lemma prop1 (n k: int)
    requires { 0 <= k <= n }
    ensures  { comb n (n - k) = comb n k }
    variant  { n }
  = if 0 < k < n then (prop1 (n-1) k; prop1 (n-1) (k-1))

  let rec lemma prop2 (n k: int)
    requires { 1 <= k <= n }
    ensures  { k * comb n k = comb n (k - 1) * (n - k + 1) }
    variant  { n }
  = if k < n then prop2 (n-1) k;
    if 1 < k then prop2 (n-1) (k-1)

  let lemma prop3 (n : int)
    requires { 0 <= n }
    ensures  { comb n 0 = 1 }
  = ()

end

module Regexp

  use export seq.Seq
  use int.Int
  use seq.FreeMonoid

  type char

  type regexp =
    | Empty
    | Epsilon
    | Char    char
    | Alt     regexp regexp
    | Concat  regexp regexp
    | Star    regexp

  type word = seq char

  inductive mem (w: word) (r: regexp) =
    | mem_eps:
        mem empty Epsilon
    | mem_char:
        forall c: char. mem (singleton c) (Char c)
    | mem_altl:
        forall w: word, r1 r2: regexp. mem w r1 -> mem w (Alt r1 r2)
    | mem_altr:
        forall w: word, r1 r2: regexp. mem w r2 -> mem w (Alt r1 r2)
    | mem_concat:
        forall w1 w2: word, r1 r2: regexp.
        mem w1 r1 -> mem w2 r2 -> mem (w1 ++ w2) (Concat r1 r2)
    | mems1:
        forall r: regexp. mem empty (Star r)
    | mems2:
        forall w1 w2: word, r: regexp.
        mem w1 r -> mem w2 (Star r) -> mem (w1 ++ w2) (Star r)

  lemma mem_star_nonempty: forall w: word. forall r: regexp.
    mem w (Star r) ->
    w <> empty ->
    exists k: int.
      0 < k <= length w /\
      mem w[..k] r /\
      mem w[k..] (Star r)

  lemma split_concat: forall w: word. forall r1 r2: regexp.
    mem w (Concat r1 r2) ->
    exists k: int.
      0 <= k <= length w /\
      mem w[..k] r1 /\ mem w[k..] r2

  lemma concat_split: forall w: word. forall r1 r2: regexp. forall i j k: int.
    0 <= i <= k <= j <= length w ->
      mem w[i..k] r1 ->
      mem w[k..j] r2 ->
      mem w[i..j] (Concat r1 r2)

  (* lemma mem_star_nonempty: forall w: word. forall r: regexp.
    mem w (Star r) ->
    w <> empty ->
    exists w1 w2: word.
      w1 <> empty /\
      w = w1 ++ w2 /\
      mem w1 r /\
      mem w2 (Star r) *)

  (* lemma merge_rigth: forall i j:int. forall w: word.
    0 <= i <= j <= length w ->
    w[i..][..j - i] = w[i..j] *)

  (* lemma merge_rigth2: forall i j:int. forall w: word.
    0 <= i <= length w ->
    0 <= j <= length w ->
    mem w[j..][..i] = mem w[j..j+i] *)

  (* lemma merge_left2: forall i j:int. forall w: word.
    0 <= i <= length w ->
    0 <= j <= length w ->
    mem w[j..][i..] = mem w[j+i..] *)

  (* lemma merge_left: forall i j:int. forall w: word.
    0 <= i <= j <= length w ->
    w[i..][j - i..] = w[j..] *)

  (* lemma nul_interval : forall w: word. forall i: int.
    0 <= i <= length w -> w[i..i] == empty *)

  (* val predicate (===) (r1 r2: regexp)
    ensures { result <-> forall w: word. mem w r1 = mem w r2 } *)

  (* lemma mem_concat_eps : forall r: regexp.
    Concat Epsilon r === r === Concat r Epsilon *)

  (* lemma w0 : forall w: word. w == w[0..] *)

  (* lemma w1 : forall w: word. forall i: int.
    0 <= i < length w -> w[i..i+1] == singleton w[i] *)

  (* lemma unfold_star : forall r1 r2: regexp. forall w: word.
    mem w (Concat (Concat r1 (Star r1)) r2) ->
    mem w (Concat (Star r1) r2) *)

  (* lemma mem_star_concat : forall w: word. forall r rk: regexp.
    mem w (Concat (Star r) rk) <->
      (mem w rk \/
       exists w1 w2: word.
         w1 <> empty   /\
         w1 ++ w2 = w  /\
         mem w1 r      /\
         mem w2 (Concat (Star r) rk)) *)

  (* lemma mem_cat_char_ax : forall w: word. forall i: int. forall c: char. forall r: regexp.
    0 <= i < length w ->
    mem w[i..i+1] (Char c) ->
    mem w[i+1..]  r <->
      mem w[i..] (Concat (Char c) r) *)

  (* lemma concat_assoc : forall r1 r2 r3: regexp.
    Concat r1 (Concat r2 r3) === Concat (Concat r1 r2) r3 *)
end
