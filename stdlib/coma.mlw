module Tree

  use list.List

  type forest = list tree
  with tree   = Node int forest

end

module Size

  use Tree
  use list.List
  use int.Int

  let rec function size_forest (f: forest) : int
    ensures { result >= 0 }
  = match f with
    | Nil      -> 0
    | Cons t f -> size_tree t + size_forest f
    end
  with function size_tree (t: tree) : int
    ensures { result > 0 }
  = match t with
    | Node _ f -> 1 + size_forest f
    end

end


module Binom

  use int.Int

  let rec function comb (n k: int) : int
    requires { 0 <= k <= n }
    variant  { n }
    ensures  { result >= 1 }
  = if k = 0 || k = n then 1 else comb (n-1) k + comb (n-1) (k-1)


  let rec lemma prop1 (n k: int)
    requires { 0 <= k <= n }
    ensures  { comb n (n - k) = comb n k }
    variant  { n }
  = if 0 < k < n then (prop1 (n-1) k; prop1 (n-1) (k-1))

  let rec lemma prop2 (n k: int)
    requires { 1 <= k <= n }
    ensures  { k * comb n k = comb n (k - 1) * (n - k + 1) }
    variant  { n }
  = if k < n then prop2 (n-1) k;
    if 1 < k then prop2 (n-1) (k-1)

  let lemma prop3 (n : int)
    requires { 0 <= n }
    ensures  { comb n 0 = 1 }
  = ()

end

module Regexp

  type char

  type regexp =
    | Empty
    | Epsilon
    | Char    char
    | Alt     regexp regexp
    | Concat  regexp regexp
    | Star    regexp

  use export seq.Seq

  type word = seq char

  (** Inductive predicate `mem w r` means
      "word `w` belongs to the language of `r`". *)

  inductive mem (w: word) (r: regexp) =
    | mem_eps:
        mem empty Epsilon
    | mem_char:
        forall c: char. mem (singleton c) (Char c)
    | mem_altl:
        forall w: word, r1 r2: regexp. mem w r1 -> mem w (Alt r1 r2)
    | mem_altr:
        forall w: word, r1 r2: regexp. mem w r2 -> mem w (Alt r1 r2)
    | mem_concat:
        forall w1 w2: word, r1 r2: regexp.
        mem w1 r1 -> mem w2 r2 -> mem (w1 ++ w2) (Concat r1 r2)
    | mems1:
        forall r: regexp. mem empty (Star r)
    | mems2:
        forall w1 w2: word, r: regexp.
        mem w1 r -> mem w2 (Star r) -> mem (w1 ++ w2) (Star r)
end
