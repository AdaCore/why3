####################################################################
#                                                                  #
#  The Why3 Verification Platform   /   The Why3 Development Team  #
#  Copyright 2010-2014   --   INRIA - CNRS - Paris-Sud University  #
#                                                                  #
#  This software is distributed under the terms of the GNU Lesser  #
#  General Public License version 2.1, with the special exception  #
#  on linking described in file LICENSE.                           #
#                                                                  #
####################################################################

include Version

VERBOSEMAKE ?= @enable_verbose_make@

ifeq ($(VERBOSEMAKE),yes)
  QUIET =
else
  QUIET = yes
endif

# install the binaries
DESTDIR =

prefix	    = @prefix@
exec_prefix = @exec_prefix@
datarootdir = @datarootdir@

BINDIR  = $(DESTDIR)@bindir@
LIBDIR  = $(DESTDIR)@libdir@
DATADIR = $(DESTDIR)@datarootdir@
MANDIR  = $(DESTDIR)@mandir@

# OS specific stuff
EXE   = @EXE@

# other variables
CC        = @CC@
OCAMLC    = @OCAMLC@
OCAMLOPT  = @OCAMLOPT@
OCAMLDEP  = @OCAMLDEP@
OCAMLLEX  = @OCAMLLEX@
OCAMLYACC = @OCAMLYACC@
OCAMLDOC  = @OCAMLDOC@
OCAMLLIB  = @OCAMLLIB@
OCAMLINSTALLLIB  = $(DESTDIR)@OCAMLINSTALLLIB@
OCAMLBEST = @OCAMLBEST@
OCAMLVERSION = @OCAMLVERSION@
COQC      = @COQC@
COQDEP    = @COQDEP@
CAMLP5O   = @CAMLP5O@
FRAMAC_LIBDIR = $(DESTDIR)@FRAMAC_LIBDIR@

DEPFLAGS  = -slash -I lib/why3
ifeq (@OCAMLBEST@,opt)
DEPFLAGS += -native
endif

RUBBER = @RUBBER@
HEVEA = @HEVEA@
HACHA = @HACHA@
EMACS = @EMACS@

#PSVIEWER  = @PSVIEWER@
#PDFVIEWER = @PDFVIEWER@

INCLUDES =
OFLAGS = -w Aer-41-44-45 -dtypes -g -I lib/why3 $(INCLUDES)
BFLAGS = -w Aer-41-44-45 -dtypes -g -I lib/why3 $(INCLUDES)

OLINKFLAGS = -linkall $(EXTCMXA)
BLINKFLAGS = -linkall $(EXTCMA)

ifeq (@enable_profiling@,yes)
OFLAGS += -g -p
endif

# external libraries common to all binaries

EXTOBJS =
EXTLIBS = str unix nums dynlink

EXTCMA	= $(addsuffix .cma,$(EXTLIBS)) $(addsuffix .cmo,$(EXTOBJS))
EXTCMXA = $(addsuffix .cmxa,$(EXTLIBS)) $(addsuffix .cmx,$(EXTOBJS))

TARGET_EMACS = share/emacs/why3.elc

###############
# main target
###############

all: @OCAMLBEST@
plugins: plugins.@OCAMLBEST@
opt: plugins.opt
byte: plugins.byte

ifeq (@enable_local@,yes)
all: install_local
endif

.PHONY: byte opt clean depend all install install_local install_no_local
.PHONY: plugins plugins.byte plugins.opt

##############
# Why3 library
##############

LIBGENERATED = src/util/config.ml \
	       src/util/rc.ml src/parser/lexer.ml \
	       src/parser/parser.mli src/parser/parser.ml \
	       src/driver/driver_parser.mli src/driver/driver_parser.ml \
	       src/driver/driver_lexer.ml src/session/xml.ml \
	       lib/ocaml/why3__BigInt_compat.ml

LIB_UTIL = config bigInt util opt lists strings extmap extset exthtbl weakhtbl \
	   hashcons stdlib exn_printer pp debug loc print_tree \
	   cmdline warning sysutil rc plugin bigInt number pqueue

LIB_CORE = ident ty term pattern decl theory \
	   task pretty dterm env trans printer

LIB_PARSER = ptree glob parser typing lexer

LIB_DRIVER = call_provers driver_ast driver_parser driver_lexer driver \
	     whyconf autodetection

LIB_TRANSFORM = simplify_formula inlining split_goal induction \
		eliminate_definition eliminate_algebraic \
		eliminate_inductive eliminate_let eliminate_if \
		libencoding discriminate encoding encoding_select \
		encoding_guards_full encoding_tags_full \
		encoding_guards encoding_tags encoding_twin \
		encoding_sort simplify_array filter_trigger \
		introduction abstraction close_epsilon lift_epsilon \
		eliminate_epsilon \
		eval_match instantiate_predicate smoke_detector

LIB_PRINTER = alt_ergo why3printer smtv1 smtv2 coq pvs isabelle \
	      simplify gappa cvc3 yices mathematica

LIB_SESSION = xml termcode session session_tools session_scheduler

LIB_WHYML = mlw_ty mlw_expr mlw_decl mlw_pretty mlw_wp mlw_module \
	    mlw_dexpr mlw_typing mlw_driver mlw_ocaml \
	    mlw_main mlw_interp

LIBMODULES =  $(addprefix src/util/, $(LIB_UTIL)) \
	      $(addprefix src/core/, $(LIB_CORE)) \
	      $(addprefix src/parser/, $(LIB_PARSER)) \
	      $(addprefix src/driver/, $(LIB_DRIVER)) \
	      $(addprefix src/transform/, $(LIB_TRANSFORM)) \
	      $(addprefix src/printer/, $(LIB_PRINTER)) \
	      $(addprefix src/session/, $(LIB_SESSION)) \
	      $(addprefix src/whyml/, $(LIB_WHYML))

LIBDIRS = util core parser driver transform printer session whyml
LIBINCLUDES = $(addprefix -I src/, $(LIBDIRS))

LIBDEP = $(addsuffix .dep, $(LIBMODULES))
LIBCMO = $(addsuffix .cmo, $(LIBMODULES))
LIBCMX = $(addsuffix .cmx, $(LIBMODULES))

$(LIBDEP): DEPFLAGS += $(LIBINCLUDES)
$(LIBCMO) $(LIBCMX): INCLUDES += $(LIBINCLUDES)
$(LIBCMX): OFLAGS += -for-pack Why3

$(LIBDEP): $(LIBGENERATED)

# Zarith

ifeq (@enable_zarith@,yes)

lib/ocaml/why3__BigInt_compat.ml: config.status lib/ocaml/why3__BigInt_zarith.ml
	cp lib/ocaml/why3__BigInt_zarith.ml $@

else

lib/ocaml/why3__BigInt_compat.ml: config.status lib/ocaml/why3__BigInt_num.ml
	cp lib/ocaml/why3__BigInt_num.ml $@

endif

clean::
	rm -f lib/ocaml/why3__BigInt_compat.ml

# build targets

byte: lib/why3/why3.cma
opt:  lib/why3/why3.cmxa

lib/why3/why3.cma: lib/why3/why3.cmo
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) -a $(BFLAGS) -o $@ $^

lib/why3/why3.cmxa: lib/why3/why3.cmx
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) -a $(OFLAGS) -o $@ $^

lib/why3/why3.cmo: $(LIBCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -pack -o $@ $^

lib/why3/why3.cmx: $(LIBCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -pack -o $@ $^

# clean and depend

ifneq "$(MAKECMDGOALS)" "clean"
include $(LIBDEP)
endif

depend: $(LIBDEP)

LIBSDIRS = src $(addprefix src/, $(LIBDIRS))
LIBCLEAN = $(addsuffix /*.cm[iox], $(LIBSDIRS)) \
	   $(addsuffix /*.annot, $(LIBSDIRS)) \
	   $(addsuffix /*.output, $(LIBSDIRS)) \
	   $(addsuffix /*.automaton, $(LIBSDIRS)) \
	   $(addsuffix /*.dep, $(LIBSDIRS)) \
	   $(addsuffix /*.o, $(LIBSDIRS)) \
	   $(addsuffix /*~, $(LIBSDIRS))

clean::
	rm -f $(LIBCLEAN) $(LIBGENERATED)
	rm -f lib/why3/why3.cm* lib/why3/why3.[ao]

###############
# installation
###############

# TODO: Clean this madness
clean_old_install:
	rm -f $(BINDIR)/why3*
	rm -rf $(DATADIR)/why3
	rm -rf $(OCAMLINSTALLLIB)/why3
	rm -rf $(LIBDIR)/why3/plugins


ifeq ($(EMACS),no)
install_no_local:: clean_old_install
else
install_no_local:: clean_old_install $(TARGET_EMACS)
endif
	mkdir -p $(BINDIR)
	mkdir -p $(DATADIR)/why3
	mkdir -p $(DATADIR)/why3/images
	mkdir -p $(DATADIR)/why3/images/boomy
	mkdir -p $(DATADIR)/why3/images/fatcow
	mkdir -p $(DATADIR)/why3/emacs
	mkdir -p $(DATADIR)/why3/vim
	mkdir -p $(DATADIR)/why3/lang
	mkdir -p $(DATADIR)/why3/theories
	mkdir -p $(DATADIR)/why3/modules/mach
	mkdir -p $(DATADIR)/why3/drivers
	mkdir -p $(DATADIR)/emacs/site-lisp/
	cp -f theories/*.why $(DATADIR)/why3/theories
	cp -f modules/*.mlw $(DATADIR)/why3/modules
	cp -f modules/mach/*.mlw $(DATADIR)/why3/modules/mach
	cp -f drivers/*.drv drivers/*.gen $(DATADIR)/why3/drivers
	cp -f share/provers-detection-data.conf $(DATADIR)/why3/
	cp -f share/images/icons.rc $(DATADIR)/why3/images
	cp -f share/images/*.png $(DATADIR)/why3/images
	cp -f share/images/boomy/*.png $(DATADIR)/why3/images/boomy
	cp -f share/images/fatcow/*.png $(DATADIR)/why3/images/fatcow
	cp -f share/why3session.dtd $(DATADIR)/why3
	cp -rf share/javascript $(DATADIR)/why3/javascript
	cp -f share/emacs/why3.el $(DATADIR)/emacs/site-lisp/why3.el
ifneq ($(EMACS),no)
	cp -f share/emacs/why3.elc $(DATADIR)/emacs/site-lisp/why3.elc
endif
	cp -f share/vim/why3.vim $(DATADIR)/why3/vim/why3.vim
	cp -f share/lang/why3.lang $(DATADIR)/why3/lang/why3.lang

install_no_local_lib::
	mkdir -p $(OCAMLINSTALLLIB)/why3
	cp -f lib/why3/why3.cm* lib/why3/why3.[ao] \
		lib/why3/META $(OCAMLINSTALLLIB)/why3

ifeq (@enable_local@,yes)
install install-lib:
	@echo "Why3 is configured in local installation mode."
	@echo "To install Why3, run ./configure --disable-local ; make ; make install"
else
install: clean_old_install install_no_local
install-lib: install_no_local_lib
endif

install-all: install install-lib

##################
# Uninstallation
##################

uninstall: clean_old_install

##################
# Why3 emacs mode
##################

%.elc: %.el
	$(EMACS) --batch --no-init-file -f batch-byte-compile $<

##################
# Why3 plugins
##################

PLUGGENERATED = plugins/tptp/tptp_lexer.ml \
		plugins/tptp/tptp_parser.ml plugins/tptp/tptp_parser.mli \
		plugins/parser/dimacs.ml \

PLUG_PARSER = genequlin dimacs
PLUG_PRINTER =
PLUG_TRANSFORM =
PLUG_TPTP = tptp_ast tptp_parser tptp_typing tptp_lexer tptp_printer

PLUGINS = genequlin dimacs tptp

TPTPMODULES = $(addprefix plugins/tptp/, $(PLUG_TPTP))

TPTPCMO = $(addsuffix .cmo, $(TPTPMODULES))
TPTPCMX = $(addsuffix .cmx, $(TPTPMODULES))

ifeq (@enable_hypothesis_selection@,yes)
PLUG_TRANSFORM += hypothesis_selection
PLUGINS += hypothesis_selection

lib/plugins/hypothesis_selection.cmxs: INCLUDES += -I @OCAMLGRAPHLIB@
lib/plugins/hypothesis_selection.cmo:  INCLUDES += -I @OCAMLGRAPHLIB@
lib/plugins/hypothesis_selection.cmxs: OFLAGS += graph.cmxa
lib/plugins/hypothesis_selection.cmo:  BFLAGS += graph.cmo
endif

PLUGMODULES = $(addprefix plugins/parser/, $(PLUG_PARSER)) \
	      $(addprefix plugins/printer/, $(PLUG_PRINTER)) \
	      $(addprefix plugins/transform/, $(PLUG_TRANSFORM)) \
	      $(TPTPMODULES)

PLUGDEP = $(addsuffix .dep, $(PLUGMODULES))
PLUGCMO = $(addsuffix .cmo, $(PLUGMODULES))
PLUGCMX = $(addsuffix .cmx, $(PLUGMODULES))

PLUGDIRS = parser printer transform tptp
PLUGINCLUDES = $(addprefix -I plugins/, $(PLUGDIRS))

$(PLUGDEP): DEPFLAGS += $(PLUGINCLUDES)
$(PLUGCMO) $(PLUGCMX): INCLUDES += $(PLUGINCLUDES)

$(PLUGDEP): $(PLUGGENERATED)

LIBPLUGCMO =  $(addsuffix .cmo,  $(addprefix lib/plugins/, $(PLUGINS)))
LIBPLUGCMXS = $(addsuffix .cmxs, $(addprefix lib/plugins/, $(PLUGINS)))

plugins.byte: $(LIBPLUGCMO)
plugins.opt : $(LIBPLUGCMXS)

lib/plugins/%.cmxs: plugins/parser/%.cmx
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -shared -o $@ $<

lib/plugins/%.cmo: plugins/parser/%.cmo
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -pack -o $@ $<

lib/plugins/%.cmxs: plugins/printer/%.cmx
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -shared -o $@ $<

lib/plugins/%.cmo: plugins/printer/%.cmo
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -pack -o $@ $<

lib/plugins/%.cmxs: plugins/transform/%.cmx
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -shared -o $@ $<

lib/plugins/%.cmo: plugins/transform/%.cmo
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -pack -o $@ $<

lib/plugins/tptp.cmxs: $(TPTPCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -shared -o $@ $^

lib/plugins/tptp.cmo: $(TPTPCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -pack -o $@ $^

PLUGSDIRS = plugins $(addprefix plugins/, $(PLUGDIRS))
PLUGCLEAN = $(addsuffix /*.cm[iox], $(PLUGSDIRS)) \
	    $(addsuffix /*.annot, $(PLUGSDIRS)) \
	    $(addsuffix /*.output, $(PLUGSDIRS)) \
	    $(addsuffix /*.automaton, $(PLUGSDIRS)) \
	    $(addsuffix /*.dep, $(PLUGSDIRS)) \
	    $(addsuffix /*.o, $(PLUGSDIRS)) \
	    $(addsuffix /*~, $(PLUGSDIRS))

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(PLUGDEP)
endif

depend: $(PLUGDEP)

clean::
	rm -f $(PLUGCLEAN) $(PLUGGENERATED)
	rm -f lib/plugins/*

install_no_local::
	mkdir -p $(LIBDIR)/why3/plugins
	cp -f $(foreach f,$(LIBPLUGCMO) $(LIBPLUGCMXS),$(wildcard $(f))) $(LIBDIR)/why3/plugins

######
# Why3
######

src/main.cmo: lib/why3/why3.cma
src/main.cmx: lib/why3/why3.cmxa

byte: bin/why3.byte
opt:  bin/why3.opt

bin/why3.opt: lib/why3/why3.cmxa src/main.cmx
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3.byte: lib/why3/why3.cma src/main.cmo
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) $^

bin/why3: bin/why3.@OCAMLBEST@
	ln -sf why3.@OCAMLBEST@ $@

install_no_local::
	cp -f bin/why3.@OCAMLBEST@ $(BINDIR)/why3$(EXE)

install_local: bin/why3

ifneq "$(MAKECMDGOALS)" "clean"
include src/main.dep
endif

depend: src/main.dep

clean::
	rm -f src/main.cm[iox] src/main.annot src/main.o src/main.dep
	rm -f bin/why3.byte bin/why3.opt bin/why3
	rm -f bin/why3ml.byte bin/why3ml.opt bin/why3ml

##############
# test targets
##############

%.gui: %.why bin/why3ide.opt
	bin/why3ide.opt $*.why

%: %.mlw bin/why3.opt
	bin/why3.opt $*.mlw

%: %.why bin/why3.opt
	bin/why3.opt $*.why

%.gui: %.mlw bin/why3ide.opt
	bin/why3ide.opt $*.mlw

%.type: %.mlw bin/why3ide.opt
	bin/why3.opt --type-only $*.mlw

##########
# gallery
##########

# we export exactly the programs that have a why3session.xml file

.PHONY: gallery

gallery::
	@if test "$(GALLERYDIR)" = ""; then echo "set GALLERYDIR first"; exit 1; fi
	@for x in examples/*/why3session.xml ; do \
	  d=`dirname $$x`; \
	  f=`basename $$d`; \
	  why3session html $$x; \
	  echo "exporting $$f"; \
	  mkdir -p $(GALLERYDIR)/$$f; \
	  cp examples/$$f.mlw examples/$$f/why3session.html $(GALLERYDIR)/$$f/; \
	  rm -f $(GALLERYDIR)/$$f/$$f.zip; \
	  cd examples/; \
	  zip -r $(GALLERYDIR)/$$f/$$f.zip $$f.mlw $$f; \
	  cd ..; \
	done

%-gallery::
	@if test "$(GALLERYDIR)" = ""; then echo "set GALLERYDIR first"; exit 1; fi
	x=$*/why3session.xml; \
	d=`dirname $$x`; \
	f=`basename $$d`; \
	why3session html $$x; \
	echo "exporting $$f"; \
	mkdir -p $(GALLERYDIR)/$$f; \
	if test -f examples/$$f.mlw; then cp examples/$$f.mlw $(GALLERYDIR)/$$f/; fi; \
	if test -f examples/$$f.why; then cp examples/$$f.why $(GALLERYDIR)/$$f/; fi; \
	cp examples/$$f/why3session.html $(GALLERYDIR)/$$f/; \
	rm -f $(GALLERYDIR)/$$f/$$f.zip; \
	cd examples/; \
	zip -r $(GALLERYDIR)/$$f/$$f.zip $$f.mlw $$f

########
# XML DTD validation
########

.PHONY: xml-validate

xml-validate:
	@for x in `find examples/ -name why3session.xml`; do \
	  xmllint --noout --valid $$x 2>&1 | head -1; \
	done

xml-validate-local:
	@for x in `find examples/ -name why3session.xml`; do \
	  xmllint --noout --dtdvalid share/why3session.dtd $$x 2>&1 | head -1; \
	done

########
# Config
########

CONFIG_FILES = why3config

CONFIGMODULES = $(addprefix src/why3config/, $(CONFIG_FILES))

CONFIGDEP = $(addsuffix .dep, $(CONFIGMODULES))
CONFIGCMO = $(addsuffix .cmo, $(CONFIGMODULES))
CONFIGCMX = $(addsuffix .cmx, $(CONFIGMODULES))

# build targets

byte: bin/why3config.byte
opt:  bin/why3config.opt

bin/why3config.opt: lib/why3/why3.cmxa $(CONFIGCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3config.byte: lib/why3/why3.cma $(CONFIGCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) $^

bin/why3config: bin/why3config.@OCAMLBEST@
	ln -sf why3config.@OCAMLBEST@ $@

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(CONFIGDEP)
endif

depend: $(CONFIGDEP)

clean::
	rm -f src/why3config/*.cm[iox] src/why3config/*.o
	rm -f src/why3config/*.annot src/why3config/*.dep src/why3config/*~
	rm -f src/why3config/*.output src/why3config/*.automaton
	rm -f bin/why3config.byte bin/why3config.opt bin/why3config

local_config: bin/why3config.@OCAMLBEST@
	WHY3LIB=$(PWD) WHY3DATA=$(PWD)/share bin/why3config.@OCAMLBEST@ \
		--detect --conf_file why3.conf

install_no_local::
	cp -f bin/why3config.@OCAMLBEST@ $(BINDIR)/why3config$(EXE)

install_local: bin/why3config

###############
# IDE
###############

ifeq (@enable_ide@,yes)

IDE_FILES = gconfig gmain

IDEMODULES = $(addprefix src/ide/, $(IDE_FILES))

IDEDEP = $(addsuffix .dep, $(IDEMODULES))
IDECMO = $(addsuffix .cmo, $(IDEMODULES))
IDECMX = $(addsuffix .cmx, $(IDEMODULES))

$(IDEDEP): DEPFLAGS += -I src/ide
$(IDECMO) $(IDECMX): INCLUDES += -I src/ide

# build targets

byte: bin/why3ide.byte
opt:  bin/why3ide.opt

bin/why3ide.opt bin/why3ide.byte: INCLUDES += -I @LABLGTK2LIB@
bin/why3ide.opt bin/why3ide.byte: EXTLIBS += lablgtk lablgtksourceview2

bin/why3ide.opt: lib/why3/why3.cmxa src/ide/resetgc.o $(IDECMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3ide.byte: lib/why3/why3.cma src/ide/resetgc.o $(IDECMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) -custom $^

bin/why3ide: bin/why3ide.@OCAMLBEST@
	ln -sf why3ide.@OCAMLBEST@ $@

src/ide/resetgc.o: src/ide/resetgc.c
	$(OCAMLC) -c -ccopt "-Wall -o $@" $<

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(IDEDEP)
endif

depend: $(IDEDEP)

clean::
	rm -f src/ide/xml.ml
	rm -f src/ide/*.cm[iox] src/ide/*.o
	rm -f src/ide/*.annot src/ide/*.dep src/ide/*~
	rm -f bin/why3ide.byte bin/why3ide.opt bin/why3ide

install_no_local::
	cp -f bin/why3ide.@OCAMLBEST@ $(BINDIR)/why3ide$(EXE)

install_local: bin/why3ide

endif


###############
# Replayer
###############

REPLAYER_FILES = replay

REPLAYERMODULES = $(addprefix src/why3replayer/, $(REPLAYER_FILES))

REPLAYERDEP = $(addsuffix .dep, $(REPLAYERMODULES))
REPLAYERCMO = $(addsuffix .cmo, $(REPLAYERMODULES))
REPLAYERCMX = $(addsuffix .cmx, $(REPLAYERMODULES))

$(REPLAYERDEP): DEPFLAGS += -I src/why3replayer
$(REPLAYERCMO) $(REPLAYERCMX): INCLUDES += -I src/why3replayer

# build targets

byte: bin/why3replayer.byte
opt:  bin/why3replayer.opt

bin/why3replayer.opt: lib/why3/why3.cmxa $(REPLAYERCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3replayer.byte: lib/why3/why3.cma $(REPLAYERCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) $^

bin/why3replayer: bin/why3replayer.@OCAMLBEST@
	ln -sf why3replayer.@OCAMLBEST@ $@

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(REPLAYERDEP)
endif

depend: $(REPLAYERDEP)

clean::
	rm -f src/why3replayer/*.cm[iox] src/why3replayer/*.o
	rm -f src/why3replayer/*.annot src/why3replayer/*.dep src/why3replayer/*~
	rm -f bin/why3replayer.byte bin/why3replayer.opt bin/why3replayer

install_no_local::
	cp -f bin/why3replayer.@OCAMLBEST@ $(BINDIR)/why3replayer$(EXE)

install_local: bin/why3replayer


###############
# Session
###############

SESSION_FILES = why3session_lib why3session_copy why3session_info	\
		why3session_latex why3session_html why3session_rm	\
		why3session_output why3session_run why3session_csv	\
		why3session

SESSIONMODULES = $(addprefix src/why3session/, $(SESSION_FILES))

SESSIONDEP = $(addsuffix .dep, $(SESSIONMODULES))
SESSIONCMO = $(addsuffix .cmo, $(SESSIONMODULES))
SESSIONCMX = $(addsuffix .cmx, $(SESSIONMODULES))

$(SESSIONDEP): DEPFLAGS += -I src/why3session
$(SESSIONCMO) $(SESSIONCMX): INCLUDES += -I src/why3session

# build targets

byte: bin/why3session.byte
opt:  bin/why3session.opt

bin/why3session.opt: lib/why3/why3.cmxa $(SESSIONCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3session.byte: lib/why3/why3.cma $(SESSIONCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) $^

bin/why3session: bin/why3session.@OCAMLBEST@
	ln -sf why3session.@OCAMLBEST@ $@

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(SESSIONDEP)
endif

depend: $(SESSIONDEP)

clean::
	rm -f src/why3session/*.cm[iox] src/why3session/*.o
	rm -f src/why3session/*.annot src/why3session/*.dep src/why3session/*~
	rm -f bin/why3session.byte bin/why3session.opt bin/why3session

install_no_local::
	cp -f bin/why3session.@OCAMLBEST@ $(BINDIR)/why3session$(EXE)

install_local: bin/why3session


###############
# Bench
###############

ifeq (@enable_bench@,yes)

BENCH_FILES = worker db bench benchrc benchdb why3bench

BENCHMODULES := $(addprefix src/why3bench/, $(BENCH_FILES))

BENCHDEP = $(addsuffix .dep, $(BENCHMODULES))
BENCHCMO = $(addsuffix .cmo, $(BENCHMODULES))
BENCHCMX = $(addsuffix .cmx, $(BENCHMODULES))

$(BENCHDEP): DEPFLAGS += -I src/why3bench
$(BENCHCMO) $(BENCHCMX): INCLUDES += -I src/why3bench -I @SQLITE3LIB@

# build targets

byte: bin/why3bench.byte
opt:  bin/why3bench.opt

bin/why3bench.opt bin/why3bench.byte: INCLUDES += -thread -I +threads -I @SQLITE3LIB@
bin/why3bench.opt bin/why3bench.byte: EXTLIBS += threads sqlite3

bin/why3bench.opt: lib/why3/why3.cmxa $(BENCHCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3bench.byte: lib/why3/why3.cma $(BENCHCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) $^

bin/why3bench: bin/why3bench.@OCAMLBEST@
	ln -sf why3bench.@OCAMLBEST@ $@

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(BENCHDEP)
endif

depend: $(BENCHDEP)

clean::
	rm -f src/why3bench/*.cm[iox] src/why3bench/*.o
	rm -f src/why3bench/*.annot src/why3bench/*.dep src/why3bench/*~
	rm -f bin/why3bench.byte bin/why3bench.opt bin/why3bench

install_no_local::
	cp -f bin/why3bench.@OCAMLBEST@ $(BINDIR)/why3bench$(EXE)

install_local: bin/why3bench

endif

##############
# Coq plugin
##############

ifeq (@enable_coq_tactic@,yes)

COQPGENERATED = src/coq-tactic/coqCompat.ml src/coq-tactic/g_why3tac.ml

COQP_FILES = coqCompat why3tac g_why3tac

COQPMODULES = $(addprefix src/coq-tactic/, $(COQP_FILES))

COQPDEP = $(addsuffix .dep, $(COQPMODULES))
COQPCMO = $(addsuffix .cmo, $(COQPMODULES))
COQPCMX = $(addsuffix .cmx, $(COQPMODULES))

COQPTREES = kernel lib interp parsing proofs pretyping tactics library toplevel
COQPINCLUDES = -I src/coq-tactic -I +camlp5 $(addprefix -I @COQLIB@/, $(COQPTREES))

$(COQPDEP): DEPFLAGS += -I src/coq-tactic
$(COQPCMO) $(COQPCMX): INCLUDES += $(COQPINCLUDES)
$(COQPCMO) $(COQPCMX): BFLAGS += -rectypes
$(COQPCMX): OFLAGS += -rectypes

$(COQPDEP): $(COQPGENERATED)

byte: src/coq-tactic/.why3-vo-byte
opt:  src/coq-tactic/.why3-vo-opt

src/coq-tactic/coqCompat.ml: src/coq-tactic/coqCompat@coq_compat_version@.ml
	cp -f $< $@

lib/coq-tactic/why3tac.cmxs: lib/why3/why3.cmxa $(COQPCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ -shared $^

lib/coq-tactic/why3tac.cma: lib/why3/why3.cma $(COQPCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) -a $(BFLAGS) -o $@ $^

src/coq-tactic/g_why3tac.ml: src/coq-tactic/g_why3tac.ml4
	$(if $(QUIET),@echo 'Camlp5   $<' &&) \
	    $(CAMLP5O) pr_o.cmo @COQLIB@/parsing/grammar.cma -impl $^ -o $@

src/coq-tactic/.why3-vo-byte: lib/coq-tactic/Why3.v lib/coq-tactic/why3tac.cma
	$(if $(QUIET),@echo 'Coqc     $<' &&) \
	    WHY3CONFIG="" $(COQC) -byte -I lib/coq-tactic/ $< && \
	    touch src/coq-tactic/.why3-vo-byte

src/coq-tactic/.why3-vo-opt: lib/coq-tactic/Why3.v lib/coq-tactic/why3tac.cmxs
	$(if $(QUIET),@echo 'Coqc     $<' &&) \
	    WHY3CONFIG="" $(COQC) -opt -I lib/coq-tactic/ $< && \
	    touch src/coq-tactic/.why3-vo-opt

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(COQPDEP)
endif

depend: $(COQPDEP)

clean::
	rm -f src/coq-tactic/*.cm[iox] src/coq-tactic/*.o
	rm -f lib/coq-tactic/*.cma lib/coq-tactic/*.cmxs
	rm -f lib/coq-tactic/*.vo lib/coq-tactic/*.glob
	rm -f src/coq-tactic/*.annot src/coq-tactic/*.dep src/coq-tactic/*~
	rm -f src/coq-tactic/.why3-vo-*
	rm -f $(COQPGENERATED)

install_no_local::
	mkdir -p $(LIBDIR)/why3/coq-tactic
	cp -f lib/coq-tactic/* $(LIBDIR)/why3/coq-tactic

endif

####################
# Coq realizations
####################

ifeq (@enable_coq_libs@,yes)

COQLIBS_INT_FILES = Abs ComputerDivision Div2 EuclideanDivision Int MinMax Power
COQLIBS_INT_ALL_FILES = Exponentiation $(COQLIBS_INT_FILES)
COQLIBS_INT = $(addprefix lib/coq/int/, $(COQLIBS_INT_ALL_FILES))

COQLIBS_BOOL_FILES = Bool
COQLIBS_BOOL = $(addprefix lib/coq/bool/, $(COQLIBS_BOOL_FILES))

COQLIBS_REAL_FILES = Abs ExpLog FromInt MinMax PowerInt Real RealInfix Square Trigonometry
COQLIBS_REAL = $(addprefix lib/coq/real/, $(COQLIBS_REAL_FILES))

COQLIBS_NUMBER_FILES = Divisibility Gcd Parity Prime Coprime
COQLIBS_NUMBER = $(addprefix lib/coq/number/, $(COQLIBS_NUMBER_FILES))

COQLIBS_SET_FILES = Set
COQLIBS_SET = $(addprefix lib/coq/set/, $(COQLIBS_SET_FILES))

COQLIBS_MAP_FILES = Map Occ MapPermut MapInjection
COQLIBS_MAP = $(addprefix lib/coq/map/, $(COQLIBS_MAP_FILES))

COQLIBS_LIST_FILES = List Length Mem Nth NthLength HdTl NthHdTl Append NthLengthAppend Reverse HdTlNoOpt NthNoOpt RevAppend Combine Distinct NumOcc Permut
COQLIBS_LIST = $(addprefix lib/coq/list/, $(COQLIBS_LIST_FILES))

COQLIBS_OPTION_FILES = Option
COQLIBS_OPTION = $(addprefix lib/coq/option/, $(COQLIBS_OPTION_FILES))

ifeq (@enable_coq_fp_libs@,yes)
COQLIBS_FP_FILES = Rounding SingleFormat Single DoubleFormat Double
COQLIBS_FP_ALL_FILES = GenFloat $(COQLIBS_FP_FILES)
COQLIBS_FP = $(addprefix lib/coq/floating_point/, $(COQLIBS_FP_ALL_FILES))
endif

COQLIBS_FILES = lib/coq/BuiltIn $(COQLIBS_INT) $(COQLIBS_BOOL) $(COQLIBS_REAL) $(COQLIBS_NUMBER) $(COQLIBS_SET) $(COQLIBS_MAP) $(COQLIBS_LIST) $(COQLIBS_OPTION) $(COQLIBS_FP)

COQV  = $(addsuffix .v,  $(COQLIBS_FILES))
COQVO = $(addsuffix .vo, $(COQLIBS_FILES))
COQVD = $(addsuffix .vd, $(COQLIBS_FILES))

%.vo: %.v
	$(if $(QUIET),@echo 'Coqc     $<' &&) \
	    $(COQC) -R lib/coq Why3 $<

%.vd: %.v
	$(if $(QUIET),@echo 'Coqdep   $<' &&) \
	    $(COQDEP) -slash -R lib/coq Why3 $< > $@

drivers/coq-realizations.aux: Makefile
	$(if $(QUIET),@echo 'Generate $@' &&) \
	(echo "(* generated automatically at compilation time *)"; \
	echo 'theory BuiltIn meta "realized_theory" "BuiltIn", "" end'; \
	for f in $(COQLIBS_INT_FILES); do \
	echo 'theory int.'"$$f"' meta "realized_theory" "int.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_BOOL_FILES); do \
	echo 'theory bool.'"$$f"' meta "realized_theory" "bool.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_REAL_FILES); do \
	echo 'theory real.'"$$f"' meta "realized_theory" "real.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_NUMBER_FILES); do \
	echo 'theory number.'"$$f"' meta "realized_theory" "number.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_SET_FILES); do \
	echo 'theory set.'"$$f"' meta "realized_theory" "set.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_MAP_FILES); do \
	echo 'theory map.'"$$f"' meta "realized_theory" "map.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_LIST_FILES); do \
	echo 'theory list.'"$$f"' meta "realized_theory" "list.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_OPTION_FILES); do \
	echo 'theory option.'"$$f"' meta "realized_theory" "option.'"$$f"'", "" end'; done; \
	for f in $(COQLIBS_FP_FILES); do \
	echo 'theory floating_point.'"$$f"' meta "realized_theory" "floating_point.'"$$f"'", "" end'; done; \
	) > $@

opt byte: $(COQVO)

install_no_local::
	mkdir -p $(LIBDIR)/why3/coq
	cp lib/coq/BuiltIn.vo $(LIBDIR)/why3/coq/
	mkdir -p $(LIBDIR)/why3/coq/int
	cp $(addsuffix .vo, $(COQLIBS_INT)) $(LIBDIR)/why3/coq/int/
	mkdir -p $(LIBDIR)/why3/coq/bool
	cp $(addsuffix .vo, $(COQLIBS_BOOL)) $(LIBDIR)/why3/coq/bool/
	mkdir -p $(LIBDIR)/why3/coq/real
	cp $(addsuffix .vo, $(COQLIBS_REAL)) $(LIBDIR)/why3/coq/real/
	mkdir -p $(LIBDIR)/why3/coq/number
	cp $(addsuffix .vo, $(COQLIBS_NUMBER)) $(LIBDIR)/why3/coq/number/
	mkdir -p $(LIBDIR)/why3/coq/set
	cp $(addsuffix .vo, $(COQLIBS_SET)) $(LIBDIR)/why3/coq/set/
	mkdir -p $(LIBDIR)/why3/coq/map
	cp $(addsuffix .vo, $(COQLIBS_MAP)) $(LIBDIR)/why3/coq/map/
	mkdir -p $(LIBDIR)/why3/coq/list
	cp $(addsuffix .vo, $(COQLIBS_LIST)) $(LIBDIR)/why3/coq/list/
	mkdir -p $(LIBDIR)/why3/coq/option
	cp $(addsuffix .vo, $(COQLIBS_OPTION)) $(LIBDIR)/why3/coq/option/
ifeq (@enable_coq_fp_libs@,yes)
	mkdir -p $(LIBDIR)/why3/coq/floating_point
	cp $(addsuffix .vo, $(COQLIBS_FP)) $(LIBDIR)/why3/coq/floating_point/
endif
	cp drivers/coq-realizations.aux $(DATADIR)/why3/drivers/

install_local: $(COQVO) drivers/coq-realizations.aux

ifneq "$(MAKECMDGOALS)" "clean"
ifneq "$(MAKECMDGOALS:update-coq%=update-coq)" "update-coq"
include $(COQVD)
endif
endif

depend: $(COQVD)

clean::
	rm -f $(COQVO) $(COQVD) $(addsuffix .glob, $(COQLIBS_FILES))

update-coq: update-coq-int update-coq-bool update-coq-real update-coq-number update-coq-set update-coq-map update-coq-list update-coq-option update-coq-fp

update-coq-int: bin/why3 drivers/coq-realizations.aux theories/int.why
	for f in $(COQLIBS_INT_ALL_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T int.$$f -o lib/coq/int/; done

update-coq-bool: bin/why3 drivers/coq-realizations.aux theories/bool.why
	for f in $(COQLIBS_BOOL_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T bool.$$f -o lib/coq/bool/; done

update-coq-real: bin/why3 drivers/coq-realizations.aux theories/real.why
	for f in $(COQLIBS_REAL_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T real.$$f -o lib/coq/real/; done

update-coq-number: bin/why3 drivers/coq-realizations.aux theories/number.why
	for f in $(COQLIBS_NUMBER_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T number.$$f -o lib/coq/number/; done

update-coq-set: bin/why3 drivers/coq-realizations.aux theories/set.why
	for f in $(COQLIBS_SET_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T set.$$f -o lib/coq/set/; done

update-coq-map: bin/why3 drivers/coq-realizations.aux theories/map.why
	for f in $(COQLIBS_MAP_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T map.$$f -o lib/coq/map/; done

update-coq-list: bin/why3 drivers/coq-realizations.aux theories/list.why
	for f in $(COQLIBS_LIST_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T list.$$f -o lib/coq/list/; done

update-coq-option: bin/why3 drivers/coq-realizations.aux theories/option.why
	for f in $(COQLIBS_OPTION_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T option.$$f -o lib/coq/option/; done

update-coq-fp: bin/why3 drivers/coq-realizations.aux theories/floating_point.why
	for f in $(COQLIBS_FP_FILES); do WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/coq-realize.drv -T floating_point.$$f -o lib/coq/floating_point/; done

else

drivers/coq-realizations.aux:
	echo "(* generated automatically at compilation time *)" > $@

install_no_local::
	cp drivers/coq-realizations.aux $(DATADIR)/why3/drivers/

endif

opt byte: drivers/coq-realizations.aux

clean::
	rm -f drivers/coq-realizations.aux

####################
# PVS realizations
####################

ifeq (@enable_pvs_libs@,yes)

PVSLIBS_INT_FILES = Int Abs MinMax ComputerDivision EuclideanDivision
PVSLIBS_INT = $(addprefix lib/pvs/int/, $(PVSLIBS_INT_FILES))

PVSLIBS_REAL_FILES = Abs FromInt MinMax Real Square ExpLog Trigonometry \
                     PowerInt
 # RealInfix
PVSLIBS_REAL = $(addprefix lib/pvs/real/, $(PVSLIBS_REAL_FILES))

PVSLIBS_LIST_FILES =
  # Nth
PVSLIBS_LIST = $(addprefix lib/pvs/int/, $(PVSLIBS_LIST_FILES))

PVSLIBS_NUMBER_FILES = # Divisibility Gcd Parity Prime
PVSLIBS_NUMBER = $(addprefix lib/pvs/number/, $(PVSLIBS_NUMBER_FILES))

PVSLIBS_FP_FILES = Rounding SingleFormat Single DoubleFormat Double
PVSLIBS_FP_ALL_FILES = $(PVSLIBS_FP_FILES)
PVSLIBS_FP = $(addprefix lib/pvs/floating_point/, $(PVSLIBS_FP_ALL_FILES))

PVSLIBS_FILES = $(PVSLIBS_INT) $(PVSLIBS_REAL) $(PVSLIBS_LIST) \
                $(PVSLIBS_NUMBER) $(PVSLIBS_FP)

drivers/pvs-realizations.aux: Makefile
	$(if $(QUIET),@echo 'Generate $@' &&) \
	(echo "(* generated automatically at compilation time *)"; \
	for f in $(PVSLIBS_INT_FILES); do \
	echo 'theory int.'"$$f"' meta "realized_theory" "int.'"$$f"'", "" end'; done; \
	for f in $(PVSLIBS_REAL_FILES); do \
	echo 'theory real.'"$$f"' meta "realized_theory" "real.'"$$f"'", "" end'; done; \
	for f in $(PVSLIBS_LIST_FILES); do \
	echo 'theory list.'"$$f"' meta "realized_theory" "list.'"$$f"'", "" end'; done; \
	for f in $(PVSLIBS_NUMBER_FILES); do \
	echo 'theory number.'"$$f"' meta "realized_theory" "number.'"$$f"'", "" end'; done; \
	for f in $(PVSLIBS_FP_FILES); do \
	echo 'theory floating_point.'"$$f"' meta "realized_theory" "floating_point.'"$$f"'", "" end'; done; \
	) > $@

install_no_local::
	mkdir -p $(LIBDIR)/why3/pvs/int
	cp $(addsuffix .pvs, $(PVSLIBS_INT)) $(LIBDIR)/why3/pvs/int/
	cp $(addsuffix .prf, $(PVSLIBS_INT)) $(LIBDIR)/why3/pvs/int/
	mkdir -p $(LIBDIR)/why3/pvs/real
	cp $(addsuffix .pvs, $(PVSLIBS_REAL)) $(LIBDIR)/why3/pvs/real/
	cp $(addsuffix .prf, $(PVSLIBS_REAL)) $(LIBDIR)/why3/pvs/real/
	mkdir -p $(LIBDIR)/why3/pvs/floating_point/
	cp $(addsuffix .pvs, $(PVSLIBS_FP)) $(LIBDIR)/why3/pvs/floating_point/
	cp drivers/pvs-realizations.aux $(DATADIR)/why3/drivers/

install_local: drivers/pvs-realizations.aux

update-pvs: bin/why3 drivers/pvs-realizations.aux
	for f in $(PVSLIBS_INT_FILES); do bin/why3 --realize -D drivers/pvs-realize.drv -T int.$$f -o lib/pvs/int/; done
	for f in $(PVSLIBS_REAL_FILES); do bin/why3 --realize -D drivers/pvs-realize.drv -T real.$$f -o lib/pvs/real/; done
	for f in $(PVSLIBS_LIST_FILES); do bin/why3 --realize -D drivers/pvs-realize.drv -T list.$$f -o lib/pvs/list/; done
	for f in $(PVSLIBS_NUMBER_FILES); do bin/why3 --realize -D drivers/pvs-realize.drv -T number.$$f -o lib/pvs/number/; done
	for f in $(PVSLIBS_FP_FILES); do bin/why3 --realize -D drivers/pvs-realize.drv -T floating_point.$$f -o lib/pvs/floating_point/; done

else

drivers/pvs-realizations.aux:
	echo "(* generated automatically at compilation time *)" > $@

install_no_local::
	cp drivers/pvs-realizations.aux $(DATADIR)/why3/drivers/

endif

opt byte: drivers/pvs-realizations.aux

clean::
	rm -f drivers/pvs-realizations.aux

#######################
# Isabelle realizations
#######################

ifeq (@enable_isabelle_libs@,yes)

ISABELLELIBS_INT_FILES = Exponentiation Abs ComputerDivision Div2 EuclideanDivision Int MinMax Power
ISABELLELIBS_INT = $(addsuffix .xml, $(addprefix lib/isabelle/int/, $(ISABELLELIBS_INT_FILES)))

ISABELLELIBS_BOOL_FILES = Bool
ISABELLELIBS_BOOL = $(addsuffix .xml, $(addprefix lib/isabelle/bool/, $(ISABELLELIBS_BOOL_FILES)))

ISABELLELIBS_REAL_FILES = # not yet realized : Abs ExpLog FromInt MinMax PowerInt Real Square RealInfix
ISABELLELIBS_REAL = $(addsuffix .xml, $(addprefix lib/isabelle/real/, $(ISABELLELIBS_REAL_FILES)))

ISABELLELIBS_NUMBER_FILES = Divisibility Gcd Parity Prime Coprime
ISABELLELIBS_NUMBER = $(addsuffix .xml, $(addprefix lib/isabelle/number/, $(ISABELLELIBS_NUMBER_FILES)))

ISABELLELIBS_SET_FILES = Set Fset
ISABELLELIBS_SET = $(addsuffix .xml, $(addprefix lib/isabelle/set/, $(ISABELLELIBS_SET_FILES)))

ISABELLELIBS_MAP_FILES = Map Occ MapPermut MapInjection
ISABELLELIBS_MAP = $(addsuffix .xml, $(addprefix lib/isabelle/map/, $(ISABELLELIBS_MAP_FILES)))

ISABELLELIBS_LIST_FILES = List Length Mem Nth NthNoOpt NthLength HdTl NthHdTl Append NthLengthAppend Reverse HdTlNoOpt RevAppend Combine Distinct NumOcc Permut
ISABELLELIBS_LIST = $(addsuffix .xml, $(addprefix lib/isabelle/list/, $(ISABELLELIBS_LIST_FILES)))

drivers/isabelle-realizations.aux: Makefile
	$(if $(QUIET),@echo 'Generate $@' &&) \
	(echo "(* generated automatically at compilation time *)"; \
	echo 'theory BuiltIn meta "realized_theory" "BuiltIn", "" end'; \
	for f in $(ISABELLELIBS_INT_FILES); do \
	echo 'theory int.'"$$f"' meta "realized_theory" "int.'"$$f"'", "" end'; done; \
	for f in $(ISABELLELIBS_BOOL_FILES); do \
	echo 'theory bool.'"$$f"' meta "realized_theory" "bool.'"$$f"'", "" end'; done; \
	for f in $(ISABELLELIBS_REAL_FILES); do \
	echo 'theory real.'"$$f"' meta "realized_theory" "real.'"$$f"'", "" end'; done; \
	for f in $(ISABELLELIBS_NUMBER_FILES); do \
	echo 'theory number.'"$$f"' meta "realized_theory" "number.'"$$f"'", "" end'; done; \
	for f in $(ISABELLELIBS_SET_FILES); do \
	echo 'theory set.'"$$f"' meta "realized_theory" "set.'"$$f"'", "" end'; done; \
	for f in $(ISABELLELIBS_MAP_FILES); do \
	echo 'theory map.'"$$f"' meta "realized_theory" "map.'"$$f"'", "" end'; done; \
	for f in $(ISABELLELIBS_LIST_FILES); do \
	echo 'theory list.'"$$f"' meta "realized_theory" "list.'"$$f"'", "" end'; done; \
	for f in $(ISABELLELIBS_OPTION_FILES); do \
	echo 'theory option.'"$$f"' meta "realized_theory" "option.'"$$f"'", "" end'; done; \
	) > $@

install_no_local::
	cp -r lib/isabelle $(LIBDIR)/why3
	cp drivers/isabelle-realizations.aux $(DATADIR)/why3/drivers/

update-isabelle: $(ISABELLELIBS_INT) $(ISABELLELIBS_BOOL) $(ISABELLELIBS_REAL) $(ISABELLELIBS_NUMBER) $(ISABELLELIBS_SET) $(ISABELLELIBS_MAP) $(ISABELLELIBS_LIST) $(ISABELLELIBS_OPTION)

$(ISABELLELIBS_INT): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/int.why
	mkdir -p lib/isabelle/int
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T int.$(notdir $(basename $@)) -o lib/isabelle/int/

$(ISABELLELIBS_BOOL): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/bool.why
	mkdir -p lib/isabelle/bool
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T bool.$(notdir $(basename $@)) -o lib/isabelle/bool/

$(ISABELLELIBS_REAL): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/real.why
	mkdir -p lib/isabelle/real
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T real.$(notdir $(basename $@)) -o lib/isabelle/real/

$(ISABELLELIBS_NUMBER): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/number.why
	mkdir -p lib/isabelle/number
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T number.$(notdir $(basename $@)) -o lib/isabelle/number/

$(ISABELLELIBS_SET): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/set.why
	mkdir -p lib/isabelle/set
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T set.$(notdir $(basename $@)) -o lib/isabelle/set/

$(ISABELLELIBS_MAP): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/map.why
	mkdir -p lib/isabelle/map
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T map.$(notdir $(basename $@)) -o lib/isabelle/map/

$(ISABELLELIBS_LIST): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/list.why
	mkdir -p lib/isabelle/list
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T list.$(notdir $(basename $@)) -o lib/isabelle/list/

$(ISABELLELIBS_OPTION): bin/why3 drivers/isabelle-realizations.aux \
  drivers/isabelle-realize.drv drivers/isabelle-common.gen theories/option.why
	mkdir -p lib/isabelle/option
	WHY3CONFIG="" bin/why3.@OCAMLBEST@ --realize -L theories -D drivers/isabelle-realize.drv -T option.$(notdir $(basename $@)) -o lib/isabelle/option/

opt byte: update-isabelle

clean::
	rm -f lib/isabelle/*/*.xml

else

drivers/isabelle-realizations.aux:
	echo "(* generated automatically at compilation time *)" > $@

install_no_local::
	cp drivers/isabelle-realizations.aux $(DATADIR)/why3/drivers/

endif

opt byte: drivers/isabelle-realizations.aux

clean::
	rm -f drivers/isabelle-realizations.aux

#######################
# Ocaml realizations
#######################

OCAMLLIBS_FILES = why3__BigInt_compat why3__BigInt why3__IntAux why3__Array

OCAMLLIBS_MODULES := $(addprefix lib/ocaml/, $(OCAMLLIBS_FILES))

OCAMLLIBS_DEP = $(addsuffix .dep, $(OCAMLLIBS_MODULES))
OCAMLLIBS_CMO = $(addsuffix .cmo, $(OCAMLLIBS_MODULES))
OCAMLLIBS_CMX = $(addsuffix .cmx, $(OCAMLLIBS_MODULES))

$(OCAMLLIBS_DEP): DEPFLAGS += -I src/util -I lib/ocaml @BIGINTINCLUDE@
$(OCAMLLIBS_CMO) $(OCAMLLIBS_CMX): INCLUDES += -I src/util -I lib/ocaml  @BIGINTINCLUDE@
$(OCAMLLIBS_CMX): OFLAGS += -for-pack Why3extract

ifneq "$(MAKECMDGOALS)" "clean"
include $(OCAMLLIBS_DEP)
endif

$(OCAMLLIBS_DEP): lib/ocaml/why3__BigInt_compat.ml

depend: $(OCAMLLIBS_DEP)

clean::
	rm -f lib/ocaml/*.cm[iox] lib/ocaml/*.o
	rm -f lib/ocaml/*.annot lib/ocaml/*.dep

opt: $(OCAMLLIBS_CMX)

byte: $(OCAMLLIBS_CMO)


byte: lib/why3/why3extract.cma
opt:  lib/why3/why3extract.cmxa

lib/why3/why3extract.cma: lib/why3/why3extract.cmo
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) -a $(BFLAGS) -o $@ $^

lib/why3/why3extract.cmxa: lib/why3/why3extract.cmx
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) -a $(OFLAGS) -o $@ $^

lib/why3/why3extract.cmo: $(OCAMLLIBS_CMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -pack -o $@ $^

lib/why3/why3extract.cmx: $(OCAMLLIBS_CMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -pack -o $@ $^



install_no_local_lib::
	mkdir -p $(OCAMLINSTALLLIB)/why3
	cp -f lib/why3/why3extract.cm* lib/why3/why3extract.[ao] \
		$(OCAMLINSTALLLIB)/why3



################
# Jessie3 plugin
################

ifeq (@enable_frama_c@,yes)

byte: jessie.byte
opt: jessie.opt

jessie.byte: src/jessie/Makefile lib/why3/why3.cma
	@$(MAKE) -C src/jessie Jessie3.cma

jessie.opt: src/jessie/Makefile lib/why3/why3.cmxa
	@$(MAKE) -C src/jessie Jessie3.cmxs

install_no_local::
	mkdir -p $(FRAMAC_LIBDIR)/plugins/
	cp -f src/jessie/Jessie3.cm* $(FRAMAC_LIBDIR)/plugins/

clean::
	$(MAKE) -C src/jessie clean

endif

#######
# tools
#######

TOOLS = lib/why3-cpulimit$(EXE)

byte opt: $(TOOLS)

lib/why3-cpulimit$(EXE): src/tools/@CPULIMIT@.c
	$(CC) -Wall -o $@ $^

clean::
	rm -f lib/why3-cpulimit$(EXE) src/tools/*~

install_no_local::
	mkdir -p $(LIBDIR)/why3
	cp -f lib/why3-cpulimit$(EXE) $(LIBDIR)/why3/why3-cpulimit$(EXE)
	cp -f lib/why3-call-pvs $(LIBDIR)/why3/why3-call-pvs

########
# why3wc
########

WHY3WCGENERATED = src/tools/why3wc.ml

WHY3WC_FILES = why3wc
WHY3WCMODULES = $(addprefix src/tools/, $(WHY3WC_FILES))

WHY3WCDEP = $(addsuffix .dep, $(WHY3WCMODULES))
WHY3WCCMO = $(addsuffix .cmo, $(WHY3WCMODULES))
WHY3WCCMX = $(addsuffix .cmx, $(WHY3WCMODULES))

$(WHY3WCDEP): DEPFLAGS += -I src/tools
$(WHY3WCCMO) $(WHY3WCCMX): INCLUDES += -I src/tools

$(WHY3WCDEP): $(WHY3WCGENERATED)

byte: bin/why3wc.byte
opt:  bin/why3wc.opt

bin/why3wc.opt: $(WHY3WCCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3wc.byte: $(WHY3WCCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) $^

bin/why3wc: bin/why3wc.@OCAMLBEST@
	ln -sf why3wc.@OCAMLBEST@ $@

ifneq "$(MAKECMDGOALS)" "clean"
include $(WHY3WCDEP)
endif

depend: $(WHY3WCDEP)

clean::
	rm -f $(WHY3WCGENERATED)
	rm -f src/tools/*.cm[iox] src/tools/*.o
	rm -f src/tools/*.annot src/tools/*.dep src/tools/*~
	rm -f bin/why3wc.byte bin/why3wc.opt bin/why3wc

install_no_local::
	cp -f bin/why3wc.@OCAMLBEST@ $(BINDIR)/why3wc$(EXE)

install_local: bin/why3wc

#########
# why3doc
#########

WHY3DOCGENERATED = src/why3doc/doc_lexer.ml

WHY3DOC_FILES = doc_html doc_def doc_lexer doc_main

WHY3DOCMODULES = $(addprefix src/why3doc/, $(WHY3DOC_FILES))

WHY3DOCDEP = $(addsuffix .dep, $(WHY3DOCMODULES))
WHY3DOCCMO = $(addsuffix .cmo, $(WHY3DOCMODULES))
WHY3DOCCMX = $(addsuffix .cmx, $(WHY3DOCMODULES))

$(WHY3DOCDEP): DEPFLAGS += -I src/why3doc
$(WHY3DOCCMO) $(WHY3DOCCMX): INCLUDES += -I src/why3doc

$(WHY3DOCDEP): $(WHY3DOCGENERATED)

# build targets

byte: bin/why3doc.byte
opt:  bin/why3doc.opt

bin/why3doc.opt: lib/why3/why3.cmxa $(WHY3DOCCMX)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLOPT) $(OFLAGS) -o $@ $(OLINKFLAGS) $^

bin/why3doc.byte: lib/why3/why3.cma $(WHY3DOCCMO)
	$(if $(QUIET),@echo 'Linking  $@' &&) \
	    $(OCAMLC) $(BFLAGS) -o $@ $(BLINKFLAGS) $^

bin/why3doc: bin/why3doc.@OCAMLBEST@
	ln -sf why3doc.@OCAMLBEST@ $@

# depend and clean targets

ifneq "$(MAKECMDGOALS)" "clean"
include $(WHY3DOCDEP)
endif

depend: $(WHY3DOCDEP)

clean::
	rm -f $(WHY3DOCGENERATED)
	rm -f src/why3doc/*.cm[iox] src/why3doc/*.o
	rm -f src/why3doc/*.annot src/why3doc/*.dep src/why3doc/*~
	rm -f bin/why3doc.byte bin/why3doc.opt bin/why3doc

install_no_local::
	cp -f bin/why3doc.@OCAMLBEST@ $(BINDIR)/why3doc$(EXE)

install_local: bin/why3doc

########
# bench
########

.PHONY: bench test

bench:: bin/why3.@OCAMLBEST@ bin/why3config.@OCAMLBEST@ plugins $(TOOLS) \
  share/Makefile.config
	$(MAKE) test-api-logic.@OCAMLBEST@
	$(MAKE) test-api-mlw-tree.@OCAMLBEST@
	$(MAKE) test-api-mlw.@OCAMLBEST@
	$(MAKE) test-session.@OCAMLBEST@
	$(MAKE) test-ocaml-extraction
	# desactivé car requiert findlib
	# if test -d examples/runstrat ; then \
	#  $(MAKE) test-runstrat.@OCAMLBEST@ ; fi
	bash bench/bench "bin/why3.@OCAMLBEST@"
	@if test "@enable_coq_tactic@" = "yes"; then \
	   echo "=== checking the Coq tactic ==="; \
	   $(MAKE) test-coq-tactic.@OCAMLBEST@; fi

###############
# test targets
###############

test2: bin/why3.byte $(TOOLS)
	bin/why3.byte tests/test-jcf.why

test: bin/why3.byte plugins.byte $(TOOLS)
	mkdir -p output_why3
	bin/why3.byte -D drivers/why3.drv -o output_why3 tests/test-jcf.why
	# bin/why3.byte -D drivers/alt_ergo.drv tests/test-jcf.why -T Test -G G
	# bin/why3.byte -P alt-ergo --timelimit 3 tests/test-jcf.why -T Test -G G
	# bin/why3.byte -D drivers/coq.drv tests/test-jcf.why -T Test -G G
	echo bin/why3.byte -P alt-ergo --timelimit 1 --prove theories/real.why
	@printf "*** Checking Coq file generation ***\\n"
	@mkdir -p output_coq
	@for i in int.Abs int.EuclideanDivision int.ComputerDivision  \
		real.Abs real.FromIntTest real.SquareTest \
		real.ExpLogTest real.PowerTest real.TrigonometryTest \
		floating_point.Test map.TestBv32 \
		; do \
	  printf "Generating Coq file for $$i\\n" && \
	  	bin/why3.byte -P coq -o output_coq -T $$i ; done
	@printf "*** Checking Coq compilation ***\\n"
	@for i in output_coq/*.v; do printf "coq $$i\\n" && coqc $$i ; done

testl: bin/why3.byte
	ocamlrun -bt bin/why3.byte tests/test-pgm-jcf.mlw
	ocamlrun -bt bin/why3.byte -P alt-ergo tests/test-pgm-jcf.mlw

testl-debug: bin/why3.opt
	bin/why3.opt --debug program_typing tests/test-pgm-jcf.mlw

testl-ide: bin/why3ide.opt
	bin/why3ide.opt tests/test-pgm-jcf.mlw

testl-type: bin/why3.byte
	ocamlrun -bt bin/why3.byte --type-only tests/test-pgm-jcf.mlw

test-api-logic.byte: examples/use_api/logic.ml lib/why3/why3.cma
	$(if $(QUIET),@echo 'Ocaml    $<' &&) \
	ocaml -I lib/why3 $(INCLUDES) $(EXTCMA) lib/why3/why3.cma $< > /dev/null \
	|| (rm -f test-api-logic.byte; printf "Test of Why3 API calls failed. Please fix it"; exit 2)
	@rm -f test-api-logic.byte;

test-api-logic.opt: examples/use_api/logic.ml lib/why3/why3.cmxa
	$(if $(QUIET),@echo 'Ocamlopt $<' &&) \
	($(OCAMLOPT) -o $@ -I lib/why3 $(INCLUDES) $(EXTCMXA) lib/why3/why3.cmxa $< \
	&& ./test-api-logic.opt > /dev/null) \
	|| (rm -f test-api-logic.opt; printf "Test of Why3 API calls failed. Please fix it"; exit 2)
	@rm -f test-api-logic.opt

test-api-mlw-tree.byte: examples/use_api/mlw_tree.ml lib/why3/why3.cma
	$(if $(QUIET),@echo 'Ocaml    $<' &&) \
	ocaml -I lib/why3 $(INCLUDES) $(EXTCMA) lib/why3/why3.cma $< > /dev/null\
	|| (rm -f test-api-mlw-tree.byte; printf "Test of Why3 API calls failed. Please fix it"; exit 2)
	@rm -f test-api-mlw-tree.byte;

test-api-mlw-tree.opt: examples/use_api/mlw_tree.ml lib/why3/why3.cmxa
	$(if $(QUIET),@echo 'Ocamlopt $<' &&) \
	($(OCAMLOPT) -o $@ -I lib/why3 $(INCLUDES) $(EXTCMXA) lib/why3/why3.cmxa $< \
	&& ./test-api-mlw-tree.opt > /dev/null) \
	|| (rm -f test-api-mlw-tree.opt; printf "Test of Why3 API calls failed. Please fix it"; exit 2)
	@rm -f test-api-mlw-tree.opt

test-api-mlw.byte: examples/use_api/mlw.ml lib/why3/why3.cma
	$(if $(QUIET),@echo 'Ocaml    $<' &&) \
	ocaml -I lib/why3 $(INCLUDES) $(EXTCMA) lib/why3/why3.cma $< \
	|| (rm -f test-api-mlw.byte; printf "Test of Why3 API calls failed. Please fix it"; exit 2)
	@rm -f test-api-mlw.byte;

test-api-mlw.opt: examples/use_api/mlw.ml lib/why3/why3.cmxa
	$(if $(QUIET),@echo 'Ocamlopt $<' &&) \
	($(OCAMLOPT) -o $@ -I lib/why3 $(INCLUDES) $(EXTCMXA) lib/why3/why3.cmxa $< \
	&& ./test-api-mlw.opt > /dev/null) \
	|| (rm -f test-api-mlw.opt; printf "Test of Why3 API calls failed. Please fix it"; exit 2)
	@rm -f test-api-mlw.opt

#test-shape: lib/why3/why3.cma
#	ocaml -I lib/why3 $(INCLUDES) $(EXTCMA) $? examples/test_shape.ml

test-session.byte: examples/use_api/create_session.ml lib/why3/why3.cma
	$(if $(QUIET),@echo 'Ocaml    $<' &&) \
	ocaml -I lib/why3 $(INCLUDES) $(EXTCMA) lib/why3/why3.cma $< > /dev/null\
	|| (rm -f why3session.xml;  \
	printf "Test of Why3 API calls for Session module failed. Please fix it"; exit 2)
	@rm -f why3session.xml

test-session.opt: examples/use_api/create_session.ml lib/why3/why3.cmxa
	$(if $(QUIET),@echo 'Ocamlopt $<' &&) \
	($(OCAMLOPT) -o $@ -I lib/why3 $(INCLUDES) $(EXTCMXA) lib/why3/why3.cmxa $< \
	&& ./test-session.opt > /dev/null) \
	|| (rm -f test-session.opt why3session.xml; \
	printf "Test of Why3 API calls for Session module failed. Please fix it"; exit 2)
	@rm -f test-session.opt why3session.xml

test-coq-tactic.byte: src/coq-tactic/.why3-vo-byte
	$(COQC) -byte -I lib/coq-tactic/ bench/coq-tactic/test.v

test-coq-tactic.opt: src/coq-tactic/.why3-vo-opt
	$(COQC) -opt -I lib/coq-tactic/ bench/coq-tactic/test.v

#only test the compilation of runstrat
test-runstrat.byte: lib/why3/why3.cma lib/why3/META
	OCAMLPATH=$(PWD)/lib $(MAKE) -C examples/use_api/runstrat clean
	OCAMLPATH=$(PWD)/lib $(MAKE) -C examples/use_api/runstrat byte

test-runstrat.opt: lib/why3/why3.cmxa lib/why3/META
	OCAMLPATH=$(PWD)/lib $(MAKE) -C examples/use_api/runstrat clean
	OCAMLPATH=$(PWD)/lib $(MAKE) -C examples/use_api/runstrat opt

test-runstrat: test-runstrat.$(OCAMLBEST)

test-ocaml-extraction: bin/why3.opt lib/why3/why3extract.cmxa
	@echo "driver ocaml32"
	@mkdir -p tests/test-extraction
	@cd tests ; ../bin/why3.opt -E ocaml32 \
	  test_extraction.mlw -o test-extraction
	@cd tests/test-extraction/ ; \
	  $(OCAMLOPT) @BIGINTINCLUDE@ -I ../../lib/why3 \
	  @BIGINTLIB@.cmxa why3extract.cmxa \
	  ref__Refint.ml test_extraction__TestExtraction.ml main.ml
	@tests/test-extraction/a.out
	@echo "driver ocaml64"
	@cd tests ; ../bin/why3.opt -E ocaml64 \
	  test_extraction.mlw -o test-extraction
	@cd tests/test-extraction/ ; \
	  $(OCAMLOPT) @BIGINTINCLUDE@ -I ../../lib/why3 \
	  @BIGINTLIB@.cmxa why3extract.cmxa \
	  ref__Refint.ml test_extraction__TestExtraction.ml main.ml
	@tests/test-extraction/a.out

################
# documentation
################

.PHONY: doc

ifeq (@enable_doc@,yes)

doc: doc/manual.pdf doc/html/index.html

BNF = qualid label constant operator term type formula theory theory2 \
	why_file spec expr expr2 module whyml_file term_old_at
BNFTEX = $(addprefix doc/, $(addsuffix _bnf.tex, $(BNF)))

doc/%_bnf.tex: doc/%.bnf doc/bnf
	doc/bnf $< > $@

doc/bnf: doc/bnf.mll
	$(OCAMLLEX) $<
	$(OCAMLOPT) -o $@ doc/bnf.ml

DOC = api glossary ide intro exec macros manpages install \
      manual starting syntax syntaxref technical version whyml \
      itp pvs coq coq_tactic isabelle

DOCTEX = $(addprefix doc/, $(addsuffix .tex, $(DOC)))

doc/manual.pdf: $(BNFTEX) $(DOCTEX) doc/manual.bib share/provers-detection-data.conf
	cd doc; $(RUBBER) --warn all --pdf manual.tex

ifeq (@enable_html_doc@,yes)

# the dependency on the pdf ensures the bbl was built
doc/html/manual.html: doc/manual.pdf doc/fix.hva
	cd doc; rm -rf html; mkdir -p html
	cp doc/*.png doc/manual.bbl doc/html/
	cd doc; $(HEVEA) -o html/manual.html -fix -O fix.hva makeidx.hva manual.tex

doc/html/index.html: doc/html/manual.html
	cd doc; $(HACHA) -tocbis -o html/index.html html/manual.html

else

doc/html/index.html:

endif

clean::
	cd doc; rm -rf html; $(RUBBER) --pdf --clean manual.tex

else

doc:

endif

##########
# API DOC
##########

.PHONY: apidoc apidot

MODULESTODOC = \
	util/util util/opt util/lists util/strings \
	util/extmap util/extset util/exthtbl \
	util/weakhtbl util/stdlib util/rc util/debug \
	core/ident core/ty core/term core/decl core/theory \
	core/env core/task \
	driver/whyconf driver/driver \
	session/session session/session_tools session/session_scheduler \
	whyml/mlw_ty whyml/mlw_expr whyml/mlw_decl whyml/mlw_module \
	whyml/mlw_main
#	transform/introduction \
#	ide/db

FILESTODOC = $(addsuffix .mli, $(addprefix src/, $(MODULESTODOC)))

doc/apidoc:
	mkdir -p doc/apidoc

apidoc: doc/apidoc $(FILESTODOC)
	$(OCAMLDOC) -d doc/apidoc -html -t "Why3 API documentation" \
		-keep-code $(INCLUDES) \
		$(LIBINCLUDES) -I lib/why3 $(FILESTODOC)

# could we include also the dependency graph ? -- someone
# At least we can give a way to create it -- francois

apidot: doc/apidoc/dg.svg doc/apidoc/dg.png

#The sed remove configuration for dot that gives bad result
doc/apidoc/dg.dot: doc/apidoc $(FILESTODOC)
	$(OCAMLDOC) -o doc/apidoc/dg.dot.tmp -dot $(INCLUDES) \
		$(LIBINCLUDES) -I lib/why3 $(FILESTODOC)
	sed -e "s/  \(size\|ratio\|rotate\|fontsize\).*$$//" doc/apidoc/dg.dot.tmp > doc/apidoc/dg.dot
	rm -f doc/apidoc/dg.dot.tmp

doc/apidoc/dg.svg: doc/apidoc/dg.dot
	dot -T svg $< > $@

doc/apidoc/dg.png: doc/apidoc/dg.dot
	dot -T png $< > $@

# what is this ? api doc is in why3.lri.fr/api instead...
# install_apidoc: apidoc
# 	rsync -av doc/apidoc/ marche@scm.gforge.inria.fr:/home/groups/why3/htdocs/apidoc/

doc/apidoc.tex: $(FILESTODOC)
	$(OCAMLDOC) -o doc/apidoc.tex -latex -noheader -notrailer $(INCLUDES) \
		$(LIBINCLUDES) -I lib/why3 $(FILESTODOC)

clean::
	rm -f doc/apidoc/*

##########
# Install rules that require root, and thus appear last in the file!
##########

install_no_local::
	if test -d /etc/bash_completion.d -a -w /etc/bash_completion.d; then cp -f share/bash/why3 /etc/bash_completion.d; fi


##########
# Stdlib formatted with why3doc
##########

.PHONY: stdlibdoc

STDLIBS = algebra \
	bag \
	bintree \
	bool \
	comparison \
	floating_point \
	graph \
	int \
	list \
	map \
	number \
	option \
	pigeon \
	real \
	relations \
	set \
	sum
# function ? tptp ?

STDMODS = array hashtbl impset pqueue queue random ref stack string

STDMACS = array int

STDLIBFILES = $(addsuffix .why, $(addprefix theories/, $(STDLIBS)))
STDMODFILES = $(addsuffix .mlw, $(addprefix modules/, $(STDMODS)))
STDMACFILES = $(addsuffix .mlw, $(addprefix modules/mach/, $(STDMACS)))

stdlibdoc: $(STDLIBFILES) $(STDMODFILES) bin/why3doc.@OCAMLBEST@
	mkdir -p doc/stdlibdoc
	rm -f doc/stdlibdoc/style.css
	WHY3CONFIG="" bin/why3doc.@OCAMLBEST@ -L theories -L modules \
          -o doc/stdlibdoc --title "Why3 Standard Library" \
	  $(STDLIBFILES) $(STDMODFILES) $(STDMACFILES)
	cd doc/stdlibdoc; \
	  for f in theories.*.html; \
	    do mv "$$f" "$${f#theories.}"; done; \
	  for f in modules.*.html; \
	    do mv "$$f" "$${f#modules.}"; done
	sed -i -e "s#theories.##g" -e "s#modules.##g" doc/stdlibdoc/index.html


clean::
	rm -f doc/stdlibdoc/*

################
# generic rules
################

%.cmi: %.mli
	$(if $(QUIET),@echo 'Ocamlc   $<' &&) $(OCAMLC) -c $(BFLAGS) $<

%.cmo: %.ml
	$(if $(QUIET),@echo 'Ocamlc   $<' &&) $(OCAMLC) -c $(BFLAGS) $<

%.cmx: %.ml
	$(if $(QUIET),@echo 'Ocamlopt $<' &&) $(OCAMLOPT) -c $(OFLAGS) $<

%.cma:
	$(if $(QUIET),@echo 'Ocamlc -a $@ $^' &&) $(OCAMLC) $(LIBOPT) -a -o $@ $^

%.cmxa:
	$(if $(QUIET),@echo 'Ocamlopt -a $@ $^' &&) $(OCAMLOPT) $(LIBOPT) -a -o $@ $^

%.cmxs: %.ml
	$(if $(QUIET),@echo 'Ocamlopt $<' &&) $(OCAMLOPT) -shared $(OFLAGS) -o $@ $<

%.ml: %.mll
	$(if $(QUIET),@echo 'Ocamllex $<' &&) $(OCAMLLEX) $<

%.ml %.mli: %.mly
	$(if $(QUIET),@echo 'Ocamlyacc $<' &&) $(OCAMLYACC) -v $<

%.dep: %.ml %.mli
	$(if $(QUIET),@echo 'Ocamldep $<' &&) $(OCAMLDEP) $(DEPFLAGS) $< $<i > $@

%.dep: %.ml
	$(if $(QUIET),@echo 'Ocamldep $<' &&) $(OCAMLDEP) $(DEPFLAGS) $< > $@

# .ml4.ml:
# 	$(CAMLP4) pr_o.cmo -impl $< > $@

# jc/jc_ai.ml: jc/jc_annot_inference.ml jc/jc_annot_fail.ml Makefile
# 	if test "@enable_apron@" = "yes" ; then \
# 	  echo "# 1 \"jc/jc_annot_inference.ml\"" > jc/jc_ai.ml; \
# 	  cat jc/jc_annot_inference.ml >> jc/jc_ai.ml; \
# 	else \
# 	  echo "# 1 \"jc/jc_annot_fail.ml\"" > jc/jc_ai.ml; \
# 	  cat jc/jc_annot_fail.ml >> jc/jc_ai.ml; \
# 	fi

# %_why.v: %.mlw $(BINARY)
# 	$(BINARY) -coq $*.mlw

# %_why.pvs: %.mlw $(BINARY)
# 	$(BINARY) -pvs $*.mlw

# Emacs tags
############

tags:
	find src -regex ".*\.ml[^#]*" | grep -v ".svn" | sort -r | xargs \
	etags "--regex-ocaml=/let[ \t]+\([^ \t]+\)/\1/" \
	      "--regex-ocaml=/let[ \t]+rec[ \t]+\([^ \t]+\)/\1/" \
	      "--regex-ocaml=/and[ \t]+\([^ \t]+\)/\1/" \
	      "--regex-ocaml=/type[ \t]+\([^ \t]+\)/\1/" \
	      "--regex-ocaml=/exception[ \t]+\([^ \t]+\)/\1/" \
	      "--regex-ocaml=/val[ \t]+\([^ \t]+\)/\1/" \
	      "--regex-ocaml=/module[ \t]+\([^ \t]+\)/\1/"

otags:
	find \( -name '*.ml' -or -name '*.mli' \) -print0 | xargs -0 otags
#	otags src/*.mli src/*.ml c/*.mli c/*.ml intf/*.mli intf/*.ml

# the previous seems broken. This one is intented for vi(m) users, but could
# be adapted for emacs (remove the -vi option ?)
otags-vi:
	find \( -name '*.ml' -or -name '*.mli' \) -print0 | xargs -0 otags -vi

wc:
	ocamlwc -p src/*.ml* src/*/*.ml*

#dep: depend
#	cat .depend* | ocamldot | dot -Tpdf > dep.pdf
#	$(PDFVIEWER) dep.pdf

# distrib
#########

NAME = why3-$(VERSION)
DISTRIB_DIR = distrib/$(NAME)
DISTRIB_TAR = $(DISTRIB_DIR).tar.gz

DISTRIB_FILES = Version Makefile.in configure.in configure \
      src/jessie/Makefile.in \
      AUTHORS README CHANGES INSTALL OCAML-LICENSE LICENSE \
      src/config.sh.in \
      src/*.ml* src/*.dep src/*/*.ml* src/*/*.dep src/*/*.c \
      plugins/printer/.keepme plugins/*/*.ml* plugins/*/*.dep \
      lib/why3/META.in lib/why3/why3.ml \
      lib/why3-call-pvs \
      doc/version.tex.in doc/manual.pdf \
      drivers/*.drv drivers/*.gen \
      examples/*.mlw examples/logic/*.why \
      examples/tests-provers/*.why examples/check-builtin/*.why \
      examples/bts/*.why \
      examples/vacid_0_binary_heaps/*.why \
      examples/vacid_0_binary_heaps/*.mlw \
      examples/bitvectors/*.why \
      examples/foveoos11-cm/*.mlw \
      examples/*/*.xml examples/*/*/*.xml examples/*/*/*/*.xml \
      examples/*/*.v   examples/*/*/*.v examples/*/*/*/*.v\
      examples/*/*.pvs   examples/*/*/*.pvs examples/*/*/*/*.pvs \
      examples/*/*.prf   examples/*/*/*.prf examples/*/*/*/*.prf \
      examples/*/*.thy   examples/*/*/*.thy examples/*/*/*/*.thy \
      examples/use_api/*.ml \
      theories/*.why \
      modules/*.mlw \
      lib/coq/*.v lib/coq/*/*.v lib/coq-tactic/*.v \
      lib/pvs/*/*.pvs lib/pvs/*/*.prf \
      lib/isabelle/why3.ML lib/isabelle/ROOT lib/isabelle/*.thy \
      lib/isabelle/etc lib/isabelle/Tools \
      lib/ocaml/*.ml lib/ocaml/*.dep \
      share/provers-detection-data.conf \
      share/why3session.dtd \
      share/javascript/*.js share/javascript/*.css \
      share/javascript/themes/default/*.gif \
      share/javascript/themes/default/*.png \
      share/javascript/themes/default/*.css \
      share/emacs/why3.el share/lang/*.lang \
      share/images/icons.rc share/images/*.png share/images/*/*.png \
      share/bash/why3 share/zsh/_why3 share/vim/why3.vim

# TODO?
# share/zsh ?
# symbolic links in share/ ?

distrib:: $(DISTRIB_TAR)

rmdistrib:
	rm -rf $(DISTRIB_DIR)

redistrib: rmdistrib distrib

$(DISTRIB_TAR): doc/manual.pdf
	@if test -d $(DISTRIB_DIR); then \
	  echo "Hum... there is already a directory $(NAME)"; \
	  echo "Please increase the version number"; exit 1; \
        fi
	mkdir -p $(DISTRIB_DIR)
	mkdir -p $(DISTRIB_DIR)/bin
	mkdir -p $(DISTRIB_DIR)/share
	mkdir -p $(DISTRIB_DIR)/lib
	mkdir -p $(DISTRIB_DIR)/lib/plugins
	mkdir -p $(DISTRIB_DIR)/lib/coq
	mkdir -p $(DISTRIB_DIR)/lib/coq-tactic
	mkdir -p $(DISTRIB_DIR)/lib/why3
	ln -s ../drivers $(DISTRIB_DIR)/share/drivers
	ln -s ../modules $(DISTRIB_DIR)/share/modules
	ln -s ../theories $(DISTRIB_DIR)/share/theories
	cp --parents $(DISTRIB_FILES) $(DISTRIB_DIR)
	rm -rf $(DISTRIB_DIR)/examples/hoare_logic
	rm -rf $(DISTRIB_DIR)/examples/misc
	cd $(DISTRIB_DIR); rm -f $(LIBGENERATED) \
          $(COQPGENERATED) $(WHY3DOCGENERATED) $(PLUGGENERATED)
	cd distrib; tar cf $(NAME).tar $(NAME); gzip -f --best $(NAME).tar


EXTRA_DIST = configure doc/manual.pdf

dist: $(EXTRA_DIST)
	rm -rf $(DISTRIB_TAR) $(DISTRIB_DIR)
	mkdir -p $(DISTRIB_DIR)
	for d in `git ls-tree -d -r --name-only HEAD`; do mkdir $(DISTRIB_DIR)/$$d; done
	for f in `git ls-tree -r --name-only HEAD` $(EXTRA_DIST); do cp $$f $(DISTRIB_DIR)/$$f; done
	rm `find $(DISTRIB_DIR) -name .gitignore`
	rm -rf  $(DISTRIB_DIR)/examples/in_progress
	rm -rf  $(DISTRIB_DIR)/misc
	cd $(DISTRIB_DIR); rm ROADMAP DEVELOPER.readme
	cd distrib; tar cf $(NAME).tar $(NAME); gzip -f --best $(NAME).tar


# distrib export: source export-doc export-www export-examples export-examples-c linux
#
# export-www:
# 	echo "<#def version>$(VERSION)</#def>" > /users/demons/filliatr/www/why/version.prehtml
# 	echo "<#def cversion>$(CVERSION)</#def>" >> /users/demons/filliatr/www/why/version.prehtml
# 	$(MAKE) -C /users/demons/filliatr/www/why install
#
#
# tarball:
# 	mkdir -p export
# 	cd export; rm -rf $(NAME) $(NAME).tar.gz
# 	$(MAKE) export/$(NAME).tar.gz
#
# EXFILES = lib/coq*/*.v examples/*/*.v examples/*/*.mlw
#
# export-examples:
# 	cp --parents $(EXFILES) $(WWW)
# 	$(MAKE) -C $(WWW)/examples clean depend
# 	echo "*** faire make all dans $(WWW)/examples ***"
#
# export-examples-c:
# 	mkdir -p $(WWW)/caduceus/examples
# 	cd examples-c; cp --parents */*.c */*.h $(WWW)/caduceus/examples
# 	mkdir -p $(WWW)/caduceus/examples/bench
# 	cp bench/c/good/*.c $(WWW)/caduceus/examples/bench
# 	rm -f $(WWW)/caduceus/examples/bench/test.c
#
# export-doc: $(DOC)
# 	cp doc/manual.ps doc/manual.html $(WWW)/manual
# 	cp doc/logic_syntax.bnf $(WWW)/manual
# 	(cd $(WWW)/manual; hacha manual.html)
# 	cp doc/caduceus.ps doc/caduceus.html $(WWW)/caduceus/manual
# 	(cd $(WWW)/caduceus/manual; hacha caduceus.html)
# 	cp doc/krakatoa.pdf doc/krakatoa.html $(WWWKRAKATOA)/manual
# 	(cd $(WWWKRAKATOA)/manual; hacha krakatoa.html)
#
# OSTYPE  ?= linux
#
# BINARYNAME = $(NAME)-$(OSTYPE)
#
# linux: binary
#
# ALLBINARYFILES = $(FILES) $(BINARYFILES)
#
# binary: $(ALLBINARYFILES)
# 	mkdir -p export/$(BINARYNAME)
# 	cp --parents $(ALLBINARYFILES) export/$(BINARYNAME)
# 	(cd export; tar czf $(BINARYNAME).tar.gz $(BINARYNAME))
# 	cp export/$(BINARYNAME).tar.gz $(FTP)

###############
# file headers
###############

headers:
	headache -c misc/headache_config.txt -h misc/header.txt \
		Makefile.in configure.in src/*.ml \
		src/*/*.ml src/*/*.ml[iyl] \
		plugins/*/*.ml plugins/*/*.ml[ily] src/tools/cpulimit.c \
		examples/use_api/*.ml

#########
# myself
#########

Makefile: Makefile.in config.status
	./config.status chmod --file $@

src/jessie/Makefile: src/jessie/Makefile.in config.status
	./config.status chmod --file $@

src/config.sh: src/config.sh.in config.status
	./config.status chmod --file $@

src/util/config.ml share/Makefile.config: src/config.sh
	$(if $(QUIET),@echo 'Generate $@' &&) \
	    BINDIR=$(BINDIR) LIBDIR=$(LIBDIR) DATADIR=$(DATADIR) src/config.sh

clean::
	rm -f src/util/config.ml src/config.ml
	rm -f share/Makefile.config

doc/version.tex: doc/version.tex.in config.status
	./config.status chmod --file $@

config.status: configure Version
	./config.status --recheck

opt byte: lib/why3/META

lib/why3/META: lib/why3/META.in config.status
	./config.status chmod --file $@

configure: configure.in
	autoconf

###################
# clean and depend
###################

.PHONY: distclean

distclean: clean
	rm -f config.status config.cache config.log \
	    Makefile src/util/config.ml doc/version.tex

depend:
	rm -f $^
	$(MAKE) $^

##################################################################
# Building the Why3 platform with ocamlbuild (OCaml 3.10 needed) #
##################################################################

# There used to be targets here but they are no longer useful.

# To build using Ocamlbuild:
# 1) Run "make Makefile" to ensure that the generated files (config.ml, ...)
# are generated.
# 2) Run Ocamlbuild with any target to generate the sanitization script.
# 3) Run ./sanitize to delete the generated files that shouldn't be generated
# (i.e. all lexers and parsers).
# 4) Run Ocamlbuild with the target you need, for example:
# ocamlbuild jc/jc_main.native

# You can also use the Makefile ./build.makefile which has some handy targets.
