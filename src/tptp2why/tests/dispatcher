#!/usr/bin/env python

# launches some provers on a bunch of tptp problems, after conversion
# with tptp2why

import sys
import getopt

import time
import subprocess
from os import path
import re

import ansi

#------------------------------------------------------------------------------
# parsing options

usage = """usage : dispatcher [--help] [-P prover [-P prover...]] \
[-p prover [-p prover...]] [-I dir] [-o file][--] file1 [file2...]

Tries to solve the given tptp files (*.p) with given provers, through why or \
directly. Every prover is called on every problem.

options :
-P prover   : adds a why prover
-p prover   : adds a prover to be called directly on tptp problem
-I dir      : use this dir to search for included files"""


class Options:
  "contains all options parsed on the command line"


  optstring = "P:p:I:o:h"
  long_optstring = ["help"]

  provers = []
  tptpProvers = []

  def parse(self):
    self.path = path.dirname(sys.argv[0])
    self.options, self.args = \
      getopt.getopt(sys.argv[1:], self.optstring, self.long_optstring)
# add each prover to self.provers
    for opt,prover in self.options:
      if opt == "-P":
        self.provers.append(prover)
      elif opt == "-p":
        self.tptpProvers.append(prover)
    self.options = dict(self.options)
# those options are now useless
    self.options.pop("-P", None)
    self.options.pop("-p", None)

  def __init__(self):
    self.parse()
    print "search for files in", self.path

options = Options()

if "--help" in options.options or "-h" in options.options:
  print usage
  sys.exit(0)


#------------------------------------------------------------------------------
# finding provers

def sendTo(problem, prover, useWhy = True):
  "calls the prover on the problem, and return its return value and output's \
  lines"
  if useWhy:
    prover = "why - -P "+prover
  else:
    if "-I" in options.options: 
      prover = prover + " -I "+options.options["-I"]
  s = subprocess.Popen(prover, shell=True, \
    stdin=subprocess.PIPE, stdout=subprocess.PIPE)
  print "\n"+ansi.inBlue("*", pos="background"), "send data to prover "+ prover
  output = s.communicate(problem)[0].splitlines()
  return (s.returncode, output)

#-----------------------------------------------------------------------------
# interpreting provers output

def isValid(retcode, output):
  "returns True in case of success"
  for pattern in ["Valid","valid", "[Pp]roof found", "[cC]ompletion [fF]ound"]:
    if any( [ re.search(pattern, line) for line in output ] ):
      return True
  return False

def isFailure(retcode, output):
  "returns True in case of failure"
  if retcode != 0:
    return True
  for pattern in ["[fF]ailure","[fF]alse", "[nN]o [Pp]roof found"]:
    if any( [ re.search(pattern, line) for line in output ] ):
      return True
  return False

def handleOutput(retcode, output):
  """if we can find it is a failure or a success, print it.
  Else, print the output."""
  print "retcode :",(ansi.inGreen(`retcode`)
    if retcode==0 else ansi.inRed(`retcode`))
  if isFailure(retcode, output):
    print ansi.inRed("Failure")
    return
  elif isValid(retcode, output):
    print ansi.inGreen("Valid")
    return
  else:
    for line in output:
      print line


def main():
  for f in options.args:
    print "\n\n"+ ansi.inBlue("file "+f, pos="background") + "\n"
    try:
      fd = open(f, 'r')
      problem = fd.read()
      fd.close()
# tptp provers
      for prover in options.tptpProvers:
        try:
          retcode, output = sendTo(problem, prover, useWhy = False)
          handleOutput(retcode, output)
        except:
          pass
# why-driven provers
# first, transform the problem
      if "-I" in options.options: 
        command = "tptp2why - -I "+options.options["-I"]
      else: 
        command = "tptp2why -"
      preprocess = subprocess.Popen(command, shell=True, \
        stdout=subprocess.PIPE, stdin=subprocess.PIPE)
      problem = preprocess.communicate(problem)[0]
# then give it to provers
      for prover in options.provers:
        try:
          retcode, output = sendTo(problem, prover)
          handleOutput(retcode, output)
        except e: print "exception :",e
    except Exception, e:
      print "exception :", e, e.args

if __name__=="__main__":
  main()
