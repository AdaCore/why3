# GUIDELINES:
# Be extremely careful when editing this file: it is automatically generated.
# Any modifications done to it can be erased by running the Makefile.
# Do not remove the spurious spaces at the end of lines to avoid git differences.
# One can use $0 anywhere to refer to the last token read.


term_eof: EPSILON WRITES 
##
## Ends in an error in state: 307.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term -> single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term -> single_term . COMMA term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_eof: UIDENT COMMA EPSILON WRITES 
##
## Ends in an error in state: 384.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_ -> single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_ -> single_term . COMMA term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_eof: UIDENT COMMA UIDENT COMMA WRITES 
##
## Ends in an error in state: 385.
##
## term_ -> single_term COMMA . term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_eof: UIDENT COMMA WRITES 
##
## Ends in an error in state: 382.
##
## term -> single_term COMMA . term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_eof: UIDENT WITH 
##
## Ends in an error in state: 1180.
##
## term_eof -> term . EOF [ # ]
##
## The known suffix of the stack is as follows:
## term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_eof: WRITES 
##
## Ends in an error in state: 1178.
##
## term_eof' -> . term_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: BEGIN UIDENT WITH 
##
## Ends in an error in state: 448.
##
## term_block -> BEGIN term . END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## BEGIN term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: BEGIN WRITES 
##
## Ends in an error in state: 196.
##
## term_block -> BEGIN . term END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_block -> BEGIN . END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## BEGIN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 317.
##
## separated_nonempty_list(COMMA,quant_vars) -> quant_vars . [ LEFTSQ DOT ]
## separated_nonempty_list(COMMA,quant_vars) -> quant_vars . COMMA separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## quant_vars 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
## In state 322, spurious reduction of production option(cast) -> cast 
## In state 321, spurious reduction of production quant_vars -> nonempty_list(binder_var) option(cast) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE COMMA WRITES 
##
## Ends in an error in state: 318.
##
## separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA . separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## quant_vars COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE DOT WRITES 
##
## Ends in an error in state: 380.
##
## single_term_ -> quant comma_list1(quant_vars) triggers DOT . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## quant comma_list1(quant_vars) triggers DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE LEFTSQ UIDENT BAR WRITES 
##
## Ends in an error in state: 377.
##
## separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) BAR . separated_nonempty_list(BAR,comma_list1(single_term)) [ RIGHTSQ ]
##
## The known suffix of the stack is as follows:
## comma_list1(single_term) BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE LEFTSQ UIDENT RIGHTBRC 
##
## Ends in an error in state: 376.
##
## separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) . [ RIGHTSQ ]
## separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) . BAR separated_nonempty_list(BAR,comma_list1(single_term)) [ RIGHTSQ ]
##
## The known suffix of the stack is as follows:
## comma_list1(single_term) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 327, spurious reduction of production separated_nonempty_list(COMMA,single_term) -> single_term 
## In state 373, spurious reduction of production comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE LEFTSQ UIDENT RIGHTSQ DONE 
##
## Ends in an error in state: 379.
##
## single_term_ -> quant comma_list1(quant_vars) triggers . DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## quant comma_list1(quant_vars) triggers 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE LEFTSQ WRITES 
##
## Ends in an error in state: 326.
##
## triggers -> LEFTSQ . separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ [ DOT ]
##
## The known suffix of the stack is as follows:
## LEFTSQ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL UNDERSCORE WRITES 
##
## Ends in an error in state: 323.
##
## nonempty_list(binder_var) -> binder_var . [ LEFTSQ DOT COMMA COLON ]
## nonempty_list(binder_var) -> binder_var . nonempty_list(binder_var) [ LEFTSQ DOT COMMA COLON ]
##
## The known suffix of the stack is as follows:
## binder_var 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FORALL WRITES 
##
## Ends in an error in state: 315.
##
## single_term_ -> quant . comma_list1(quant_vars) triggers DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## quant 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTBRC RANGE WRITES 
##
## Ends in an error in state: 80.
##
## ty -> ty . ARROW ty [ RIGHTBRC ARROW ]
## ty_arg -> LEFTBRC ty . RIGHTBRC [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTBRC ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTBRC WRITES 
##
## Ends in an error in state: 73.
##
## ty_arg -> LEFTBRC . ty RIGHTBRC [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR GHOST RANGE WRITES 
##
## Ends in an error in state: 257.
##
## binder -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
## ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COLON ATTRIBUTE ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR GHOST UNDERSCORE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 262.
##
## binder -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST binder_vars cast 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR GHOST WRITES 
##
## Ends in an error in state: 256.
##
## binder -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## binder -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## binder -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR RANGE COMMA RANGE COMMA WRITES 
##
## Ends in an error in state: 95.
##
## separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## ty COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR RANGE COMMA RANGE WRITES 
##
## Ends in an error in state: 94.
##
## separated_nonempty_list(COMMA,ty) -> ty . [ RIGHTPAR ]
## separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
## ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR RANGE COMMA WRITES 
##
## Ends in an error in state: 93.
##
## comma_list2(ty) -> ty COMMA . comma_list1(ty) [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## ty COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR RANGE POSITION WRITES 
##
## Ends in an error in state: 107.
##
## binder_vars_rest -> binder_vars_head nonempty_list(attr) . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## binder_vars_head nonempty_list(attr) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production nonempty_list(attr) -> attr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR RANGE UNDERSCORE WRITES 
##
## Ends in an error in state: 117.
##
## binder_vars_rest -> binder_vars_head anon_binder . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## binder_vars_head anon_binder 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR RANGE WRITES 
##
## Ends in an error in state: 126.
##
## binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
## comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
## ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COMMA COLON ATTRIBUTE ARROW ]
## ty_arg -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR UNDERSCORE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 267.
##
## binder -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR binder_vars cast 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR UNDERSCORE UNDERSCORE WRITES 
##
## Ends in an error in state: 111.
##
## list(binder_var) -> binder_var . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## binder_var 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR UNDERSCORE WRITES 
##
## Ends in an error in state: 124.
##
## binder_vars_rest -> anon_binder . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## anon_binder 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN LEFTPAR WRITES 
##
## Ends in an error in state: 255.
##
## binder -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## binder -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## binder -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## binder -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## binder -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## ty_arg -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## ty_arg -> LEFTPAR . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## ty_arg -> LEFTPAR . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN UIDENT DOT WRITES 
##
## Ends in an error in state: 75.
##
## lqualid -> uqualid DOT . lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN UIDENT WRITES 
##
## Ends in an error in state: 74.
##
## lqualid -> uqualid . DOT lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## uqualid -> uqualid . DOT uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN UNDERSCORE ARROW WRITES 
##
## Ends in an error in state: 275.
##
## single_term_ -> FUN binders ARROW . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN binders ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN UNDERSCORE WITH 
##
## Ends in an error in state: 402.
##
## nonempty_list(binder) -> binder . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
## nonempty_list(binder) -> binder . nonempty_list(binder) [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## binder 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN UNDERSCORE WRITES 
##
## Ends in an error in state: 274.
##
## single_term_ -> FUN binders . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN binders 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 402, spurious reduction of production nonempty_list(binder) -> binder 
## In state 270, spurious reduction of production binders -> nonempty_list(binder) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: FUN WRITES 
##
## Ends in an error in state: 254.
##
## single_term_ -> FUN . binders ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: IF UIDENT THEN UIDENT ELSE WRITES 
##
## Ends in an error in state: 408.
##
## single_term_ -> IF term THEN term ELSE . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term THEN term ELSE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: IF UIDENT THEN UIDENT WITH 
##
## Ends in an error in state: 407.
##
## single_term_ -> IF term THEN term . ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term THEN term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: IF UIDENT THEN WRITES 
##
## Ends in an error in state: 406.
##
## single_term_ -> IF term THEN . term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term THEN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: IF UIDENT WITH 
##
## Ends in an error in state: 405.
##
## single_term_ -> IF term . THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: IF WRITES 
##
## Ends in an error in state: 253.
##
## single_term_ -> IF . term THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC RANGE EQUAL UIDENT SEMICOLON WRITES 
##
## Ends in an error in state: 459.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL term SEMICOLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC RANGE EQUAL UIDENT WITH 
##
## Ends in an error in state: 458.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC RANGE EQUAL WRITES 
##
## Ends in an error in state: 457.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC RANGE WRITES 
##
## Ends in an error in state: 464.
##
## ident_rich -> lident . [ WITH RIGHTBRC LEFTSQ ]
## lqualid -> lident . [ EQUAL DOT ]
##
## The known suffix of the stack is as follows:
## lident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC UIDENT DOT RANGE WRITES 
##
## Ends in an error in state: 452.
##
## ident_rich -> lident . [ WITH RIGHTBRC LEFTSQ ]
## lqualid -> uqualid DOT lident . [ EQUAL DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT lident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC UIDENT DOT WRITES 
##
## Ends in an error in state: 451.
##
## lqualid -> uqualid DOT . lident [ EQUAL DOT ]
## qualid -> uqualid DOT . ident_rich [ WITH LEFTSQ ]
## term_sub_ -> uqualid DOT . mk_term(term_block) [ WITH LEFTSQ DOT ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC UIDENT WITH RANGE WRITES 
##
## Ends in an error in state: 456.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC UIDENT WITH WRITES 
##
## Ends in an error in state: 454.
##
## term_block -> LEFTBRC term_arg WITH . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTBRC term_arg WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC UIDENT WRITES 
##
## Ends in an error in state: 453.
##
## term_block -> LEFTBRC term_arg . WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ term LARROW term RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT term RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ DOTDOT term RIGHTSQ [ WITH LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## LEFTBRC term_arg 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 396, spurious reduction of production mk_term(term_arg_) -> term_arg_ 
## In state 336, spurious reduction of production term_arg -> mk_term(term_arg_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTBRC WRITES 
##
## Ends in an error in state: 193.
##
## term_block -> LEFTBRC . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_block -> LEFTBRC . term_arg WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTPAR MINUS WRITES 
##
## Ends in an error in state: 469.
##
## lident_op -> MINUS . UNDERSCORE [ RIGHTPAR ]
## lident_op -> MINUS . [ RIGHTPAR ]
## prefix_op -> MINUS . [ UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE ]
## single_term_ -> MINUS . INTEGER [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> MINUS . REAL [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTPAR OP4 WRITES 
##
## Ends in an error in state: 472.
##
## lident_op -> op_symbol . [ RIGHTPAR ]
## lident_op -> op_symbol . UNDERSCORE [ RIGHTPAR ]
## prefix_op -> op_symbol . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
##
## The known suffix of the stack is as follows:
## op_symbol 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTPAR OPPREF WRITES 
##
## Ends in an error in state: 192.
##
## lident_op -> OPPREF . option(UNDERSCORE) [ RIGHTPAR ]
## term_arg_ -> OPPREF . term_arg [ UIDENT TRUE SO RIGHTPAR REAL RANGE OR OPPREF OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER GT FLOAT FALSE EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BY BEGIN BARBAR AT ARROW AND AMPAMP ]
## term_dot_ -> OPPREF . term_dot [ DOT ]
##
## The known suffix of the stack is as follows:
## OPPREF 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTPAR RIGHTPAR WRITES 
##
## Ends in an error in state: 288.
##
## term_arg_ -> term_sub_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_dot_ -> term_sub_ . [ DOT ]
##
## The known suffix of the stack is as follows:
## term_sub_ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTPAR UIDENT WITH 
##
## Ends in an error in state: 470.
##
## term_block -> LEFTPAR term . RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LEFTPAR WRITES 
##
## Ends in an error in state: 190.
##
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_block -> LEFTPAR . term RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_block -> LEFTPAR . RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET GHOST WRITES 
##
## Ends in an error in state: 212.
##
## pat_uni_ -> GHOST . mk_pat(pat_uni_) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## GHOST 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTBRC RANGE EQUAL UNDERSCORE RIGHTPAR 
##
## Ends in an error in state: 227.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL pattern 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 230, spurious reduction of production pat_conj_ -> pat_uni_ 
## In state 231, spurious reduction of production pattern_ -> pat_conj_ 
## In state 226, spurious reduction of production mk_pat(pattern_) -> pattern_ 
## In state 232, spurious reduction of production pattern -> mk_pat(pattern_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTBRC RANGE EQUAL UNDERSCORE SEMICOLON WRITES 
##
## Ends in an error in state: 228.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL pattern SEMICOLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTBRC RANGE EQUAL WRITES 
##
## Ends in an error in state: 211.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTBRC RANGE WRITES 
##
## Ends in an error in state: 210.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTBRC WRITES 
##
## Ends in an error in state: 208.
##
## pat_arg_ -> LEFTBRC . field_list1(pattern) RIGHTBRC [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR OPPREF RIGHTPAR EQUAL UIDENT IN WRITES 
##
## Ends in an error in state: 418.
##
## single_term_ -> LET attrs(lident_op_id) EQUAL term IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_op_id) EQUAL term IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR OPPREF RIGHTPAR EQUAL UIDENT WITH 
##
## Ends in an error in state: 417.
##
## single_term_ -> LET attrs(lident_op_id) EQUAL term . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_op_id) EQUAL term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR OPPREF RIGHTPAR EQUAL WRITES 
##
## Ends in an error in state: 416.
##
## single_term_ -> LET attrs(lident_op_id) EQUAL . term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_op_id) EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR OPPREF RIGHTPAR POSITION WRITES 
##
## Ends in an error in state: 415.
##
## single_term_ -> LET attrs(lident_op_id) . EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> LET attrs(lident_op_id) . mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_op_id) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 414, spurious reduction of production attrs(lident_op_id) -> lident_op_id list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR OPPREF RIGHTPAR UNDERSCORE EQUAL CORE_LIDENT IN WRITES 
##
## Ends in an error in state: 421.
##
## single_term_ -> LET attrs(lident_op_id) mk_term(lam_defn) IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_op_id) mk_term(lam_defn) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR OPPREF RIGHTPAR UNDERSCORE EQUAL CORE_LIDENT WITH 
##
## Ends in an error in state: 420.
##
## single_term_ -> LET attrs(lident_op_id) mk_term(lam_defn) . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_op_id) mk_term(lam_defn) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 426, spurious reduction of production lam_defn -> binders EQUAL term 
## In state 423, spurious reduction of production mk_term(lam_defn) -> lam_defn 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR OPPREF RIGHTPAR WRITES 
##
## Ends in an error in state: 413.
##
## attrs(lident_op_id) -> lident_op_id . list(attr) [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ]
##
## The known suffix of the stack is as follows:
## lident_op_id 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR UNDERSCORE SEMICOLON 
##
## Ends in an error in state: 249.
##
## pat_arg_ -> LEFTPAR pattern . RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR pattern 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 230, spurious reduction of production pat_conj_ -> pat_uni_ 
## In state 231, spurious reduction of production pattern_ -> pat_conj_ 
## In state 226, spurious reduction of production mk_pat(pattern_) -> pattern_ 
## In state 232, spurious reduction of production pattern -> mk_pat(pattern_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET LEFTPAR WRITES 
##
## Ends in an error in state: 205.
##
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT POSITION LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ATTRIBUTE ]
## pat_arg_ -> LEFTPAR . RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
## pat_arg_ -> LEFTPAR . pattern RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET RANGE UNDERSCORE EQUAL CORE_LIDENT IN WRITES 
##
## Ends in an error in state: 429.
##
## single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_nq) mk_term(lam_defn) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET RANGE UNDERSCORE EQUAL CORE_LIDENT WITH 
##
## Ends in an error in state: 428.
##
## single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_nq) mk_term(lam_defn) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 426, spurious reduction of production lam_defn -> binders EQUAL term 
## In state 423, spurious reduction of production mk_term(lam_defn) -> lam_defn 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET RANGE UNDERSCORE EQUAL WRITES 
##
## Ends in an error in state: 425.
##
## lam_defn -> binders EQUAL . term [ IN ]
##
## The known suffix of the stack is as follows:
## binders EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET RANGE UNDERSCORE WRITES 
##
## Ends in an error in state: 424.
##
## lam_defn -> binders . EQUAL term [ IN ]
##
## The known suffix of the stack is as follows:
## binders 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 402, spurious reduction of production nonempty_list(binder) -> binder 
## In state 270, spurious reduction of production binders -> nonempty_list(binder) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET RANGE WITH 
##
## Ends in an error in state: 427.
##
## pat_arg_ -> attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
## single_term_ -> LET attrs(lident_nq) . mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET attrs(lident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 109, spurious reduction of production list(attr) -> 
## In state 110, spurious reduction of production attrs(lident_nq) -> lident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UIDENT DOT WRITES 
##
## Ends in an error in state: 214.
##
## uqualid -> uqualid DOT . uident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UIDENT LEFTPAR WRITES 
##
## Ends in an error in state: 207.
##
## pat_arg_ -> LEFTPAR . RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## pat_arg_ -> LEFTPAR . pattern RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UIDENT UIDENT WRITES 
##
## Ends in an error in state: 215.
##
## pat_arg_ -> uqualid . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UIDENT UNDERSCORE WRITES 
##
## Ends in an error in state: 217.
##
## nonempty_list(pat_arg) -> pat_arg . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## nonempty_list(pat_arg) -> pat_arg . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## pat_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UIDENT WRITES 
##
## Ends in an error in state: 213.
##
## pat_arg_ -> uqualid . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## pat_uni_ -> uqualid . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE AS GHOST CONTINUE 
##
## Ends in an error in state: 240.
##
## pat_uni_ -> mk_pat(pat_uni_) AS ghost . attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) AS ghost 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE AS WRITES 
##
## Ends in an error in state: 239.
##
## pat_uni_ -> mk_pat(pat_uni_) AS . ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) AS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE BAR WRITES 
##
## Ends in an error in state: 244.
##
## pattern_ -> mk_pat(pat_conj_) BAR . pattern [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_conj_) BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE COMMA UNDERSCORE COMMA WRITES 
##
## Ends in an error in state: 237.
##
## separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE COMMA UNDERSCORE WRITES 
##
## Ends in an error in state: 236.
##
## pat_uni_ -> mk_pat(pat_uni_) . AS ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE COMMA WRITES 
##
## Ends in an error in state: 234.
##
## comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . comma_list1(mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE EQUAL UIDENT IN WRITES 
##
## Ends in an error in state: 411.
##
## single_term_ -> LET pattern EQUAL term IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern EQUAL term IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE EQUAL UIDENT WITH 
##
## Ends in an error in state: 410.
##
## single_term_ -> LET pattern EQUAL term . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern EQUAL term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE EQUAL WRITES 
##
## Ends in an error in state: 252.
##
## single_term_ -> LET pattern EQUAL . term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE SEMICOLON 
##
## Ends in an error in state: 251.
##
## single_term_ -> LET pattern . EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 230, spurious reduction of production pat_conj_ -> pat_uni_ 
## In state 231, spurious reduction of production pattern_ -> pat_conj_ 
## In state 226, spurious reduction of production mk_pat(pattern_) -> pattern_ 
## In state 232, spurious reduction of production pattern -> mk_pat(pattern_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET UNDERSCORE WRITES 
##
## Ends in an error in state: 230.
##
## mk_pat(pat_uni_) -> pat_uni_ . [ COMMA COLON AS ]
## pat_conj_ -> pat_uni_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat_uni_ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: LET WRITES 
##
## Ends in an error in state: 203.
##
## single_term_ -> LET . pattern EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> LET . attrs(lident_op_id) EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> LET . attrs(lident_nq) mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> LET . attrs(lident_op_id) mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT VAL 
##
## Ends in an error in state: 431.
##
## single_term_ -> MATCH term . WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT WITH BAR WRITES 
##
## Ends in an error in state: 433.
##
## bar_list1(match_case(term)) -> BAR . separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
##
## The known suffix of the stack is as follows:
## BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT WITH UNDERSCORE ARROW CORE_LIDENT BAR WRITES 
##
## Ends in an error in state: 439.
##
## separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR . separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
##
## The known suffix of the stack is as follows:
## match_case(term) BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT WITH UNDERSCORE ARROW CORE_LIDENT RIGHTBRC 
##
## Ends in an error in state: 442.
##
## single_term_ -> MATCH term WITH match_cases(term) . END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH term WITH match_cases(term) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 437, spurious reduction of production match_case(term) -> pattern ARROW term 
## In state 438, spurious reduction of production separated_nonempty_list(BAR,match_case(term)) -> match_case(term) 
## In state 441, spurious reduction of production bar_list1(match_case(term)) -> separated_nonempty_list(BAR,match_case(term)) 
## In state 444, spurious reduction of production match_cases(term) -> bar_list1(match_case(term)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT WITH UNDERSCORE ARROW CORE_LIDENT WITH 
##
## Ends in an error in state: 438.
##
## separated_nonempty_list(BAR,match_case(term)) -> match_case(term) . [ RIGHTBRC END ]
## separated_nonempty_list(BAR,match_case(term)) -> match_case(term) . BAR separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
##
## The known suffix of the stack is as follows:
## match_case(term) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 437, spurious reduction of production match_case(term) -> pattern ARROW term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT WITH UNDERSCORE ARROW WRITES 
##
## Ends in an error in state: 436.
##
## match_case(term) -> pattern ARROW . term [ RIGHTBRC END BAR ]
##
## The known suffix of the stack is as follows:
## pattern ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT WITH UNDERSCORE SEMICOLON 
##
## Ends in an error in state: 435.
##
## match_case(term) -> pattern . ARROW term [ RIGHTBRC END BAR ]
##
## The known suffix of the stack is as follows:
## pattern 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 230, spurious reduction of production pat_conj_ -> pat_uni_ 
## In state 231, spurious reduction of production pattern_ -> pat_conj_ 
## In state 226, spurious reduction of production mk_pat(pattern_) -> pattern_ 
## In state 232, spurious reduction of production pattern -> mk_pat(pattern_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH UIDENT WITH WRITES 
##
## Ends in an error in state: 432.
##
## single_term_ -> MATCH term WITH . match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH term WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MATCH WRITES 
##
## Ends in an error in state: 202.
##
## single_term_ -> MATCH . term WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: MINUS WRITES 
##
## Ends in an error in state: 199.
##
## prefix_op -> MINUS . [ UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE ]
## single_term_ -> MINUS . INTEGER [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> MINUS . REAL [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: NOT EPSILON WRITES 
##
## Ends in an error in state: 445.
##
## single_term_ -> NOT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## NOT single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: NOT WRITES 
##
## Ends in an error in state: 198.
##
## single_term_ -> NOT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## NOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: OLD UIDENT AT 
##
## Ends in an error in state: 446.
##
## single_term_ -> OLD single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## OLD single_term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: OLD WRITES 
##
## Ends in an error in state: 197.
##
## single_term_ -> OLD . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## OLD 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: OP4 WRITES 
##
## Ends in an error in state: 331.
##
## single_term_ -> prefix_op . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## prefix_op 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: OPPREF WRITES 
##
## Ends in an error in state: 189.
##
## term_arg_ -> OPPREF . term_arg [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_dot_ -> OPPREF . term_dot [ DOT ]
##
## The known suffix of the stack is as follows:
## OPPREF 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: POSITION EPSILON WRITES 
##
## Ends in an error in state: 342.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> attr single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## attr single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: POSITION WRITES 
##
## Ends in an error in state: 341.
##
## single_term_ -> attr . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## attr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: RANGE DOT UIDENT DOT WRITES 
##
## Ends in an error in state: 293.
##
## lqualid_rich -> uqualid DOT . lident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## lqualid_rich -> uqualid DOT . lident_op_id [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: RANGE DOT UIDENT WRITES 
##
## Ends in an error in state: 292.
##
## lqualid_rich -> uqualid . DOT lident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## lqualid_rich -> uqualid . DOT lident_op_id [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## uqualid -> uqualid . DOT uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: RANGE DOT WRITES 
##
## Ends in an error in state: 291.
##
## term_sub_ -> term_dot DOT . lqualid_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_dot DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: RANGE WHILE 
##
## Ends in an error in state: 339.
##
## ident_rich -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## lqualid -> lident . [ DOT ]
##
## The known suffix of the stack is as follows:
## lident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT AMPAMP EPSILON WRITES 
##
## Ends in an error in state: 368.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term AMPAMP single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term AMPAMP single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT AMPAMP WRITES 
##
## Ends in an error in state: 367.
##
## single_term_ -> single_term AMPAMP . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term AMPAMP 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT AND EPSILON WRITES 
##
## Ends in an error in state: 366.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term AND single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term AND single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT AND WRITES 
##
## Ends in an error in state: 365.
##
## single_term_ -> single_term AND . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term AND 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT ARROW EPSILON WRITES 
##
## Ends in an error in state: 370.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term ARROW single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term ARROW single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT ARROW WRITES 
##
## Ends in an error in state: 369.
##
## single_term_ -> single_term ARROW . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT AT WRITES 
##
## Ends in an error in state: 357.
##
## single_term_ -> single_term AT . uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term AT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT BARBAR EPSILON WRITES 
##
## Ends in an error in state: 364.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term BARBAR single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term BARBAR single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT BARBAR WRITES 
##
## Ends in an error in state: 363.
##
## single_term_ -> single_term BARBAR . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term BARBAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT BY EPSILON WRITES 
##
## Ends in an error in state: 362.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term BY single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term BY single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT BY WRITES 
##
## Ends in an error in state: 361.
##
## single_term_ -> single_term BY . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term BY 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON LEFTPAR RANGE WRITES 
##
## Ends in an error in state: 91.
##
## comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
## ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## ty_arg -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON LEFTPAR WRITES 
##
## Ends in an error in state: 72.
##
## ty_arg -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## ty_arg -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## ty_arg -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON RANGE ARROW QUOTE_LIDENT WHILE 
##
## Ends in an error in state: 83.
##
## ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## ty -> ty ARROW ty . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## ty ARROW ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON RANGE ARROW WRITES 
##
## Ends in an error in state: 82.
##
## ty -> ty ARROW . ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## ty ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON RANGE RANGE WHILE 
##
## Ends in an error in state: 86.
##
## nonempty_list(ty_arg) -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## nonempty_list(ty_arg) -> ty_arg . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON RANGE UNDERSCORE 
##
## Ends in an error in state: 121.
##
## cast -> COLON ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
## ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## COLON ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON RANGE WHILE 
##
## Ends in an error in state: 85.
##
## ty -> lqualid . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## ty_arg -> lqualid . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## lqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COLON WRITES 
##
## Ends in an error in state: 120.
##
## cast -> COLON . ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## COLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT COMMA WRITES 
##
## Ends in an error in state: 371.
##
## separated_nonempty_list(COMMA,single_term) -> single_term COMMA . separated_nonempty_list(COMMA,single_term) [ RIGHTSQ RIGHTBRC EOF BAR ]
##
## The known suffix of the stack is as follows:
## single_term COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT DOT RANGE WHILE 
##
## Ends in an error in state: 285.
##
## ident_rich -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## lqualid -> uqualid DOT lident . [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT lident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT DOT WRITES 
##
## Ends in an error in state: 280.
##
## lqualid -> uqualid DOT . lident [ DOT ]
## qualid -> uqualid DOT . ident_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> uqualid DOT . mk_term(term_block) [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT EQUAL EPSILON WRITES 
##
## Ends in an error in state: 356.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term EQUAL single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term EQUAL single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT EQUAL WRITES 
##
## Ends in an error in state: 355.
##
## single_term_ -> single_term EQUAL . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT GT EPSILON WRITES 
##
## Ends in an error in state: 354.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term GT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term GT single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT GT WRITES 
##
## Ends in an error in state: 353.
##
## single_term_ -> single_term GT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term GT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ DOTDOT UIDENT WITH 
##
## Ends in an error in state: 304.
##
## term_sub_ -> term_arg LEFTSQ DOTDOT term . RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ DOTDOT term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ DOTDOT WRITES 
##
## Ends in an error in state: 303.
##
## term_sub_ -> term_arg LEFTSQ DOTDOT . term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ DOTDOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ UIDENT DOTDOT UIDENT WITH 
##
## Ends in an error in state: 394.
##
## term_sub_ -> term_arg LEFTSQ term DOTDOT term . RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term DOTDOT term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ UIDENT DOTDOT WRITES 
##
## Ends in an error in state: 392.
##
## term_sub_ -> term_arg LEFTSQ term DOTDOT . term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term DOTDOT . RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term DOTDOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ UIDENT LARROW UIDENT WITH 
##
## Ends in an error in state: 390.
##
## term_sub_ -> term_arg LEFTSQ term LARROW term . RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term LARROW term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ UIDENT LARROW WRITES 
##
## Ends in an error in state: 389.
##
## term_sub_ -> term_arg LEFTSQ term LARROW . term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term LARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ UIDENT WITH 
##
## Ends in an error in state: 387.
##
## term_sub_ -> term_arg LEFTSQ term . RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term . LARROW term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term . DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term . DOTDOT RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LEFTSQ WRITES 
##
## Ends in an error in state: 302.
##
## term_sub_ -> term_arg LEFTSQ . term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . term LARROW term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . term DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . term DOTDOT RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LRARROW EPSILON WRITES 
##
## Ends in an error in state: 360.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term LRARROW single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term LRARROW single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LRARROW WRITES 
##
## Ends in an error in state: 359.
##
## single_term_ -> single_term LRARROW . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term LRARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LT EPSILON WRITES 
##
## Ends in an error in state: 352.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term LT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term LT single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LT WRITES 
##
## Ends in an error in state: 351.
##
## single_term_ -> single_term LT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term LT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LTGT EPSILON WRITES 
##
## Ends in an error in state: 350.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term LTGT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term LTGT single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT LTGT WRITES 
##
## Ends in an error in state: 349.
##
## single_term_ -> single_term LTGT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term LTGT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT MINUS EPSILON WRITES 
##
## Ends in an error in state: 348.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term MINUS single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term MINUS single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT MINUS WRITES 
##
## Ends in an error in state: 347.
##
## single_term_ -> single_term MINUS . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OP1 EPSILON WRITES 
##
## Ends in an error in state: 346.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term OP1 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OP1 single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OP1 WRITES 
##
## Ends in an error in state: 345.
##
## single_term_ -> single_term OP1 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OP1 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OP2 EPSILON WRITES 
##
## Ends in an error in state: 344.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term OP2 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OP2 single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OP2 WRITES 
##
## Ends in an error in state: 343.
##
## single_term_ -> single_term OP2 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OP2 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OP3 EPSILON WRITES 
##
## Ends in an error in state: 329.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term OP3 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OP3 single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OP3 WRITES 
##
## Ends in an error in state: 328.
##
## single_term_ -> single_term OP3 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OP3 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OP4 WRITES 
##
## Ends in an error in state: 312.
##
## single_term_ -> single_term OP4 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OP4 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OR EPSILON WRITES 
##
## Ends in an error in state: 311.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term OR single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OR single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT OR WRITES 
##
## Ends in an error in state: 310.
##
## single_term_ -> single_term OR . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term OR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT RIGHTSQ 
##
## Ends in an error in state: 1176.
##
## term_comma_list_eof -> comma_list1(single_term) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## comma_list1(single_term) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 327, spurious reduction of production separated_nonempty_list(COMMA,single_term) -> single_term 
## In state 373, spurious reduction of production comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT SO EPSILON WRITES 
##
## Ends in an error in state: 309.
##
## single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term SO single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term SO single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT SO WRITES 
##
## Ends in an error in state: 308.
##
## single_term_ -> single_term SO . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term SO 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT UIDENT WRITES 
##
## Ends in an error in state: 397.
##
## located(term_arg) -> term_arg . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term LARROW term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 396, spurious reduction of production mk_term(term_arg_) -> term_arg_ 
## In state 336, spurious reduction of production term_arg -> mk_term(term_arg_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT WITH 
##
## Ends in an error in state: 327.
##
## separated_nonempty_list(COMMA,single_term) -> single_term . [ RIGHTSQ RIGHTBRC EOF BAR ]
## separated_nonempty_list(COMMA,single_term) -> single_term . COMMA separated_nonempty_list(COMMA,single_term) [ RIGHTSQ RIGHTBRC EOF BAR ]
## single_term_ -> single_term . AT uident [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## single_term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: UIDENT WRITES 
##
## Ends in an error in state: 300.
##
## mk_term(term_arg_) -> term_arg_ . [ UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN ]
## single_term_ -> term_arg_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg_ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_comma_list_eof: WRITES 
##
## Ends in an error in state: 1174.
##
## term_comma_list_eof' -> . term_comma_list_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_eof: UIDENT WRITES 
##
## Ends in an error in state: 1172.
##
## qualid_eof -> qualid . EOF [ # ]
##
## The known suffix of the stack is as follows:
## qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_eof: WRITES 
##
## Ends in an error in state: 1170.
##
## qualid_eof' -> . qualid_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR LEFTSQ DOTDOT UNDERSCORE WRITES 
##
## Ends in an error in state: 47.
##
## lident_op -> LEFTSQ DOTDOT UNDERSCORE . RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ DOTDOT UNDERSCORE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR LEFTSQ DOTDOT WRITES 
##
## Ends in an error in state: 46.
##
## lident_op -> LEFTSQ DOTDOT . RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ DOTDOT . UNDERSCORE RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ DOTDOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR LEFTSQ LARROW WRITES 
##
## Ends in an error in state: 44.
##
## lident_op -> LEFTSQ LARROW . RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ LARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR LEFTSQ RIGHTSQ WRITES 
##
## Ends in an error in state: 42.
##
## lident_op -> LEFTSQ RIGHTSQ . [ RIGHTPAR ]
## lident_op -> LEFTSQ RIGHTSQ . LARROW [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ RIGHTSQ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR LEFTSQ UNDERSCORE DOTDOT WRITES 
##
## Ends in an error in state: 40.
##
## lident_op -> LEFTSQ UNDERSCORE DOTDOT . RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ UNDERSCORE DOTDOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR LEFTSQ UNDERSCORE WRITES 
##
## Ends in an error in state: 39.
##
## lident_op -> LEFTSQ UNDERSCORE . DOTDOT RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ UNDERSCORE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR LEFTSQ WRITES 
##
## Ends in an error in state: 38.
##
## lident_op -> LEFTSQ . RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . LARROW RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . RIGHTSQ LARROW [ RIGHTPAR ]
## lident_op -> LEFTSQ . DOTDOT RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . UNDERSCORE DOTDOT RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . DOTDOT UNDERSCORE RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR MINUS WRITES 
##
## Ends in an error in state: 35.
##
## lident_op -> MINUS . UNDERSCORE [ RIGHTPAR ]
## lident_op -> MINUS . [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR OP4 WRITES 
##
## Ends in an error in state: 52.
##
## lident_op -> op_symbol . [ RIGHTPAR ]
## lident_op -> op_symbol . UNDERSCORE [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## op_symbol 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR OPPREF WRITES 
##
## Ends in an error in state: 28.
##
## lident_op -> OPPREF . option(UNDERSCORE) [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## OPPREF 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: LEFTPAR WRITES 
##
## Ends in an error in state: 27.
##
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT ARROW AND AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: UIDENT COMMA WRITES 
##
## Ends in an error in state: 1166.
##
## separated_nonempty_list(COMMA,qualid) -> qualid COMMA . separated_nonempty_list(COMMA,qualid) [ EOF ]
##
## The known suffix of the stack is as follows:
## qualid COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: UIDENT DOT UIDENT WHILE 
##
## Ends in an error in state: 281.
##
## ident_rich -> uident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## uqualid -> uqualid DOT uident . [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: UIDENT DOT WRITES 
##
## Ends in an error in state: 743.
##
## qualid -> uqualid DOT . ident_rich [ VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: UIDENT WHILE 
##
## Ends in an error in state: 287.
##
## ident_rich -> uident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## uqualid -> uident . [ DOT ]
##
## The known suffix of the stack is as follows:
## uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: UIDENT WRITES 
##
## Ends in an error in state: 1165.
##
## separated_nonempty_list(COMMA,qualid) -> qualid . [ EOF ]
## separated_nonempty_list(COMMA,qualid) -> qualid . COMMA separated_nonempty_list(COMMA,qualid) [ EOF ]
##
## The known suffix of the stack is as follows:
## qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qualid_comma_list_eof: WRITES 
##
## Ends in an error in state: 1162.
##
## qualid_comma_list_eof' -> . qualid_comma_list_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: AXIOM UIDENT COLON WRITES 
##
## Ends in an error in state: 1139.
##
## pure_decl -> AXIOM attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM attrs(ident_nq) COLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: AXIOM UIDENT POSITION WRITES 
##
## Ends in an error in state: 1138.
##
## pure_decl -> AXIOM attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM attrs(ident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 1042, spurious reduction of production attrs(ident_nq) -> ident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: AXIOM WRITES 
##
## Ends in an error in state: 1137.
##
## pure_decl -> AXIOM . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE EXPORT UIDENT AS 
##
## Ends in an error in state: 1091.
##
## use_clone -> CLONE EXPORT tqualid . clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE EXPORT tqualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 563, spurious reduction of production tqualid -> uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE EXPORT WRITES 
##
## Ends in an error in state: 1090.
##
## use_clone -> CLONE EXPORT . tqualid clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE EXPORT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE IMPORT CONTINUE 
##
## Ends in an error in state: 1133.
##
## use_clone -> CLONE boption(IMPORT) . tqualid option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE boption(IMPORT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT AS CORE_UIDENT WRITES 
##
## Ends in an error in state: 1135.
##
## use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) . clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH AXIOM WRITES 
##
## Ends in an error in state: 1124.
##
## single_clone_subst -> AXIOM . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> AXIOM . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH CONSTANT UIDENT EQUAL WRITES 
##
## Ends in an error in state: 1122.
##
## single_clone_subst -> CONSTANT qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT qualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH CONSTANT UIDENT WRITES 
##
## Ends in an error in state: 1121.
##
## single_clone_subst -> CONSTANT qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> CONSTANT qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH CONSTANT WRITES 
##
## Ends in an error in state: 1120.
##
## single_clone_subst -> CONSTANT . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> CONSTANT . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH EXCEPTION UIDENT EQUAL WRITES 
##
## Ends in an error in state: 1118.
##
## single_clone_subst -> EXCEPTION qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXCEPTION qualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH EXCEPTION UIDENT WRITES 
##
## Ends in an error in state: 1117.
##
## single_clone_subst -> EXCEPTION qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> EXCEPTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXCEPTION qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH EXCEPTION WRITES 
##
## Ends in an error in state: 1116.
##
## single_clone_subst -> EXCEPTION . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> EXCEPTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXCEPTION 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH FUNCTION UIDENT EQUAL WRITES 
##
## Ends in an error in state: 1114.
##
## single_clone_subst -> FUNCTION qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION qualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH FUNCTION UIDENT WRITES 
##
## Ends in an error in state: 1113.
##
## single_clone_subst -> FUNCTION qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> FUNCTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH FUNCTION WRITES 
##
## Ends in an error in state: 1112.
##
## single_clone_subst -> FUNCTION . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> FUNCTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH GOAL WRITES 
##
## Ends in an error in state: 1109.
##
## single_clone_subst -> GOAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> GOAL . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH LEMMA UIDENT WRITES 
##
## Ends in an error in state: 1127.
##
## separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst . COMMA separated_nonempty_list(COMMA,single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## single_clone_subst 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 1108, spurious reduction of production single_clone_subst -> LEMMA qualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH LEMMA WRITES 
##
## Ends in an error in state: 1106.
##
## single_clone_subst -> LEMMA . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> LEMMA . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH PREDICATE UIDENT EQUAL WRITES 
##
## Ends in an error in state: 1104.
##
## single_clone_subst -> PREDICATE qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE qualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH PREDICATE UIDENT WRITES 
##
## Ends in an error in state: 1103.
##
## single_clone_subst -> PREDICATE qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> PREDICATE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH PREDICATE WRITES 
##
## Ends in an error in state: 1102.
##
## single_clone_subst -> PREDICATE . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> PREDICATE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH TYPE UIDENT EQUAL RANGE WRITES 
##
## Ends in an error in state: 1101.
##
## single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## ty -> ty . ARROW ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
##
## The known suffix of the stack is as follows:
## TYPE qualid list(ty_var) EQUAL ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH TYPE UIDENT EQUAL WRITES 
##
## Ends in an error in state: 1100.
##
## single_clone_subst -> TYPE qualid list(ty_var) EQUAL . ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE qualid list(ty_var) EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH TYPE UIDENT QUOTE_LIDENT EOF 
##
## Ends in an error in state: 1099.
##
## single_clone_subst -> TYPE qualid list(ty_var) . EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE qualid list(ty_var) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 588, spurious reduction of production list(attr) -> 
## In state 589, spurious reduction of production attrs(quote_lident) -> quote_lident list(attr) 
## In state 591, spurious reduction of production ty_var -> attrs(quote_lident) 
## In state 587, spurious reduction of production list(ty_var) -> 
## In state 590, spurious reduction of production list(ty_var) -> ty_var list(ty_var) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH TYPE UIDENT WRITES 
##
## Ends in an error in state: 1098.
##
## single_clone_subst -> TYPE qualid . list(ty_var) EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> TYPE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH TYPE WRITES 
##
## Ends in an error in state: 1097.
##
## single_clone_subst -> TYPE . qualid list(ty_var) EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> TYPE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH VAL UIDENT COMMA WRITES 
##
## Ends in an error in state: 1128.
##
## separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA . separated_nonempty_list(COMMA,single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## single_clone_subst COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH VAL UIDENT EQUAL WRITES 
##
## Ends in an error in state: 1095.
##
## single_clone_subst -> VAL qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL qualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH VAL UIDENT WRITES 
##
## Ends in an error in state: 1094.
##
## single_clone_subst -> VAL qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> VAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH VAL WRITES 
##
## Ends in an error in state: 1093.
##
## single_clone_subst -> VAL . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## single_clone_subst -> VAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE UIDENT WITH WRITES 
##
## Ends in an error in state: 1092.
##
## clone_subst -> WITH . comma_list1(single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CLONE WRITES 
##
## Ends in an error in state: 1089.
##
## use_clone -> CLONE . EXPORT tqualid clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## use_clone -> CLONE . boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: COINDUCTIVE WRITES 
##
## Ends in an error in state: 1087.
##
## pure_decl -> COINDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## COINDUCTIVE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CONSTANT RANGE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 1085.
##
## constant_decl -> attrs(lident_rich) cast . option(preceded(EQUAL,term)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) cast 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CONSTANT RANGE WRITES 
##
## Ends in an error in state: 1084.
##
## constant_decl -> attrs(lident_rich) . cast option(preceded(EQUAL,term)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: CONSTANT WRITES 
##
## Ends in an error in state: 1082.
##
## pure_decl -> CONSTANT . constant_decl [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT GHOST RANGE UNDERSCORE 
##
## Ends in an error in state: 180.
##
## return -> GHOST ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## GHOST ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT GHOST WRITES 
##
## Ends in an error in state: 179.
##
## return -> GHOST . ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## GHOST 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT LEFTPAR GHOST RANGE WRITES 
##
## Ends in an error in state: 142.
##
## ret_ghost -> GHOST ty . COMMA ret_rest [ RIGHTPAR ]
## return -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT LEFTPAR GHOST WRITES 
##
## Ends in an error in state: 707.
##
## ret_ghost -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
## return -> LEFTPAR GHOST . ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT LEFTPAR RANGE COMMA RANGE COMMA WRITES 
##
## Ends in an error in state: 162.
##
## ret_ghost -> ty COMMA . GHOST ty [ RIGHTPAR ]
## ret_ghost -> ty COMMA . ret_ghost [ RIGHTPAR ]
## separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## ty COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT LEFTPAR RANGE COMMA WRITES 
##
## Ends in an error in state: 158.
##
## comma_list2(ty) -> ty COMMA . comma_list1(ty) [ RIGHTPAR ]
## ret_ghost -> ty COMMA . GHOST ty [ RIGHTPAR ]
## ret_ghost -> ty COMMA . ret_ghost [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## ty COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT LEFTPAR RANGE WRITES 
##
## Ends in an error in state: 157.
##
## comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
## ret_ghost -> ty . COMMA GHOST ty [ RIGHTPAR ]
## ret_ghost -> ty . COMMA ret_ghost [ RIGHTPAR ]
## ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## ty_arg -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT LEFTPAR WRITES 
##
## Ends in an error in state: 706.
##
## return -> LEFTPAR . GHOST ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## return -> LEFTPAR . ret_ghost RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## ty_arg -> LEFTPAR . comma_list2(ty) RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
## ty_arg -> LEFTPAR . RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
## ty_arg -> LEFTPAR . ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION UIDENT WITH 
##
## Ends in an error in state: 1080.
##
## prog_decl -> EXCEPTION attrs(uident_nq) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## prog_decl -> EXCEPTION attrs(uident_nq) . return [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXCEPTION attrs(uident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 632, spurious reduction of production list(attr) -> 
## In state 633, spurious reduction of production attrs(uident_nq) -> uident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: EXCEPTION WRITES 
##
## Ends in an error in state: 1079.
##
## prog_decl -> EXCEPTION . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## prog_decl -> EXCEPTION . attrs(uident_nq) return [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXCEPTION 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: FUNCTION RANGE COLON CORE_LIDENT EQUAL CORE_LIDENT THEN 
##
## Ends in an error in state: 1073.
##
## pure_decl -> FUNCTION function_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION function_decl 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 992, spurious reduction of production option(preceded(EQUAL,term)) -> EQUAL term 
## In state 1078, spurious reduction of production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: FUNCTION RANGE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 1077.
##
## function_decl -> attrs(lident_rich) params cast . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) params cast 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: FUNCTION RANGE UNDERSCORE WRITES 
##
## Ends in an error in state: 1076.
##
## function_decl -> attrs(lident_rich) params . cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) params 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 552, spurious reduction of production list(param) -> 
## In state 553, spurious reduction of production list(param) -> param list(param) 
## In state 558, spurious reduction of production params -> list(param) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: FUNCTION RANGE WRITES 
##
## Ends in an error in state: 1075.
##
## function_decl -> attrs(lident_rich) . params cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: FUNCTION WRITES 
##
## Ends in an error in state: 1072.
##
## pure_decl -> FUNCTION . function_decl list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: GOAL UIDENT COLON WRITES 
##
## Ends in an error in state: 1070.
##
## pure_decl -> GOAL attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL attrs(ident_nq) COLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: GOAL UIDENT POSITION WRITES 
##
## Ends in an error in state: 1069.
##
## pure_decl -> GOAL attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL attrs(ident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 1042, spurious reduction of production attrs(ident_nq) -> ident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: GOAL WRITES 
##
## Ends in an error in state: 1068.
##
## pure_decl -> GOAL . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: IMPORT UIDENT WRITES 
##
## Ends in an error in state: 1067.
##
## module_decl -> IMPORT uqualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## uqualid -> uqualid . DOT uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END DOT CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## IMPORT uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: IMPORT WRITES 
##
## Ends in an error in state: 1066.
##
## module_decl -> IMPORT . uqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## IMPORT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE EQUAL BAR WRITES 
##
## Ends in an error in state: 1055.
##
## bar_list1(ind_case) -> BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE EQUAL UIDENT COLON CORE_LIDENT BAR WRITES 
##
## Ends in an error in state: 1058.
##
## separated_nonempty_list(BAR,ind_case) -> ind_case BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ind_case BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE EQUAL UIDENT COLON CORE_LIDENT THEN 
##
## Ends in an error in state: 1057.
##
## separated_nonempty_list(BAR,ind_case) -> ind_case . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(BAR,ind_case) -> ind_case . BAR separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ind_case 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 1062, spurious reduction of production ind_case -> attrs(ident_nq) COLON term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE EQUAL UIDENT COLON WRITES 
##
## Ends in an error in state: 1061.
##
## ind_case -> attrs(ident_nq) COLON . term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(ident_nq) COLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE EQUAL UIDENT POSITION WRITES 
##
## Ends in an error in state: 1060.
##
## ind_case -> attrs(ident_nq) . COLON term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(ident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 1042, spurious reduction of production attrs(ident_nq) -> ident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE EQUAL WRITES 
##
## Ends in an error in state: 1054.
##
## ind_defn -> EQUAL . bar_list1(ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE UNDERSCORE WRITES 
##
## Ends in an error in state: 1053.
##
## inductive_decl -> attrs(lident_rich) params . ind_defn [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) params 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 552, spurious reduction of production list(param) -> 
## In state 553, spurious reduction of production list(param) -> param list(param) 
## In state 558, spurious reduction of production params -> list(param) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE WITH WRITES 
##
## Ends in an error in state: 1050.
##
## separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH . separated_nonempty_list(WITH,inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## inductive_decl WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE RANGE WRITES 
##
## Ends in an error in state: 1052.
##
## inductive_decl -> attrs(lident_rich) . params ind_defn [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: INDUCTIVE WRITES 
##
## Ends in an error in state: 1046.
##
## pure_decl -> INDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## INDUCTIVE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LEMMA UIDENT ATTRIBUTE WRITES 
##
## Ends in an error in state: 1043.
##
## pure_decl -> LEMMA attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA attrs(ident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 1042, spurious reduction of production attrs(ident_nq) -> ident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LEMMA UIDENT COLON WRITES 
##
## Ends in an error in state: 1044.
##
## pure_decl -> LEMMA attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA attrs(ident_nq) COLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LEMMA UIDENT WRITES 
##
## Ends in an error in state: 1041.
##
## attrs(ident_nq) -> ident_nq . list(attr) [ COLON ]
##
## The known suffix of the stack is as follows:
## ident_nq 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LEMMA WRITES 
##
## Ends in an error in state: 1038.
##
## pure_decl -> LEMMA . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET GHOST COMMA 
##
## Ends in an error in state: 1028.
##
## prog_decl -> LET ghost . kind attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## prog_decl -> LET ghost . kind attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET ghost 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET PREDICATE CONTINUE 
##
## Ends in an error in state: 1029.
##
## prog_decl -> LET ghost kind . attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## prog_decl -> LET ghost kind . attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET ghost kind 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE COLON CORE_LIDENT EQUAL WRITES 
##
## Ends in an error in state: 1036.
##
## const_defn -> cast EQUAL . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## cast EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 1035.
##
## const_defn -> cast . EQUAL seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## cast 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL ABSURD WHILE 
##
## Ends in an error in state: 764.
##
## expr -> single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr -> single_expr . COMMA expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL ANY RANGE RANGE UNDERSCORE 
##
## Ends in an error in state: 181.
##
## return -> ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 86, spurious reduction of production nonempty_list(ty_arg) -> ty_arg 
## In state 90, spurious reduction of production ty -> lqualid nonempty_list(ty_arg) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL ANY WRITES 
##
## Ends in an error in state: 716.
##
## single_expr_ -> ANY . return_named spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## ANY 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL BEGIN DIVERGES DIVERGES WITH 
##
## Ends in an error in state: 935.
##
## expr_block -> BEGIN single_spec spec . seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> BEGIN single_spec spec . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## BEGIN single_spec spec 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL BEGIN DIVERGES UIDENT WITH 
##
## Ends in an error in state: 937.
##
## expr_block -> BEGIN single_spec spec seq_expr . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## BEGIN single_spec spec seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL BEGIN DIVERGES WITH 
##
## Ends in an error in state: 934.
##
## expr_block -> BEGIN single_spec . spec seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> BEGIN single_spec . spec END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## BEGIN single_spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL BEGIN UIDENT WITH 
##
## Ends in an error in state: 939.
##
## expr_block -> BEGIN seq_expr . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## BEGIN seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL BEGIN WITH 
##
## Ends in an error in state: 679.
##
## expr_block -> BEGIN . single_spec spec seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> BEGIN . single_spec spec END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> BEGIN . seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> BEGIN . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## BEGIN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL BREAK WHILE 
##
## Ends in an error in state: 712.
##
## single_expr_ -> BREAK . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> BREAK . uident [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## BREAK 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL CHECK LEFTBRC UIDENT WITH 
##
## Ends in an error in state: 784.
##
## single_expr_ -> assertion_kind LEFTBRC term . RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## assertion_kind LEFTBRC term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL CHECK LEFTBRC WRITES 
##
## Ends in an error in state: 783.
##
## single_expr_ -> assertion_kind LEFTBRC . term RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## assertion_kind LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL CHECK WRITES 
##
## Ends in an error in state: 782.
##
## single_expr_ -> assertion_kind . LEFTBRC term RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## assertion_kind 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL CONTINUE WHILE 
##
## Ends in an error in state: 709.
##
## single_expr_ -> CONTINUE . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> CONTINUE . uident [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## CONTINUE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL EXCEPTION UIDENT IN WRITES 
##
## Ends in an error in state: 708.
##
## single_expr_ -> EXCEPTION attrs(uident) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## EXCEPTION attrs(uident) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL EXCEPTION UIDENT POSITION WRITES 
##
## Ends in an error in state: 705.
##
## single_expr_ -> EXCEPTION attrs(uident) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> EXCEPTION attrs(uident) . return IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## EXCEPTION attrs(uident) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 691, spurious reduction of production attrs(uident) -> uident list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL EXCEPTION UIDENT RANGE IN WRITES 
##
## Ends in an error in state: 831.
##
## single_expr_ -> EXCEPTION attrs(uident) return IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## EXCEPTION attrs(uident) return IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL EXCEPTION UIDENT RANGE WRITES 
##
## Ends in an error in state: 830.
##
## single_expr_ -> EXCEPTION attrs(uident) return . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## EXCEPTION attrs(uident) return 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 181, spurious reduction of production return -> ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL EXCEPTION WRITES 
##
## Ends in an error in state: 704.
##
## single_expr_ -> EXCEPTION . attrs(uident) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> EXCEPTION . attrs(uident) return IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## EXCEPTION 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE EQUAL UIDENT TO UIDENT DO INVARIANT LEFTBRC CORE_LIDENT RIGHTBRC WITH 
##
## Ends in an error in state: 839.
##
## single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) . loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 843, spurious reduction of production list(invariant) -> 
## In state 844, spurious reduction of production list(invariant) -> invariant list(invariant) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE EQUAL UIDENT TO UIDENT DO UIDENT WITH 
##
## Ends in an error in state: 841.
##
## single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body . DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 840, spurious reduction of production loop_body -> seq_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE EQUAL UIDENT TO UIDENT DO WRITES 
##
## Ends in an error in state: 838.
##
## single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO . list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE EQUAL UIDENT TO UIDENT WITH 
##
## Ends in an error in state: 837.
##
## single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr . DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE EQUAL UIDENT TO WRITES 
##
## Ends in an error in state: 836.
##
## single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction . seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq EQUAL seq_expr for_direction 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE EQUAL UIDENT WITH 
##
## Ends in an error in state: 833.
##
## single_expr_ -> FOR lident_nq EQUAL seq_expr . for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq EQUAL seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE EQUAL WRITES 
##
## Ends in an error in state: 703.
##
## single_expr_ -> FOR lident_nq EQUAL . seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR RANGE WRITES 
##
## Ends in an error in state: 702.
##
## single_expr_ -> FOR lident_nq . EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR lident_nq 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FOR WRITES 
##
## Ends in an error in state: 701.
##
## single_expr_ -> FOR . lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FOR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FUN UNDERSCORE ARROW DIVERGES WITH 
##
## Ends in an error in state: 700.
##
## single_expr_ -> FUN binders spec ARROW spec . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FUN binders spec ARROW spec 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FUN UNDERSCORE ARROW WITH 
##
## Ends in an error in state: 699.
##
## single_expr_ -> FUN binders spec ARROW . spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FUN binders spec ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FUN UNDERSCORE DIVERGES ANY 
##
## Ends in an error in state: 698.
##
## single_expr_ -> FUN binders spec . ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FUN binders spec 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FUN UNDERSCORE EQUAL 
##
## Ends in an error in state: 697.
##
## single_expr_ -> FUN binders . spec ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FUN binders 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 402, spurious reduction of production nonempty_list(binder) -> binder 
## In state 270, spurious reduction of production binders -> nonempty_list(binder) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL FUN WRITES 
##
## Ends in an error in state: 696.
##
## single_expr_ -> FUN . binders spec ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## FUN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL GHOST ABSURD WHILE 
##
## Ends in an error in state: 846.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> GHOST single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## GHOST single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL GHOST WRITES 
##
## Ends in an error in state: 695.
##
## single_expr_ -> GHOST . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## GHOST 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL IF UIDENT THEN UIDENT DIVERGES DIVERGES WHILE 
##
## Ends in an error in state: 849.
##
## single_expr_ -> IF seq_expr THEN contract_expr . ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> IF seq_expr THEN contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## IF seq_expr THEN contract_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
## In state 829, spurious reduction of production contract_expr -> assign_expr single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL IF UIDENT THEN UIDENT ELSE WRITES 
##
## Ends in an error in state: 850.
##
## single_expr_ -> IF seq_expr THEN contract_expr ELSE . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## IF seq_expr THEN contract_expr ELSE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL IF UIDENT THEN WRITES 
##
## Ends in an error in state: 848.
##
## single_expr_ -> IF seq_expr THEN . contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> IF seq_expr THEN . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## IF seq_expr THEN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL IF UIDENT WITH 
##
## Ends in an error in state: 847.
##
## single_expr_ -> IF seq_expr . THEN contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> IF seq_expr . THEN contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## IF seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL IF WRITES 
##
## Ends in an error in state: 694.
##
## single_expr_ -> IF . seq_expr THEN contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> IF . seq_expr THEN contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## IF 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LABEL UIDENT IN WRITES 
##
## Ends in an error in state: 693.
##
## single_expr_ -> LABEL attrs(uident) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LABEL attrs(uident) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LABEL UIDENT UIDENT 
##
## Ends in an error in state: 692.
##
## single_expr_ -> LABEL attrs(uident) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LABEL attrs(uident) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 690, spurious reduction of production list(attr) -> 
## In state 691, spurious reduction of production attrs(uident) -> uident list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LABEL UIDENT WRITES 
##
## Ends in an error in state: 690.
##
## attrs(uident) -> uident . list(attr) [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT ]
##
## The known suffix of the stack is as follows:
## uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LABEL WRITES 
##
## Ends in an error in state: 689.
##
## single_expr_ -> LABEL . attrs(uident) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LABEL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC RANGE EQUAL UIDENT SEMICOLON WRITES 
##
## Ends in an error in state: 974.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL expr SEMICOLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC RANGE EQUAL UIDENT WRITES 
##
## Ends in an error in state: 973.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC RANGE EQUAL WRITES 
##
## Ends in an error in state: 655.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC TRUE WRITES 
##
## Ends in an error in state: 757.
##
## expr_block -> LEFTBRC expr_arg . WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ expr RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ expr LARROW expr RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT expr RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ DOTDOT expr RIGHTSQ [ WITH LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## LEFTBRC expr_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC UIDENT DOT WRITES 
##
## Ends in an error in state: 724.
##
## expr_pure -> uqualid DOT . LEFTBRC ident_rich RIGHTBRC [ WITH LEFTSQ DOT ]
## expr_sub -> uqualid DOT . mk_expr(expr_block) [ WITH LEFTSQ DOT ]
## lqualid -> uqualid DOT . lident [ EQUAL DOT ]
## qualid -> uqualid DOT . ident_rich [ WITH RIGHTBRC LEFTSQ ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC UIDENT WITH WRITES 
##
## Ends in an error in state: 758.
##
## expr_block -> LEFTBRC expr_arg WITH . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTBRC expr_arg WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC UIDENT WRITES 
##
## Ends in an error in state: 941.
##
## expr_arg_ -> qualid . [ WITH LEFTSQ ]
## expr_pure -> LEFTBRC qualid . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTBRC qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTBRC WRITES 
##
## Ends in an error in state: 677.
##
## expr_block -> LEFTBRC . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> LEFTBRC . expr_arg WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_pure -> LEFTBRC . qualid RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTPAR MINUS WRITES 
##
## Ends in an error in state: 944.
##
## lident_op -> MINUS . UNDERSCORE [ RIGHTPAR ]
## lident_op -> MINUS . [ RIGHTPAR ]
## prefix_op -> MINUS . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## single_expr_ -> MINUS . INTEGER [ WRITES VARIANT SEMICOLON RIGHTPAR RETURNS REQUIRES READS RAISES OP4 OP3 OP2 OP1 MINUS LTGT LT LARROW GT EQUAL ENSURES DIVERGES COMMA COLON BARBAR AMPAMP ALIAS ]
## single_expr_ -> MINUS . REAL [ WRITES VARIANT SEMICOLON RIGHTPAR RETURNS REQUIRES READS RAISES OP4 OP3 OP2 OP1 MINUS LTGT LT LARROW GT EQUAL ENSURES DIVERGES COMMA COLON BARBAR AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTPAR OPPREF WRITES 
##
## Ends in an error in state: 676.
##
## expr_arg_ -> OPPREF . expr_arg [ WRITES VARIANT UIDENT TRUE SEMICOLON RIGHTPAR RETURNS REQUIRES REAL READS RANGE RAISES PURE OPPREF OP4 OP3 OP2 OP1 MINUS LTGT LT LIDENT LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER GT FLOAT FALSE EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COMMA COLON BEGIN BARBAR AMPAMP ALIAS ]
## expr_dot_ -> OPPREF . expr_dot [ DOT ]
## lident_op -> OPPREF . option(UNDERSCORE) [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## OPPREF 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTPAR RIGHTPAR WHILE 
##
## Ends in an error in state: 736.
##
## expr_arg_ -> expr_sub . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_dot_ -> expr_sub . [ DOT ]
##
## The known suffix of the stack is as follows:
## expr_sub 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTPAR UIDENT WITH 
##
## Ends in an error in state: 945.
##
## expr_block -> LEFTPAR seq_expr . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LEFTPAR WRITES 
##
## Ends in an error in state: 674.
##
## expr_block -> LEFTPAR . seq_expr RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET GHOST COMMA 
##
## Ends in an error in state: 867.
##
## single_expr_ -> LET ghost . kind let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET ghost . kind attrs(lident_op_id) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET ghost . kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET ghost . kind attrs(lident_op_id) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET LEFTPAR EQUAL RIGHTPAR EQUAL UIDENT IN WRITES 
##
## Ends in an error in state: 894.
##
## single_expr_ -> LET ghost kind attrs(lident_op_id) EQUAL seq_expr IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_op_id) EQUAL seq_expr IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET LEFTPAR EQUAL RIGHTPAR EQUAL UIDENT WITH 
##
## Ends in an error in state: 893.
##
## single_expr_ -> LET ghost kind attrs(lident_op_id) EQUAL seq_expr . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_op_id) EQUAL seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET LEFTPAR EQUAL RIGHTPAR EQUAL WRITES 
##
## Ends in an error in state: 892.
##
## single_expr_ -> LET ghost kind attrs(lident_op_id) EQUAL . seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_op_id) EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET LEFTPAR EQUAL RIGHTPAR POSITION WRITES 
##
## Ends in an error in state: 891.
##
## single_expr_ -> LET ghost kind attrs(lident_op_id) . EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET ghost kind attrs(lident_op_id) . mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_op_id) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 414, spurious reduction of production attrs(lident_op_id) -> lident_op_id list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET LEFTPAR EQUAL RIGHTPAR UNDERSCORE EQUAL UIDENT IN WRITES 
##
## Ends in an error in state: 897.
##
## single_expr_ -> LET ghost kind attrs(lident_op_id) mk_expr(fun_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_op_id) mk_expr(fun_defn) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET LEFTPAR EQUAL RIGHTPAR UNDERSCORE EQUAL UIDENT WITH 
##
## Ends in an error in state: 896.
##
## single_expr_ -> LET ghost kind attrs(lident_op_id) mk_expr(fun_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_op_id) mk_expr(fun_defn) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 905, spurious reduction of production fun_defn -> binders return_opt spec EQUAL spec seq_expr 
## In state 899, spurious reduction of production mk_expr(fun_defn) -> fun_defn 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET PREDICATE CONTINUE 
##
## Ends in an error in state: 868.
##
## single_expr_ -> LET ghost kind . let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET ghost kind . attrs(lident_op_id) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET ghost kind . attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET ghost kind . attrs(lident_op_id) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET RANGE UNDERSCORE EQUAL UIDENT IN WRITES 
##
## Ends in an error in state: 908.
##
## single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET RANGE UNDERSCORE EQUAL UIDENT WITH 
##
## Ends in an error in state: 907.
##
## single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 905, spurious reduction of production fun_defn -> binders return_opt spec EQUAL spec seq_expr 
## In state 899, spurious reduction of production mk_expr(fun_defn) -> fun_defn 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET RANGE WITH 
##
## Ends in an error in state: 906.
##
## pat_arg_ -> attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
## single_expr_ -> LET ghost kind attrs(lident_nq) . mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 109, spurious reduction of production list(attr) -> 
## In state 110, spurious reduction of production attrs(lident_nq) -> lident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET REC RANGE CORE_LIDENT EQUAL UIDENT IN WRITES 
##
## Ends in an error in state: 688.
##
## single_expr_ -> LET REC with_list1(rec_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET REC with_list1(rec_defn) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET REC RANGE CORE_LIDENT EQUAL UIDENT VAL 
##
## Ends in an error in state: 687.
##
## single_expr_ -> LET REC with_list1(rec_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET REC with_list1(rec_defn) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 866, spurious reduction of production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr 
## In state 855, spurious reduction of production separated_nonempty_list(WITH,rec_defn) -> rec_defn 
## In state 854, spurious reduction of production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET REC WRITES 
##
## Ends in an error in state: 686.
##
## single_expr_ -> LET REC . with_list1(rec_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET REC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UIDENT WRITES 
##
## Ends in an error in state: 869.
##
## let_pat_uni_ -> uqualid . nonempty_list(pat_arg) [ EQUAL COMMA COLON BAR AS ]
## pat_arg_ -> uqualid . [ EQUAL COMMA COLON BAR AS ]
## uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE AS GHOST CONTINUE 
##
## Ends in an error in state: 877.
##
## let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost . attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
##
## The known suffix of the stack is as follows:
## mk_pat(let_pat_uni_) AS ghost 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE AS WRITES 
##
## Ends in an error in state: 876.
##
## let_pat_uni_ -> mk_pat(let_pat_uni_) AS . ghost attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
##
## The known suffix of the stack is as follows:
## mk_pat(let_pat_uni_) AS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE BAR CORE_LIDENT SEMICOLON 
##
## Ends in an error in state: 884.
##
## single_expr_ -> LET ghost kind let_pattern . EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind let_pattern 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 109, spurious reduction of production list(attr) -> 
## In state 110, spurious reduction of production attrs(lident_nq) -> lident_nq list(attr) 
## In state 220, spurious reduction of production pat_arg_ -> attrs(lident_nq) 
## In state 223, spurious reduction of production pat_uni_ -> pat_arg_ 
## In state 230, spurious reduction of production pat_conj_ -> pat_uni_ 
## In state 231, spurious reduction of production pattern_ -> pat_conj_ 
## In state 226, spurious reduction of production mk_pat(pattern_) -> pattern_ 
## In state 232, spurious reduction of production pattern -> mk_pat(pattern_) 
## In state 882, spurious reduction of production let_pattern_ -> mk_pat(let_pat_conj_) BAR pattern 
## In state 883, spurious reduction of production mk_pat(let_pattern_) -> let_pattern_ 
## In state 872, spurious reduction of production let_pattern -> mk_pat(let_pattern_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE BAR WRITES 
##
## Ends in an error in state: 881.
##
## let_pattern_ -> mk_pat(let_pat_conj_) BAR . pattern [ EQUAL ]
##
## The known suffix of the stack is as follows:
## mk_pat(let_pat_conj_) BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE COMMA CORE_LIDENT SEMICOLON 
##
## Ends in an error in state: 890.
##
## let_pattern_ -> let_pat_conj_ . [ EQUAL ]
## mk_pat(let_pat_conj_) -> let_pat_conj_ . [ BAR ]
##
## The known suffix of the stack is as follows:
## let_pat_conj_ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 109, spurious reduction of production list(attr) -> 
## In state 110, spurious reduction of production attrs(lident_nq) -> lident_nq list(attr) 
## In state 220, spurious reduction of production pat_arg_ -> attrs(lident_nq) 
## In state 223, spurious reduction of production pat_uni_ -> pat_arg_ 
## In state 222, spurious reduction of production mk_pat(pat_uni_) -> pat_uni_ 
## In state 236, spurious reduction of production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) 
## In state 235, spurious reduction of production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_)) 
## In state 875, spurious reduction of production let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE COMMA WRITES 
##
## Ends in an error in state: 874.
##
## let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA . comma_list1(mk_pat(pat_uni_)) [ EQUAL BAR ]
##
## The known suffix of the stack is as follows:
## mk_pat(let_pat_uni_) COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE EQUAL UIDENT IN WRITES 
##
## Ends in an error in state: 887.
##
## single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind let_pattern EQUAL seq_expr IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE EQUAL UIDENT WITH 
##
## Ends in an error in state: 886.
##
## single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind let_pattern EQUAL seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE EQUAL WRITES 
##
## Ends in an error in state: 885.
##
## single_expr_ -> LET ghost kind let_pattern EQUAL . seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET ghost kind let_pattern EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET UNDERSCORE WRITES 
##
## Ends in an error in state: 889.
##
## let_pat_conj_ -> let_pat_uni_ . [ EQUAL BAR ]
## mk_pat(let_pat_uni_) -> let_pat_uni_ . [ COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## let_pat_uni_ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL LET WRITES 
##
## Ends in an error in state: 685.
##
## single_expr_ -> LET . ghost kind let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET . ghost kind attrs(lident_op_id) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET . ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET . ghost kind attrs(lident_op_id) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> LET . REC with_list1(rec_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LET 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT VAL 
##
## Ends in an error in state: 910.
##
## single_expr_ -> MATCH seq_expr . WITH ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## MATCH seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH BAR WRITES 
##
## Ends in an error in state: 927.
##
## ext_match_cases -> BAR . ext_match_cases1 [ END ]
##
## The known suffix of the stack is as follows:
## BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH EXCEPTION UIDENT ARROW ABSURD WITH 
##
## Ends in an error in state: 918.
##
## ext_match_cases1 -> EXCEPTION exn_handler . ext_match_cases0 [ END ]
##
## The known suffix of the stack is as follows:
## EXCEPTION exn_handler 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 917, spurious reduction of production exn_handler -> uqualid option(pat_arg) ARROW seq_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH EXCEPTION WRITES 
##
## Ends in an error in state: 912.
##
## ext_match_cases1 -> EXCEPTION . exn_handler ext_match_cases0 [ END ]
##
## The known suffix of the stack is as follows:
## EXCEPTION 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH UNDERSCORE ARROW ABSURD BAR WRITES 
##
## Ends in an error in state: 919.
##
## ext_match_cases0 -> BAR . ext_match_cases1 [ END ]
##
## The known suffix of the stack is as follows:
## BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH UNDERSCORE ARROW ABSURD WITH 
##
## Ends in an error in state: 923.
##
## ext_match_cases1 -> match_case(seq_expr) . ext_match_cases0 [ END ]
##
## The known suffix of the stack is as follows:
## match_case(seq_expr) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 922, spurious reduction of production match_case(seq_expr) -> pattern ARROW seq_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH UNDERSCORE ARROW WRITES 
##
## Ends in an error in state: 921.
##
## match_case(seq_expr) -> pattern ARROW . seq_expr [ END BAR ]
##
## The known suffix of the stack is as follows:
## pattern ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH UNDERSCORE SEMICOLON 
##
## Ends in an error in state: 920.
##
## match_case(seq_expr) -> pattern . ARROW seq_expr [ END BAR ]
##
## The known suffix of the stack is as follows:
## pattern 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 230, spurious reduction of production pat_conj_ -> pat_uni_ 
## In state 231, spurious reduction of production pattern_ -> pat_conj_ 
## In state 226, spurious reduction of production mk_pat(pattern_) -> pattern_ 
## In state 232, spurious reduction of production pattern -> mk_pat(pattern_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH UIDENT WITH WRITES 
##
## Ends in an error in state: 911.
##
## single_expr_ -> MATCH seq_expr WITH . ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## MATCH seq_expr WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MATCH WRITES 
##
## Ends in an error in state: 684.
##
## single_expr_ -> MATCH . seq_expr WITH ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## MATCH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL MINUS WRITES 
##
## Ends in an error in state: 681.
##
## prefix_op -> MINUS . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## single_expr_ -> MINUS . INTEGER [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> MINUS . REAL [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL NOT ABSURD WHILE 
##
## Ends in an error in state: 932.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> NOT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## NOT single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL NOT WRITES 
##
## Ends in an error in state: 680.
##
## single_expr_ -> NOT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## NOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL OP4 WRITES 
##
## Ends in an error in state: 768.
##
## single_expr_ -> prefix_op . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## prefix_op 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL OPPREF WRITES 
##
## Ends in an error in state: 673.
##
## expr_arg_ -> OPPREF . expr_arg [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_dot_ -> OPPREF . expr_dot [ DOT ]
##
## The known suffix of the stack is as follows:
## OPPREF 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL POSITION ABSURD WHILE 
##
## Ends in an error in state: 779.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> attr single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## attr single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL POSITION WRITES 
##
## Ends in an error in state: 778.
##
## single_expr_ -> attr . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## attr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL PURE LEFTBRC UIDENT WITH 
##
## Ends in an error in state: 671.
##
## expr_sub -> PURE LEFTBRC term . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## PURE LEFTBRC term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL PURE LEFTBRC WRITES 
##
## Ends in an error in state: 670.
##
## expr_sub -> PURE LEFTBRC . term RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## PURE LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL PURE WRITES 
##
## Ends in an error in state: 669.
##
## expr_sub -> PURE . LEFTBRC term RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## PURE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RAISE LEFTPAR UIDENT UIDENT RIGHTBRC 
##
## Ends in an error in state: 947.
##
## single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## RAISE LEFTPAR uqualid option(expr_arg) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 756, spurious reduction of production mk_expr(expr_arg_) -> expr_arg_ 
## In state 730, spurious reduction of production expr_arg -> mk_expr(expr_arg_) 
## In state 949, spurious reduction of production option(expr_arg) -> expr_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RAISE LEFTPAR UIDENT WRITES 
##
## Ends in an error in state: 668.
##
## single_expr_ -> RAISE LEFTPAR uqualid . option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## uqualid -> uqualid . DOT uident [ UIDENT TRUE RIGHTPAR REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE DOT CORE_UIDENT CORE_LIDENT BEGIN ]
##
## The known suffix of the stack is as follows:
## RAISE LEFTPAR uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RAISE LEFTPAR WRITES 
##
## Ends in an error in state: 667.
##
## single_expr_ -> RAISE LEFTPAR . uqualid option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## RAISE LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RAISE UIDENT UIDENT UIDENT 
##
## Ends in an error in state: 949.
##
## expr_sub -> expr_arg . LEFTSQ expr RIGHTSQ [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ expr LARROW expr RIGHTSQ [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT expr RIGHTSQ [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT RIGHTSQ [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ DOTDOT expr RIGHTSQ [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## option(expr_arg) -> expr_arg . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 756, spurious reduction of production mk_expr(expr_arg_) -> expr_arg_ 
## In state 730, spurious reduction of production expr_arg -> mk_expr(expr_arg_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RAISE UIDENT WHILE 
##
## Ends in an error in state: 950.
##
## single_expr_ -> RAISE uqualid . option(expr_arg) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## uqualid -> uqualid . DOT uident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## RAISE uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RAISE WRITES 
##
## Ends in an error in state: 666.
##
## single_expr_ -> RAISE . uqualid option(expr_arg) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> RAISE . LEFTPAR uqualid option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## RAISE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RANGE DOT LEFTBRC UIDENT WRITES 
##
## Ends in an error in state: 745.
##
## expr_pure -> LEFTBRC qualid . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTBRC qualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RANGE DOT LEFTBRC WRITES 
##
## Ends in an error in state: 741.
##
## expr_pure -> LEFTBRC . qualid RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RANGE DOT UIDENT DOT LEFTBRC UIDENT WRITES 
##
## Ends in an error in state: 751.
##
## expr_pure -> uqualid DOT LEFTBRC ident_rich . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## uqualid DOT LEFTBRC ident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RANGE DOT UIDENT DOT LEFTBRC WRITES 
##
## Ends in an error in state: 749.
##
## expr_pure -> uqualid DOT LEFTBRC . ident_rich RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## uqualid DOT LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RANGE DOT UIDENT DOT WRITES 
##
## Ends in an error in state: 748.
##
## expr_pure -> uqualid DOT . LEFTBRC ident_rich RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## lqualid_rich -> uqualid DOT . lident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## lqualid_rich -> uqualid DOT . lident_op_id [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RANGE DOT UIDENT WRITES 
##
## Ends in an error in state: 747.
##
## expr_pure -> uqualid . DOT LEFTBRC ident_rich RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## lqualid_rich -> uqualid . DOT lident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## lqualid_rich -> uqualid . DOT lident_op_id [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## uqualid -> uqualid . DOT uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RANGE DOT WRITES 
##
## Ends in an error in state: 740.
##
## expr_sub -> expr_dot DOT . mk_expr(expr_pure) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_dot DOT . lqualid_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_dot DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL RETURN UNDERSCORE 
##
## Ends in an error in state: 665.
##
## single_expr_ -> RETURN . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> RETURN . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## RETURN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT VAL 
##
## Ends in an error in state: 953.
##
## single_expr_ -> TRY seq_expr . WITH bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## TRY seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT WITH BAR WRITES 
##
## Ends in an error in state: 955.
##
## bar_list1(exn_handler) -> BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
##
## The known suffix of the stack is as follows:
## BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT WITH UIDENT ARROW ABSURD BAR WRITES 
##
## Ends in an error in state: 958.
##
## separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
##
## The known suffix of the stack is as follows:
## exn_handler BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT WITH UIDENT ARROW ABSURD WITH 
##
## Ends in an error in state: 957.
##
## separated_nonempty_list(BAR,exn_handler) -> exn_handler . [ END ]
## separated_nonempty_list(BAR,exn_handler) -> exn_handler . BAR separated_nonempty_list(BAR,exn_handler) [ END ]
##
## The known suffix of the stack is as follows:
## exn_handler 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 917, spurious reduction of production exn_handler -> uqualid option(pat_arg) ARROW seq_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT WITH UIDENT ARROW WRITES 
##
## Ends in an error in state: 916.
##
## exn_handler -> uqualid option(pat_arg) ARROW . seq_expr [ END BAR ]
##
## The known suffix of the stack is as follows:
## uqualid option(pat_arg) ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT WITH UIDENT UNDERSCORE ANY 
##
## Ends in an error in state: 915.
##
## exn_handler -> uqualid option(pat_arg) . ARROW seq_expr [ END BAR ]
##
## The known suffix of the stack is as follows:
## uqualid option(pat_arg) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT WITH UIDENT WRITES 
##
## Ends in an error in state: 913.
##
## exn_handler -> uqualid . option(pat_arg) ARROW seq_expr [ END BAR ]
## uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY UIDENT WITH WRITES 
##
## Ends in an error in state: 954.
##
## single_expr_ -> TRY seq_expr WITH . bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## TRY seq_expr WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL TRY WRITES 
##
## Ends in an error in state: 663.
##
## single_expr_ -> TRY . seq_expr WITH bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## TRY 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT AMPAMP ABSURD WHILE 
##
## Ends in an error in state: 803.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr AMPAMP single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr AMPAMP single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT AMPAMP WRITES 
##
## Ends in an error in state: 802.
##
## single_expr_ -> single_expr AMPAMP . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr AMPAMP 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT BARBAR ABSURD WHILE 
##
## Ends in an error in state: 801.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr BARBAR single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr BARBAR single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT BARBAR WRITES 
##
## Ends in an error in state: 800.
##
## single_expr_ -> single_expr BARBAR . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr BARBAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT COMMA ABSURD WHILE 
##
## Ends in an error in state: 805.
##
## expr_list1 -> single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_list1 -> single_expr . COMMA expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT COMMA UIDENT COMMA WRITES 
##
## Ends in an error in state: 806.
##
## expr_list1 -> single_expr COMMA . expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT COMMA WRITES 
##
## Ends in an error in state: 804.
##
## expr -> single_expr COMMA . expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT DIVERGES DIVERGES WHILE 
##
## Ends in an error in state: 824.
##
## seq_expr -> contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## seq_expr -> contract_expr . SEMICOLON [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## seq_expr -> contract_expr . SEMICOLON seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## contract_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
## In state 829, spurious reduction of production contract_expr -> assign_expr single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT DIVERGES WHILE 
##
## Ends in an error in state: 828.
##
## contract_expr -> assign_expr single_spec . spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## assign_expr single_spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT DOT LEFTBRC UIDENT WRITES 
##
## Ends in an error in state: 732.
##
## expr_pure -> uqualid DOT LEFTBRC ident_rich . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## qualid -> ident_rich . [ WITH LEFTSQ ]
##
## The known suffix of the stack is as follows:
## uqualid DOT LEFTBRC ident_rich 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT DOT LEFTBRC WRITES 
##
## Ends in an error in state: 722.
##
## expr_block -> LEFTBRC . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_block -> LEFTBRC . expr_arg WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_pure -> uqualid DOT LEFTBRC . ident_rich RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## uqualid DOT LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT DOT WRITES 
##
## Ends in an error in state: 721.
##
## expr_pure -> uqualid DOT . LEFTBRC ident_rich RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> uqualid DOT . mk_expr(expr_block) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## lqualid -> uqualid DOT . lident [ DOT ]
## qualid -> uqualid DOT . ident_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## uqualid -> uqualid DOT . uident [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT EQUAL ABSURD WHILE 
##
## Ends in an error in state: 799.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr EQUAL single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr EQUAL single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT EQUAL WRITES 
##
## Ends in an error in state: 798.
##
## single_expr_ -> single_expr EQUAL . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT GT ABSURD WHILE 
##
## Ends in an error in state: 797.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr GT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr GT single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT GT WRITES 
##
## Ends in an error in state: 796.
##
## single_expr_ -> single_expr GT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr GT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LARROW WRITES 
##
## Ends in an error in state: 822.
##
## assign_expr -> expr LARROW . expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr LARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ DOTDOT UIDENT WRITES 
##
## Ends in an error in state: 809.
##
## expr_sub -> expr_arg LEFTSQ DOTDOT expr . RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ DOTDOT expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ DOTDOT WRITES 
##
## Ends in an error in state: 762.
##
## expr_sub -> expr_arg LEFTSQ DOTDOT . expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ DOTDOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ UIDENT DOTDOT UIDENT WRITES 
##
## Ends in an error in state: 818.
##
## expr_sub -> expr_arg LEFTSQ expr DOTDOT expr . RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr DOTDOT expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ UIDENT DOTDOT WRITES 
##
## Ends in an error in state: 816.
##
## expr_sub -> expr_arg LEFTSQ expr DOTDOT . expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ expr DOTDOT . RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr DOTDOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ UIDENT LARROW UIDENT WRITES 
##
## Ends in an error in state: 814.
##
## expr_sub -> expr_arg LEFTSQ expr LARROW expr . RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr LARROW expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ UIDENT LARROW WRITES 
##
## Ends in an error in state: 813.
##
## expr_sub -> expr_arg LEFTSQ expr LARROW . expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr LARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ UIDENT WRITES 
##
## Ends in an error in state: 811.
##
## expr_sub -> expr_arg LEFTSQ expr . RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ expr . LARROW expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ expr . DOTDOT expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ expr . DOTDOT RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LEFTSQ WRITES 
##
## Ends in an error in state: 761.
##
## expr_sub -> expr_arg LEFTSQ . expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ . expr LARROW expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ . expr DOTDOT expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ . expr DOTDOT RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg LEFTSQ . DOTDOT expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LT ABSURD WHILE 
##
## Ends in an error in state: 795.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr LT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr LT single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LT WRITES 
##
## Ends in an error in state: 794.
##
## single_expr_ -> single_expr LT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr LT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LTGT ABSURD WHILE 
##
## Ends in an error in state: 793.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr LTGT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr LTGT single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT LTGT WRITES 
##
## Ends in an error in state: 792.
##
## single_expr_ -> single_expr LTGT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr LTGT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT MINUS ABSURD WHILE 
##
## Ends in an error in state: 791.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr MINUS single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr MINUS single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT MINUS WRITES 
##
## Ends in an error in state: 790.
##
## single_expr_ -> single_expr MINUS . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT OP1 ABSURD WHILE 
##
## Ends in an error in state: 789.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr OP1 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr OP1 single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT OP1 WRITES 
##
## Ends in an error in state: 788.
##
## single_expr_ -> single_expr OP1 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr OP1 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT OP2 ABSURD WHILE 
##
## Ends in an error in state: 787.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr OP2 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr OP2 single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT OP2 WRITES 
##
## Ends in an error in state: 786.
##
## single_expr_ -> single_expr OP2 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr OP2 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT OP3 ABSURD WHILE 
##
## Ends in an error in state: 781.
##
## single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr OP3 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr OP3 single_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT OP3 WRITES 
##
## Ends in an error in state: 780.
##
## single_expr_ -> single_expr OP3 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr OP3 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT OP4 WRITES 
##
## Ends in an error in state: 765.
##
## single_expr_ -> single_expr OP4 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## single_expr OP4 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT SEMICOLON UNDERSCORE 
##
## Ends in an error in state: 825.
##
## seq_expr -> contract_expr SEMICOLON . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## seq_expr -> contract_expr SEMICOLON . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## contract_expr SEMICOLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT SO 
##
## Ends in an error in state: 772.
##
## mk_expr(expr_arg_) -> expr_arg_ . [ UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN ]
## single_expr_ -> expr_arg_ . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg_ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL UIDENT UIDENT SO 
##
## Ends in an error in state: 777.
##
## expr_sub -> expr_arg . LEFTSQ expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ expr LARROW expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## expr_sub -> expr_arg . LEFTSQ DOTDOT expr RIGHTSQ [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## located(expr_arg) -> expr_arg . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## expr_arg 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 756, spurious reduction of production mk_expr(expr_arg_) -> expr_arg_ 
## In state 730, spurious reduction of production expr_arg -> mk_expr(expr_arg_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL VAL GHOST COMMA 
##
## Ends in an error in state: 658.
##
## single_expr_ -> VAL ghost . kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## VAL ghost 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL VAL PREDICATE CONTINUE 
##
## Ends in an error in state: 659.
##
## single_expr_ -> VAL ghost kind . attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## VAL ghost kind 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL VAL RANGE IN WRITES 
##
## Ends in an error in state: 662.
##
## single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL VAL RANGE UNDERSCORE IMPORT 
##
## Ends in an error in state: 661.
##
## single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 552, spurious reduction of production list(param) -> 
## In state 553, spurious reduction of production list(param) -> param list(param) 
## In state 558, spurious reduction of production params -> list(param) 
## In state 135, spurious reduction of production return_opt -> 
## In state 184, spurious reduction of production spec -> 
## In state 549, spurious reduction of production val_defn -> params return_opt spec 
## In state 133, spurious reduction of production mk_expr(val_defn) -> val_defn 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL VAL RANGE WITH 
##
## Ends in an error in state: 660.
##
## single_expr_ -> VAL ghost kind attrs(lident_rich) . mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## VAL ghost kind attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL VAL WRITES 
##
## Ends in an error in state: 657.
##
## single_expr_ -> VAL . ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## VAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL WHILE UIDENT DO INVARIANT LEFTBRC CORE_LIDENT RIGHTBRC WRITES 
##
## Ends in an error in state: 968.
##
## loop_annotation -> invariant . loop_annotation [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
##
## The known suffix of the stack is as follows:
## invariant 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL WHILE UIDENT DO UIDENT WITH 
##
## Ends in an error in state: 971.
##
## single_expr_ -> WHILE seq_expr DO loop_annotation loop_body . DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## WHILE seq_expr DO loop_annotation loop_body 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 840, spurious reduction of production loop_body -> seq_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL WHILE UIDENT DO VARIANT LEFTBRC CORE_LIDENT RIGHTBRC WRITES 
##
## Ends in an error in state: 966.
##
## loop_annotation -> variant . loop_annotation [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
##
## The known suffix of the stack is as follows:
## variant 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL WHILE UIDENT DO WRITES 
##
## Ends in an error in state: 965.
##
## single_expr_ -> WHILE seq_expr DO . loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## WHILE seq_expr DO 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL WHILE UIDENT WITH 
##
## Ends in an error in state: 964.
##
## single_expr_ -> WHILE seq_expr . DO loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## WHILE seq_expr 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL WHILE WRITES 
##
## Ends in an error in state: 656.
##
## single_expr_ -> WHILE . seq_expr DO loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
##
## The known suffix of the stack is as follows:
## WHILE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE EQUAL WRITES 
##
## Ends in an error in state: 1031.
##
## const_defn -> EQUAL . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE UNDERSCORE ARROW 
##
## Ends in an error in state: 900.
##
## fun_defn -> binders . return_opt spec EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 402, spurious reduction of production nonempty_list(binder) -> binder 
## In state 270, spurious reduction of production binders -> nonempty_list(binder) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE UNDERSCORE COLON CORE_LIDENT WITH 
##
## Ends in an error in state: 901.
##
## fun_defn -> binders return_opt . spec EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders return_opt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 181, spurious reduction of production return -> ty 
## In state 183, spurious reduction of production return_named -> return 
## In state 182, spurious reduction of production return_opt -> COLON return_named 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE UNDERSCORE DIVERGES WITH 
##
## Ends in an error in state: 902.
##
## fun_defn -> binders return_opt spec . EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders return_opt spec 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE UNDERSCORE EQUAL DIVERGES WITH 
##
## Ends in an error in state: 904.
##
## fun_defn -> binders return_opt spec EQUAL spec . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders return_opt spec EQUAL spec 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE UNDERSCORE EQUAL WITH 
##
## Ends in an error in state: 903.
##
## fun_defn -> binders return_opt spec EQUAL . spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders return_opt spec EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET RANGE WRITES 
##
## Ends in an error in state: 1030.
##
## prog_decl -> LET ghost kind attrs(lident_rich) . mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## prog_decl -> LET ghost kind attrs(lident_rich) . const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET ghost kind attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC GHOST WRITES 
##
## Ends in an error in state: 858.
##
## rec_defn -> ghost . kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC PREDICATE CONTINUE 
##
## Ends in an error in state: 859.
##
## rec_defn -> ghost kind . attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost kind 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE CORE_LIDENT EQUAL UIDENT TO 
##
## Ends in an error in state: 855.
##
## separated_nonempty_list(WITH,rec_defn) -> rec_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(WITH,rec_defn) -> rec_defn . WITH separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## rec_defn 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 727, spurious reduction of production expr_arg_ -> qualid 
## In state 772, spurious reduction of production single_expr_ -> expr_arg_ 
## In state 763, spurious reduction of production mk_expr(single_expr_) -> single_expr_ 
## In state 770, spurious reduction of production single_expr -> mk_expr(single_expr_) 
## In state 764, spurious reduction of production expr -> single_expr 
## In state 821, spurious reduction of production assign_expr -> expr 
## In state 827, spurious reduction of production contract_expr -> assign_expr 
## In state 824, spurious reduction of production seq_expr -> contract_expr 
## In state 866, spurious reduction of production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE CORE_LIDENT EQUAL UIDENT WITH WRITES 
##
## Ends in an error in state: 856.
##
## separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH . separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## rec_defn WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE UNDERSCORE ARROW 
##
## Ends in an error in state: 861.
##
## rec_defn -> ghost kind attrs(lident_rich) binders . return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost kind attrs(lident_rich) binders 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 402, spurious reduction of production nonempty_list(binder) -> binder 
## In state 270, spurious reduction of production binders -> nonempty_list(binder) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE UNDERSCORE COLON CORE_LIDENT WITH 
##
## Ends in an error in state: 862.
##
## rec_defn -> ghost kind attrs(lident_rich) binders return_opt . spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost kind attrs(lident_rich) binders return_opt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 181, spurious reduction of production return -> ty 
## In state 183, spurious reduction of production return_named -> return 
## In state 182, spurious reduction of production return_opt -> COLON return_named 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE UNDERSCORE DIVERGES WITH 
##
## Ends in an error in state: 863.
##
## rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec . EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost kind attrs(lident_rich) binders return_opt spec 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE UNDERSCORE EQUAL DIVERGES WITH 
##
## Ends in an error in state: 865.
##
## rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec . seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production spec -> 
## In state 551, spurious reduction of production spec -> single_spec spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE UNDERSCORE EQUAL WITH 
##
## Ends in an error in state: 864.
##
## rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL . spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC RANGE WRITES 
##
## Ends in an error in state: 860.
##
## rec_defn -> ghost kind attrs(lident_rich) . binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ghost kind attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET REC WRITES 
##
## Ends in an error in state: 1026.
##
## prog_decl -> LET REC . with_list1(rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET REC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: LET WRITES 
##
## Ends in an error in state: 1025.
##
## prog_decl -> LET . ghost kind attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## prog_decl -> LET . ghost kind attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## prog_decl -> LET . REC with_list1(rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT AXIOM WRITES 
##
## Ends in an error in state: 1018.
##
## meta_arg -> AXIOM . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT CONSTANT WRITES 
##
## Ends in an error in state: 1016.
##
## meta_arg -> CONSTANT . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT FUNCTION WRITES 
##
## Ends in an error in state: 1014.
##
## meta_arg -> FUNCTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT GOAL WRITES 
##
## Ends in an error in state: 1012.
##
## meta_arg -> GOAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT LEMMA WRITES 
##
## Ends in an error in state: 1009.
##
## meta_arg -> LEMMA . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT PREDICATE WRITES 
##
## Ends in an error in state: 1007.
##
## meta_arg -> PREDICATE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT STRING COMMA WRITES 
##
## Ends in an error in state: 1022.
##
## separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA . separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## meta_arg COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT STRING WRITES 
##
## Ends in an error in state: 1021.
##
## separated_nonempty_list(COMMA,meta_arg) -> meta_arg . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(COMMA,meta_arg) -> meta_arg . COMMA separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## meta_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT TYPE RANGE WRITES 
##
## Ends in an error in state: 1005.
##
## meta_arg -> TYPE ty . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## ty -> ty . ARROW ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
##
## The known suffix of the stack is as follows:
## TYPE ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT TYPE WRITES 
##
## Ends in an error in state: 1004.
##
## meta_arg -> TYPE . ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META UIDENT WRITES 
##
## Ends in an error in state: 1003.
##
## meta_decl -> META sident . comma_list1(meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## META sident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: META WRITES 
##
## Ends in an error in state: 1002.
##
## meta_decl -> META . sident comma_list1(meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## META 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: MODULE WRITES 
##
## Ends in an error in state: 1000.
##
## module_head -> MODULE . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## MODULE 
##

module name expected.
found "$0".
expecting a capitalized identifier (token UIDENT_NQ)

mlw_file: PREDICATE RANGE EQUAL CORE_LIDENT THEN 
##
## Ends in an error in state: 986.
##
## pure_decl -> PREDICATE predicate_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE predicate_decl 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 992, spurious reduction of production option(preceded(EQUAL,term)) -> EQUAL term 
## In state 999, spurious reduction of production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE EQUAL WRITES 
##
## Ends in an error in state: 991.
##
## option(preceded(EQUAL,term)) -> EQUAL . term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE LEFTPAR GHOST RANGE WRITES 
##
## Ends in an error in state: 102.
##
## binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
## param -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COLON ATTRIBUTE ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE LEFTPAR GHOST UNDERSCORE COLON RANGE WRITES 
##
## Ends in an error in state: 122.
##
## param -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST binder_vars cast 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE LEFTPAR GHOST WRITES 
##
## Ends in an error in state: 101.
##
## param -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## param -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## param -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE LEFTPAR UNDERSCORE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 130.
##
## param -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR binder_vars cast 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE LEFTPAR WRITES 
##
## Ends in an error in state: 70.
##
## param -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## param -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## param -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## param -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## param -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## ty_arg -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## ty_arg -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## ty_arg -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE RANGE POSITION WHILE 
##
## Ends in an error in state: 115.
##
## nonempty_list(attr) -> attr . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## nonempty_list(attr) -> attr . nonempty_list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## attr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE RANGE WHILE 
##
## Ends in an error in state: 273.
##
## lident -> lident_keyword . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## lident_nq -> lident_keyword . [ POSITION ATTRIBUTE ]
##
## The known suffix of the stack is as follows:
## lident_keyword 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE UNDERSCORE WHILE 
##
## Ends in an error in state: 552.
##
## list(param) -> param . list(param) [ WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
##
## The known suffix of the stack is as follows:
## param 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE UNDERSCORE WRITES 
##
## Ends in an error in state: 998.
##
## predicate_decl -> attrs(lident_rich) params . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) params 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 552, spurious reduction of production list(param) -> 
## In state 553, spurious reduction of production list(param) -> param list(param) 
## In state 558, spurious reduction of production params -> list(param) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE WHILE 
##
## Ends in an error in state: 57.
##
## attrs(lident_rich) -> lident_rich . list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS ]
##
## The known suffix of the stack is as follows:
## lident_rich 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE WITH RANGE COLON CORE_LIDENT AT 
##
## Ends in an error in state: 990.
##
## with_logic_decl -> WITH attrs(lident_rich) params option(cast) . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH attrs(lident_rich) params option(cast) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
## In state 322, spurious reduction of production option(cast) -> cast 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE WITH RANGE EQUAL UIDENT THEN 
##
## Ends in an error in state: 994.
##
## list(with_logic_decl) -> with_logic_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## with_logic_decl 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 992, spurious reduction of production option(preceded(EQUAL,term)) -> EQUAL term 
## In state 993, spurious reduction of production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE WITH RANGE UNDERSCORE ALIAS 
##
## Ends in an error in state: 989.
##
## with_logic_decl -> WITH attrs(lident_rich) params . option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH attrs(lident_rich) params 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 552, spurious reduction of production list(param) -> 
## In state 553, spurious reduction of production list(param) -> param list(param) 
## In state 558, spurious reduction of production params -> list(param) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE WITH RANGE WRITES 
##
## Ends in an error in state: 988.
##
## with_logic_decl -> WITH attrs(lident_rich) . params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE WITH WRITES 
##
## Ends in an error in state: 987.
##
## with_logic_decl -> WITH . attrs(lident_rich) params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE RANGE WRITES 
##
## Ends in an error in state: 997.
##
## predicate_decl -> attrs(lident_rich) . params option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: PREDICATE WRITES 
##
## Ends in an error in state: 985.
##
## pure_decl -> PREDICATE . predicate_decl list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: SCOPE CORE_UIDENT WRITES 
##
## Ends in an error in state: 1142.
##
## module_decl -> scope_head . list(module_decl) END [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## scope_head 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: SCOPE IMPORT CORE_LIDENT 
##
## Ends in an error in state: 983.
##
## scope_head -> SCOPE boption(IMPORT) . uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## SCOPE boption(IMPORT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: SCOPE WRITES 
##
## Ends in an error in state: 982.
##
## scope_head -> SCOPE . boption(IMPORT) uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## SCOPE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: THEORY UIDENT END WRITES 
##
## Ends in an error in state: 1157.
##
## list(mlw_module) -> mlw_module . list(mlw_module) [ EOF ]
##
## The known suffix of the stack is as follows:
## mlw_module 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: THEORY UIDENT VAL RANGE EOF 
##
## Ends in an error in state: 1145.
##
## list(module_decl) -> module_decl . list(module_decl) [ END ]
##
## The known suffix of the stack is as follows:
## module_decl 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
## In state 66, spurious reduction of production list(param) -> 
## In state 558, spurious reduction of production params -> list(param) 
## In state 135, spurious reduction of production return_opt -> 
## In state 184, spurious reduction of production spec -> 
## In state 549, spurious reduction of production val_defn -> params return_opt spec 
## In state 133, spurious reduction of production mk_expr(val_defn) -> val_defn 
## In state 557, spurious reduction of production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) 
## In state 1144, spurious reduction of production module_decl -> prog_decl 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: THEORY UIDENT WITH 
##
## Ends in an error in state: 1152.
##
## mlw_module -> module_head . list(module_decl) END [ THEORY MODULE EOF ]
##
## The known suffix of the stack is as follows:
## module_head 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 632, spurious reduction of production list(attr) -> 
## In state 633, spurious reduction of production attrs(uident_nq) -> uident_nq list(attr) 
## In state 981, spurious reduction of production module_head -> THEORY attrs(uident_nq) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: THEORY UIDENT WRITES 
##
## Ends in an error in state: 632.
##
## attrs(uident_nq) -> uident_nq . list(attr) [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## uident_nq 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: THEORY WRITES 
##
## Ends in an error in state: 980.
##
## module_head -> THEORY . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## THEORY 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE BY LEFTBRC RANGE EQUAL ABSURD RIGHTBRC WRITES 
##
## Ends in an error in state: 583.
##
## separated_nonempty_list(WITH,type_decl) -> type_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(WITH,type_decl) -> type_decl . WITH separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## type_decl 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE BY LEFTBRC RANGE WRITES 
##
## Ends in an error in state: 654.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE BY LEFTBRC WRITES 
##
## Ends in an error in state: 652.
##
## type_witness -> BY LEFTBRC . field_list1(expr) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## BY LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE BY WRITES 
##
## Ends in an error in state: 651.
##
## type_witness -> BY . LEFTBRC field_list1(expr) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## BY 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL BAR WRITES 
##
## Ends in an error in state: 629.
##
## bar_list1(type_case) -> BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL CORE_UIDENT WRITES 
##
## Ends in an error in state: 628.
##
## uident -> CORE_UIDENT . [ DOT ]
## uident_nq -> CORE_UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
##
## The known suffix of the stack is as follows:
## CORE_UIDENT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC CORE_LIDENT WRITES 
##
## Ends in an error in state: 141.
##
## lident -> CORE_LIDENT . [ UIDENT RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT COMMA ARROW ]
## lident_nq -> CORE_LIDENT . [ POSITION COLON ATTRIBUTE ]
##
## The known suffix of the stack is as follows:
## CORE_LIDENT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC GHOST WRITES 
##
## Ends in an error in state: 615.
##
## field_modifiers -> GHOST . [ RANGE LIDENT FLOAT CORE_LIDENT ]
## field_modifiers -> GHOST . MUTABLE [ RANGE LIDENT FLOAT CORE_LIDENT ]
##
## The known suffix of the stack is as follows:
## GHOST 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC LIDENT WRITES 
##
## Ends in an error in state: 139.
##
## lident -> LIDENT . [ UIDENT RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT COMMA ARROW ]
## lident_nq -> LIDENT . [ POSITION COLON ATTRIBUTE ]
##
## The known suffix of the stack is as follows:
## LIDENT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC MUTABLE GHOST WRITES 
##
## Ends in an error in state: 620.
##
## type_field -> field_modifiers . attrs(lident_nq) cast [ SEMICOLON RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## field_modifiers 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC MUTABLE RANGE WITH 
##
## Ends in an error in state: 621.
##
## type_field -> field_modifiers attrs(lident_nq) . cast [ SEMICOLON RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## field_modifiers attrs(lident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 109, spurious reduction of production list(attr) -> 
## In state 110, spurious reduction of production attrs(lident_nq) -> lident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC MUTABLE WRITES 
##
## Ends in an error in state: 613.
##
## field_modifiers -> MUTABLE . [ RANGE LIDENT FLOAT CORE_LIDENT ]
## field_modifiers -> MUTABLE . GHOST [ RANGE LIDENT FLOAT CORE_LIDENT ]
##
## The known suffix of the stack is as follows:
## MUTABLE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC RANGE COLON CORE_LIDENT SEMICOLON WRITES 
##
## Ends in an error in state: 618.
##
## semicolon_list1(type_field) -> type_field SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(type_field) -> type_field SEMICOLON . semicolon_list1(type_field) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## type_field SEMICOLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC RANGE COLON CORE_LIDENT WRITES 
##
## Ends in an error in state: 617.
##
## semicolon_list1(type_field) -> type_field . [ RIGHTBRC ]
## semicolon_list1(type_field) -> type_field . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(type_field) -> type_field . SEMICOLON semicolon_list1(type_field) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## type_field 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 121, spurious reduction of production cast -> COLON ty 
## In state 624, spurious reduction of production type_field -> attrs(lident_nq) cast 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC RANGE POSITION WRITES 
##
## Ends in an error in state: 623.
##
## type_field -> attrs(lident_nq) . cast [ SEMICOLON RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## attrs(lident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 110, spurious reduction of production attrs(lident_nq) -> lident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC RANGE WRITES 
##
## Ends in an error in state: 155.
##
## lident -> lident_keyword . [ UIDENT RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT COMMA ARROW ]
## lident_nq -> lident_keyword . [ POSITION COLON ATTRIBUTE ]
##
## The known suffix of the stack is as follows:
## lident_keyword 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC RIGHTBRC WRITES 
##
## Ends in an error in state: 645.
##
## type_decl -> attrs(lident_nq) list(ty_var) typedefn . list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_nq) list(ty_var) typedefn 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LEFTBRC WRITES 
##
## Ends in an error in state: 612.
##
## ty_arg -> LEFTBRC . ty RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ARROW ]
## typedefn -> EQUAL vis_mut LEFTBRC . loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL vis_mut LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT FLOAT INTEGER INTEGER WRITES 
##
## Ends in an error in state: 608.
##
## typedefn -> EQUAL LT FLOAT INTEGER INTEGER . GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT FLOAT INTEGER INTEGER 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT FLOAT INTEGER WRITES 
##
## Ends in an error in state: 607.
##
## typedefn -> EQUAL LT FLOAT INTEGER . INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT FLOAT INTEGER 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT FLOAT WRITES 
##
## Ends in an error in state: 606.
##
## typedefn -> EQUAL LT FLOAT . INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT FLOAT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT RANGE INTEGER INTEGER WRITES 
##
## Ends in an error in state: 604.
##
## typedefn -> EQUAL LT RANGE int_constant int_constant . GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT RANGE int_constant int_constant 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT RANGE INTEGER WRITES 
##
## Ends in an error in state: 603.
##
## typedefn -> EQUAL LT RANGE int_constant . int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT RANGE int_constant 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT RANGE MINUS WRITES 
##
## Ends in an error in state: 600.
##
## int_constant -> MINUS . INTEGER [ MINUS INTEGER GT ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT RANGE WRITES 
##
## Ends in an error in state: 599.
##
## typedefn -> EQUAL LT RANGE . int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT RANGE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL LT WRITES 
##
## Ends in an error in state: 598.
##
## typedefn -> EQUAL LT . RANGE int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## typedefn -> EQUAL LT . FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL MUTABLE WRITES 
##
## Ends in an error in state: 595.
##
## vis_mut -> MUTABLE . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## vis_mut -> MUTABLE . abstract [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
##
## The known suffix of the stack is as follows:
## MUTABLE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL PRIVATE MUTABLE WRITES 
##
## Ends in an error in state: 610.
##
## typedefn -> EQUAL vis_mut . bar_list1(type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## typedefn -> EQUAL vis_mut . LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## typedefn -> EQUAL vis_mut . ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL vis_mut 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL PRIVATE WRITES 
##
## Ends in an error in state: 643.
##
## vis_mut -> abstract . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## vis_mut -> abstract . MUTABLE [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
##
## The known suffix of the stack is as follows:
## abstract 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL RANGE WRITES 
##
## Ends in an error in state: 640.
##
## ty -> ty . ARROW ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ARROW ]
## typedefn -> EQUAL vis_mut ty . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL vis_mut ty 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL UIDENT ATTRIBUTE WRITES 
##
## Ends in an error in state: 637.
##
## type_case -> attrs(uident_nq) . params [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(uident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 633, spurious reduction of production attrs(uident_nq) -> uident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL UIDENT BAR WRITES 
##
## Ends in an error in state: 635.
##
## separated_nonempty_list(BAR,type_case) -> type_case BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## type_case BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL UIDENT CORE_LIDENT WRITES 
##
## Ends in an error in state: 634.
##
## separated_nonempty_list(BAR,type_case) -> type_case . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## separated_nonempty_list(BAR,type_case) -> type_case . BAR separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## type_case 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 132, spurious reduction of production lident -> CORE_LIDENT 
## In state 89, spurious reduction of production lqualid -> lident 
## In state 88, spurious reduction of production ty_arg -> lqualid 
## In state 134, spurious reduction of production param -> ty_arg 
## In state 552, spurious reduction of production list(param) -> 
## In state 553, spurious reduction of production list(param) -> param list(param) 
## In state 558, spurious reduction of production params -> list(param) 
## In state 638, spurious reduction of production type_case -> attrs(uident_nq) params 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL UIDENT WRITES 
##
## Ends in an error in state: 611.
##
## uident -> UIDENT . [ DOT ]
## uident_nq -> UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
##
## The known suffix of the stack is as follows:
## UIDENT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE EQUAL WRITES 
##
## Ends in an error in state: 593.
##
## typedefn -> EQUAL . vis_mut bar_list1(type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## typedefn -> EQUAL . vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## typedefn -> EQUAL . vis_mut ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## typedefn -> EQUAL . LT RANGE int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## typedefn -> EQUAL . LT FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE INVARIANT LEFTBRC CORE_LIDENT RIGHTBRC ATTRIBUTE 
##
## Ends in an error in state: 650.
##
## type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) . type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_nq) list(ty_var) typedefn list(invariant) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 843, spurious reduction of production list(invariant) -> 
## In state 844, spurious reduction of production list(invariant) -> invariant list(invariant) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE INVARIANT LEFTBRC CORE_LIDENT RIGHTBRC WRITES 
##
## Ends in an error in state: 843.
##
## list(invariant) -> invariant . list(invariant) [ WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
##
## The known suffix of the stack is as follows:
## invariant 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE INVARIANT LEFTBRC UIDENT WITH 
##
## Ends in an error in state: 648.
##
## invariant -> INVARIANT LEFTBRC term . RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
##
## The known suffix of the stack is as follows:
## INVARIANT LEFTBRC term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE INVARIANT LEFTBRC WRITES 
##
## Ends in an error in state: 647.
##
## invariant -> INVARIANT LEFTBRC . term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
##
## The known suffix of the stack is as follows:
## INVARIANT LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE INVARIANT WRITES 
##
## Ends in an error in state: 646.
##
## invariant -> INVARIANT . LEFTBRC term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
##
## The known suffix of the stack is as follows:
## INVARIANT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE POSITION WHILE 
##
## Ends in an error in state: 61.
##
## list(attr) -> attr . list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS ]
##
## The known suffix of the stack is as follows:
## attr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE QUOTE_LIDENT ATTRIBUTE WRITES 
##
## Ends in an error in state: 587.
##
## list(ty_var) -> ty_var . list(ty_var) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## ty_var 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 61, spurious reduction of production list(attr) -> 
## In state 62, spurious reduction of production list(attr) -> attr list(attr) 
## In state 589, spurious reduction of production attrs(quote_lident) -> quote_lident list(attr) 
## In state 591, spurious reduction of production ty_var -> attrs(quote_lident) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE QUOTE_LIDENT WRITES 
##
## Ends in an error in state: 588.
##
## attrs(quote_lident) -> quote_lident . list(attr) [ WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
##
## The known suffix of the stack is as follows:
## quote_lident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE UNDERSCORE 
##
## Ends in an error in state: 586.
##
## type_decl -> attrs(lident_nq) . list(ty_var) typedefn list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## attrs(lident_nq) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 109, spurious reduction of production list(attr) -> 
## In state 110, spurious reduction of production attrs(lident_nq) -> lident_nq list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE WITH WRITES 
##
## Ends in an error in state: 584.
##
## separated_nonempty_list(WITH,type_decl) -> type_decl WITH . separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## type_decl WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE RANGE WRITES 
##
## Ends in an error in state: 109.
##
## attrs(lident_nq) -> lident_nq . list(attr) [ WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ]
##
## The known suffix of the stack is as follows:
## lident_nq 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: TYPE WRITES 
##
## Ends in an error in state: 581.
##
## pure_decl -> TYPE . with_list1(type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE EXPORT WRITES 
##
## Ends in an error in state: 561.
##
## use_clone -> USE EXPORT . tqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## USE EXPORT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE IMPORT CONTINUE 
##
## Ends in an error in state: 571.
##
## use_clone -> USE boption(IMPORT) . comma_list1(use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## USE boption(IMPORT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE STRING WRITES 
##
## Ends in an error in state: 567.
##
## any_qualid -> any_qualid . DOT sident [ DOT ]
## tqualid -> any_qualid . DOT uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## any_qualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE UIDENT AS WRITES 
##
## Ends in an error in state: 575.
##
## option(preceded(AS,uident)) -> AS . uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE UIDENT DOT UIDENT WRITES 
##
## Ends in an error in state: 569.
##
## ident -> uident . [ DOT ]
## tqualid -> any_qualid DOT uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## any_qualid DOT uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE UIDENT DOT WRITES 
##
## Ends in an error in state: 568.
##
## any_qualid -> any_qualid DOT . sident [ DOT ]
## tqualid -> any_qualid DOT . uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## any_qualid DOT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE UIDENT WITH 
##
## Ends in an error in state: 574.
##
## use_as -> tqualid . option(preceded(AS,uident)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## tqualid 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 563, spurious reduction of production tqualid -> uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE UIDENT WRITES 
##
## Ends in an error in state: 563.
##
## ident -> uident . [ DOT ]
## tqualid -> uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## uident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: USE WRITES 
##
## Ends in an error in state: 559.
##
## use_clone -> USE . EXPORT tqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## use_clone -> USE . boption(IMPORT) comma_list1(use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## USE 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL CORE_LIDENT END 
##
## Ends in an error in state: 1155.
##
## nonempty_list(module_decl) -> module_decl . [ EOF ]
## nonempty_list(module_decl) -> module_decl . nonempty_list(module_decl) [ EOF ]
##
## The known suffix of the stack is as follows:
## module_decl 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
## In state 66, spurious reduction of production list(param) -> 
## In state 558, spurious reduction of production params -> list(param) 
## In state 135, spurious reduction of production return_opt -> 
## In state 184, spurious reduction of production spec -> 
## In state 549, spurious reduction of production val_defn -> params return_opt spec 
## In state 133, spurious reduction of production mk_expr(val_defn) -> val_defn 
## In state 557, spurious reduction of production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) 
## In state 1144, spurious reduction of production module_decl -> prog_decl 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL GHOST COMMA 
##
## Ends in an error in state: 20.
##
## prog_decl -> VAL ghost . kind attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL ghost 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL PREDICATE CONTINUE 
##
## Ends in an error in state: 25.
##
## prog_decl -> VAL ghost kind . attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL ghost kind 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ALIAS LEFTBRC UIDENT VAL 
##
## Ends in an error in state: 538.
##
## alias -> term . WITH term [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ALIAS LEFTBRC UIDENT WITH CORE_LIDENT WITH 
##
## Ends in an error in state: 545.
##
## separated_nonempty_list(COMMA,alias) -> alias . [ RIGHTBRC ]
## separated_nonempty_list(COMMA,alias) -> alias . COMMA separated_nonempty_list(COMMA,alias) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## alias 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 540, spurious reduction of production alias -> term WITH term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ALIAS LEFTBRC UIDENT WITH WRITES 
##
## Ends in an error in state: 539.
##
## alias -> term WITH . term [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## term WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ALIAS LEFTBRC WRITES 
##
## Ends in an error in state: 537.
##
## single_spec -> ALIAS LEFTBRC . comma_list0(alias) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## ALIAS LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ALIAS WRITES 
##
## Ends in an error in state: 536.
##
## single_spec -> ALIAS . LEFTBRC comma_list0(alias) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## ALIAS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE COLON RANGE GT 
##
## Ends in an error in state: 184.
##
## val_defn -> params return_opt . spec [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## params return_opt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 85, spurious reduction of production ty_arg -> lqualid 
## In state 79, spurious reduction of production ty -> ty_arg 
## In state 181, spurious reduction of production return -> ty 
## In state 183, spurious reduction of production return_named -> return 
## In state 182, spurious reduction of production return_opt -> COLON return_named 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE COLON WRITES 
##
## Ends in an error in state: 136.
##
## return_opt -> COLON . return_named [ WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS ]
##
## The known suffix of the stack is as follows:
## COLON 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE DIVERGES UNDERSCORE 
##
## Ends in an error in state: 550.
##
## spec -> single_spec . spec [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## single_spec 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ENSURES LEFTBRC UIDENT WITH 
##
## Ends in an error in state: 533.
##
## single_spec -> ENSURES LEFTBRC ensures . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## ENSURES LEFTBRC ensures 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 532, spurious reduction of production ensures -> term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ENSURES LEFTBRC WRITES 
##
## Ends in an error in state: 531.
##
## single_spec -> ENSURES LEFTBRC . ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## ENSURES LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE ENSURES WRITES 
##
## Ends in an error in state: 530.
##
## single_spec -> ENSURES . LEFTBRC ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## ENSURES 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC BAR UIDENT WRITES 
##
## Ends in an error in state: 509.
##
## raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
## raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
## uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC BAR WRITES 
##
## Ends in an error in state: 508.
##
## bar_list1(raises) -> BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT ARROW CORE_LIDENT BAR WRITES 
##
## Ends in an error in state: 517.
##
## separated_nonempty_list(BAR,raises) -> raises BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## raises BAR 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT ARROW CORE_LIDENT WITH 
##
## Ends in an error in state: 516.
##
## separated_nonempty_list(BAR,raises) -> raises . [ RIGHTBRC ]
## separated_nonempty_list(BAR,raises) -> raises . BAR separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## raises 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 511, spurious reduction of production raises -> uqualid ARROW term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT ARROW WRITES 
##
## Ends in an error in state: 510.
##
## raises -> uqualid ARROW . term [ RIGHTBRC BAR ]
##
## The known suffix of the stack is as follows:
## uqualid ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT COMMA UIDENT WRITES 
##
## Ends in an error in state: 521.
##
## uqualid -> uqualid . DOT uident [ RIGHTBRC DOT COMMA ]
## xsymbol -> uqualid . [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT COMMA WRITES 
##
## Ends in an error in state: 520.
##
## separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA . separated_nonempty_list(COMMA,xsymbol) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## xsymbol COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT UNDERSCORE ARROW WRITES 
##
## Ends in an error in state: 513.
##
## raises -> uqualid pat_arg ARROW . term [ RIGHTBRC BAR ]
##
## The known suffix of the stack is as follows:
## uqualid pat_arg ARROW 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT UNDERSCORE WRITES 
##
## Ends in an error in state: 512.
##
## raises -> uqualid pat_arg . ARROW term [ RIGHTBRC BAR ]
##
## The known suffix of the stack is as follows:
## uqualid pat_arg 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC UIDENT WRITES 
##
## Ends in an error in state: 523.
##
## raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
## raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
## uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT COMMA ARROW ]
## xsymbol -> uqualid . [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## uqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES LEFTBRC WRITES 
##
## Ends in an error in state: 507.
##
## single_spec -> RAISES LEFTBRC . bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## single_spec -> RAISES LEFTBRC . comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## RAISES LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RAISES WRITES 
##
## Ends in an error in state: 506.
##
## single_spec -> RAISES . LEFTBRC bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## single_spec -> RAISES . LEFTBRC comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## RAISES 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE READS LEFTBRC RANGE COMMA WRITES 
##
## Ends in an error in state: 501.
##
## separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA . separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE READS LEFTBRC RANGE WRITES 
##
## Ends in an error in state: 500.
##
## separated_nonempty_list(COMMA,lqualid) -> lqualid . [ RIGHTBRC ]
## separated_nonempty_list(COMMA,lqualid) -> lqualid . COMMA separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE READS LEFTBRC WRITES 
##
## Ends in an error in state: 498.
##
## single_spec -> READS LEFTBRC . comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## READS LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE READS WRITES 
##
## Ends in an error in state: 497.
##
## single_spec -> READS . LEFTBRC comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## READS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE REQUIRES LEFTBRC UIDENT WITH 
##
## Ends in an error in state: 495.
##
## single_spec -> REQUIRES LEFTBRC term . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## REQUIRES LEFTBRC term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE REQUIRES LEFTBRC WRITES 
##
## Ends in an error in state: 494.
##
## single_spec -> REQUIRES LEFTBRC . term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## REQUIRES LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE REQUIRES WRITES 
##
## Ends in an error in state: 493.
##
## single_spec -> REQUIRES . LEFTBRC term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## REQUIRES 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RETURNS LEFTBRC UNDERSCORE ARROW CORE_LIDENT END 
##
## Ends in an error in state: 491.
##
## single_spec -> RETURNS LEFTBRC match_cases(term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## RETURNS LEFTBRC match_cases(term) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 339, spurious reduction of production ident_rich -> lident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 307, spurious reduction of production term -> single_term 
## In state 437, spurious reduction of production match_case(term) -> pattern ARROW term 
## In state 438, spurious reduction of production separated_nonempty_list(BAR,match_case(term)) -> match_case(term) 
## In state 441, spurious reduction of production bar_list1(match_case(term)) -> separated_nonempty_list(BAR,match_case(term)) 
## In state 444, spurious reduction of production match_cases(term) -> bar_list1(match_case(term)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RETURNS LEFTBRC WRITES 
##
## Ends in an error in state: 490.
##
## single_spec -> RETURNS LEFTBRC . match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## RETURNS LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE RETURNS WRITES 
##
## Ends in an error in state: 489.
##
## single_spec -> RETURNS . LEFTBRC match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## RETURNS 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE UNDERSCORE WITH 
##
## Ends in an error in state: 135.
##
## val_defn -> params . return_opt spec [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## params 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 552, spurious reduction of production list(param) -> 
## In state 553, spurious reduction of production list(param) -> param list(param) 
## In state 558, spurious reduction of production params -> list(param) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE VARIANT LEFTBRC UIDENT COMMA WRITES 
##
## Ends in an error in state: 480.
##
## separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA . separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## single_variant COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE VARIANT LEFTBRC UIDENT VAL 
##
## Ends in an error in state: 481.
##
## single_term_ -> single_term . AT uident [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . ARROW single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LRARROW single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OR single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BARBAR single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AND single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . AMPAMP single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . BY single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . SO single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP1 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . EQUAL single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LTGT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . LT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . GT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP2 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP3 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . OP4 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . MINUS single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_term_ -> single_term . cast [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## single_variant -> single_term . option(preceded(WITH,lqualid)) [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## single_term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE VARIANT LEFTBRC UIDENT WITH RANGE WRITES 
##
## Ends in an error in state: 479.
##
## separated_nonempty_list(COMMA,single_variant) -> single_variant . [ RIGHTBRC ]
## separated_nonempty_list(COMMA,single_variant) -> single_variant . COMMA separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## single_variant 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE VARIANT LEFTBRC UIDENT WITH WRITES 
##
## Ends in an error in state: 482.
##
## option(preceded(WITH,lqualid)) -> WITH . lqualid [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## WITH 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE VARIANT LEFTBRC WRITES 
##
## Ends in an error in state: 478.
##
## variant -> VARIANT LEFTBRC . comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## VARIANT LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE VARIANT WRITES 
##
## Ends in an error in state: 477.
##
## variant -> VARIANT . LEFTBRC comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## VARIANT 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE WITH 
##
## Ends in an error in state: 66.
##
## prog_decl -> VAL ghost kind attrs(lident_rich) . mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL ghost kind attrs(lident_rich) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 57, spurious reduction of production list(attr) -> 
## In state 60, spurious reduction of production attrs(lident_rich) -> lident_rich list(attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE WRITES LEFTBRC UIDENT EOF 
##
## Ends in an error in state: 475.
##
## single_spec -> WRITES LEFTBRC comma_list0(single_term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## WRITES LEFTBRC comma_list0(single_term) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 287, spurious reduction of production ident_rich -> uident 
## In state 340, spurious reduction of production qualid -> ident_rich 
## In state 330, spurious reduction of production term_arg_ -> qualid 
## In state 300, spurious reduction of production single_term_ -> term_arg_ 
## In state 306, spurious reduction of production mk_term(single_term_) -> single_term_ 
## In state 337, spurious reduction of production single_term -> mk_term(single_term_) 
## In state 327, spurious reduction of production separated_nonempty_list(COMMA,single_term) -> single_term 
## In state 473, spurious reduction of production loption(separated_nonempty_list(COMMA,single_term)) -> separated_nonempty_list(COMMA,single_term) 
## In state 474, spurious reduction of production comma_list0(single_term) -> loption(separated_nonempty_list(COMMA,single_term)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE WRITES LEFTBRC WRITES 
##
## Ends in an error in state: 186.
##
## single_spec -> WRITES LEFTBRC . comma_list0(single_term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## WRITES LEFTBRC 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL RANGE WRITES WRITES 
##
## Ends in an error in state: 185.
##
## single_spec -> WRITES . LEFTBRC comma_list0(single_term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
##
## The known suffix of the stack is as follows:
## WRITES 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: VAL WRITES 
##
## Ends in an error in state: 18.
##
## prog_decl -> VAL . ghost kind attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mlw_file: WRITES 
##
## Ends in an error in state: 17.
##
## mlw_file' -> . mlw_file [ # ]
##
## The known suffix of the stack is as follows:
## 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

ident_comma_list_eof: UIDENT COMMA WRITES 
##
## Ends in an error in state: 13.
##
## separated_nonempty_list(COMMA,ident) -> ident COMMA . separated_nonempty_list(COMMA,ident) [ EOF ]
##
## The known suffix of the stack is as follows:
## ident COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

ident_comma_list_eof: UIDENT WRITES 
##
## Ends in an error in state: 12.
##
## separated_nonempty_list(COMMA,ident) -> ident . [ EOF ]
## separated_nonempty_list(COMMA,ident) -> ident . COMMA separated_nonempty_list(COMMA,ident) [ EOF ]
##
## The known suffix of the stack is as follows:
## ident 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

ident_comma_list_eof: WRITES 
##
## Ends in an error in state: 0.
##
## ident_comma_list_eof' -> . ident_comma_list_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

<YOUR SYNTAX ERROR MESSAGE HERE>
