(* autogenerated from convert.ml and sql_access.ml *)
open Printer_utils
let print_header e =
  e.p "(*";
  e.p " * Copyright (c) 2009 Anil Madhavapeddy <anil@recoil.org>";
  e.p " *";
  e.p " * Permission to use, copy, modify, and distribute this software for any";
  e.p " * purpose with or without fee is hereby granted, provided that the above";
  e.p " * copyright notice and this permission notice appear in all copies.";
  e.p " *";
  e.p " * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES";
  e.p " * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF";
  e.p " * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR";
  e.p " * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES";
  e.p " * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN";
  e.p " * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF";
  e.p " * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.";
  e.p " *)";
  e.p "";
  e.p "open Sqlite3";
  e.p "open Printf";
  e.p "";
  e.p "type transaction_mode = [";
  e.p "    |`Deferred";
  e.p "    |`Immediate";
  e.p "    |`Exclusive";
  e.p "]";
  e.p "";
  e.p "type state = {";
  e.p "    db : db;";
  e.p "    mutable in_transaction: int;";
  e.p "    busyfn: db -> unit;";
  e.p "    mode: transaction_mode;";
  e.p "}";
  e.p "";
  e.p "let default_busyfn (db:Sqlite3.db) =";
  e.p "    print_endline \"WARNING: busy\";";
  e.p "    Thread.delay (Random.float 1.)";
  e.p "";
  e.p "let raise_sql_error x =";
  e.p "    raise (Sqlite3.Error (Rc.to_string x))";
  e.p "";
  e.p "let try_finally fn finalfn =";
  e.p "    try";
  e.p "      let r = fn () in";
  e.p "      finalfn ();";
  e.p "      r";
  e.p "    with e -> begin";
  e.p "      print_endline (sprintf \"WARNING: exception: %s\" (Printexc.to_string e));";
  e.p "      finalfn ();";
  e.p "      raise e";
  e.p "    end";
  e.p "";
  e.p "(* retry until a non-BUSY error code is returned *)";
  e.p "let rec db_busy_retry db fn =";
  e.p "    match fn () with";
  e.p "    |Rc.BUSY -> ";
  e.p "       db.busyfn db.db;";
  e.p "       db_busy_retry db fn;";
  e.p "    |x -> x";
  e.p "";
  e.p "(* make sure an OK is returned from the database *)";
  e.p "let db_must_ok db fn =";
  e.p "    match db_busy_retry db fn with";
  e.p "    |Rc.OK -> ()";
  e.p "    |x -> raise_sql_error x";
  e.p "";
  e.p "(* make sure a DONE is returned from the database *)";
  e.p "let db_must_done db fn = ";
  e.p "   match db_busy_retry db fn with";
  e.p "   |Rc.DONE -> ()";
  e.p "   |x -> raise_sql_error x";
  e.p "";
  e.p "(* request a transaction *)";
  e.p "let transaction db fn =";
  e.p "    let m = match db.mode with";
  e.p "    |`Deferred -> \"DEFERRED\" |`Immediate -> \"IMMEDIATE\" |`Exclusive -> \"EXCLUSIVE\" in";
  e.p "    try_finally (fun () ->";
  e.p "        if db.in_transaction = 0 then (";
  e.p "           db_must_ok db (fun () -> exec db.db (sprintf \"BEGIN %s TRANSACTION\" m));";
  e.p "        );";
  e.p "        db.in_transaction <- db.in_transaction + 1;";
  e.p "        fn ();";
  e.p "    ) (fun () ->";
  e.p "        if db.in_transaction = 1 then (";
  e.p "           db_must_ok db (fun () -> exec db.db \"END TRANSACTION\");";
  e.p "        );";
  e.p "        db.in_transaction <- db.in_transaction - 1";
  e.p "    )";
  e.p "";
  e.p "(* iterate over a result set *)";
  e.p "let step_fold db stmt iterfn =";
  e.p "    let stepfn () = Sqlite3.step stmt in";
  e.p "    let rec fn a = match db_busy_retry db stepfn with";
  e.p "    |Sqlite3.Rc.ROW -> fn (iterfn stmt :: a)";
  e.p "    |Sqlite3.Rc.DONE -> a";
  e.p "    |x -> raise_sql_error x";
  e.p "    in";
  e.p "    fn []";
  ()