
(* test file *)

theory A
  type t
  logic c:t
end

theory B
  uses A
  open A
  logic d : t
  logic p : t -> prop
end

theory C
  uses B
  uses T : B.A 
  logic e : T.t
  axiom test : B.p(T.c)
end

theory Int
  type int
end

theory List

  type 'a list

  logic nil  : 'a list

  logic cons : 'a, 'a list -> 'a list

  logic is_nil : 'a list -> prop

  uses Int 
  open Int
  
  logic length : 'a list -> int

end

theory Eq 

  logic eq : 'a, 'a -> prop 

  (* This part is just a definition of the equality *)

  (* This theory define eq but of course these axioms should not be send
   to provers *)
 
  axiom refl : forall x:'a. eq(x,x) 
  axiom sym  : forall x,y:'a. eq(x,y) -> eq(y,x)
  axiom trans : forall x,y,z:'a. eq(x,y) -> eq(y,z) -> eq(x,z)
  (* This one can't be written in first order logic. *)
  type t
  type u
  logic f : t -> u
  axiom congru : forall x,y:t. eq(x,y) -> eq(f(x),f(y))

end

theory Set

  type elt

  type t 

  logic in_ : elt , t -> prop

  logic empty : t

  axiom empty_def1 : forall x:elt. not in_(x, empty)

  logic add : elt, t -> t

  uses Eq

  axiom add_def1 : forall x,y:elt. forall s:t.
                   in_(x, add(y, s)) <-> (Eq.eq(x, y) or in_(x, s))

end

theory Set_poly

  type 'a t 

  logic in_ : 'a , 'a t -> prop

  logic empty : 'a t

  axiom empty_def1 : forall x:'a. not in_(x, empty)

  logic add : 'a, 'a t -> 'a t

  uses Eq

  axiom add_def1 : forall x,y:'a. forall s:'a t.
                   in_(x, add(y, s)) <-> (Eq.eq(x, y) or in_(x, s))

end

theory Test

  uses Eq, L : List
  open L
  axiom a : forall x : 'a. not Eq.eq(nil, cons(nil, nil))

end


theory Array

  type ('a,'b) t

  logic select : ('a,'b) t,'a -> 'b
  logic store : ('a,'b) t,'a,'b -> ('a,'b) t
  
  uses Eq
  axiom select_eq : forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
        Eq.eq(a1,a2) -> Eq.eq(select(store(m,a1,b),a2),b)

  axiom select_eq : forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
        not Eq.eq(a1,a2) -> Eq.eq(select(store(m,a1,b),a2),select(m,a2))

  logic const : 'b -> ('a,'b) t
  axiom const : forall b:'b. forall a:'a. Eq.eq(select(const(b),a),b)

end

theory Bool
  type t = | True | False
end

theory Set_array
  uses Array, Bool
  (*type 'a t = ('a,bool_.t) Array.t*)

  uses Eq
  logic empty : ('a,Bool.t) Array.t
  axiom empty : Eq.eq(empty,Array.const(Bool.False))


  logic in_ : 'a, ('a,Bool.t) Array.t -> prop
  axiom in_ : forall s:'a t. forall e:'a. 
        in_(e,s) <-> Eq.eq(select(x,y),Bool.True)


  logic add : 'a, ('a,Bool.t) Array.t -> ('a,Bool.t) Array.t (* add(x,s) = store(x,s,bool.True) *)
  axiom add : forall x:'a. forall s: ('a,Bool.t) Array.t. Eq.eq(add(x,s),store(s,x,Bool.True))

end