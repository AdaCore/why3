
(* test file *)

theory ThA
  type test
  logic test (test : test) : test
  goal Test : forall test : test . forall test : test . test(test) <> test
end

theory Test
  use import prelude.Int
  logic id(x: int) : int = x
  logic id2(x: int) : int = id(x)
  logic succ(x:int) : int = id(x+1)
  logic even(x: int) = 2*(x/2) = x
  clone ThA with type test = int, logic test = (-_)
  goal G : forall x:int. 1 = succ(id2(zero))
  goal G2 : forall x:int. 0 = 1
end

theory Test_simplify_array
       use import prelude.Array
       goal G : forall x,y:int. forall m: (int,int) t. 
       select(store(m,y,x),y) = x
end 

theory Test_conjunction
       use import prelude.Int
       goal G : forall x:int. x*x=4 -> ((x*x*x=8 or x*x*x=-8) and x*x*2 = 8)
       goal G2 : forall x:int. (x+x=4 or x*x=4) -> ((x*x*x=8 or x*x*x=-8) and x*x*2 = 8)
end

theory Split_conj
       logic p(x:int)
       (*goal G : forall x,y,z:int. ((p(x) -> p(y)) and ((not p(x)) -> p(z))) -> ((p(x) and p(y)) or ((not p(x)) and p(z)))*)
       (*goal G : forall x,y,z:int. (if p(x) then p(y) else p(z)) <-> ((p(x) and p(y)) or ((not p(x)) and p(z)))*)
       (*goal G : forall x,y,z:int. (if p(x) then p(y) else p(z)) -> (if p(x) then p(y) else p(z))*)
       goal G : forall x,y,z:int. (p(x) <-> p(z)) -> (p(x) <-> p(z))
       (*goal G : forall x,y,z:int. (p(z) <-> p(x)) -> (((not p(z)) and (not p(x))  or  ((p(z)) and (p(x))))) *)
       (*goal G : forall x,y,z:int. (p(x) or p(y)) -> p(z)*)
end


(*
Local Variables: 
compile-command: "make -C .. test"
End: 
*)

