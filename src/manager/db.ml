(* autogenerated by sql_orm *)
module Sql_access = struct
  (*
   * Copyright (c) 2009 Anil Madhavapeddy <anil@recoil.org>
   *
   * Permission to use, copy, modify, and distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *)
  
  open Sqlite3
  open Printf
  
  type transaction_mode = [
      |`Deferred
      |`Immediate
      |`Exclusive
  ]
  
  type state = {
      db : db;
      mutable in_transaction: int;
      busyfn: db -> unit;
      mode: transaction_mode;
  }
  
  let default_busyfn (db:Sqlite3.db) =
      print_endline "WARNING: busy";
      Thread.delay (Random.float 1.)
  
  let raise_sql_error x =
      raise (Sqlite3.Error (Rc.to_string x))
  
  let try_finally fn finalfn =
      try
        let r = fn () in
        finalfn ();
        r
      with e -> begin
        print_endline (sprintf "WARNING: exception: %s" (Printexc.to_string e));
        finalfn ();
        raise e
      end
  
  (* retry until a non-BUSY error code is returned *)
  let rec db_busy_retry db fn =
      match fn () with
      |Rc.BUSY -> 
         db.busyfn db.db;
         db_busy_retry db fn;
      |x -> x
  
  (* make sure an OK is returned from the database *)
  let db_must_ok db fn =
      match db_busy_retry db fn with
      |Rc.OK -> ()
      |x -> raise_sql_error x
  
  (* make sure a DONE is returned from the database *)
  let db_must_done db fn = 
     match db_busy_retry db fn with
     |Rc.DONE -> ()
     |x -> raise_sql_error x
  
  (* request a transaction *)
  let transaction db fn =
      let m = match db.mode with
      |`Deferred -> "DEFERRED" |`Immediate -> "IMMEDIATE" |`Exclusive -> "EXCLUSIVE" in
      try_finally (fun () ->
          if db.in_transaction = 0 then (
             db_must_ok db (fun () -> exec db.db (sprintf "BEGIN %s TRANSACTION" m));
          );
          db.in_transaction <- db.in_transaction + 1;
          fn ();
      ) (fun () ->
          if db.in_transaction = 1 then (
             db_must_ok db (fun () -> exec db.db "END TRANSACTION");
          );
          db.in_transaction <- db.in_transaction - 1
      )
  
  (* iterate over a result set *)
  let step_fold db stmt iterfn =
      let stepfn () = Sqlite3.step stmt in
      let rec fn a = match db_busy_retry db stepfn with
      |Sqlite3.Rc.ROW -> fn (iterfn stmt :: a)
      |Sqlite3.Rc.DONE -> a
      |x -> raise_sql_error x
      in
      fn []
end


open Sql_access
module Challenge = struct
  type t = <
    id : int64 option;
    set_id : int64 option -> unit;
    log : int64;
    set_log : int64 -> unit;
    input : string;
    set_input : string -> unit;
    answer : string option;
    set_answer : string option -> unit;
    time : float;
    set_time : float -> unit;
    correct : int64;
    set_correct : int64 -> unit;
    save: int64; delete: unit
  >

  let init db =
    let sql = "create table if not exists challenge (id integer primary key autoincrement,log integer,input text,answer text,time real,correct integer);" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    ()

  (* object definition *)
  let t ?(id=None) ~log ~input ?(answer=None) ~time ~correct db : t = object
    (* get functions *)
    val mutable _id = id
    method id : int64 option = _id
    val mutable _log = log
    method log : int64 = _log
    val mutable _input = input
    method input : string = _input
    val mutable _answer = answer
    method answer : string option = _answer
    val mutable _time = time
    method time : float = _time
    val mutable _correct = correct
    method correct : int64 = _correct

    (* set functions *)
    method set_id v =
      _id <- v
    method set_log v =
      _log <- v
    method set_input v =
      _input <- v
    method set_answer v =
      _answer <- v
    method set_time v =
      _time <- v
    method set_correct v =
      _correct <- v

    (* admin functions *)
    method delete =
      match _id with
      |None -> ()
      |Some id ->
        let sql = "DELETE FROM challenge WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT id));
        ignore(step_fold db stmt (fun _ -> ()));
        _id <- None

    method save = transaction db (fun () ->
      (* insert any foreign-one fields into their table and get id *)
      let _curobj_id = match _id with
      |None -> (* insert new record *)
        let sql = "INSERT INTO challenge VALUES(NULL,?,?,?,?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _log in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _input in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (match _answer with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _time in Sqlite3.Data.FLOAT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 5 (let v = _correct in Sqlite3.Data.INT v));
        db_must_done db (fun () -> Sqlite3.step stmt);
        let __id = Sqlite3.last_insert_rowid db.db in
        _id <- Some __id;
        __id
      |Some id -> (* update *)
        let sql = "UPDATE challenge SET log=?,input=?,answer=?,time=?,correct=? WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _log in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _input in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (match _answer with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _time in Sqlite3.Data.FLOAT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 5 (let v = _correct in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 6 (Sqlite3.Data.INT id));
        db_must_done db (fun () -> Sqlite3.step stmt);
        id
      in
      _curobj_id
    )
  end

  (* General get function for any of the columns *)
  let get ?(id=None) ?(log=None) ?(input=None) ?(answer=None) ?(time=None) ?(correct=None) ?(custom_where=("",[])) db =
    (* assemble the SQL query string *)
    let q = "" in
    let _first = ref true in
    let f () = match !_first with |true -> _first := false; " WHERE " |false -> " AND " in
    let q = match id with |None -> q |Some b -> q ^ (f()) ^ "challenge.id=?" in
    let q = match log with |None -> q |Some b -> q ^ (f()) ^ "challenge.log=?" in
    let q = match input with |None -> q |Some b -> q ^ (f()) ^ "challenge.input=?" in
    let q = match answer with |None -> q |Some b -> q ^ (f()) ^ "challenge.answer=?" in
    let q = match time with |None -> q |Some b -> q ^ (f()) ^ "challenge.time=?" in
    let q = match correct with |None -> q |Some b -> q ^ (f()) ^ "challenge.correct=?" in
    let q = match custom_where with |"",_ -> q |w,_ -> q ^ (f()) ^ "(" ^ w ^ ")" in
    let sql="SELECT challenge.id, challenge.log, challenge.input, challenge.answer, challenge.time, challenge.correct FROM challenge " ^ q in
    let stmt=Sqlite3.prepare db.db sql in
    (* bind the position variables to the statement *)
    let bindpos = ref 1 in
    ignore(match id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match log with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match input with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match answer with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match time with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.FLOAT v));
      incr bindpos
    );
    ignore(match correct with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match custom_where with |_,[] -> () |_,eb ->
      List.iter (fun b ->
        db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos b);
        incr bindpos
      ) eb);
    (* convert statement into an ocaml object *)
    let of_stmt stmt =
    t
      (* native fields *)
      ~id:(
      (match Sqlite3.column stmt 0 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: challenge id")))
      )
      ~log:(
      (match Sqlite3.column stmt 1 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: challenge log"))
      )
      ~input:(
      (match Sqlite3.column stmt 2 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~answer:(
      (match Sqlite3.column stmt 3 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (Sqlite3.Data.to_string x))
      )
      ~time:(
      (match Sqlite3.column stmt 4 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.FLOAT i -> i|x -> (try float_of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: challenge time"))
      )
      ~correct:(
      (match Sqlite3.column stmt 5 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: challenge correct"))
      )
      (* foreign fields *)
    db
    in 
    (* execute the SQL query *)
    step_fold db stmt of_stmt

end

module Log_entry = struct
  type t = <
    id : int64 option;
    set_id : int64 option -> unit;
    attempt : int64;
    set_attempt : int64 -> unit;
    successful : int64;
    set_successful : int64 -> unit;
    starting_date : float;
    set_starting_date : float -> unit;
    end_date : float;
    set_end_date : float -> unit;
    challenges : Challenge.t list;
    set_challenges : Challenge.t list -> unit;
    save: int64; delete: unit
  >

  let init db =
    let sql = "create table if not exists log_entry (id integer primary key autoincrement,attempt integer,successful integer,starting_date real,end_date real);" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "create table if not exists map_challenges_log_entry_challenge (log_entry_id integer, challenge_id integer, primary key(log_entry_id, challenge_id));" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    ()

  (* object definition *)
  let t ?(id=None) ~attempt ~successful ~starting_date ~end_date ~challenges db : t = object
    (* get functions *)
    val mutable _id = id
    method id : int64 option = _id
    val mutable _attempt = attempt
    method attempt : int64 = _attempt
    val mutable _successful = successful
    method successful : int64 = _successful
    val mutable _starting_date = starting_date
    method starting_date : float = _starting_date
    val mutable _end_date = end_date
    method end_date : float = _end_date
    val mutable _challenges = challenges
    method challenges : Challenge.t list = _challenges

    (* set functions *)
    method set_id v =
      _id <- v
    method set_attempt v =
      _attempt <- v
    method set_successful v =
      _successful <- v
    method set_starting_date v =
      _starting_date <- v
    method set_end_date v =
      _end_date <- v
    method set_challenges v =
      _challenges <- v

    (* admin functions *)
    method delete =
      match _id with
      |None -> ()
      |Some id ->
        let sql = "DELETE FROM log_entry WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT id));
        ignore(step_fold db stmt (fun _ -> ()));
        _id <- None

    method save = transaction db (fun () ->
      (* insert any foreign-one fields into their table and get id *)
      let _curobj_id = match _id with
      |None -> (* insert new record *)
        let sql = "INSERT INTO log_entry VALUES(NULL,?,?,?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _attempt in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _successful in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _starting_date in Sqlite3.Data.FLOAT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _end_date in Sqlite3.Data.FLOAT v));
        db_must_done db (fun () -> Sqlite3.step stmt);
        let __id = Sqlite3.last_insert_rowid db.db in
        _id <- Some __id;
        __id
      |Some id -> (* update *)
        let sql = "UPDATE log_entry SET attempt=?,successful=?,starting_date=?,end_date=? WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _attempt in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _successful in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _starting_date in Sqlite3.Data.FLOAT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _end_date in Sqlite3.Data.FLOAT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 5 (Sqlite3.Data.INT id));
        db_must_done db (fun () -> Sqlite3.step stmt);
        id
      in
      List.iter (fun f ->
        let _refobj_id = f#save in
        let sql = "INSERT OR IGNORE INTO map_challenges_log_entry_challenge VALUES(?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (Sqlite3.Data.INT _refobj_id));
        ignore(step_fold db stmt (fun _ -> ()));
      ) _challenges;
      let ids = String.concat "," (List.map (fun x -> match x#id with |None -> assert false |Some x -> Int64.to_string x) _challenges) in
      let sql = "DELETE FROM map_challenges_log_entry_challenge WHERE log_entry_id=? AND (challenge_id NOT IN (" ^ ids ^ "))" in
      let stmt = Sqlite3.prepare db.db sql in
      db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
      ignore(step_fold db stmt (fun _ -> ()));
      _curobj_id
    )
  end

  (* General get function for any of the columns *)
  let get ?(id=None) ?(attempt=None) ?(successful=None) ?(starting_date=None) ?(end_date=None) ?(custom_where=("",[])) db =
    (* assemble the SQL query string *)
    let q = "" in
    let _first = ref true in
    let f () = match !_first with |true -> _first := false; " WHERE " |false -> " AND " in
    let q = match id with |None -> q |Some b -> q ^ (f()) ^ "log_entry.id=?" in
    let q = match attempt with |None -> q |Some b -> q ^ (f()) ^ "log_entry.attempt=?" in
    let q = match successful with |None -> q |Some b -> q ^ (f()) ^ "log_entry.successful=?" in
    let q = match starting_date with |None -> q |Some b -> q ^ (f()) ^ "log_entry.starting_date=?" in
    let q = match end_date with |None -> q |Some b -> q ^ (f()) ^ "log_entry.end_date=?" in
    let q = match custom_where with |"",_ -> q |w,_ -> q ^ (f()) ^ "(" ^ w ^ ")" in
    let sql="SELECT log_entry.id, log_entry.attempt, log_entry.successful, log_entry.starting_date, log_entry.end_date FROM log_entry " ^ q in
    let stmt=Sqlite3.prepare db.db sql in
    (* bind the position variables to the statement *)
    let bindpos = ref 1 in
    ignore(match id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match attempt with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match successful with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match starting_date with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.FLOAT v));
      incr bindpos
    );
    ignore(match end_date with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.FLOAT v));
      incr bindpos
    );
    ignore(match custom_where with |_,[] -> () |_,eb ->
      List.iter (fun b ->
        db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos b);
        incr bindpos
      ) eb);
    (* convert statement into an ocaml object *)
    let of_stmt stmt =
    t
      (* native fields *)
      ~id:(
      (match Sqlite3.column stmt 0 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: log_entry id")))
      )
      ~attempt:(
      (match Sqlite3.column stmt 1 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: log_entry attempt"))
      )
      ~successful:(
      (match Sqlite3.column stmt 2 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: log_entry successful"))
      )
      ~starting_date:(
      (match Sqlite3.column stmt 3 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.FLOAT i -> i|x -> (try float_of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: log_entry starting_date"))
      )
      ~end_date:(
      (match Sqlite3.column stmt 4 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.FLOAT i -> i|x -> (try float_of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: log_entry end_date"))
      )
      (* foreign fields *)
      ~challenges:(
        (* foreign many-many mapping field *)
        let sql' = "select challenge_id from map_challenges_log_entry_challenge where log_entry_id=?" in
        let stmt' = Sqlite3.prepare db.db sql' in
        let log_entry__id = Sqlite3.column stmt 0 in
        db_must_ok db (fun () -> Sqlite3.bind stmt' 1 log_entry__id);
        List.flatten (step_fold db stmt' (fun s ->
          let i = match Sqlite3.column s 0 with |Sqlite3.Data.INT i -> i |_ -> assert false in
          Challenge.get ~id:(Some i) db)
        ))
    db
    in 
    (* execute the SQL query *)
    step_fold db stmt of_stmt

end

module Attempts = struct
  type t = <
    id : int64 option;
    set_id : int64 option -> unit;
    solution : int64;
    set_solution : int64 -> unit;
    log_entries : Log_entry.t list;
    set_log_entries : Log_entry.t list -> unit;
    save: int64; delete: unit
  >

  let init db =
    let sql = "create table if not exists attempts (id integer primary key autoincrement,solution integer);" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "create table if not exists map_log_entries_attempts_log_entry (attempts_id integer, log_entry_id integer, primary key(attempts_id, log_entry_id));" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    ()

  (* object definition *)
  let t ?(id=None) ~solution ~log_entries db : t = object
    (* get functions *)
    val mutable _id = id
    method id : int64 option = _id
    val mutable _solution = solution
    method solution : int64 = _solution
    val mutable _log_entries = log_entries
    method log_entries : Log_entry.t list = _log_entries

    (* set functions *)
    method set_id v =
      _id <- v
    method set_solution v =
      _solution <- v
    method set_log_entries v =
      _log_entries <- v

    (* admin functions *)
    method delete =
      match _id with
      |None -> ()
      |Some id ->
        let sql = "DELETE FROM attempts WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT id));
        ignore(step_fold db stmt (fun _ -> ()));
        _id <- None

    method save = transaction db (fun () ->
      (* insert any foreign-one fields into their table and get id *)
      let _curobj_id = match _id with
      |None -> (* insert new record *)
        let sql = "INSERT INTO attempts VALUES(NULL,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _solution in Sqlite3.Data.INT v));
        db_must_done db (fun () -> Sqlite3.step stmt);
        let __id = Sqlite3.last_insert_rowid db.db in
        _id <- Some __id;
        __id
      |Some id -> (* update *)
        let sql = "UPDATE attempts SET solution=? WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _solution in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (Sqlite3.Data.INT id));
        db_must_done db (fun () -> Sqlite3.step stmt);
        id
      in
      List.iter (fun f ->
        let _refobj_id = f#save in
        let sql = "INSERT OR IGNORE INTO map_log_entries_attempts_log_entry VALUES(?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (Sqlite3.Data.INT _refobj_id));
        ignore(step_fold db stmt (fun _ -> ()));
      ) _log_entries;
      let ids = String.concat "," (List.map (fun x -> match x#id with |None -> assert false |Some x -> Int64.to_string x) _log_entries) in
      let sql = "DELETE FROM map_log_entries_attempts_log_entry WHERE attempts_id=? AND (log_entry_id NOT IN (" ^ ids ^ "))" in
      let stmt = Sqlite3.prepare db.db sql in
      db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
      ignore(step_fold db stmt (fun _ -> ()));
      _curobj_id
    )
  end

  (* General get function for any of the columns *)
  let get ?(id=None) ?(solution=None) ?(custom_where=("",[])) db =
    (* assemble the SQL query string *)
    let q = "" in
    let _first = ref true in
    let f () = match !_first with |true -> _first := false; " WHERE " |false -> " AND " in
    let q = match id with |None -> q |Some b -> q ^ (f()) ^ "attempts.id=?" in
    let q = match solution with |None -> q |Some b -> q ^ (f()) ^ "attempts.solution=?" in
    let q = match custom_where with |"",_ -> q |w,_ -> q ^ (f()) ^ "(" ^ w ^ ")" in
    let sql="SELECT attempts.id, attempts.solution FROM attempts " ^ q in
    let stmt=Sqlite3.prepare db.db sql in
    (* bind the position variables to the statement *)
    let bindpos = ref 1 in
    ignore(match id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match solution with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match custom_where with |_,[] -> () |_,eb ->
      List.iter (fun b ->
        db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos b);
        incr bindpos
      ) eb);
    (* convert statement into an ocaml object *)
    let of_stmt stmt =
    t
      (* native fields *)
      ~id:(
      (match Sqlite3.column stmt 0 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: attempts id")))
      )
      ~solution:(
      (match Sqlite3.column stmt 1 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: attempts solution"))
      )
      (* foreign fields *)
      ~log_entries:(
        (* foreign many-many mapping field *)
        let sql' = "select log_entry_id from map_log_entries_attempts_log_entry where attempts_id=?" in
        let stmt' = Sqlite3.prepare db.db sql' in
        let attempts__id = Sqlite3.column stmt 0 in
        db_must_ok db (fun () -> Sqlite3.bind stmt' 1 attempts__id);
        List.flatten (step_fold db stmt' (fun s ->
          let i = match Sqlite3.column s 0 with |Sqlite3.Data.INT i -> i |_ -> assert false in
          Log_entry.get ~id:(Some i) db)
        ))
    db
    in 
    (* execute the SQL query *)
    step_fold db stmt of_stmt

end

module Solution = struct
  type t = <
    id : int64 option;
    set_id : int64 option -> unit;
    user : string;
    set_user : string -> unit;
    problem_id : int64;
    set_problem_id : int64 -> unit;
    solved : int64;
    set_solved : int64 -> unit;
    attempts : Attempts.t list;
    set_attempts : Attempts.t list -> unit;
    save: int64; delete: unit
  >

  let init db =
    let sql = "create table if not exists solution (id integer primary key autoincrement,user text,problem_id integer,solved integer);" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "create table if not exists map_attempts_solution_attempts (solution_id integer, attempts_id integer, primary key(solution_id, attempts_id));" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    ()

  (* object definition *)
  let t ?(id=None) ~user ~problem_id ~solved ~attempts db : t = object
    (* get functions *)
    val mutable _id = id
    method id : int64 option = _id
    val mutable _user = user
    method user : string = _user
    val mutable _problem_id = problem_id
    method problem_id : int64 = _problem_id
    val mutable _solved = solved
    method solved : int64 = _solved
    val mutable _attempts = attempts
    method attempts : Attempts.t list = _attempts

    (* set functions *)
    method set_id v =
      _id <- v
    method set_user v =
      _user <- v
    method set_problem_id v =
      _problem_id <- v
    method set_solved v =
      _solved <- v
    method set_attempts v =
      _attempts <- v

    (* admin functions *)
    method delete =
      match _id with
      |None -> ()
      |Some id ->
        let sql = "DELETE FROM solution WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT id));
        ignore(step_fold db stmt (fun _ -> ()));
        _id <- None

    method save = transaction db (fun () ->
      (* insert any foreign-one fields into their table and get id *)
      let _curobj_id = match _id with
      |None -> (* insert new record *)
        let sql = "INSERT INTO solution VALUES(NULL,?,?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _user in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _problem_id in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _solved in Sqlite3.Data.INT v));
        db_must_done db (fun () -> Sqlite3.step stmt);
        let __id = Sqlite3.last_insert_rowid db.db in
        _id <- Some __id;
        __id
      |Some id -> (* update *)
        let sql = "UPDATE solution SET user=?,problem_id=?,solved=? WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _user in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _problem_id in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _solved in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (Sqlite3.Data.INT id));
        db_must_done db (fun () -> Sqlite3.step stmt);
        id
      in
      List.iter (fun f ->
        let _refobj_id = f#save in
        let sql = "INSERT OR IGNORE INTO map_attempts_solution_attempts VALUES(?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (Sqlite3.Data.INT _refobj_id));
        ignore(step_fold db stmt (fun _ -> ()));
      ) _attempts;
      let ids = String.concat "," (List.map (fun x -> match x#id with |None -> assert false |Some x -> Int64.to_string x) _attempts) in
      let sql = "DELETE FROM map_attempts_solution_attempts WHERE solution_id=? AND (attempts_id NOT IN (" ^ ids ^ "))" in
      let stmt = Sqlite3.prepare db.db sql in
      db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
      ignore(step_fold db stmt (fun _ -> ()));
      _curobj_id
    )
  end

  (* General get function for any of the columns *)
  let get ?(id=None) ?(user=None) ?(problem_id=None) ?(solved=None) ?(custom_where=("",[])) db =
    (* assemble the SQL query string *)
    let q = "" in
    let _first = ref true in
    let f () = match !_first with |true -> _first := false; " WHERE " |false -> " AND " in
    let q = match id with |None -> q |Some b -> q ^ (f()) ^ "solution.id=?" in
    let q = match user with |None -> q |Some b -> q ^ (f()) ^ "solution.user=?" in
    let q = match problem_id with |None -> q |Some b -> q ^ (f()) ^ "solution.problem_id=?" in
    let q = match solved with |None -> q |Some b -> q ^ (f()) ^ "solution.solved=?" in
    let q = match custom_where with |"",_ -> q |w,_ -> q ^ (f()) ^ "(" ^ w ^ ")" in
    let sql="SELECT solution.id, solution.user, solution.problem_id, solution.solved FROM solution " ^ q in
    let stmt=Sqlite3.prepare db.db sql in
    (* bind the position variables to the statement *)
    let bindpos = ref 1 in
    ignore(match id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match user with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match problem_id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match solved with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match custom_where with |_,[] -> () |_,eb ->
      List.iter (fun b ->
        db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos b);
        incr bindpos
      ) eb);
    (* convert statement into an ocaml object *)
    let of_stmt stmt =
    t
      (* native fields *)
      ~id:(
      (match Sqlite3.column stmt 0 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: solution id")))
      )
      ~user:(
      (match Sqlite3.column stmt 1 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~problem_id:(
      (match Sqlite3.column stmt 2 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: solution problem_id"))
      )
      ~solved:(
      (match Sqlite3.column stmt 3 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: solution solved"))
      )
      (* foreign fields *)
      ~attempts:(
        (* foreign many-many mapping field *)
        let sql' = "select attempts_id from map_attempts_solution_attempts where solution_id=?" in
        let stmt' = Sqlite3.prepare db.db sql' in
        let solution__id = Sqlite3.column stmt 0 in
        db_must_ok db (fun () -> Sqlite3.bind stmt' 1 solution__id);
        List.flatten (step_fold db stmt' (fun s ->
          let i = match Sqlite3.column s 0 with |Sqlite3.Data.INT i -> i |_ -> assert false in
          Attempts.get ~id:(Some i) db)
        ))
    db
    in 
    (* execute the SQL query *)
    step_fold db stmt of_stmt

end

module Problems = struct
  type t = <
    id : int64 option;
    set_id : int64 option -> unit;
    number : int64;
    set_number : int64 -> unit;
    short_descr : string;
    set_short_descr : string -> unit;
    description : string;
    set_description : string -> unit;
    solved_by : int64;
    set_solved_by : int64 -> unit;
    save: int64; delete: unit
  >

  let init db =
    let sql = "create table if not exists problems (id integer primary key autoincrement,number integer,short_descr text,description text,solved_by integer);" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "CREATE UNIQUE INDEX IF NOT EXISTS problems_number_idx ON problems (number) " in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    ()

  (* object definition *)
  let t ?(id=None) ~number ~short_descr ~description ~solved_by db : t = object
    (* get functions *)
    val mutable _id = id
    method id : int64 option = _id
    val mutable _number = number
    method number : int64 = _number
    val mutable _short_descr = short_descr
    method short_descr : string = _short_descr
    val mutable _description = description
    method description : string = _description
    val mutable _solved_by = solved_by
    method solved_by : int64 = _solved_by

    (* set functions *)
    method set_id v =
      _id <- v
    method set_number v =
      _number <- v
    method set_short_descr v =
      _short_descr <- v
    method set_description v =
      _description <- v
    method set_solved_by v =
      _solved_by <- v

    (* admin functions *)
    method delete =
      match _id with
      |None -> ()
      |Some id ->
        let sql = "DELETE FROM problems WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT id));
        ignore(step_fold db stmt (fun _ -> ()));
        _id <- None

    method save = transaction db (fun () ->
      (* insert any foreign-one fields into their table and get id *)
      let _curobj_id = match _id with
      |None -> (* insert new record *)
        let sql = "INSERT INTO problems VALUES(NULL,?,?,?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _number in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _short_descr in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _description in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _solved_by in Sqlite3.Data.INT v));
        db_must_done db (fun () -> Sqlite3.step stmt);
        let __id = Sqlite3.last_insert_rowid db.db in
        _id <- Some __id;
        __id
      |Some id -> (* update *)
        let sql = "UPDATE problems SET number=?,short_descr=?,description=?,solved_by=? WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _number in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _short_descr in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _description in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _solved_by in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 5 (Sqlite3.Data.INT id));
        db_must_done db (fun () -> Sqlite3.step stmt);
        id
      in
      _curobj_id
    )
  end

  (* General get function for any of the columns *)
  let get ?(id=None) ?(number=None) ?(short_descr=None) ?(description=None) ?(solved_by=None) ?(custom_where=("",[])) db =
    (* assemble the SQL query string *)
    let q = "" in
    let _first = ref true in
    let f () = match !_first with |true -> _first := false; " WHERE " |false -> " AND " in
    let q = match id with |None -> q |Some b -> q ^ (f()) ^ "problems.id=?" in
    let q = match number with |None -> q |Some b -> q ^ (f()) ^ "problems.number=?" in
    let q = match short_descr with |None -> q |Some b -> q ^ (f()) ^ "problems.short_descr=?" in
    let q = match description with |None -> q |Some b -> q ^ (f()) ^ "problems.description=?" in
    let q = match solved_by with |None -> q |Some b -> q ^ (f()) ^ "problems.solved_by=?" in
    let q = match custom_where with |"",_ -> q |w,_ -> q ^ (f()) ^ "(" ^ w ^ ")" in
    let sql="SELECT problems.id, problems.number, problems.short_descr, problems.description, problems.solved_by FROM problems " ^ q in
    let stmt=Sqlite3.prepare db.db sql in
    (* bind the position variables to the statement *)
    let bindpos = ref 1 in
    ignore(match id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match number with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match short_descr with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match description with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match solved_by with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match custom_where with |_,[] -> () |_,eb ->
      List.iter (fun b ->
        db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos b);
        incr bindpos
      ) eb);
    (* convert statement into an ocaml object *)
    let of_stmt stmt =
    t
      (* native fields *)
      ~id:(
      (match Sqlite3.column stmt 0 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: problems id")))
      )
      ~number:(
      (match Sqlite3.column stmt 1 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: problems number"))
      )
      ~short_descr:(
      (match Sqlite3.column stmt 2 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~description:(
      (match Sqlite3.column stmt 3 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~solved_by:(
      (match Sqlite3.column stmt 4 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: problems solved_by"))
      )
      (* foreign fields *)
    db
    in 
    (* execute the SQL query *)
    step_fold db stmt of_stmt

end

module User = struct
  type t = <
    id : int64 option;
    set_id : int64 option -> unit;
    username : string;
    set_username : string -> unit;
    password : string;
    set_password : string -> unit;
    email : string;
    set_email : string -> unit;
    allow_contact : int64;
    set_allow_contact : int64 -> unit;
    nationality : string option;
    set_nationality : string option -> unit;
    preferred_language : string option;
    set_preferred_language : string option -> unit;
    score : int64;
    set_score : int64 -> unit;
    solutions : Solution.t list;
    set_solutions : Solution.t list -> unit;
    save: int64; delete: unit
  >

  let init db =
    let sql = "create table if not exists user (id integer primary key autoincrement,username text,password text,email text,allow_contact integer,nationality text,preferred_language text,score integer);" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "create table if not exists map_solutions_user_solution (user_id integer, solution_id integer, primary key(user_id, solution_id));" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "CREATE UNIQUE INDEX IF NOT EXISTS user_username_idx ON user (username) " in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "CREATE INDEX IF NOT EXISTS user_nationality_idx ON user (nationality) " in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    let sql = "CREATE INDEX IF NOT EXISTS user_preferred_language_idx ON user (preferred_language) " in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    ()

  (* object definition *)
  let t ?(id=None) ~username ~password ~email ~allow_contact ?(nationality=None) ?(preferred_language=None) ~score ~solutions db : t = object
    (* get functions *)
    val mutable _id = id
    method id : int64 option = _id
    val mutable _username = username
    method username : string = _username
    val mutable _password = password
    method password : string = _password
    val mutable _email = email
    method email : string = _email
    val mutable _allow_contact = allow_contact
    method allow_contact : int64 = _allow_contact
    val mutable _nationality = nationality
    method nationality : string option = _nationality
    val mutable _preferred_language = preferred_language
    method preferred_language : string option = _preferred_language
    val mutable _score = score
    method score : int64 = _score
    val mutable _solutions = solutions
    method solutions : Solution.t list = _solutions

    (* set functions *)
    method set_id v =
      _id <- v
    method set_username v =
      _username <- v
    method set_password v =
      _password <- v
    method set_email v =
      _email <- v
    method set_allow_contact v =
      _allow_contact <- v
    method set_nationality v =
      _nationality <- v
    method set_preferred_language v =
      _preferred_language <- v
    method set_score v =
      _score <- v
    method set_solutions v =
      _solutions <- v

    (* admin functions *)
    method delete =
      match _id with
      |None -> ()
      |Some id ->
        let sql = "DELETE FROM user WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT id));
        ignore(step_fold db stmt (fun _ -> ()));
        _id <- None

    method save = transaction db (fun () ->
      (* insert any foreign-one fields into their table and get id *)
      let _curobj_id = match _id with
      |None -> (* insert new record *)
        let sql = "INSERT INTO user VALUES(NULL,?,?,?,?,?,?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _username in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _password in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _email in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _allow_contact in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 5 (match _nationality with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 6 (match _preferred_language with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 7 (let v = _score in Sqlite3.Data.INT v));
        db_must_done db (fun () -> Sqlite3.step stmt);
        let __id = Sqlite3.last_insert_rowid db.db in
        _id <- Some __id;
        __id
      |Some id -> (* update *)
        let sql = "UPDATE user SET username=?,password=?,email=?,allow_contact=?,nationality=?,preferred_language=?,score=? WHERE id=?" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _username in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (let v = _password in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _email in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (let v = _allow_contact in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 5 (match _nationality with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 6 (match _preferred_language with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 7 (let v = _score in Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 8 (Sqlite3.Data.INT id));
        db_must_done db (fun () -> Sqlite3.step stmt);
        id
      in
      List.iter (fun f ->
        let _refobj_id = f#save in
        let sql = "INSERT OR IGNORE INTO map_solutions_user_solution VALUES(?,?)" in
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (Sqlite3.Data.INT _refobj_id));
        ignore(step_fold db stmt (fun _ -> ()));
      ) _solutions;
      let ids = String.concat "," (List.map (fun x -> match x#id with |None -> assert false |Some x -> Int64.to_string x) _solutions) in
      let sql = "DELETE FROM map_solutions_user_solution WHERE user_id=? AND (solution_id NOT IN (" ^ ids ^ "))" in
      let stmt = Sqlite3.prepare db.db sql in
      db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT _curobj_id));
      ignore(step_fold db stmt (fun _ -> ()));
      _curobj_id
    )
  end

  (* General get function for any of the columns *)
  let get ?(id=None) ?(username=None) ?(password=None) ?(email=None) ?(allow_contact=None) ?(nationality=None) ?(preferred_language=None) ?(score=None) ?(custom_where=("",[])) db =
    (* assemble the SQL query string *)
    let q = "" in
    let _first = ref true in
    let f () = match !_first with |true -> _first := false; " WHERE " |false -> " AND " in
    let q = match id with |None -> q |Some b -> q ^ (f()) ^ "user.id=?" in
    let q = match username with |None -> q |Some b -> q ^ (f()) ^ "user.username=?" in
    let q = match password with |None -> q |Some b -> q ^ (f()) ^ "user.password=?" in
    let q = match email with |None -> q |Some b -> q ^ (f()) ^ "user.email=?" in
    let q = match allow_contact with |None -> q |Some b -> q ^ (f()) ^ "user.allow_contact=?" in
    let q = match nationality with |None -> q |Some b -> q ^ (f()) ^ "user.nationality=?" in
    let q = match preferred_language with |None -> q |Some b -> q ^ (f()) ^ "user.preferred_language=?" in
    let q = match score with |None -> q |Some b -> q ^ (f()) ^ "user.score=?" in
    let q = match custom_where with |"",_ -> q |w,_ -> q ^ (f()) ^ "(" ^ w ^ ")" in
    let sql="SELECT user.id, user.username, user.password, user.email, user.allow_contact, user.nationality, user.preferred_language, user.score FROM user " ^ q in
    let stmt=Sqlite3.prepare db.db sql in
    (* bind the position variables to the statement *)
    let bindpos = ref 1 in
    ignore(match id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match username with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match password with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match email with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match allow_contact with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match nationality with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match preferred_language with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      incr bindpos
    );
    ignore(match score with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      incr bindpos
    );
    ignore(match custom_where with |_,[] -> () |_,eb ->
      List.iter (fun b ->
        db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos b);
        incr bindpos
      ) eb);
    (* convert statement into an ocaml object *)
    let of_stmt stmt =
    t
      (* native fields *)
      ~id:(
      (match Sqlite3.column stmt 0 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: user id")))
      )
      ~username:(
      (match Sqlite3.column stmt 1 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~password:(
      (match Sqlite3.column stmt 2 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~email:(
      (match Sqlite3.column stmt 3 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~allow_contact:(
      (match Sqlite3.column stmt 4 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: user allow_contact"))
      )
      ~nationality:(
      (match Sqlite3.column stmt 5 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (Sqlite3.Data.to_string x))
      )
      ~preferred_language:(
      (match Sqlite3.column stmt 6 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (Sqlite3.Data.to_string x))
      )
      ~score:(
      (match Sqlite3.column stmt 7 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: user score"))
      )
      (* foreign fields *)
      ~solutions:(
        (* foreign many-many mapping field *)
        let sql' = "select solution_id from map_solutions_user_solution where user_id=?" in
        let stmt' = Sqlite3.prepare db.db sql' in
        let user__id = Sqlite3.column stmt 0 in
        db_must_ok db (fun () -> Sqlite3.bind stmt' 1 user__id);
        List.flatten (step_fold db stmt' (fun s ->
          let i = match Sqlite3.column s 0 with |Sqlite3.Data.INT i -> i |_ -> assert false in
          Solution.get ~id:(Some i) db)
        ))
    db
    in 
    (* execute the SQL query *)
    step_fold db stmt of_stmt

end

module Init = struct
  type t = state
  type transaction_mode = [`Exclusive |`Deferred |`Immediate ]
  let t ?(busyfn=default_busyfn) ?(mode=`Immediate) db_name =
    let db = {db=Sqlite3.db_open db_name; in_transaction=0; mode=mode; busyfn=busyfn } in
    Challenge.init db;
    Log_entry.init db;
    Attempts.init db;
    Solution.init db;
    Problems.init db;
    User.init db;
    db

  let db handle = handle.db
end

