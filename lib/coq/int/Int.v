(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.

(* Why3 goal *)
Notation infix_ls := Zlt (only parsing).

(* Why3 assumption *)
Definition infix_lseq(x:Z) (y:Z): Prop := (infix_ls x y) \/ (x = y).

Lemma infix_lseq_Zle :
  forall x y, infix_lseq x y <-> Zle x y.
Proof.
intros x y.
apply iff_Symmetric.
apply Zle_lt_or_eq_iff.
Qed.

(* Why3 goal *)
Notation infix_pl := Zplus (only parsing).

(* Why3 goal *)
Notation prefix_mn := Zopp (only parsing).

(* Why3 goal *)
Notation infix_as := Zmult (only parsing).

(* Why3 goal *)
Lemma Assoc : forall (x:Z) (y:Z) (z:Z), ((infix_pl (infix_pl x y)
  z) = (infix_pl x (infix_pl y z))).
Proof.
intros x y z.
apply sym_eq.
apply Zplus_assoc.
Qed.

(* Why3 goal *)
Lemma Unit_def_l : forall (x:Z), ((infix_pl 0%Z x) = x).
Proof.
exact Zplus_0_l.
Qed.

(* Why3 goal *)
Lemma Unit_def_r : forall (x:Z), ((infix_pl x 0%Z) = x).
Proof.
exact Zplus_0_r.
Qed.

(* Why3 goal *)
Lemma Inv_def_l : forall (x:Z), ((infix_pl (prefix_mn x) x) = 0%Z).
Proof.
exact Zplus_opp_l.
Qed.

(* Why3 goal *)
Lemma Inv_def_r : forall (x:Z), ((infix_pl x (prefix_mn x)) = 0%Z).
Proof.
exact Zplus_opp_r.
Qed.

(* Why3 goal *)
Lemma Comm : forall (x:Z) (y:Z), ((infix_pl x y) = (infix_pl y x)).
Proof.
exact Zplus_comm.
Qed.

(* Why3 goal *)
Lemma Assoc1 : forall (x:Z) (y:Z) (z:Z), ((infix_as (infix_as x y)
  z) = (infix_as x (infix_as y z))).
Proof.
intros x y z.
apply sym_eq.
apply Zmult_assoc.
Qed.

(* Why3 goal *)
Lemma Mul_distr_l : forall (x:Z) (y:Z) (z:Z), ((infix_as x (infix_pl y
  z)) = (infix_pl (infix_as x y) (infix_as x z))).
Proof.
intros x y z.
apply Zmult_plus_distr_r.
Qed.

(* Why3 goal *)
Lemma Mul_distr_r : forall (x:Z) (y:Z) (z:Z), ((infix_as (infix_pl y z)
  x) = (infix_pl (infix_as y x) (infix_as z x))).
Proof.
intros x y z.
apply Zmult_plus_distr_l.
Qed.

(* Why3 assumption *)
Definition infix_mn(x:Z) (y:Z): Z := (infix_pl x (prefix_mn y)).

(* Why3 goal *)
Lemma Comm1 : forall (x:Z) (y:Z), ((infix_as x y) = (infix_as y x)).
Proof.
exact Zmult_comm.
Qed.

(* Why3 goal *)
Lemma Unitary : forall (x:Z), ((infix_as 1%Z x) = x).
Proof.
exact Zmult_1_l.
Qed.

(* Why3 goal *)
Lemma NonTrivialRing : ~ (0%Z = 1%Z).
Proof.
discriminate.
Qed.

(* Why3 goal *)
Lemma Refl : forall (x:Z), (infix_lseq x x).
Proof.
intros x.
apply infix_lseq_Zle.
apply Zle_refl.
Qed.

(* Why3 goal *)
Lemma Trans : forall (x:Z) (y:Z) (z:Z), (infix_lseq x y) -> ((infix_lseq y
  z) -> (infix_lseq x z)).
Proof.
intros x y z H1 H2.
apply infix_lseq_Zle.
apply Zle_trans with y ;
  now apply infix_lseq_Zle.
Qed.

(* Why3 goal *)
Lemma Antisymm : forall (x:Z) (y:Z), (infix_lseq x y) -> ((infix_lseq y x) ->
  (x = y)).
Proof.
intros x y H1 H2.
apply Zle_antisym ;
  now apply infix_lseq_Zle.
Qed.

(* Why3 goal *)
Lemma Total : forall (x:Z) (y:Z), (infix_lseq x y) \/ (infix_lseq y x).
Proof.
intros x y.
destruct (Zle_or_lt x y) as [H|H].
left.
now apply infix_lseq_Zle.
right.
apply infix_lseq_Zle.
now apply Zlt_le_weak.
Qed.

(* Why3 goal *)
Lemma ZeroLessOne : (infix_lseq 0%Z 1%Z).
Proof.
now left.
Qed.

(* Why3 goal *)
Lemma CompatOrderAdd : forall (x:Z) (y:Z) (z:Z), (infix_lseq x y) ->
  (infix_lseq (infix_pl x z) (infix_pl y z)).
Proof.
intros x y z H.
apply infix_lseq_Zle.
apply Zplus_le_compat_r.
now apply infix_lseq_Zle.
Qed.

(* Why3 goal *)
Lemma CompatOrderMult : forall (x:Z) (y:Z) (z:Z), (infix_lseq x y) ->
  ((infix_lseq 0%Z z) -> (infix_lseq (infix_as x z) (infix_as y z))).
Proof.
intros x y z H1 H2.
apply infix_lseq_Zle.
apply Zmult_le_compat_r ;
  now apply infix_lseq_Zle.
Qed.


