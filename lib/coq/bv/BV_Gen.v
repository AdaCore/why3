(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require bv.Pow2int.

(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require bv.Pow2int.

Definition last_bit : nat.
  Admitted.
Definition size : nat := S last_bit.

(* Why3 goal *)
Definition size_int: Z.
  exact (Z.of_nat size).
Defined.

Lemma size_int_to_nat : Z.to_nat size_int = size.
  unfold size_int; apply Nat2Z.id.
Qed.

Lemma size_int_S : size_int = Z.succ (Z.of_nat last_bit).
  unfold size_int, size.
  rewrite Nat2Z.inj_succ; trivial.
Qed.

(* Why3 goal *)
Lemma size_int_pos : (0%Z < size_int)%Z.
  easy.
Qed.

Require Import Bool.Bvector.

(* Why3 goal *)
Definition t : Type.
  exact (Bvector size).
Defined.

Fixpoint nth_aux {l} (v : Vector.t bool l) (m : Z) : bool :=
  match v with
    | Vector.nil => false
    | Vector.cons b _ tl => if Z_eq_dec m 0 then b else nth_aux tl (Z.pred m)
  end.

(* nth helper lemmas *)

Lemma nth_cons {l} (v : Vector.t bool l) (m : Z) b : (m <> -1)%Z ->
  nth_aux (Vector.cons bool b l v) (Z.succ m) = nth_aux v m.
  intro; simpl.
  case Z.eq_dec; intro.
  assert False by omega; easy.
  rewrite <- Zpred_succ; easy.
Qed.

Lemma nth_cons_pred {l} (v : Vector.t bool l) (m : Z) b : (m <> 0)%Z ->
  nth_aux (Vector.cons bool b l v) m = nth_aux v (Z.pred m).
  intro.
  rewrite Zsucc_pred with (n := m), <- Zpred_succ; apply nth_cons; omega.
Qed.

Lemma nth_high : forall {l} (v : Vector.t bool l) m, (m >= (Z.of_nat l))%Z -> nth_aux v m = false.
  induction v.
  easy.
  rewrite Nat2Z.inj_succ.
  intros; rewrite nth_cons_pred by omega.
  apply IHv; omega.
Qed.

Lemma nth_low : forall {l} (v : Vector.t bool l) m, (m < 0)%Z -> nth_aux v m = false.
  induction v.
  easy.
  intros; rewrite nth_cons_pred by omega.
  apply IHv; omega.
Qed.

Lemma nth_zero_is_hd : forall {l} (b : Vector.t bool (S l)), nth_aux b 0 = Vector.hd b.
  apply Vector.rectS; easy.
Qed.

Lemma nth_predl_is_last : forall {l} (b : Vector.t bool (S l)), nth_aux b (Z.of_nat l) = Vector.last b.
  apply Vector.rectS.
  easy.
  intros.
  rewrite Nat2Z.inj_succ, nth_cons by omega.
  easy.
Qed.

Lemma nth_const {l} (m : Z) b: (0 <= m < Z.of_nat l)%Z -> nth_aux (Vector.const b l) m = b.
  revert b m.
  induction l.
  simpl.
  intros; assert False by omega; easy.
  rewrite Nat2Z.inj_succ; intros; simpl.
  case (Z.eq_dec m 0); intro.
  easy.
  apply IHl; omega.
Qed.

Lemma nth_aux_map : forall {l} (f : bool -> bool) (v : Vector.t bool l) m,
                       (0 <= m < Z.of_nat l)%Z ->
                       f (nth_aux v m) = nth_aux (Vector.map f v) m.
  induction v.
  simpl; intros; assert False by omega; easy.
  rewrite Nat2Z.inj_succ; intros; simpl.
  case (Z.eq_dec m 0); intro.
  easy.
  apply IHv; omega.
Qed.

Lemma nth_aux_map2 : forall {l} (f : bool -> bool -> bool) (v1 v2 : Vector.t bool l) m,
                       (0 <= m < Z.of_nat l)%Z ->
                       f (nth_aux v1 m) (nth_aux v2 m) = nth_aux (Vector.map2 f v1 v2) m.
  intros l f v1 v2; pattern l, v1, v2.
  apply Vector.rect2.
  simpl; intros; assert False by omega; easy.
  intros.
  rewrite Nat2Z.inj_succ in H0; simpl.
  case (Z.eq_dec m 0); intro.
  easy.
  apply H; omega.
Qed.

Lemma nth_aux_tl : forall {l} (v : Vector.t bool (S l)) m, (m <> -1)%Z -> nth_aux (Vector.tl v) m = nth_aux v (Z.succ m).
  intros l v; pattern l, v.
  apply Vector.rectS.
  simpl.
  intros; case Z.eq_dec.
  intro; assert False by omega; easy.
  trivial.
  intros.
  simpl (Vector.tl (a :: v0)).
  symmetry; apply nth_cons; omega.
Qed.

Lemma nth_aux_shiftout_last : forall {l} (v : Vector.t bool (S l)), nth_aux (Vector.shiftout v) (Z.of_nat l) = false.
  intros l v; pattern l, v.
  apply Vector.rectS; intros.
  easy.
  rewrite Nat2Z.inj_succ.
  assert (Vector.shiftout (a :: v0) = a :: (Vector.shiftout v0)) by easy.
  rewrite H0, nth_cons by omega.
  apply H.
Qed.

Lemma nth_aux_shiftout_not_last : forall {l} (v : Vector.t bool (S l)) m, (m <> Z.of_nat l)%Z -> nth_aux (Vector.shiftout v) m = nth_aux v m.
  intros l v; pattern l, v.
  apply Vector.rectS; intros.
  simpl; case Z.eq_dec; easy.
  simpl; case Z.eq_dec; trivial.
  intro; apply H.
  rewrite Nat2Z.inj_succ in H0; omega.
Qed.

Lemma nth_aux_shiftin_false : forall {l} (v : Vector.t bool l) m, nth_aux (Vector.shiftin false v) m = nth_aux v m.
  induction v; intro; simpl; case (Z.eq_dec m 0); trivial.
Qed.

Lemma nth_aux_shiftin_low : forall {l} (v : Vector.t bool l) m b, 0 < l -> (0 <= m < Z.of_nat l)%Z -> nth_aux (Vector.shiftin b v) m = nth_aux v m.
  induction v; intros.
  easy.
  simpl; case Z.eq_dec.
  easy.
  rewrite Nat2Z.inj_succ in H0.
  intro; apply IHv; omega.
Qed.

Lemma nth_aux_shiftin_high : forall {l} (v : Vector.t bool l) b, nth_aux (Vector.shiftin b v) (Z.of_nat l) = b.
  induction v.
  easy.
  unfold Vector.shiftin.
  fold (@Vector.shiftin bool).
  rewrite Nat2Z.inj_succ.
  intro; rewrite nth_cons by omega.
  apply IHv.
Qed.

(* end of nth helpers *)

(* Why3 goal *)
Definition nth: t -> Z -> bool.
  exact nth_aux.
Defined.

Lemma nth_aux_out_of_bound : forall {l} (v : Vector.t bool l) (n : Z), ((n < 0%Z)%Z \/
  (Z.of_nat l <= n)%Z) -> ((nth_aux v n) = false).
induction v.
simpl; auto.
simpl.
intros.
case Z.eq_dec.
intros; elimtype False; destruct H. 
omega.
subst n0.
auto with zarith. 
intro; rewrite IHv;auto.
intuition; auto with zarith.
right.
rewrite Zpos_P_of_succ_nat in H0.
omega.
Qed.

(* Why3 goal *)
Lemma nth_out_of_bound : forall (x:t) (n:Z), ((n < 0%Z)%Z \/
  (size_int <= n)%Z) -> ((nth x n) = false).
intros.
unfold nth.
rewrite nth_aux_out_of_bound; auto with zarith.
Qed.

Definition zero_aux {l} : Vector.t bool l.
  exact (Vector.const false l).
Defined.

(* Why3 goal *)
Definition zero: t.
  exact zero_aux.
Defined.

Lemma Nth_zero_aux : forall {l} (n:Z), ((@nth_aux l zero_aux n) = false).
  induction l.
  easy.
  simpl.
  intro n; case (Z.eq_dec n 0); easy.
Qed.

(* Why3 goal *)
Lemma Nth_zero : forall (n:Z), ((nth zero n) = false).
intros n; apply Nth_zero_aux.
Qed.

Definition ones_aux l : Vector.t bool l.
  exact (Vector.const true l).
Defined.

(* Why3 goal *)
Definition ones: t.
  exact (ones_aux size).
Defined.

(* Why3 goal *)
Lemma Nth_ones : forall (n:Z), ((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((nth ones n) = true).
  intros; apply nth_const; easy.
Qed.

(* Why3 goal *)
Definition bw_and: t -> t -> t.
  exact (Vector.map2 (fun x y => x && y)).
Defined.

(* Why3 goal *)
Lemma Nth_bw_and : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < size_int)%Z) -> ((nth (bw_and v1 v2) n) = (Init.Datatypes.andb (nth v1
  n) (nth v2 n))).
  symmetry.
  apply nth_aux_map2 with (f := fun x y => x && y); easy.
Qed.

(* Why3 goal *)
Definition bw_or: t -> t -> t.
  exact (Vector.map2 (fun x y => x || y)).
Defined.

(* Why3 goal *)
Lemma Nth_bw_or : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < size_int)%Z) -> ((nth (bw_or v1 v2) n) = (Init.Datatypes.orb (nth v1
  n) (nth v2 n))).
  symmetry.
  apply nth_aux_map2; easy.
Qed.

(* Why3 goal *)
Definition bw_xor: t -> t -> t.
  exact (Vector.map2 (fun x y => xorb x y)).
Defined.

(* Why3 goal *)
Lemma Nth_bw_xor : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < size_int)%Z) -> ((nth (bw_xor v1 v2) n) = (Init.Datatypes.xorb (nth v1
  n) (nth v2 n))).
  symmetry.
  apply nth_aux_map2; easy.
Qed.

(* Why3 goal *)
Definition bw_not: t -> t.
  exact (Vector.map (fun x => negb x)).
Defined.

(* Why3 goal *)
Lemma Nth_bw_not : forall (v:t) (n:Z), ((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((nth (bw_not v) n) = (Init.Datatypes.negb (nth v n))).
  symmetry.
  apply nth_aux_map; easy.
Qed.

(* Why3 goal *)
Definition lsr: t -> Z -> t.
  exact (fun v m => BshiftRl_iter last_bit v (Z.to_nat m)).
Defined.

Lemma bshiftRl_iter_nth_low : forall b s m,
                                (Z.of_nat s < size_int)%Z ->
                                (0 <= m < size_int)%Z ->
                                (m + Z.of_nat s < size_int)%Z ->
   nth_aux (BshiftRl_iter last_bit b s) m = nth_aux b (m + Z.of_nat s).
  induction s.
  simpl.
  intros; rewrite <- Zplus_0_r_reverse; easy.
  rewrite Nat2Z.inj_succ; intros.
  simpl BshiftRl_iter.
  unfold BshiftRl, Bhigh.
  rewrite nth_aux_tl by omega.
  rewrite nth_aux_shiftin_false.
  rewrite <- Zplus_succ_r_reverse, <- Z.add_succ_l.
  apply IHs; omega.
Qed.

(* Why3 goal *)
Lemma Lsr_nth_low : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((n + s)%Z < size_int)%Z -> ((nth (lsr b s) n) = (nth b (n + s)%Z)))).
  unfold nth, lsr.
  intros.
  assert ((n + s)%Z = (n + Z.of_nat (Z.to_nat s))%Z).
  rewrite Z2Nat.id with (n := s); omega.
  rewrite H2.
  apply bshiftRl_iter_nth_low; omega.
Qed.

Lemma bshiftRl_iter_nth_high : forall (b:t) (s:nat) (n:Z) ,
  (Z.of_nat s < size_int)%Z -> (size_int <= (n + Z.of_nat s)%Z)%Z -> ((nth_aux (BshiftRl_iter last_bit b s) n) = false).
  induction s.
  simpl.
  rewrite size_int_S; intros; apply nth_high; rewrite Nat2Z.inj_succ; omega.
  rewrite Nat2Z.inj_succ; intros.
  simpl BshiftRl_iter.
  unfold BshiftRl, Bhigh.
  rewrite nth_aux_tl by omega.
  rewrite nth_aux_shiftin_false.
  apply IHs; omega.
Qed.

(* Why3 goal *)
Lemma Lsr_nth_high : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((size_int <= (n + s)%Z)%Z -> ((nth (lsr b s) n) = false))).
  unfold nth, lsr.
  intros.
  apply bshiftRl_iter_nth_high; rewrite Z2Nat.id with (n := s); omega.
Qed.

(* Why3 goal *)
Definition asr: t -> Z -> t.
  exact (fun v m => BshiftRa_iter last_bit v (Z.to_nat m)).
Defined.

Definition eq_aux {l} (v1 v2 : Vector.t bool l): Prop := forall (n:Z), ((0%Z <= n)%Z /\
  (n < (Z.of_nat l))%Z) -> ((nth_aux v1 n) = (nth_aux v2 n)).

Lemma eq_aux_cons : forall {l} v1 v2 b b',  b = b' /\ @eq_aux l v1 v2 <-> eq_aux (b :: v1) (b' :: v2).
  intros; unfold eq_aux.
  rewrite Nat2Z.inj_succ.
  split; intros.
  simpl; case Z.eq_dec; intro.
  easy.
  apply H; omega.
  split.
  apply (H 0%Z); omega.
  intros.
  rewrite <- (nth_cons v1 n b) by omega.
  rewrite <- (nth_cons v2 n b') by omega.
  apply H; omega.
Qed.

Lemma Extensionality_aux : forall {l} (x y : Vector.t bool l), eq_aux x y -> x = y.
  intros l x y; pattern l, x, y.
  apply Vector.rect2.
  easy.
  intros.
  apply (eq_aux_cons v1 v2 a b) in H0; destruct H0.
  apply H in H1.
  rewrite H0, H1; trivial.
Qed.

(* Vector helper lemmas *)

Lemma singleton_is_singl : forall b : Vector.t bool 1, b = [ Vector.hd b ].
  intro; apply Extensionality_aux; unfold eq_aux; intros.
  change (Z.of_nat 1) with 1%Z in H; assert (n = 0%Z) as e by omega; rewrite e; simpl.
  apply nth_zero_is_hd.
Qed.

Lemma shiftrepeat_is_shiftin : forall {l} (v : Vector.t bool (S l)), Vector.shiftrepeat v = Vector.shiftin (Vector.last v) v.
  apply Vector.rectS.
  easy.
  intros; simpl.
  rewrite H; trivial.
Qed.

Lemma last_tail_shiftreapeat : forall {l} (v : Vector.t bool (S l)), Vector.last (Vector.tl (Vector.shiftrepeat v)) = Vector.last v.
  apply Vector.caseS; intros.
  induction n.
  apply Vector.case0 with (v := t0); easy.
  simpl.
  apply Vector.shiftrepeat_last.
Qed.

(* end of Vector helpers *)

Lemma BshiftRa_iter_nth_low : forall (b:t) (s:nat) (n:Z),
  (Z.of_nat s < size_int)%Z -> (0%Z <= n < size_int)%Z ->
  (0%Z <= (n + Z.of_nat s)%Z < size_int)%Z -> (nth_aux (BshiftRa_iter last_bit b s) n) = (nth_aux b (n + Z.of_nat s)%Z).
  induction s.
  simpl.
  intros; rewrite <- Zplus_0_r_reverse; easy.
  rewrite Nat2Z.inj_succ; intros.
  simpl BshiftRa_iter.
  unfold BshiftRa, Bhigh.
  rewrite nth_aux_tl by omega.
  rewrite shiftrepeat_is_shiftin.
  rewrite nth_aux_shiftin_low.
  rewrite <- Zplus_succ_r_reverse, <- Z.add_succ_l.
  apply IHs; omega.
  omega.
  fold size; fold size_int; omega.
Qed.

(* Why3 goal *)
Lemma Asr_nth_low : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((0%Z <= (n + s)%Z)%Z /\ ((n + s)%Z < size_int)%Z) -> ((nth (asr b s)
  n) = (nth b (n + s)%Z)))).
  unfold nth, lsr.
  intros.
  assert ((n + s)%Z = (n + Z.of_nat (Z.to_nat s))%Z).
  rewrite Z2Nat.id with (n := s); omega.
  rewrite H2.
  apply BshiftRa_iter_nth_low; omega.
Qed.

Lemma bshiftra_iter_last : forall {l} (v : Bvector (S l)) s, Vector.last (BshiftRa_iter l v s) = Vector.last v.
  induction s.
  easy.
  simpl; unfold BshiftRa, Bhigh.
  rewrite last_tail_shiftreapeat.
  apply IHs.
Qed.

Lemma BhiftRa_iter_nth_high : forall (b:t) (s:nat) (n:Z),
  (Z.of_nat s < size_int)%Z -> (0%Z <= n < size_int)%Z ->
  (size_int <= n + Z.of_nat s)%Z -> ((nth_aux (BshiftRa_iter last_bit b s) n) = nth_aux b
  (size_int - 1%Z))%Z.
  induction s.
  simpl BshiftRa_iter.
  simpl (Z.of_nat 0).
  intros.
  assert (n = size_int - 1)%Z by omega; rewrite H2; trivial.
  rewrite Nat2Z.inj_succ; intros.
  simpl BshiftRa_iter.
  unfold BshiftRa, Bhigh.
  rewrite nth_aux_tl by omega.
  rewrite shiftrepeat_is_shiftin.
  case (Z.eq_dec (Z.succ n) size_int).
  intro; unfold size_int in e.
  rewrite e, nth_aux_shiftin_high.
  rewrite bshiftra_iter_last.
  rewrite size_int_S, Z.sub_1_r, <- Zpred_succ.
  symmetry; apply nth_predl_is_last.
  intro; rewrite nth_aux_shiftin_low.
  apply IHs; omega.
  omega.
  fold size; fold size_int; omega.
Qed.

(* Why3 goal *)
Lemma Asr_nth_high : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((size_int <= (n + s)%Z)%Z -> ((nth (asr b s) n) = (nth b
  (size_int - 1%Z)%Z)))).
  unfold nth, asr.
  intros.
  apply BhiftRa_iter_nth_high.
  rewrite Z2Nat.id; omega.
  omega.
  rewrite Z2Nat.id; omega.
Qed.

(* Why3 goal *)
Definition lsl: t -> Z -> t.
  exact (fun v m => BshiftL_iter last_bit v (Z.to_nat m)).
Defined.

Lemma bshiftL_iter_nth_high : forall {l} v s m, (0 <= m - Z.of_nat s < Z.of_nat (S l))%Z -> (m < Z.of_nat (S l))%Z -> nth_aux (BshiftL_iter l v s) m = nth_aux v (m - Z.of_nat s).
  induction s; intros.
  simpl.
  rewrite <- Zminus_0_l_reverse; easy.
  simpl.
  case Z.eq_dec; intro.
  symmetry; apply nth_low.
  rewrite e; simpl; apply Pos2Z.neg_is_neg.
  case (Z.eq_dec (Z.pred m) (Z.of_nat l)).
  intro.
  rewrite Nat2Z.inj_succ in H0.
  assert False by omega; easy.
  intro.
  rewrite nth_aux_shiftout_not_last by omega.
  rewrite Zpos_P_of_succ_nat.
  rewrite Z.sub_succ_r.
  rewrite <- Z.sub_pred_l.
  rewrite Nat2Z.inj_succ in H, H.
  apply IHs; omega.
Qed.

(* Why3 goal *)
Lemma Lsl_nth_high : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((0%Z <= (n - s)%Z)%Z /\ ((n - s)%Z < size_int)%Z) -> ((nth (lsl b s)
  n) = (nth b (n - s)%Z)))).
  intros.
  unfold lsl.
  unfold nth.
  rewrite size_int_S in H, H0, H1.
  assert ((n - s)%Z = (n - Z.of_nat (Z.to_nat s))%Z).
  rewrite Z2Nat.id with (n := s); omega.
  rewrite H2.
  apply (bshiftL_iter_nth_high b (Z.to_nat s) n).
  rewrite Nat2Z.inj_succ.
  omega.
  rewrite Nat2Z.inj_succ.
  omega.
Qed.

Lemma Lsl_nth_low_aux : forall x (b : t) (n : int),
   (Z.of_nat x < size_int)%Z ->
   (0 <= n)%Z ->
   (n < size_int)%Z ->
   (n - Z.of_nat x < 0)%Z -> nth (lsl b (Z.of_nat x)) n = false.
  induction x.
  simpl; intros; assert False by omega; easy.
  rewrite Nat2Z.inj_succ; intros.
  unfold nth, lsl.
  rewrite Z2Nat.inj_succ by omega.
  simpl.
  case Z.eq_dec.
  trivial.
  intro.
  rewrite nth_aux_shiftout_not_last.
  apply IHx; omega.
  assert (last_bit = pred size) by easy.
  rewrite H3.
  rewrite Nat2Z.inj_pred.
  unfold size_int in H, H1.
  omega.
  unfold size.
  omega.
Qed.

(* Why3 goal *)
Lemma Lsl_nth_low : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((n - s)%Z < 0%Z)%Z -> ((nth (lsl b s) n) = false))).
  intros.
  assert (s = Z.of_nat (Z.to_nat s)).
  symmetry; apply Z2Nat.id; omega.
  rewrite H2.
  apply Lsl_nth_low_aux; omega.
Qed.

(* Why3 goal *)
Definition max_int: Z.
  exact (Pow2int.pow2 size_int - 1)%Z.
Defined.

Lemma max_int_nat : forall l, (0 <= Pow2int.pow2 (Z.of_nat l) - 1)%Z.
  intro.
  rewrite Z.sub_1_r.
  apply Zlt_0_le_0_pred.
  apply Pow2int.pow2pos.
  omega.
Qed.

Fixpoint bvec_to_nat n (v : Bvector n) {struct v} : nat :=
  match v with
    | Vector.nil => O
    | Vector.cons false n v => 2 * bvec_to_nat n v
    | Vector.cons true n v => 1 + 2 * bvec_to_nat n v
  end.

Lemma bvec_to_nat_zero : forall {l}, bvec_to_nat l (Vector.const false l) = 0.
  induction l; [easy|simpl; omega].
Qed.

Definition twos_complement n (v : Bvector n) : Z :=
  match v with
    | Vector.nil => 0%Z
    | Vector.cons false n v => Z.of_nat (bvec_to_nat n v)
    | Vector.cons true n v => (Z.of_nat (bvec_to_nat n v) - Pow2int.pow2 (Z.of_nat (S n)))%Z
  end.

Require Arith.Div2.

Fixpoint nat_to_bvec (length val : nat) {struct length} : Bvector length :=
  match length as x return Bvector x with
    | O => Bnil
    | S length =>
      Bcons (Z.odd (Z.of_nat val)) length (nat_to_bvec length (Div2.div2 val))
  end.

Lemma Nat_to_bvec_zero : forall {n}, Vector.const false n = nat_to_bvec n 0.
  induction n.
  easy.
  simpl.
  unfold Bcons.
  rewrite IHn; trivial.
Qed.

(* Why3 goal *)
Definition to_int: t -> Z.
  exact (twos_complement size).
Defined.

(* Why3 goal *)
Definition to_uint: t -> Z.
  exact (fun x => Z.of_nat (bvec_to_nat size x)).
Defined.

(* Why3 goal *)
Definition of_int: Z -> t.
  exact (fun x => nat_to_bvec size (Z.to_nat x)).
Defined.

Lemma bvec_to_nat_extensionality : forall {m} (v v' : Bvector m),
 (bvec_to_nat m v) = (bvec_to_nat m v') -> v = v'.
  unfold Bvector.
  intros m v v'.
  pattern m,v,v'.
  apply Vector.rect2.
  trivial.
  case a, b; intros.
  rewrite H; auto; inversion H0; omega.
  inversion H0; assert False; omega.
  inversion H0; assert False; omega.
  rewrite H; auto; inversion H0; omega.
Qed.

(* Why3 goal *)
Lemma to_uint_extensionality : forall (v:t) (v':t),
  ((to_uint v) = (to_uint v')) -> (v = v').
  unfold to_uint.
  intros v v'.
  rewrite Nat2Z.inj_iff.
  apply bvec_to_nat_extensionality.
Qed.

(* pow2 helper lemmas *)

Lemma id_lt_pow2: forall n, (Z.of_nat (S n) < Pow2int.pow2 (Z.of_nat (S n)))%Z.
  intro.
  induction n.
  easy.
  rewrite Nat2Z.inj_succ.
  apply Z.le_lt_trans with (m := (2 * Z.of_nat (S n))%Z).
  rewrite Nat2Z.inj_succ; omega.
  apply Z.lt_le_trans with (m := (2 * Pow2int.pow2 (Z.of_nat (S n)))%Z).
  omega.
  rewrite two_p_S by omega.
  unfold Pow2int.pow2; omega.
Qed.

Lemma pow2_lt_mono_nat : forall i j : nat, (i < j) -> (Pow2int.pow2 (Z.of_nat i) < Pow2int.pow2 (Z.of_nat j))%Z.
  intros.
  unfold Pow2int.pow2; rewrite two_p_equiv, two_p_equiv.
  apply Z.pow_lt_mono_r; omega.
Qed.

Lemma pow2_le_mono_nat : forall i j : nat, (i <= j) -> (Pow2int.pow2 (Z.of_nat i) <= Pow2int.pow2 (Z.of_nat j))%Z.
  intros.
  unfold Pow2int.pow2; rewrite two_p_equiv, two_p_equiv.
  apply Z.pow_le_mono_r; omega.
Qed.

Lemma pow2_le_mono_pos : forall i j : positive, (Pos.le i j) -> (Pow2int.pow2 (Zpos i) <= Pow2int.pow2 (Zpos j))%Z.
  intros.
  rewrite <- positive_nat_Z, <- positive_nat_Z.
  apply pow2_le_mono_nat.
  apply Pos2Nat.inj_le; trivial.
Qed.

Lemma pow2_pos : forall i : positive, (2 <= Pow2int.pow2 (Z.pos i))%Z.
  intros.
  rewrite <- Pow2int.Power_1.
  apply pow2_le_mono_pos.
  apply Pos.le_1_l.
Qed.

(* end of pow2 helpers *)

(* arithmetic helper lemmas *)

Lemma lem_time2 : forall a b, a < b -> 1 + 2 * a < 2 * b.
  intros; omega.
Qed.

Lemma le_le_le: forall x y z t, (t <= z)%Z -> (x <= y <= t)%Z -> (x <= y <= z)%Z.
  split; [easy|apply Int.Trans with (y := t0); easy].
Qed.

Lemma le_lt_le: forall x y z t, (t <= z)%Z -> (x <= y < t)%Z -> (x <= y <= z)%Z.
  split; [easy|apply Int.Trans with (y := t0); [apply Z.lt_le_incl, H0|easy]].
Qed.

Lemma factor_sub : forall n m p, (n * m - n * p = n * (m - p))%Z.
  intros.
  rewrite Int.infix_mn_def, Int.infix_mn_def, Zopp_mult_distr_r.
  apply Zred_factor4.
Qed.

Lemma lt_sym: forall x y, (x < y)%Z <-> (y > x)%Z.
  intro; split; omega.
Qed.

(* end of arithmetic helpers *)

Lemma bvec_to_nat_range : forall {n} v, bvec_to_nat n v < Z.to_nat (Pow2int.pow2 (Z.of_nat n)).
  induction v.
  simpl bvec_to_nat; auto.
  apply NPeano.Nat.le_lt_trans with (m := 1 + (bvec_to_nat n v * 2)).
  simpl; case h; omega.
  rewrite Nat2Z.inj_succ, <- Z.add_1_r, Pow2int.Power_s by omega.
  rewrite Z2Nat.inj_mul.
  assert (Z.to_nat 2 = 2) by easy; rewrite H.
  rewrite mult_comm.
  apply lem_time2.
  easy.
  easy.
  apply Zlt_le_weak, Pow2int.pow2pos; omega.
Qed.

Lemma twos_complement_neg : forall {n} v, (twos_complement (S n) (true :: v) < 0)%Z.
  intros.
  unfold twos_complement.
  apply Z.lt_sub_0.
  apply Zlt_trans with (m := Pow2int.pow2 (Z.of_nat n)).
  rewrite Z2Nat.inj_lt.
  rewrite Nat2Z.id.
  apply bvec_to_nat_range.
  omega.
  apply Zlt_le_weak, Pow2int.pow2pos; omega.
  apply pow2_lt_mono_nat; omega.
Qed.

Lemma twos_complement_pos : forall {n} v, (twos_complement (S n) (false :: v) >= 0)%Z.
  intros.
  unfold twos_complement; omega.
Qed.

Lemma twos_complement_extensionality : forall {m} (v v' : Bvector m),
  (twos_complement m v = twos_complement m v' -> v = v').
  destruct v; intros.
  apply Vector.case0 with (v := v'); trivial.
  revert v h H.
  apply Vector.caseS with (v := v'); intros.
  case h, h0; intros.
  inversion H.
  apply bvec_to_nat_extensionality; simpl; omega.
  Lemma tmp : forall {n} v v', twos_complement (S n) (false :: v) <> twos_complement (S n) (true :: v').
    intros.
    intro.
    assert ((twos_complement (S n) (true :: v') >= 0)%Z).
    rewrite <- H; apply twos_complement_pos.
    assert ((twos_complement (S n) (true :: v') < 0)%Z).
    apply twos_complement_neg.
    easy.
  Qed.
  assert (twos_complement (S n0) (false :: v) <>
          twos_complement (S n0) (true :: t0)).
  apply tmp.
  assert False by omega; easy.
  assert (twos_complement (S n0) (false :: t0) <>
          twos_complement (S n0) (true :: v)).
  apply tmp.
  assert False by omega; easy.
  inversion H.
  apply bvec_to_nat_extensionality; simpl; omega.
Qed.

(* Why3 goal *)
Lemma to_int_extensionality : forall (v:t) (v':t),
  ((to_int v) = (to_int v')) -> (v = v').
  apply twos_complement_extensionality.
Qed.

(* Why3 assumption *)
Definition uint_in_range (i:Z): Prop := (0%Z <= i)%Z /\ (i <= max_int)%Z.

Lemma size_int_in_range: uint_in_range size_int.
  unfold uint_in_range, max_int, size_int, size.
  split; [omega|apply Z.lt_le_pred, id_lt_pow2].
Qed.

(* Why3 goal *)
Lemma to_uint_bounds : forall (v:t), (uint_in_range (to_uint v)).
  intros v.
  unfold to_uint, uint_in_range.
  split.
  omega.
  assert (max_int = Z.of_nat (Z.to_nat max_int)).
  rewrite Z2Nat.id.
  easy.
  unfold max_int, size_int.
  apply max_int_nat.
  rewrite H.
  apply inj_le.
  unfold max_int.
  change (bvec_to_nat size v <= Z.to_nat (Z.pred (Pow2int.pow2 size_int))).
  rewrite Z2Nat.inj_pred.
  apply NPeano.Nat.lt_le_pred.
  apply bvec_to_nat_range.
Qed.

(* to_uint helper lemmas *)

Lemma to_uint_bounds_lt: forall v, (0%Z <= to_uint v < max_int + 1)%Z.
  split.
  apply to_uint_bounds.
  apply Zle_lt_succ, to_uint_bounds.
Qed.

Lemma to_uint_nat : forall v, (0 <= to_uint v)%Z.
  apply to_uint_bounds.
Qed.

(* end of to_uint helpers *)

(* even / odd helper lemmas *)

Lemma odd_is_odd : forall n : nat, Even.odd n <-> Z.odd (Z.of_nat n) = true.
  intro.
  rewrite Zodd_bool_iff, Zodd_ex_iff, <- NPeano.Odd_equiv.
  unfold NPeano.Odd.
  split; intro; destruct H.
  exists (Z.of_nat x); omega.
  rewrite <-Z2Nat.id with (n := x) in H by omega.
  exists (Z.to_nat x); omega.
Qed.

Lemma even_not_odd : forall n : nat, Even.even n <-> not (Even.odd n).
  intro; split; intro.
  intro; apply Even.not_even_and_odd with (n := n); easy.
  case (Even.even_or_odd n); easy.
Qed.

Lemma even_is_even : forall n : nat, Even.even n <-> Z.even (Z.of_nat n) = true.
  intro.
  rewrite even_not_odd, odd_is_odd, Zeven.Zeven_odd_bool, negb_true_iff, not_true_iff_false; easy.
Qed.

Lemma case_odd : forall (i : nat), (Z.odd (Z.of_nat i) = true) + (Z.odd (Z.of_nat i) = false).
  induction i.
  right; simpl; easy.
  rewrite Nat2Z.inj_succ.
  destruct IHi.
  right; rewrite Z.odd_succ, <- Z.negb_odd; rewrite e; trivial.
  left; rewrite Z.odd_succ, <- Z.negb_odd; rewrite e; trivial.
Qed.

Lemma odd_even_le : forall n m, Z.even n = true -> Z.odd m = true -> (n <= m)%Z -> (n < m)%Z.
  intros.
  case (Z_le_lt_eq_dec n m); trivial.
  intro; assert False.
  rewrite e, <- Z.negb_odd, negb_true_iff, H0 in H; easy.
  easy.
Qed.

Lemma pow2_is_even : forall n, (n > 0)%Z -> Z.even (Pow2int.pow2 n) = true.
  intros.
  unfold Pow2int.pow2.
  rewrite two_p_equiv, Z.even_pow by omega; easy.
Qed.

Lemma max_int_is_odd : forall n, (n > 0)%Z -> Z.odd (Pow2int.pow2 n - 1) = true.
  intros.
  rewrite Z.sub_1_r, Z.odd_pred.
  apply pow2_is_even; trivial.
Qed.

(* end of even / odd helpers *)

Lemma bvec_to_nat_nat_to_bvec : forall {n} i, (Z.of_nat i <= Pow2int.pow2 (Z.of_nat n) - 1)%Z ->
  bvec_to_nat n (nat_to_bvec n i) = i.
  induction n.
  simpl; intro; omega.
  destruct i; intros.
  simpl.
  rewrite <- Nat_to_bvec_zero, bvec_to_nat_zero; trivial.
  unfold nat_to_bvec, Bcons, bvec_to_nat.
  case (case_odd (S i)); intro.
  assert (Even.even i).
  rewrite even_not_odd, odd_is_odd.
  rewrite Nat2Z.inj_succ, Z.odd_succ, <- Z.negb_odd, negb_true_iff in e.
  rewrite e; easy.
  rewrite e.
  apply NPeano.Nat.succ_inj_wd.
  change (2 * bvec_to_nat n (nat_to_bvec n (Div2.div2 (S i))) = i).
  rewrite IHn.
  rewrite <- Div2.even_div2, <- NPeano.double_twice, <- Div2.even_double by easy; trivial.
  rewrite Z.mul_le_mono_pos_l with (p := 2%Z) by easy.
  rewrite Z.add_le_mono_l with (p := 1%Z) by easy.
  apply Z.le_trans with (m := Z.of_nat (S i)).
  rewrite <- Div2.even_div2, <- Nat2Z.inj_mul with (n:= 2), <- NPeano.double_twice, <- Div2.even_double, Nat2Z.inj_succ by trivial; omega.
  apply Z.le_trans with (m := (Pow2int.pow2 (Z.of_nat (S n)) - 1)%Z); trivial.
  rewrite Nat2Z.inj_succ, <- Z.add_1_r, Pow2int.Power_s; omega.
  rewrite e.
  change (2 * bvec_to_nat n (nat_to_bvec n (Div2.div2 (S i))) = S i).
  rewrite IHn.
  rewrite  <- NPeano.double_twice, <- Div2.even_double; trivial.
  rewrite even_not_odd, odd_is_odd, e; auto.
  rewrite Z.mul_le_mono_pos_l with (p := 2%Z) by easy.
  apply Z.le_trans with (m := Z.of_nat (S i)).
  rewrite <- Nat2Z.inj_mul with (n := 2), <- NPeano.double_twice, <- Div2.even_double.
  omega.
  rewrite even_not_odd, odd_is_odd, not_true_iff_false; trivial.
  apply odd_even_le, Z.lt_le_pred in H.
  apply Z.le_trans with (m := (Pow2int.pow2 (Z.of_nat (S n)) - 2)%Z).
  omega.
  rewrite Nat2Z.inj_succ, <- Z.add_1_r, Pow2int.Power_s; omega.
  rewrite Zeven.Zeven_odd_bool, e; easy.
  unfold Pow2int.pow2.
  rewrite Z.sub_1_r, Z.odd_pred, Nat2Z.inj_succ.
  rewrite pow2_is_even by omega; easy.
Qed.

(* Why3 goal *)
Lemma to_uint_of_int : forall (i:Z), (uint_in_range i) ->
  ((to_uint (of_int i)) = i).
  intros i h1; destruct h1.
  unfold to_uint, of_int.
  rewrite bvec_to_nat_nat_to_bvec.
  apply Z2Nat.id; easy.
  rewrite Z2Nat.id; easy.
Qed.

(* Why3 assumption *)
Definition ult (x:t) (y:t): Prop := ((to_uint x) < (to_uint y))%Z.

(* Why3 assumption *)
Definition ule (x:t) (y:t): Prop := ((to_uint x) <= (to_uint y))%Z.

(* Why3 assumption *)
Definition ugt (x:t) (y:t): Prop := ((to_uint y) < (to_uint x))%Z.

(* Why3 assumption *)
Definition uge (x:t) (y:t): Prop := ((to_uint y) <= (to_uint x))%Z.

(* Why3 assumption *)
Definition slt (v1:t) (v2:t): Prop := ((to_int v1) < (to_int v2))%Z.

(* Why3 assumption *)
Definition sle (v1:t) (v2:t): Prop := ((to_int v1) <= (to_int v2))%Z.

(* Why3 assumption *)
Definition sgt (v1:t) (v2:t): Prop := ((to_int v2) < (to_int v1))%Z.

(* Why3 assumption *)
Definition sge (v1:t) (v2:t): Prop := ((to_int v2) <= (to_int v1))%Z.

(* Why3 goal *)
Definition nth_bv: t -> t -> bool.
  exact (fun v w => nth v (to_uint w)).
Defined.

(* Why3 goal *)
Lemma Nth_bv_is_nth : forall (x:t) (i:t), ((nth_bv x i) = (nth x
  (to_uint i))).
  trivial.
Qed.

(* Why3 goal *)
Lemma Of_int_zero : (zero = (of_int 0%Z)).
  apply Nat_to_bvec_zero.
Qed.

Lemma Nat_to_bvec_ones : forall {n}, Vector.const true n = nat_to_bvec n (Z.to_nat (Pow2int.pow2 (Z.of_nat n) - 1)).
  induction n.
  easy.
  unfold nat_to_bvec.
  rewrite Z2Nat.id by (apply max_int_nat).
  rewrite max_int_is_odd by easy.
  fold nat_to_bvec.
  assert ((Div2.div2 (Z.to_nat (Pow2int.pow2 (Z.of_nat (S n)) - 1))) = (Z.to_nat (Pow2int.pow2 (Z.of_nat n) - 1))).
  apply eq_add_S.
  rewrite Div2.odd_div2.
  rewrite <- Z2Nat.inj_succ by (apply max_int_nat).
  rewrite Z.sub_1_r, <- Zsucc_pred, Nat2Z.inj_succ, <- Z.add_1_r.
  rewrite Pow2int.Power_s by omega.
  rewrite Z2Nat.inj_mul, Div2.div2_double.
  rewrite <- Z2Nat.inj_succ by (apply max_int_nat).
  rewrite Z.sub_1_r, <- Zsucc_pred; trivial.
  easy.
  apply Z.lt_le_incl, Pow2int.pow2pos; omega.
  rewrite odd_is_odd.
  rewrite Z2Nat.id by (apply max_int_nat).
  apply max_int_is_odd; easy.
  rewrite H, <- IHn; auto.
Qed.

(* Why3 goal *)
Lemma Of_int_ones : (ones = (of_int max_int)).
  apply Nat_to_bvec_ones.
Qed.

Import EuclideanDivision.

(* Why3 goal *)
Definition add: t -> t -> t.
  exact (fun v v' => of_int (mod1 (to_uint v + to_uint v') (max_int + 1))).
Defined.

(* mod helper lemmas *)

Lemma mod1_nat : forall x y, 0 < y -> 0 <= mod1 x y.
  intros.
  unfold mod1, div.
  case Z_le_dec; intro.
  apply Zle_minus_le_0, Z_mult_div_ge; omega.
  destruct n; apply Z.mod_pos_bound; trivial.
Qed.

Lemma mod1_nat_high_bound_lt: forall u v, 0 < v -> mod1 u v < v.
  intros.
  rewrite <- Z.abs_eq by omega.
  apply Mod_bound; omega.
Qed.

Lemma mod1_nat_high_bound_le: forall u v, 0 <= v ->
                                       mod1 u (v + 1) <= v.
  intros.
  rewrite Zpred_succ, <- Z.lt_le_pred.
  apply mod1_nat_high_bound_lt; omega.
Qed.

Lemma mod1_in_range : forall x, uint_in_range (mod1 x (max_int + 1)).
  split.
  apply mod1_nat, Zle_lt_succ, max_int_nat.
  apply mod1_nat_high_bound_le, max_int_nat.
Qed.

Lemma mod1_out : forall x y, 0 <= x < y -> mod1 x y = x.
  intros; unfold mod1.
  rewrite Div_inf; omega.
Qed.

Lemma mod_mod_mult: forall a b c, b > 0 -> c > 0 -> ((a mod (c * b)) mod b) = a mod b.
  intros.
  rewrite Z.mul_comm.
  rewrite Z.rem_mul_r by omega.
  rewrite <-Zplus_mod_idemp_r.
  rewrite Z.mul_comm, Z_mod_mult, Zplus_0_r.
  apply Zmod_mod.
Qed.

(* end of mod helpers *)

(* Why3 goal *)
Lemma to_uint_add : forall (v1:t) (v2:t), ((to_uint (add v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) + (to_uint v2))%Z
  (max_int + 1%Z)%Z)).
  intros v1 v2.
  apply to_uint_of_int, mod1_in_range.
Qed.

(* Why3 goal *)
Definition sub: t -> t -> t.
  exact (fun v v' => of_int (mod1 (to_uint v - to_uint v') (max_int + 1))).
Defined.

(* Why3 goal *)
Lemma to_uint_sub : forall (v1:t) (v2:t), ((to_uint (sub v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) - (to_uint v2))%Z
  (max_int + 1%Z)%Z)).
  intros v1 v2.
  apply to_uint_of_int, mod1_in_range.
Qed.

(* Why3 goal *)
Definition neg: t -> t.
  exact (fun v => of_int (mod1 (- to_uint v) (max_int + 1))).
Defined.

(* Why3 goal *)
Lemma to_uint_neg : forall (v:t),
  ((to_uint (neg v)) = (int.EuclideanDivision.mod1 (-(to_uint v))%Z
  (max_int + 1%Z)%Z)).
  intros v.
  apply to_uint_of_int, mod1_in_range.
Qed.

(* Why3 goal *)
Definition mul: t -> t -> t.
  exact (fun v v' => of_int (mod1 (to_uint v * to_uint v') (max_int + 1))).
Defined.

(* Why3 goal *)
Lemma to_uint_mul : forall (v1:t) (v2:t), ((to_uint (mul v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) * (to_uint v2))%Z
  (max_int + 1%Z)%Z)).
  intros v1 v2.
  apply to_uint_of_int, mod1_in_range.
Qed.

(* Why3 goal *)
Definition udiv: t -> t -> t.
  exact (fun v v' => of_int (div (to_uint v) (to_uint v'))).
Defined.

(* Why3 goal *)
Lemma to_uint_udiv : forall (v1:t) (v2:t), ((to_uint (udiv v1
  v2)) = (int.EuclideanDivision.div (to_uint v1) (to_uint v2))).
  intros v1 v2.
  apply to_uint_of_int.
  apply le_le_le with (t := to_uint v1).
  apply to_uint_bounds.
  case (Z.eq_dec (to_uint v2) 0); intro.
  rewrite e; unfold uint_in_range, div.
  rewrite Zmod_0_r; simpl.
  rewrite Zdiv_0_r.
  split; [easy|apply to_uint_nat].
  apply Div_bound; split.
  apply to_uint_nat.
  apply Z.le_neq; split; [apply to_uint_nat|omega].
Qed.

(* Why3 goal *)
Definition urem: t -> t -> t.
  exact (fun v v' => of_int (mod1 (to_uint v) (to_uint v'))).
Defined.

(* Why3 goal *)
Lemma to_uint_urem : forall (v1:t) (v2:t), ((to_uint (urem v1
  v2)) = (int.EuclideanDivision.mod1 (to_uint v1) (to_uint v2))).
  intros v1 v2.
  apply to_uint_of_int.
  case (Z.eq_dec (to_uint v2) 0); intro.
  rewrite e.
  unfold uint_in_range, mod1; simpl.
  rewrite <- Zminus_0_l_reverse; apply to_uint_bounds.
  apply le_lt_le with (t := Z.abs (to_uint v2)).
  rewrite Z.abs_eq; apply to_uint_bounds.
  apply Mod_bound; trivial.
Qed.

Fixpoint rotate_right_aux {l} (b : Vector.t bool (S l)) (p : nat) : Vector.t bool (S l) :=
match p with
  | O => b
  | S q => let prev := rotate_right_aux b q in
            (Vector.shiftin (Vector.hd prev) (Vector.tl prev))
end.

(* Why3 goal *)
Definition rotate_right: t -> t -> t.
  exact (fun b p => rotate_right_aux b (bvec_to_nat size p)).
Defined.

Fixpoint rotate_left_aux {l} (b : Vector.t bool (S l)) (p : nat) : Vector.t bool (S l) :=
match p with
  | O => b
  | S q => let prev := rotate_left_aux b q in
            ((Vector.last prev) :: (Vector.shiftout prev))
end.

(* Why3 goal *)
Definition rotate_left: t -> t -> t.
  exact (fun b p => rotate_left_aux b (bvec_to_nat size p)).
Defined.

Lemma mod1_is_mod : forall x y, y > 0 -> mod1 x y = Zmod x y.
  intros; unfold mod1, div.
  case Z_le_dec; intro.
  rewrite Z.mod_eq by omega; trivial.
  destruct n; apply Z_mod_lt; omega.
Qed.

Lemma mod1_succ_low : forall x y, y > 0 -> mod1 x y < (Z.pred y) -> mod1 (Z.succ x) y = Z.succ (mod1 x y).
  intros x y H.
  rewrite mod1_is_mod, mod1_is_mod by trivial.
  rewrite Z.mod_eq, Z.mod_eq by omega.
  intro; cut (Zsucc x / y = x / y).
  intro e; rewrite e; omega.
  rewrite Z.div_unique_pos with (a := Z.succ x) (b := y) (r := (x mod y) + 1) (q := x / y).
  trivial.
  rewrite <- Z.mod_eq in H0 by omega.
  split; [apply Z.le_le_succ_r, Z_mod_lt; trivial|omega].
  rewrite <- Zplus_assoc_reverse, <- Z_div_mod_eq by omega; omega.
Qed.

Lemma mod1_succ_high : forall x y, y > 0 -> mod1 x y = (Z.pred y) -> mod1 (Z.succ x) y = 0.
  intros x y H.
  rewrite mod1_is_mod, mod1_is_mod by omega; intro.
  rewrite <- Z.add_1_r, Zplus_mod, H0.
  case (Z.eq_dec y 1); intro e.
  rewrite e; easy.
  rewrite Zmod_1_l by omega.
  rewrite Z.add_1_r, <- Zsucc_pred.
  apply Z_mod_same_full.
Qed.

Lemma mod1_add : forall x y, y > 0 -> mod1 (x + y) y = mod1 x y.
  intros.
  rewrite mod1_is_mod, mod1_is_mod by omega.
  rewrite <- Z.mul_1_l with (n := x + y), <- Zred_factor4, Z.mul_1_l.
  apply Z.mod_add; omega.
Qed.

Lemma Nth_rotate_aux_left : forall {l} (v : Vector.t bool (S l)) (n:nat) (i:nat), (Z.of_nat i < (Z.succ (Z.of_nat l))) -> ((nth_aux v (Z.of_nat i)) = (nth_aux (rotate_left_aux v n) (mod1 ((Z.of_nat i) + (Z.of_nat n)) (Z.succ (Z.of_nat l))))).
  induction n; intros.
  simpl.
  rewrite <- Zplus_0_r_reverse, mod1_out; [trivial|omega].
  rewrite Nat2Z.inj_succ, <- Zplus_succ_r_reverse.
  rewrite IHn by trivial.
  case (Z.eq_dec (mod1 (Z.of_nat i + Z.of_nat n) (Z.succ (Z.of_nat l))) (Z.of_nat l)); intro e.
  rewrite e, mod1_succ_high by omega.
  apply nth_predl_is_last.
  rewrite mod1_succ_low.
  change (nth_aux (rotate_left_aux v n)
                  (mod1 (Z.of_nat i + Z.of_nat n) (Z.succ (Z.of_nat l))) =
          nth_aux ((Vector.last (rotate_left_aux v n)) :: (Vector.shiftout (rotate_left_aux v n)))
                  (Z.succ (mod1 (Z.of_nat i + Z.of_nat n) (Z.succ (Z.of_nat l))))).
  rewrite nth_cons.
  symmetry; apply nth_aux_shiftout_not_last.
  omega.
  intro.
  assert (0 <= mod1 (Z.of_nat i + Z.of_nat n) (Z.succ (Z.of_nat l))).
  apply mod1_nat; omega.
  omega.
  omega.
  assert (mod1 (Z.of_nat i + Z.of_nat n) (Z.succ (Z.of_nat l)) <
          Z.succ (Z.of_nat l)).
  apply mod1_nat_high_bound_lt; omega.
  omega.
Qed.

(* Why3 goal *)
Lemma Nth_rotate_left : forall (v:t) (n:t) (i:t), (ult i
  (of_int size_int)) -> ((ult n (sub ones (of_int size_int))) -> ((nth_bv v
  i) = (nth_bv (rotate_left v n) (urem (add i n) (of_int size_int))))).
  intros v n i h1 h2.
  unfold ult in h1, h2.
  rewrite to_uint_of_int in h1 by apply size_int_in_range.
  unfold nth_bv.
  rewrite to_uint_urem, to_uint_add.
  rewrite mod1_out with (x := (to_uint i + to_uint n)).
  rewrite to_uint_of_int by apply size_int_in_range.
  rewrite size_int_S.
  apply Nth_rotate_aux_left.
  fold (to_uint i); rewrite <- size_int_S; trivial.
  split.
  apply Z.add_nonneg_nonneg; apply to_uint_nat.
  rewrite to_uint_sub in h2.
  rewrite to_uint_of_int in h2 by apply size_int_in_range.
  rewrite Of_int_ones, to_uint_of_int, mod1_out in h2.
  omega.
  split.
  unfold max_int.
  rewrite <- Z.le_add_le_sub_l.
  simpl (_+_).
  apply Z.lt_le_pred, id_lt_pow2.
  unfold size_int.
  omega.
  split.
  unfold max_int.
  apply Z.lt_le_pred, Pow2int.pow2pos.
  unfold size_int; omega.
  omega.
Qed.

Lemma Nth_rotate_aux_right : forall {l} (v : Vector.t bool (S l)) (n:nat) (i:nat),
  (Z.of_nat i < (Z.succ (Z.of_nat l))) ->
  (nth_aux (rotate_right_aux v n) (Z.of_nat i)) = (nth_aux v (mod1 ((Z.of_nat i) + (Z.of_nat n)) (Z.succ (Z.of_nat l)))).
  induction n.
  simpl; intros; rewrite <- Zplus_0_r_reverse, mod1_out; [trivial|omega].
  intros; rewrite Nat2Z.inj_succ, <-Z.add_succ_comm, <-Nat2Z.inj_succ.
  case (Z.eq_dec (Z.of_nat i) (Z.of_nat l)); intro e.
  rewrite Nat2Z.inj_succ, e.
  simpl (rotate_right_aux v (S n)).
  rewrite nth_aux_shiftin_high.
  rewrite Z.add_comm, mod1_add by omega.
  rewrite <-nth_zero_is_hd.
  apply (IHn 0%nat); simpl; omega.
  rewrite <-IHn by (rewrite Nat2Z.inj_succ; omega).
  simpl (rotate_right_aux v (S n)).
  rewrite nth_aux_shiftin_low by omega.
  rewrite Nat2Z.inj_succ.
  apply nth_aux_tl; omega.
Qed.

(* Why3 goal *)
Lemma Nth_rotate_right : forall (v:t) (n:t) (i:t), (ult i
  (of_int size_int)) -> ((ult n (sub ones (of_int size_int))) ->
  ((nth_bv (rotate_right v n) i) = (nth_bv v (urem (add i n)
  (of_int size_int))))).
  intros v n i h1 h2.
  unfold ult in h1, h2.
  rewrite to_uint_of_int in h1 by apply size_int_in_range.
  unfold nth_bv.
  rewrite to_uint_urem, to_uint_add.
  rewrite mod1_out with (x := (to_uint i + to_uint n)).
  rewrite to_uint_of_int by apply size_int_in_range.
  rewrite size_int_S.
  apply Nth_rotate_aux_right.
  fold (to_uint i); rewrite <- size_int_S; trivial.
  split.
  apply Z.add_nonneg_nonneg; apply to_uint_nat.
  rewrite to_uint_sub in h2.
  rewrite to_uint_of_int in h2 by apply size_int_in_range.
  rewrite Of_int_ones, to_uint_of_int, mod1_out in h2.
  omega.
  split.
  unfold max_int.
  rewrite <- Z.le_add_le_sub_l.
  simpl (_+_).
  apply Z.lt_le_pred, id_lt_pow2.
  unfold size_int.
  omega.
  split.
  unfold max_int.
  apply Z.lt_le_pred, Pow2int.pow2pos.
  unfold size_int; omega.
  omega.
Qed.

(* Why3 goal *)
Definition lsr_bv: t -> t -> t.
  exact (fun v w => lsr v (to_uint w)).
Defined.

(* Why3 goal *)
Lemma lsr_bv_is_lsr : forall (x:t) (n:t), ((lsr_bv x n) = (lsr x
  (to_uint n))).
  easy.
Qed.

Lemma bvec_to_nat_tl: forall {l} v, Z.of_nat (bvec_to_nat l (Vector.tl v)) = Z.of_nat (bvec_to_nat (S l) v) / 2.
  apply Vector.rectS; intros.
  simpl.
  symmetry; case a.
  apply Zdiv_1_l; omega.
  apply Zdiv_0_l.
  simpl (Vector.tl (a :: v)).
  case a.
  change (Z.of_nat (bvec_to_nat (S n) v) =
   Z.of_nat (S (2 * bvec_to_nat (S n) v)) / 2).
  rewrite Nat2Z.inj_succ, Nat2Z.inj_mul, Z.mul_comm, <-Z.add_1_l.
  rewrite Z.div_add, Zdiv_1_l by omega; omega.
  change (Z.of_nat (bvec_to_nat (S n) v) =
   Z.of_nat (2 * bvec_to_nat (S n) v) / 2).
  rewrite Nat2Z.inj_mul, Z.mul_comm, Z_div_mult_full; omega.
Qed.

Lemma bvec_to_nat_shiftin: forall {l} v, bvec_to_nat (S l) (Vector.shiftin false v) = bvec_to_nat l v.
  induction v.
  easy.
  case h; simpl; rewrite IHv; easy.
Qed.

Lemma to_uint_lsr_aux : forall (v:t) (n:nat), ((to_uint (lsr v
  (Z.of_nat n))) = (div (to_uint v) (Pow2int.pow2 (Z.of_nat n)))).
  unfold div.
  intros; case Z_le_dec; [|intro e; destruct e; apply Z_mod_lt, lt_sym, Pow2int.pow2pos; omega].
  revert v n.
  induction n; intro.
  simpl.
  assert (lsr v 0 = v) as H by easy; rewrite H; symmetry; apply Zdiv_1_r.
  unfold lsr.
  rewrite Nat2Z.id.
  simpl BshiftRl_iter.
  unfold BshiftRl, Bhigh, to_uint, div.
  rewrite bvec_to_nat_tl.
  rewrite bvec_to_nat_shiftin.
  rewrite Nat2Z.inj_succ, <-Z.add_1_r, Pow2int.Power_s by omega.
  rewrite Z.mul_comm, <-Zdiv_Zdiv.
  rewrite <- Nat2Z.id with (n := n).
  change (to_uint (lsr v (Z.of_nat n)) / 2 =
          to_uint v / Pow2int.pow2 (Z.of_nat (Z.to_nat (Z.of_nat n))) / 2).
  rewrite Nat2Z.id.
  rewrite IHn.
  omega.
  apply Z_mod_lt, lt_sym, Pow2int.pow2pos; omega.
  apply Z.lt_le_incl, Pow2int.pow2pos; omega.
  omega.
Qed.

(* Why3 goal *)
Lemma to_uint_lsr : forall (v:t) (n:t), ((to_uint (lsr_bv v
  n)) = (int.EuclideanDivision.div (to_uint v)
  (bv.Pow2int.pow2 (to_uint n)))).
  intros v n.
  apply to_uint_lsr_aux.
Qed.

(* Why3 goal *)
Definition asr_bv: t -> t -> t.
  exact (fun v w => asr v (to_uint w)).
Defined.

(* Why3 goal *)
Lemma asr_bv_is_asr : forall (x:t) (n:t), ((asr_bv x n) = (asr x
  (to_uint n))).
  easy.
Qed.

(* Why3 goal *)
Definition lsl_bv: t -> t -> t.
  exact (fun v w => lsl v (to_uint w)).
Defined.

(* Why3 goal *)
Lemma lsl_bv_is_lsl : forall (x:t) (n:t), ((lsl_bv x n) = (lsl x
  (to_uint n))).
  easy.
Qed.

Lemma bvec_to_nat_shiftout_mod1 : forall {l} v, Z.of_nat (bvec_to_nat l (Vector.shiftout v)) = (Z.of_nat (bvec_to_nat (S l) v)) mod (Pow2int.pow2 (Z.of_nat l)).
  intros.
  revert l v.
  apply Vector.rectS; intros.
  simpl.
  symmetry; apply Zmod_1_r.
  case a.
  change (Z.of_nat (S (2 * bvec_to_nat n (Vector.shiftout v))) = (Z.of_nat (S (2 * bvec_to_nat (S n) v))) mod (Pow2int.pow2 (Z.of_nat (S n)))).
  rewrite Nat2Z.inj_succ with (n := n), <-Z.add_1_r with (n := Z.of_nat n), Pow2int.Power_s by omega.
  rewrite Nat2Z.inj_succ, Nat2Z.inj_succ, <-Z.add_1_l, <-Z.add_1_l, Nat2Z.inj_mul, Nat2Z.inj_mul.
  rewrite Z.rem_mul_r.
  rewrite Zmod_odd.
  assert (Z.odd (1 + Z.of_nat 2 * Z.of_nat (bvec_to_nat (S n) v)) = true) by (rewrite Z.odd_add_mul_2; easy).
  rewrite H0.
  rewrite Int.Comm1 with (y := Z.of_nat (bvec_to_nat (S n) v)), Z_div_plus_full, Zdiv_1_l by easy.
  rewrite H; easy.
  omega.
  apply Pow2int.pow2pos; omega.
  change (Z.of_nat (2 * bvec_to_nat n (Vector.shiftout v)) = (Z.of_nat (2 * bvec_to_nat (S n) v)) mod (Pow2int.pow2 (Z.of_nat (S n)))).
  rewrite Nat2Z.inj_succ with (n := n), <-Z.add_1_r with (n := Z.of_nat n), Pow2int.Power_s by omega.
  rewrite Nat2Z.inj_mul, Nat2Z.inj_mul.
  rewrite Zmult_mod_distr_l.
  rewrite H; trivial.
Qed.

Lemma to_uint_lsl_aux : forall (v:t) (n:nat), ((to_uint (lsl v
  (Z.of_nat n))) = (mod1 ((to_uint v) * (Pow2int.pow2 (Z.of_nat n)))%Z
  (max_int + 1%Z)%Z)).
  intros v n.
  rewrite mod1_is_mod.
  Focus 2.
  unfold max_int.
  rewrite Z.sub_1_r, Z.add_1_r, <-Zsucc_pred, <-lt_sym.
  apply Pow2int.pow2pos; unfold size_int; omega.
  induction n.
  simpl.
  apply Zmod_unique with (q := 0).
  apply to_uint_bounds_lt.
  assert (lsl v 0 = v) as H by easy; rewrite H; omega.
  unfold lsl.
  rewrite Nat2Z.id.
  unfold BshiftL, Bcons, to_uint.
  simpl BshiftL_iter.
  rewrite <- Nat2Z.id with (n := n).
  change (Z.of_nat (2 * bvec_to_nat last_bit (Vector.shiftout (lsl v (Z.of_nat n)))) = (Z.of_nat (bvec_to_nat size v) * Pow2int.pow2 (Z.of_nat (S (Z.to_nat (Z.of_nat n)))))  mod (max_int + 1))%Z.
  rewrite Nat2Z.id.
  rewrite Nat2Z.inj_mul.
  rewrite bvec_to_nat_shiftout_mod1.
  change (2 * ((to_uint (lsl v (Z.of_nat n))) mod (Pow2int.pow2 (Z.of_nat last_bit))) = (to_uint v * Pow2int.pow2 (Z.of_nat (S n))) mod (max_int + 1)).
  unfold max_int.
  rewrite Z.sub_1_r, Z.add_1_r, <-Zsucc_pred, size_int_S.
  rewrite Nat2Z.inj_succ, <-Z.add_1_r, Pow2int.Power_s by omega.
  rewrite Zmult_assoc, Int.Comm1 with (y := 2), <-Z.add_1_r, Pow2int.Power_s by omega.
  rewrite Zmult_assoc_reverse, Zmult_mod_distr_l.
  rewrite Z.mul_cancel_l by omega.
  rewrite IHn.
  unfold max_int.
  rewrite Z.sub_1_r, Z.add_1_r, <-Zsucc_pred.
  rewrite size_int_S, <-Z.add_1_r, Pow2int.Power_s by omega.
  apply mod_mod_mult.
  apply lt_sym, Pow2int.pow2pos; omega.
  omega.
Qed.

(* Why3 goal *)
Lemma to_uint_lsl : forall (v:t) (n:t), ((to_uint (lsl_bv v
  n)) = (int.EuclideanDivision.mod1 ((to_uint v) * (bv.Pow2int.pow2 (to_uint n)))%Z
  (max_int + 1%Z)%Z)).
  intros v n.
  apply to_uint_lsl_aux.
Qed.

(* Why3 goal *)
Lemma two_power_size_val : ((max_int + 1%Z)%Z = (bv.Pow2int.pow2 size_int)).
  unfold max_int.
  omega.
Qed.

(* Why3 assumption *)
Definition eq_sub_bv (a:t) (b:t) (i:t) (n:t): Prop := let mask :=
  (lsl_bv (sub (lsl_bv (of_int 1%Z) n) (of_int 1%Z)) i) in ((bw_and b
  mask) = (bw_and a mask)).

(* Why3 assumption *)
Definition eq_sub (a:t) (b:t) (i:Z) (n:Z): Prop := forall (j:Z),
  ((i <= j)%Z /\ (j < (i + n)%Z)%Z) -> ((nth a j) = (nth b j)).

(* Why3 goal *)
Lemma eq_sub_equiv : forall (a:t) (b:t) (i:t) (n:t), (eq_sub a b (to_uint i)
  (to_uint n)) <-> (eq_sub_bv a b i n).
intros a b i n.
admit.
Qed.

(* Why3 goal *)
Lemma Extensionality : forall (x:t) (y:t), (eq_sub x y 0%Z size_int) ->
  (x = y).
  intros x y.
  apply Extensionality_aux.
Qed.

