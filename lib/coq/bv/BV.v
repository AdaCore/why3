(********************************************************************)
(*                                                                  *)
(*  The Why3 Verification Platform   /   The Why3 Development Team  *)
(*  Copyright 2010-2015   --   INRIA - CNRS - Paris-Sud University  *)
(*                                                                  *)
(*  This software is distributed under the terms of the GNU Lesser  *)
(*  General Public License version 2.1, with the special exception  *)
(*  on linking described in file LICENSE.                           *)
(*                                                                  *)
(********************************************************************)

(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require bv.Pow2int.

(* Why3 goal *)
Definition size_int: Z.

Defined.

(* Why3 goal *)
Definition t : Type.

Defined.

(* Why3 goal *)
Definition max_int: Z.

Defined.

(* Why3 goal *)
Definition to_int: t -> Z.

Defined.

(* Why3 goal *)
Definition to_uint: t -> Z.

Defined.

(* Why3 goal *)
Definition of_int: Z -> t.

Defined.

(* Why3 goal *)
Lemma size_int_pos : (0%Z < size_int)%Z.


Qed.

(* Why3 goal *)
Lemma to_uint_extensionality : forall (v:t) (v':t),
  ((to_uint v) = (to_uint v')) -> (v = v').
intros v v' h1.

Qed.

(* Why3 goal *)
Lemma to_int_extensionality : forall (v:t) (v':t),
  ((to_int v) = (to_int v')) -> (v = v').
intros v v' h1.

Qed.

(* Why3 assumption *)
Definition uint_in_range (i:Z): Prop := (0%Z <= i)%Z /\ (i <= max_int)%Z.

(* Why3 goal *)
Lemma to_uint_bounds : forall (v:t), (uint_in_range (to_uint v)).
intros v.

Qed.

(* Why3 goal *)
Lemma to_uint_of_int : forall (i:Z), (uint_in_range i) ->
  ((to_uint (of_int i)) = i).
intros i h1.

Qed.

(* Why3 assumption *)
Definition ult (x:t) (y:t): Prop := ((to_uint x) < (to_uint y))%Z.

(* Why3 assumption *)
Definition ule (x:t) (y:t): Prop := ((to_uint x) <= (to_uint y))%Z.

(* Why3 assumption *)
Definition ugt (x:t) (y:t): Prop := ((to_uint y) < (to_uint x))%Z.

(* Why3 assumption *)
Definition uge (x:t) (y:t): Prop := ((to_uint y) <= (to_uint x))%Z.

(* Why3 assumption *)
Definition slt (v1:t) (v2:t): Prop := ((to_int v1) < (to_int v2))%Z.

(* Why3 assumption *)
Definition sle (v1:t) (v2:t): Prop := ((to_int v1) <= (to_int v2))%Z.

(* Why3 assumption *)
Definition sgt (v1:t) (v2:t): Prop := ((to_int v2) < (to_int v1))%Z.

(* Why3 assumption *)
Definition sge (v1:t) (v2:t): Prop := ((to_int v2) <= (to_int v1))%Z.

(* Why3 goal *)
Definition nth: t -> Z -> bool.

Defined.

(* Why3 goal *)
Definition nth_bv: t -> t -> bool.

Defined.

(* Why3 goal *)
Lemma Nth_bv_is_nth : forall (x:t) (i:t), ((nth_bv x i) = (nth x
  (to_uint i))).
intros x i.

Qed.

(* Why3 goal *)
Definition zero: t.

Defined.

(* Why3 goal *)
Lemma Of_int_zero : (zero = (of_int 0%Z)).


Qed.

(* Why3 goal *)
Lemma Nth_zero : forall (n:Z), ((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((nth zero n) = false).
intros n (h1,h2).

Qed.

(* Why3 goal *)
Definition ones: t.

Defined.

(* Why3 goal *)
Lemma Of_int_ones : (ones = (of_int max_int)).


Qed.

(* Why3 goal *)
Lemma Nth_ones : forall (n:Z), ((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((nth ones n) = true).
intros n (h1,h2).

Qed.

(* Why3 assumption *)
Definition eq (v1:t) (v2:t): Prop := forall (n:Z), ((0%Z <= n)%Z /\
  (n < size_int)%Z) -> ((nth v1 n) = (nth v2 n)).

(* Why3 goal *)
Lemma Extensionality : forall (x:t) (y:t), (eq x y) -> (x = y).
intros x y h1.

Qed.

(* Why3 goal *)
Definition add: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma to_uint_add : forall (v1:t) (v2:t), ((to_uint (add v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) + (to_uint v2))%Z
  (max_int + 1%Z)%Z)).
intros v1 v2.

Qed.

(* Why3 goal *)
Definition sub: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma to_uint_sub : forall (v1:t) (v2:t), ((to_uint (sub v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) - (to_uint v2))%Z
  (max_int + 1%Z)%Z)).
intros v1 v2.

Qed.

(* Why3 goal *)
Definition neg: t -> t.

Defined.

(* Why3 goal *)
Lemma to_uint_neg : forall (v:t),
  ((to_uint (neg v)) = (int.EuclideanDivision.mod1 (-(to_uint v))%Z
  (max_int + 1%Z)%Z)).
intros v.

Qed.

(* Why3 goal *)
Definition mul: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma to_uint_mul : forall (v1:t) (v2:t), ((to_uint (mul v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) * (to_uint v2))%Z
  (max_int + 1%Z)%Z)).
intros v1 v2.

Qed.

(* Why3 goal *)
Definition udiv: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma to_uint_udiv : forall (v1:t) (v2:t), ((to_uint (udiv v1
  v2)) = (int.EuclideanDivision.div (to_uint v1) (to_uint v2))).
intros v1 v2.

Qed.

(* Why3 goal *)
Definition urem: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma to_uint_urem : forall (v1:t) (v2:t), ((to_uint (urem v1
  v2)) = (int.EuclideanDivision.mod1 (to_uint v1) (to_uint v2))).
intros v1 v2.

Qed.

(* Why3 goal *)
Definition bw_and: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma Nth_bw_and : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < size_int)%Z) -> ((nth (bw_and v1 v2) n) = (Init.Datatypes.andb (nth v1
  n) (nth v2 n))).
intros v1 v2 n (h1,h2).

Qed.

(* Why3 goal *)
Definition bw_or: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma Nth_bw_or : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < size_int)%Z) -> ((nth (bw_or v1 v2) n) = (Init.Datatypes.orb (nth v1
  n) (nth v2 n))).
intros v1 v2 n (h1,h2).

Qed.

(* Why3 goal *)
Definition bw_xor: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma Nth_bw_xor : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < size_int)%Z) -> ((nth (bw_xor v1 v2) n) = (Init.Datatypes.xorb (nth v1
  n) (nth v2 n))).
intros v1 v2 n (h1,h2).

Qed.

(* Why3 goal *)
Definition bw_not: t -> t.

Defined.

(* Why3 goal *)
Lemma Nth_bw_not : forall (v:t) (n:Z), ((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((nth (bw_not v) n) = (Init.Datatypes.negb (nth v n))).
intros v n (h1,h2).

Qed.

(* Why3 goal *)
Definition rotate_right: t -> t -> t.

Defined.

(* Why3 goal *)
Definition rotate_left: t -> t -> t.

Defined.

(* Why3 goal *)
Lemma Nth_rotate_left : forall (v:t) (n:t) (i:t), (ult i
  (of_int size_int)) -> ((nth_bv v i) = (nth_bv (rotate_left v n)
  (urem (add i n) (of_int size_int)))).
intros v n i h1.

Qed.

(* Why3 goal *)
Lemma Nth_rotate_right : forall (v:t) (n:t) (i:t), (ult i
  (of_int size_int)) -> ((nth_bv (rotate_right v n) i) = (nth_bv v
  (urem (add i n) (of_int size_int)))).
intros v n i h1.

Qed.

(* Why3 goal *)
Definition lsr_bv: t -> t -> t.

Defined.

(* Why3 goal *)
Definition lsr: t -> Z -> t.

Defined.

(* Why3 goal *)
Lemma lsr_bv_is_lsr : forall (x:t) (n:t), ((lsr_bv x n) = (lsr x
  (to_uint n))).
intros x n.

Qed.

(* Why3 goal *)
Lemma Lsr_nth_low : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((n + s)%Z < size_int)%Z -> ((nth (lsr b s) n) = (nth b (n + s)%Z)))).
intros b n s (h1,h2) (h3,h4) h5.

Qed.

(* Why3 goal *)
Lemma Lsr_nth_high : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((size_int <= (n + s)%Z)%Z -> ((nth (lsr b s) n) = false))).
intros b n s (h1,h2) (h3,h4) h5.

Qed.

(* Why3 goal *)
Lemma to_uint_lsr : forall (v:t) (n:t), ((to_uint (lsr_bv v
  n)) = (int.EuclideanDivision.div (to_uint v)
  (bv.Pow2int.pow2 (to_uint n)))).
intros v n.

Qed.

(* Why3 goal *)
Definition asr_bv: t -> t -> t.

Defined.

(* Why3 goal *)
Definition asr: t -> Z -> t.

Defined.

(* Why3 goal *)
Lemma asr_bv_is_asr : forall (x:t) (n:t), ((asr_bv x n) = (asr x
  (to_uint n))).
intros x n.

Qed.

(* Why3 goal *)
Lemma Asr_nth_low : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((0%Z <= (n + s)%Z)%Z /\ ((n + s)%Z < size_int)%Z) -> ((nth (asr b s)
  n) = (nth b (n + s)%Z)))).
intros b n s (h1,h2) (h3,h4) (h5,h6).

Qed.

(* Why3 goal *)
Lemma Asr_nth_high : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  ((size_int <= (n + s)%Z)%Z -> ((nth (asr b s) n) = (nth b
  (size_int - 1%Z)%Z)))).
intros b n s (h1,h2) (h3,h4) h5.

Qed.

(* Why3 goal *)
Definition lsl_bv: t -> t -> t.

Defined.

(* Why3 goal *)
Definition lsl: t -> Z -> t.

Defined.

(* Why3 goal *)
Lemma lsl_bv_is_lsl : forall (x:t) (n:t), ((lsl_bv x n) = (lsl x
  (to_uint n))).
intros x n.

Qed.

(* Why3 goal *)
Lemma Lsl_nth_high : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((0%Z <= (n - s)%Z)%Z /\ ((n - s)%Z < size_int)%Z) -> ((nth (lsl b s)
  n) = (nth b (n - s)%Z)))).
intros b n s (h1,h2) (h3,h4) (h5,h6).

Qed.

(* Why3 goal *)
Lemma Lsl_nth_low : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  (s < size_int)%Z) -> (((0%Z <= n)%Z /\ (n < size_int)%Z) ->
  (((n - s)%Z < 0%Z)%Z -> ((nth (lsl b s) n) = false))).
intros b n s (h1,h2) (h3,h4) h5.

Qed.

(* Why3 goal *)
Lemma to_uint_lsl : forall (v:t) (n:t), ((to_uint (lsl_bv v
  n)) = (int.EuclideanDivision.mod1 ((to_uint v) * (bv.Pow2int.pow2 (to_uint n)))%Z
  (max_int + 1%Z)%Z)).
intros v n.

Qed.

(* Why3 goal *)
Lemma two_power_size_val : ((max_int + 1%Z)%Z = (bv.Pow2int.pow2 size_int)).


Qed.

