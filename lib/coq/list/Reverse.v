(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require list.List.
Require list.Length.
Require list.Mem.
Require list.Append.

(* Why3 goal *)
Lemma reverse_def : forall {a:Type} {a_WT:WhyType a}, forall (l:(list a)),
  ((Lists.List.rev l) = match l with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | (Init.Datatypes.cons x r) =>
      (Init.Datatypes.app (Lists.List.rev r) (Init.Datatypes.cons x Init.Datatypes.nil))
  end).
Proof.
now intros a a_WT [|x l].
Qed.

(* Why3 goal *)
Lemma reverse_append : forall {a:Type} {a_WT:WhyType a}, forall (l1:(list a))
  (l2:(list a)) (x:a),
  ((Init.Datatypes.app (Lists.List.rev (Init.Datatypes.cons x l1)) l2) = (Init.Datatypes.app (Lists.List.rev l1) (Init.Datatypes.cons x l2))).
Proof.
intros a a_WT l1 l2 x.
simpl.
now rewrite <- List.app_assoc.
Qed.

(* Why3 goal *)
Lemma reverse_reverse : forall {a:Type} {a_WT:WhyType a},
  forall (l:(list a)), ((Lists.List.rev (Lists.List.rev l)) = l).
Proof.
intros a a_WT l.
apply List.rev_involutive.
Qed.

(* Why3 goal *)
Lemma Reverse_length : forall {a:Type} {a_WT:WhyType a}, forall (l:(list a)),
  ((list.Length.length (Lists.List.rev l)) = (list.Length.length l)).
Proof.
intros a a_WT l.
rewrite 2!Length.length_std.
now rewrite List.rev_length.
Qed.

