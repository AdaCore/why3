(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require set.Set.
Require settheory.Relation.

Import set.Set.

(* Why3 goal *)
Definition inverse: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, (set.Set.set (a* b)%type) -> (set.Set.set (b*
  a)%type).
intros a a_WT b b_WT s.
exact (fun p => match p with (x,y) => mem (y,x) s end).
Defined.

(* Why3 goal *)
Lemma Inverse_def : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (r:(set.Set.set (a* b)%type)),
  forall (x:a) (y:b), (set.Set.mem (y, x) (inverse r)) <-> (set.Set.mem (x,
  y) r).
intros a a_WT b b_WT r x y.
unfold inverse, mem; tauto.
Qed.

(* Why3 goal *)
Definition dom: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (set.Set.set (a* b)%type) -> (set.Set.set a).
intros a a_WT b b_WT s.
exact (fun x => exists y, mem (x,y) s).
Defined.

(* Why3 goal *)
Lemma dom_def : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (r:(set.Set.set (a* b)%type)), forall (x:a), (set.Set.mem x
  (dom r)) <-> exists y:b, (set.Set.mem (x, y) r).
intros a a_WT b b_WT r x.
unfold dom; intuition.
Qed.

(* Why3 goal *)
Definition ran: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (set.Set.set (a* b)%type) -> (set.Set.set b).
intros a a_WT b b_WT s.
exact (fun y => exists x, mem (x,y) s).
Defined.

(* Why3 goal *)
Lemma ran_def : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (r:(set.Set.set (a* b)%type)), forall (y:b), (set.Set.mem y
  (ran r)) <-> exists x:a, (set.Set.mem (x, y) r).
intros a a_WT b b_WT r y.
unfold ran; intuition.
Qed.

(* Why3 goal *)
Lemma dom_empty : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  ((dom (set.Set.empty :(set.Set.set (a*
  b)%type))) = (set.Set.empty :(set.Set.set a))).
intros a a_WT b b_WT.
apply extensionality; intro x.
rewrite dom_def.
split.
intros (y,h); auto.
unfold mem, empty; intuition.
Qed.

(* Why3 goal *)
Lemma dom_add : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(set.Set.set (a* b)%type)) (x:a) (y:b), ((dom (set.Set.add (x, y)
  f)) = (set.Set.add x (dom f))).
intros a a_WT b b_WT f x y.
apply extensionality.
intro z.
rewrite add_def1.
do 2 rewrite dom_def.
split.
intro H; destruct H.
rewrite add_def1 in H.
destruct H.
inversion H; intuition.
right; exists x0; auto.
intro H; destruct H.
subst z.
exists y; rewrite add_def1; auto.
destruct H.
exists x0; rewrite add_def1; auto.
Qed.


