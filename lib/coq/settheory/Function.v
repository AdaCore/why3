(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require set.Set.
Require settheory.Relation.
Require settheory.InverseDomRan.

Import set.Set.
Import settheory.InverseDomRan.

(* Why3 goal *)
Definition infix_plmngt: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, (set.Set.set a) -> (set.Set.set b) ->
  (set.Set.set (set.Set.set (a* b)%type)).
intros a a_WT b b_WT s t.
exact (fun r => subset (dom r) s /\ subset (ran r) t /\
         forall x y1 y2, mem (x,y1) r /\ mem (x,y2) r ->
            y1 = y2).
Defined.

(* Why3 goal *)
Lemma mem_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)), (set.Set.mem f (infix_plmngt s
  t)) <-> ((forall (x:a) (y:b), (set.Set.mem (x, y) f) -> ((set.Set.mem x
  s) /\ (set.Set.mem y t))) /\ forall (x:a) (y1:b) (y2:b), ((set.Set.mem (x,
  y1) f) /\ (set.Set.mem (x, y2) f)) -> (y1 = y2)).
intros a a_WT b b_WT f s t.
unfold infix_plmngt, mem.
unfold dom, ran.
unfold subset.
unfold mem.
split.
intros (h1 & h2 & h3).
split; auto.
intros x y h.
split.
apply h1.
now exists y.
apply h2.
now exists x.
intros (h1 & h2).
split.
intros x (y,h).
generalize (h1 x y h); tauto.
split.
intros y (x,h).
generalize (h1 x y h); tauto.
assumption.
Qed.

(* Why3 goal *)
Lemma domain_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (x:a) (y:b), (set.Set.mem f
  (infix_plmngt s t)) -> ((set.Set.mem (x, y) f) -> (set.Set.mem x s)).
intros a a_WT b b_WT f s t x y (h1 & _) h4.
apply h1.
apply dom_def.
now exists y.
Qed.

(* Why3 goal *)
Lemma range_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (x:a) (y:b), (set.Set.mem f
  (infix_plmngt s t)) -> ((set.Set.mem (x, y) f) -> (set.Set.mem y t)).
intros a a_WT b b_WT f s t x y h1 h2.
apply h1.
apply ran_def.
now exists x.
Qed.

(* Why3 goal *)
Lemma function_extend_range : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (u:(set.Set.set b)),
  (set.Set.subset t u) -> ((set.Set.mem f (infix_plmngt s t)) ->
  (set.Set.mem f (infix_plmngt s u))).
intros a a_WT b b_WT f s t u h1 h2.
unfold infix_plmngt, mem in *.
intuition.
now apply subset_trans with t.
Qed.

(* Why3 goal *)
Lemma function_reduce_range : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (u:(set.Set.set b)),
  (set.Set.subset u t) -> ((set.Set.mem f (infix_plmngt s t)) ->
  ((forall (x:a) (y:b), (set.Set.mem (x, y) f) -> (set.Set.mem y u)) ->
  (set.Set.mem f (infix_plmngt s u)))).
intros a a_WT b b_WT f s t u h1 h2 h3.
unfold infix_plmngt, mem in *.
intuition.
unfold subset.
intros y h.
destruct h as (x,h).
unfold ran, mem in h.
unfold mem; now apply h3 with (x:=x).
Qed.

(* Why3 goal *)
Definition infix_mnmngt: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, (set.Set.set a) -> (set.Set.set b) ->
  (set.Set.set (set.Set.set (a* b)%type)).
intros a a_WT b b_WT s t.
exact (fun f => mem f (infix_plmngt s t) /\ dom f = s).
Defined.

(* Why3 goal *)
Lemma mem_total_functions : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)), (set.Set.mem f (infix_mnmngt s
  t)) <-> ((set.Set.mem f (infix_plmngt s t)) /\
  ((settheory.InverseDomRan.dom f) = s)).
intros a a_WT b b_WT f s t.
unfold infix_mnmngt, mem.
intuition.
Qed.

(* Why3 goal *)
Lemma total_function_is_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)), (set.Set.mem f (infix_mnmngt s
  t)) -> (set.Set.mem f (infix_plmngt s t)).
intros a a_WT b b_WT f s t h1.
unfold infix_mnmngt, mem in h1.
unfold mem; tauto.
Qed.

(* Why3 goal *)
Lemma singleton_is_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (x:a) (y:b), (set.Set.mem (set.Set.add (
  x, y) (set.Set.empty :(set.Set.set (a* b)%type)))
  (infix_mnmngt (set.Set.add x (set.Set.empty :(set.Set.set a)))
  (set.Set.add y (set.Set.empty :(set.Set.set b))))).
intros a a_WT b b_WT x y.
rewrite mem_total_functions.
split.

rewrite mem_function.
split.

intros x' y'.
repeat rewrite set.Set.add_def1.
(*
repeat rewrite set.Set.mem_empty.
Anomaly: unknown meta ?1230. Please report.
*)
intuition; inversion H0; auto.

intros x0 y1 y2.
repeat rewrite set.Set.add_def1.
intuition; inversion H; inversion H0; auto.

rewrite dom_add.
rewrite dom_empty; auto.

Qed.

Require Import ClassicalEpsilon.

(* Why3 goal *)
Definition apply: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (set.Set.set (a* b)%type) -> a -> b.
intros a a_WT b b_WT f x.
assert (i: inhabited b) by (apply inhabits; assumption).
exact (epsilon i (fun y:b => mem x (dom f) -> mem (x,y) f)).
Defined.

(* Why3 goal *)
Lemma apply_def0 : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (a1:a), ((set.Set.mem f
  (infix_plmngt s t)) /\ (set.Set.mem a1 (settheory.InverseDomRan.dom f))) ->
  (set.Set.mem (a1, (apply f a1)) f).
intros a a_WT b b_WT f s t a1 (h1,h2).
unfold apply.
unfold mem.
unfold mem in h2.
generalize h2.
apply epsilon_spec.
destruct (classic (dom f a1)).
destruct H as (x, h).
exists x.
intro.
apply h.
exists b_WT.
tauto.
Qed.

(* Why3 goal *)
Lemma apply_def1 : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (a1:a), ((set.Set.mem f
  (infix_mnmngt s t)) /\ (set.Set.mem a1 s)) -> (set.Set.mem (a1, (apply f
  a1)) f).
intros a a_WT b b_WT f s t a1 (h1 & h2).
eapply apply_def0.
split.
apply total_function_is_function; eauto.
destruct h1.
subst s; auto.
Qed.

(* Why3 goal *)
Lemma apply_def2 : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (a1:a) (b1:b), ((set.Set.mem f
  (infix_plmngt s t)) /\ (set.Set.mem (a1, b1) f)) -> ((apply f a1) = b1).
intros a a_WT b b_WT f s t a1 b1 (h1,h2).
generalize h1; intro h1'.
rewrite mem_function in h1.
destruct h1 as (_ & h).
apply h with (x:=a1).
split; auto.
eapply apply_def0; split.
eauto.
rewrite dom_def.
exists b1; auto.
Qed.

(* Why3 goal *)
Lemma injection : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(set.Set.set (a* b)%type)) (s:(set.Set.set a)) (t:(set.Set.set
  b)), forall (x:a) (y:a), (set.Set.mem f (infix_mnmngt s t)) ->
  ((set.Set.mem (settheory.InverseDomRan.inverse f) (infix_plmngt t s)) ->
  ((set.Set.mem x s) -> ((set.Set.mem y s) -> (((apply f x) = (apply f y)) ->
  (x = y))))).
intros a a_WT b b_WT f s t x y h1 h2 h3 h4 h5.
destruct h2 as (h6 & h7 & h8).
apply h8 with (apply f x).
split.
unfold inverse, mem.
apply apply_def1 with s t; tauto.
rewrite h5.
unfold inverse, mem.
apply apply_def1 with s t; tauto.
Qed.

(* Why3 goal *)
Lemma apply_singleton : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (x:a) (y:b), ((apply (set.Set.add (x, y)
  (set.Set.empty :(set.Set.set (a* b)%type))) x) = y).
intros a a_WT b b_WT x y.
rewrite apply_def2 with (s:=(add x empty)) 
  (t:=(add y empty)) (b1 := y); auto.
split.
apply total_function_is_function.
apply singleton_is_function.
apply add_def1; auto.
Qed.

(* Why3 goal *)
Definition semicolon: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b} {c:Type} {c_WT:WhyType c}, (set.Set.set (a*
  b)%type) -> (set.Set.set (b* c)%type) -> (set.Set.set (a* c)%type).
intros a a_WT b b_WT c c_WT f g.
exact (fun p => match p with 
  (x,z) => exists y:b, f (x,y) /\ g (y,z) end).
Defined.

(* Why3 goal *)
Lemma semicolon_def : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b} {c:Type} {c_WT:WhyType c}, forall (x:a) (z:c)
  (p:(set.Set.set (a* b)%type)) (q:(set.Set.set (b* c)%type)), (set.Set.mem (
  x, z) (semicolon p q)) <-> exists y:b, (set.Set.mem (x, y) p) /\
  (set.Set.mem (y, z) q).
intros a a_WT b b_WT c c_WT x z p q.
tauto.
Qed.

(* Why3 goal *)
Lemma semicolon_is_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b} {c:Type} {c_WT:WhyType c}, forall (f:(set.Set.set
  (a* b)%type)) (g:(set.Set.set (b* c)%type)) (s:(set.Set.set a))
  (t:(set.Set.set b)) (u:(set.Set.set c)), ((set.Set.mem f (infix_plmngt s
  t)) /\ (set.Set.mem g (infix_plmngt t u))) -> (set.Set.mem (semicolon f g)
  (infix_plmngt s u)).
intros a a_WT b b_WT c c_WT f g s t u ((f1&f2&f3),(g1&g2&g3)).
rewrite mem_function.
split.
intros x z (y & h1 & h2).
split.
apply f1; exists y; auto.
apply g2; exists y; auto.
intros x y1 y2 ((h1&h2&h3)&(i1&i2&i3)).
eapply g3.
split. apply h3.
assert (h1=i1).
eapply f3.
split. apply h2. apply i2.
subst i1.
apply i3.
Qed.

(* Why3 goal *)
Lemma apply_compose : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b} {c:Type} {c_WT:WhyType c}, forall (x:a)
  (f:(set.Set.set (a* b)%type)) (g:(set.Set.set (b* c)%type)) (s:(set.Set.set
  a)) (t:(set.Set.set b)) (u:(set.Set.set c)), ((set.Set.mem f
  (infix_plmngt s t)) /\ ((set.Set.mem g (infix_plmngt t u)) /\
  ((set.Set.mem x (settheory.InverseDomRan.dom f)) /\ (set.Set.mem (apply f
  x) (settheory.InverseDomRan.dom g))))) -> ((apply (semicolon f g)
  x) = (apply g (apply f x))).
intros a a_WT b b_WT c c_WT x f g s t u (h1 & h2 & h3 & h4).
eapply apply_def2.
split.
eapply semicolon_is_function.
split; eauto.
rewrite semicolon_def.
exists (apply f x).
split.
eapply apply_def0.
split.
eauto.
assumption.
eapply apply_def0.
split.
eauto.
assumption.
Qed.


