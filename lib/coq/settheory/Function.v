(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require set.Set.
Require settheory.Relation.
Require settheory.InverseDomRan.

Import set.Set.
Import settheory.InverseDomRan.

(* Why3 goal *)
Definition infix_plmngt: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, (set.Set.set a) -> (set.Set.set b) ->
  (set.Set.set (set.Set.set (a* b)%type)).
intros a a_WT b b_WT s t.
exact (fun r => subset (dom r) s /\ subset (ran r) t /\
         forall x y1 y2, mem (x,y1) r /\ mem (x,y2) r ->
            y1 = y2).
Defined.

(* Why3 goal *)
Lemma mem_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)), (set.Set.mem f (infix_plmngt s
  t)) <-> ((forall (x:a) (y:b), (set.Set.mem (x, y) f) -> ((set.Set.mem x
  s) /\ (set.Set.mem y t))) /\ forall (x:a) (y1:b) (y2:b), ((set.Set.mem (x,
  y1) f) /\ (set.Set.mem (x, y2) f)) -> (y1 = y2)).
intros a a_WT b b_WT f s t.
unfold infix_plmngt, mem.
unfold dom, ran.
unfold subset.
unfold mem.
split.
intros (h1 & h2 & h3).
split; auto.
intros x y h.
split.
apply h1.
now exists y.
apply h2.
now exists x.
intros (h1 & h2).
split.
intros x (y,h).
generalize (h1 x y h); tauto.
split.
intros y (x,h).
generalize (h1 x y h); tauto.
assumption.
Qed.

(* Why3 goal *)
Lemma domain_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (x:a) (y:b), (set.Set.mem f
  (infix_plmngt s t)) -> ((set.Set.mem (x, y) f) -> (set.Set.mem x s)).
intros a a_WT b b_WT f s t x y (h1 & _) h4.
apply h1.
apply dom_def.
now exists y.
Qed.

(* Why3 goal *)
Lemma range_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (x:a) (y:b), (set.Set.mem f
  (infix_plmngt s t)) -> ((set.Set.mem (x, y) f) -> (set.Set.mem y t)).
intros a a_WT b b_WT f s t x y h1 h2.
apply h1.
apply ran_def.
now exists x.
Qed.

(* Why3 goal *)
Lemma function_extend_range : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (u:(set.Set.set b)),
  (set.Set.subset t u) -> ((set.Set.mem f (infix_plmngt s t)) ->
  (set.Set.mem f (infix_plmngt s u))).
intros a a_WT b b_WT f s t u h1 h2.
unfold infix_plmngt, mem in *.
intuition.
now apply subset_trans with t.
Qed.

(* Why3 goal *)
Lemma function_reduce_range : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (u:(set.Set.set b)),
  (set.Set.subset u t) -> ((set.Set.mem f (infix_plmngt s t)) ->
  ((forall (x:a) (y:b), (set.Set.mem (x, y) f) -> (set.Set.mem y u)) ->
  (set.Set.mem f (infix_plmngt s u)))).
intros a a_WT b b_WT f s t u h1 h2 h3.
unfold infix_plmngt, mem in *.
intuition.
unfold subset.
intros y h.
destruct h as (x,h).
unfold ran, mem in h.
unfold mem; now apply h3 with (x:=x).
Qed.

(* Why3 goal *)
Definition infix_mnmngt: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, (set.Set.set a) -> (set.Set.set b) ->
  (set.Set.set (set.Set.set (a* b)%type)).
intros a a_WT b b_WT s t.
exact (fun f => mem f (infix_plmngt s t) /\ dom f = s).
Defined.

(* Why3 goal *)
Lemma mem_total_functions : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)), (set.Set.mem f (infix_mnmngt s
  t)) <-> ((set.Set.mem f (infix_plmngt s t)) /\
  (set.Set.infix_eqeq (settheory.InverseDomRan.dom f) s)).
intros a a_WT b b_WT f s t.
unfold infix_mnmngt, mem.
intuition.
now subst s.
apply predicate_extensionality; assumption.
Qed.

(* Why3 goal *)
Lemma total_function_is_function : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)), (set.Set.mem f (infix_mnmngt s
  t)) -> (set.Set.mem f (infix_plmngt s t)).
intros a a_WT b b_WT f s t h1.
unfold infix_mnmngt, mem in h1.
unfold mem; tauto.
Qed.

Require Import ClassicalEpsilon.

(* Why3 goal *)
Definition apply: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (set.Set.set (a* b)%type) -> a -> b.
intros a a_WT b b_WT f x.
assert (i: inhabited b) by (apply inhabits; assumption).
exact (epsilon i (fun y:b => mem x (dom f) -> mem (x,y) f)).
Defined.

(* Why3 goal *)
Lemma apply_def1 : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (a1:a), ((set.Set.mem a1 s) /\
  (set.Set.mem f (infix_mnmngt s t))) -> (set.Set.mem (a1, (apply f a1)) f).
intros a a_WT b b_WT f s t a1 (h1 & h2 & h3).
unfold apply.
unfold mem.
cut (dom f a1). 
apply epsilon_spec.
destruct (classic (dom f a1)).
destruct H as (x, h).
exists x.
intro.
apply h.
exists b_WT.
tauto.
rewrite h3.
now apply h1.
Qed.

(* Why3 goal *)
Lemma apply_def2 : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (f:(set.Set.set (a* b)%type))
  (s:(set.Set.set a)) (t:(set.Set.set b)) (a1:a) (b1:b), ((set.Set.mem f
  (infix_mnmngt s t)) /\ (set.Set.mem (a1, b1) f)) -> (b1 = (apply f a1)).
intros a a_WT b b_WT f s t a1 b1 (h1,h2).
generalize h1; intros (h3 & h4).
destruct h3 as (h5 & h6 & h7).
apply h7 with a1.
split; auto.
apply apply_def1 with s t.
split; auto.
rewrite <- h4.
unfold dom, mem.
now exists b1.
Qed.

(* Why3 goal *)
Lemma injection : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(set.Set.set (a* b)%type)) (s:(set.Set.set a)) (t:(set.Set.set
  b)), forall (x:a) (y:a), (set.Set.mem f (infix_mnmngt s t)) ->
  ((set.Set.mem (settheory.InverseDomRan.inverse f) (infix_plmngt t s)) ->
  ((set.Set.mem x s) -> ((set.Set.mem y s) -> (((apply f x) = (apply f y)) ->
  (x = y))))).
intros a a_WT b b_WT f s t x y h1 h2 h3 h4 h5.
destruct h2 as (h6 & h7 & h8).
apply h8 with (apply f x).
split.
unfold inverse, mem.
apply apply_def1 with s t; tauto.
rewrite h5.
unfold inverse, mem.
apply apply_def1 with s t; tauto.
Qed.


