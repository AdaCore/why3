
(* The Why prelude *)

theory Int 

  logic (<) (int, int)
  logic (<=)(int, int)
  logic (>) (int, int)
  logic (>=)(int, int)
  
  logic (+) (int, int) : int
  logic (-) (int, int) : int
  logic (*) (int, int) : int
  logic (/) (int, int) : int
  logic (%) (int, int) : int

  logic neg(int) : int
  
  (* ring structure *)
  axiom Add_assoc:    forall x,y,z:int. x+(y+z) = (x+y)+z
  axiom Add_comm:     forall x,y:int. x+y = y+x
  axiom Zero_neutral: forall x:int. x+0 = x
  axiom Neg:          forall x:int. x+neg(x) = 0
  axiom Mul_assoc:    forall x,y,z:int. x*(y*z) = (x*y)*z
  axiom Mul_distr:    forall x,y,z:int. x*(y+z) = x*y + x*z

  (* int is a unitary, communtative ring *)
  axiom Mul_comm:     forall x,y:int. x*y = y*x
  axiom One_neutral:  forall x:int. 1*x = x

end

theory Real

  logic (<) (real, real)
  logic (<=)(real, real)
  logic (>) (real, real)
  logic (>=)(real, real)
  
  logic (+) (real, real) : real
  logic (-) (real, real) : real
  logic (*) (real, real) : real
  logic (/) (real, real) : real

  logic neg(real) : real
  logic inv(real) : real

  (* field structure *)
  axiom Add_assoc:    forall x,y,z:real. x+(y+z) = (x+y)+z
  axiom Add_comm:     forall x,y:real. x+y = y+x
  axiom Mul_comm:     forall x,y:real. x*y = y*x
  axiom Zero_neutral: forall x:real. x+0. = x
  axiom Neg:          forall x:real. x+neg(x) = 0.
  axiom Mul_assoc:    forall x,y,z:real. x*(y*z) = (x*y)*z
  axiom Mul_distr:    forall x,y,z:real. x*(y+z) = x*y + x*z
  axiom One_neutral:  forall x:real. 1.*x = x
  axiom Inv:          forall x:real. x*inv(x) = 1.

end

theory Bool

  type bool = True | False

end

theory List

  type 'a list = Nil | Cons('a, 'a list)

  logic is_nil(x : 'a list) = x = Nil

end

theory Array

  type ('a,'b) t

  logic select (('a,'b) t, 'a) : 'b
  logic store (('a,'b) t, 'a, 'b) : ('a,'b) t
  
  axiom Select_eq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
    a1 = a2 -> select(store(m,a1,b),a2) = b

  axiom Select_neq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
    a1 <> a2 -> select(store(m,a1,b),a2) = select(m,a2)

  logic const('b) : ('a,'b) t

  axiom Const : forall b:'b. forall a:'a. select(const(b),a) = b

end

theory Set

  type 'a t 

  logic mem('a, 'a t)

  logic empty : 'a t

  axiom Empty_def1 : forall x : 'a. not mem(x, empty)

  logic add('a, 'a t) : 'a t

  axiom Add_def1 : 
    forall x, y : 'a. forall s : 'a t.
    mem(x, add(y, s)) <-> (x = y or mem(x, s))

  logic union('a t, 'a t) : 'a t

  axiom Union_def1 : 
    forall s1, s2 : 'a t. forall x : 'a.
    mem(x, union(s1, s2)) <-> (mem(x, s1) or mem(x, s2))

  logic inter('a t, 'a t) : 'a t

  axiom Inter_def1 : 
    forall s1, s2 : 'a t. forall x : 'a.
    mem(x, inter(s1, s2)) <-> (mem(x, s1) and mem(x, s2))

  logic diff('a t, 'a t) : 'a t

  axiom Diff_def1 : 
    forall s1, s2 : 'a t. forall x : 'a.
    mem(x, diff(s1, s2)) <-> (mem(x, s1) and not mem(x, s2))

  logic equal(s1 : 'a t, s2 : 'a t) = forall x : 'a. mem(x, s1) <-> mem(x, s2)

  logic subset(s1 : 'a t, s2 : 'a t) = forall x : 'a. mem(x, s1) -> mem(x, s2)

end



(*
Local Variables: 
compile-command: "make -C ../.. test"
End: 
*)
