
(* The Why prelude *)

theory Int 

  logic (_< _) (int, int)
  logic (_<=_)(int, int)
  logic (_> _) (int, int)
  logic (_>=_)(int, int)
  
  logic (_+_) (int, int) : int
  logic (_-_) (int, int) : int
  logic (_*_) (int, int) : int
  logic (_/_) (int, int) : int
  logic (_%_) (int, int) : int

  logic zero : int = 0
  logic (-_)(int) : int
  
  (* ring structure *)
  clone export math.RingStructure with 
     type t = int, logic zero = zero, 
     logic (_+_) = (_+_), logic (_*_) = (_*_), logic (-_) = (-_)

  (* int is a unitary, commutative ring *)
  axiom Mul_comm:     forall x,y:int. x * y = y * x
  axiom One_neutral:  forall x:int. 1 * x = x

end

theory Real

  logic (_< _) (real, real)
  logic (_<=_)(real, real)
  logic (_> _) (real, real)
  logic (_>=_)(real, real)
  
  logic (_+_) (real, real) : real
  logic (_-_) (real, real) : real
  logic (_*_) (real, real) : real
  logic (_/_) (real, real) : real

  logic (-_)(real) : real
  logic inv(real) : real

  (* field structure *)
  axiom Add_assoc:    forall x,y,z:real. x + (y + z) = (x + y) + z
  axiom Add_comm:     forall x,y:real. x + y = y + x
  axiom Mul_comm:     forall x,y:real. x * y = y * x
  axiom Zero_neutral: forall x:real. x + 0. = x
  axiom Neg:          forall x:real. x + -x = 0.
  axiom Mul_assoc:    forall x,y,z:real. x * (y * z) = (x * y) * z
  axiom Mul_distr:    forall x,y,z:real. x * (y + z) = x * y + x * z
  axiom One_neutral:  forall x:real. 1. * x = x
  axiom Inv:          forall x:real. x * inv(x) = 1.

end

theory Bool

  type bool = True | False

end

theory List

  type 'a list = Nil | Cons('a, 'a list)

  logic is_nil(x : 'a list) = x = Nil

  logic mem(x: 'a, l : 'a list) = match l with
    | Nil -> false
    | Cons(y, r) -> x = y or mem(x, r)
    end

end

theory Array

  type ('a,'b) t

  logic select (('a,'b) t, 'a) : 'b
  logic store (('a,'b) t, 'a, 'b) : ('a,'b) t
  
  axiom Select_eq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
    a1 = a2 -> select(store(m,a1,b),a2) = b

  axiom Select_neq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
    a1 <> a2 -> select(store(m,a1,b),a2) = select(m,a2)

  logic const('b) : ('a,'b) t

  axiom Const : forall b:'b. forall a:'a. select(const(b),a) = b

end

theory Set

  type 'a t 

  logic mem('a, 'a t)

  logic empty : 'a t

  axiom Empty_def1 : forall x : 'a. not mem(x, empty)

  logic add('a, 'a t) : 'a t

  axiom Add_def1 : 
    forall x, y : 'a. forall s : 'a t.
    mem(x, add(y, s)) <-> (x = y or mem(x, s))

  logic union('a t, 'a t) : 'a t

  axiom Union_def1 : 
    forall s1, s2 : 'a t. forall x : 'a.
    mem(x, union(s1, s2)) <-> (mem(x, s1) or mem(x, s2))

  logic inter('a t, 'a t) : 'a t

  axiom Inter_def1 : 
    forall s1, s2 : 'a t. forall x : 'a.
    mem(x, inter(s1, s2)) <-> (mem(x, s1) and mem(x, s2))

  logic diff('a t, 'a t) : 'a t

  axiom Diff_def1 : 
    forall s1, s2 : 'a t. forall x : 'a.
    mem(x, diff(s1, s2)) <-> (mem(x, s1) and not mem(x, s2))

  logic equal(s1 : 'a t, s2 : 'a t) = forall x : 'a. mem(x, s1) <-> mem(x, s2)

  logic subset(s1 : 'a t, s2 : 'a t) = forall x : 'a. mem(x, s1) -> mem(x, s2)

end



(*
Local Variables: 
compile-command: "make -C ../.. test"
End: 
*)
