
(* The Why prelude *)

theory Int 

  logic (<) (int, int)
  logic (<=)(int, int)
  logic (>) (int, int)
  logic (>=)(int, int)
  
  logic ( + ) (int, int) : int
  logic ( - ) (int, int) : int
  logic ( * ) (int, int) : int
  logic ( / ) (int, int) : int
  logic ( % ) (int, int) : int

  logic neg(int) : int
  
  (* ring structure *)
  axiom Add_assoc: forall x,y,z:int. x+(y+z) = (x+y)+z
  axiom Add_comm: forall x,y:int. x+y = y+x
  axiom Zero_neutral: forall x:int. x+0 = x
  axiom Neg: forall x:int. x+neg(x) = 0
  axiom Mul_assoc: forall x,y,z:int. x*(y*z) = (x*y)*z
  axiom Mul_distr: forall  x,y,z:int. x*(y+z) = x*y + x*z

  (* int is a unitary, communtative ring *)
  axiom Mul_comm: forall x,y:int. x*y = y*x
  axiom Unitary: forall x:int. 1*x = x

end

theory Real

  logic (<) (real, real)
  logic (<=)(real, real)
  logic (>) (real, real)
  logic (>=)(real, real)
  
  logic ( + ) (real, real) : real
  logic ( - ) (real, real) : real
  logic ( * ) (real, real) : real
  logic ( / ) (real, real) : real

  logic neg(real) : real
  logic inv(real) : real

  (* field structure *)
  axiom Add_assoc: forall x,y,z:real. x+(y+z) = (x+y)+z
  axiom Add_comm: forall x,y:real. x+y = y+x
  axiom Mul_comm: forall x,y:real. x*y = y*x
  axiom Zero_neutral: forall x:real. x+0. = x
  axiom Neg: forall x:real. x+neg(x) = 0.
  axiom Mul_assoc: forall x,y,z:real. x*(y*z) = (x*y)*z
  axiom Mul_distr: forall  x,y,z:real. x*(y+z) = x*y + x*z
  axiom Unitary: forall x:real. 1.*x = x
  axiom Inv: forall x:real. x*inv(x) = 1.

end

theory Bool

  (*type t = | True | False*)

end

theory List

  (* type 'a list = Nil | Cons ('a, 'a list) *)

  type 'a list

  logic nil : 'a list

  logic cons('a, 'a list) : 'a list

  logic is_nil('a list)

end

theory Array

  type ('a,'b) t

  logic select (('a,'b) t, 'a) : 'b
  logic store (('a,'b) t, 'a, 'b) : ('a,'b) t
  
  axiom Select_eq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
    a1 = a2 -> select(store(m,a1,b),a2) = b

  axiom Select_neq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. forall b : 'b.
    a1 <> a2 -> select(store(m,a1,b),a2) = select(m,a2)

  logic const('b) : ('a,'b) t

  axiom Const : forall b:'b. forall a:'a. select(const(b),a) = b

end

(*
Local Variables: 
compile-command: "make -C ../.. test"
End: 
*)
