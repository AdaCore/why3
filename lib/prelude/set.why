theory Set
  type 'a t 

  logic mem ('a , 'a t)

  logic empty : 'a t

  axiom empty_def1 : forall x:'a. not mem(x, empty)

  logic add ('a, 'a t) : 'a t

  axiom add_def1 : forall x,y:'a. forall s:'a t.
                   mem(x, add(y, s)) <-> (x = y or mem(x, s))
end

theory Set_list 
    use open List
    logic add(x:'a,s:'a t) : 'a t = Cons(x,s)   
    logic mem(x:'a,s:'a t) = match s with        
          | Nil -> false
          | Cons(x2,s2) -> x=x2 or mem(x,s2)
     
    theory Set_list  : Set with t = list
                                empty = Nil
                                add = add
                                mem = mem

    use include Set_list
end

theory Set_array
  uses Array, Bool
  type 'a t = ('a,Bool.t) Array.t

  (*logic empty : ('a,Bool.t) Array.t
  axiom empty : Eq.eq(empty,Array.const(Bool.False))*)
  logic empty : ('a,Bool.t) Array.t = Array.const(Bool.False)

  (*logic mem : 'a, ('a,Bool.t) Array.t -> prop
  axiom mem : forall s:'a t. forall e:'a. 
        mem(e,s) <-> Eq.eq(select(x,y),Bool.True)
        *)

  logic mem(s:'a t, e:'a) = select(x,y) = Bool.True

  (*logic add : 'a, ('a,Bool.t) Array.t -> ('a,Bool.t) Array.t (* add(x,s) = store(x,s,bool.True) *)
  axiom add : forall x:'a. forall s: ('a,Bool.t) Array.t. add(x,s) = store(s,x,Bool.True)*)
  logic add(x:'a,s: ('a,Bool.t) Array.t) : ('a,Bool.t) Array.t = store(s,x,Bool.True)

  theory Set_array  : Set with t = t
                               empty = empty
                               add = add
                               mem = mem

  use include Set_array

end