module Loop
 use import        "ref".Ref
 use import        "int".Int

function sum_of int : int

axiom sum_of_base :
   sum_of 0 = 0

axiom sum_of_ind :
   forall x : int. sum_of (x + 1) = sum_of x + x + 1

(* Valid *)
   val z : ref int

 let test1 (x : ref int) =
   { !x = 0 /\ !z = 0 }
   while !z < 10 do
      invariant { !x = sum_of !z /\ 0 <= !z <= 10}
      z := !z + 1;
      x := !x + !z
   done
   { !x = sum_of 10 }
end

module Loop2

 use import        "ref".Ref
 use import        "int".Int

   predicate even int

   val havoc : x : ref int ->
      {even !x}
      unit writes x
      {even !x}

(* Valid *)
   let test2 (x : ref int) =
   { even !x}
      loop
         invariant { even !x }
         havoc x
      end
   { even !x }

(* Valid *)
   let test3 (x : ref int) =
   { even !x }
      loop
         invariant { even !x }
         havoc x
      end
   { not (even !x) }

   predicate odd int

   val havoc_switch : x : ref int ->
      {even !x}
      unit writes x
      {odd !x}

(* Unknown *)
   let test4 (x : ref int) =
   { even !x }
      loop
         invariant { even !x }
         havoc_switch x
      end
   { odd !x }

exception Exit

(* Valid *)
 let test5 (x : ref int) =
   { }
   try
      loop
         invariant { }
         if !x = 0 then raise Exit
      end
   with Exit -> ()
   end
   { !x = 0 }

(* Valid *)
 let test6 (x : ref int) =
   { }
   try
      loop
         invariant { }
         x := !x + 1;
         if !x = 0 then raise Exit
      end
   with Exit -> ()
   end
   { !x = 0 }

(* Valid *)
 let test7 (x : ref int) =
   { }
   try
      loop
         invariant { }
         if !x = 0 then (
         x := !x + 1;
         raise Exit)
      end
   with Exit -> ()
   end
   { !x = 1 }

(* Unknown *)
 let test8 (x : ref int) =
   { }
   try
      loop
         invariant { }
         if !x = 0 then (
         x := !x + 1;
         raise Exit)
      end
   with Exit -> ()
   end
   { !x = 0 }

(* Unknown *)
 let test9 (x : ref int) =
   { }
   try
      loop
         invariant { }
         if !x = 0 then x := !x + 1
         else raise Exit
      end
   with Exit -> ()
   end
   { !x = 0 }

(* Valid *)
 let test10 (x : ref int) =
   { }
   try
      loop
         invariant { }
         if !x = 0 then x := !x + 1
         else raise Exit
      end
   with Exit -> ()
   end
   { !x <> 0 }
end
