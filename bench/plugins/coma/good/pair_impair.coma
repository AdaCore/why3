use coma.Tree
use coma.Size
use int.Int
use int.MinMax
use list.List
use list.FoldLeft

let halt [] = (? any)
let fail [] = { false } any

let unForest {f: forest} (cons [] {t: tree} {ff: forest}) (nil []) =
  any
  [ o [] {t: tree} {ff: forest} -> { f = Cons t ff } (! cons {t} {ff})
  | o []                        -> { f = Nil } (! nil) ]

let unTree {t: tree} (fo [] {v: int} {f: forest}) =
  any
  [ o [] {v: int} {f: forest} -> { t = Node v f } (! fo {v} {f}) ]

let rec ht {t: tree} (out {n:int}) =
  unTree {t}
         (fun {_v:int} {f: forest} -> hf {f} out)

with hf {f: forest} (out {n:int}) =
  hf_aux {f} (fun {l: list int} -> out {fold_left max 0 l} )

with hf_aux {f: forest} (out {l: list int}) =
  (! unForest {f}
           (fun {t: tree} {ff: forest} ->
              ht {t} (fun {n: int} ->
             hf_aux {ff} (fun {l: list int} ->
              out {Cons (n+1) l})))
           (-> out {Nil: list int}))

let cons {t: tree} {f: forest} (out {fo: forest}) =
  (! bk {Cons t f})
  [ bk {fo : forest} ->
      hf {fo} (fun {h_fo: int} ->
      hf {f}  (fun {h_f:  int} ->
      ht {t}  (fun {h_t:  int} ->
        { h_fo = max h_t h_f }
        halt)))]
        -- (! out fo)))) ]


-- type forest = tree list
-- and  tree   = Node of int * forest

-- let rec ht = function
--     Node (_, f) ->
--       let l = hf f in
--       List.fold_left Int.max 0 l
-- and hf = function
--     [] -> []
--   | t::ff ->
--       let n = ht t in
--       (n+1) :: (hf ff)


-- let t0 = Node (0, [])
-- let t1 = Node (0, [t0])
-- let t2 = Node (0, [t0; t1; t1])

-- let () =
--   Format.print_int (ht t0);
--   Format.print_int (ht t1);
--   Format.print_int (ht t2);

