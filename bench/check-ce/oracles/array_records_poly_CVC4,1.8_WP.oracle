<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 27, characters 45-49:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_631:array basic_record) -> 0
  Line 20:
    mixfix [] :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_659:array basic_record)
                      (bOUND_VARIABLE_660:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 5
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_772:bool) (bOUND_VARIABLE_773:int)
                      (bOUND_VARIABLE_774:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 5
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_782:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_790:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_790:basic_record) -> 5
  Line 23:
    i : int = (- 1)
  Line 27:
    i : int = (- 1)

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 27, characters 21-25:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_640:array basic_record) -> 0
  Line 20:
    mixfix [] :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_668:array basic_record)
                      (bOUND_VARIABLE_669:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 5
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_781:bool) (bOUND_VARIABLE_782:int)
                      (bOUND_VARIABLE_783:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 5
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_791:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_799:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_799:basic_record) -> 5
  Line 23:
    i : int = (- 1)
  Line 27:
    i : int = (- 1)
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 27, characters 5-81:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_660:array basic_record) -> 0
  Line 20:
    mixfix [] :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_688:array basic_record)
                      (bOUND_VARIABLE_689:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 5
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_801:bool) (bOUND_VARIABLE_802:int)
                      (bOUND_VARIABLE_803:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 5
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_808:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_816:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_816:basic_record) -> 5
  Line 23:
    i : int = (- 1)
  Line 27:
    i : int = (- 1)
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 28, characters 64-68:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 16:
    elts :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_754:array basic_record) ->
                      fun (x:int) -> epsilon x1:basic_record.
                       x1.flag = True /\
                       x1.first_value = 3 /\ x1.second_value = 0
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_773:array basic_record) -> 0
  Line 20:
    mixfix [] :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_799:array basic_record)
                      (bOUND_VARIABLE_800:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_916:bool) (bOUND_VARIABLE_917:int)
                      (bOUND_VARIABLE_918:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 0
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_936:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_941:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_941:basic_record) -> 0
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
  Line 28:
    i : int = (- 1)

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 28, characters 21-25:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 16:
    elts :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_768:array basic_record) ->
                      fun (x:int) -> epsilon x1:basic_record.
                       x1.flag = True /\
                       x1.first_value = 3 /\ x1.second_value = 0
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_787:array basic_record) -> 0
  Line 20:
    mixfix [] :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_813:array basic_record)
                      (bOUND_VARIABLE_814:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_930:bool) (bOUND_VARIABLE_931:int)
                      (bOUND_VARIABLE_932:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 0
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_950:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_955:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_955:basic_record) -> 0
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
  Line 28:
    i : int = (- 1)
    result of call at line 28, characters 64-81 : int = 0
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 28, characters 5-82:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 16:
    elts :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_806:array basic_record) ->
                      fun (x:int) -> epsilon x1:basic_record.
                       x1.flag = True /\
                       x1.first_value = 3 /\ x1.second_value = 0
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_825:array basic_record) -> 0
  Line 20:
    mixfix [] :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_854:array basic_record)
                      (bOUND_VARIABLE_855:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_6301:bool) (bOUND_VARIABLE_6302:int)
                      (bOUND_VARIABLE_6303:int) -> epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 0
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_975:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_980:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_980:basic_record) -> 0
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
  Line 28:
    i : int = (- 1)
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 28, characters 21-30 : bool = True
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0
    result of call at line 28, characters 64-81 : int = 0
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 0

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 29, characters 64-68:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_917:array basic_record) -> 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_1091:bool) (bOUND_VARIABLE_1092:int)
                      (bOUND_VARIABLE_1093:int) ->
                      if bOUND_VARIABLE_1091
                      then if bOUND_VARIABLE_1092 = 3
                           then if bOUND_VARIABLE_1093 = 5 then epsilon x:
                                basic_record.
                                x.flag = True /\
                                x.first_value = 3 /\ x.second_value = 5
                                else epsilon x:basic_record.
                                x.flag = True /\
                                x.first_value = 3 /\ x.second_value = 69
                           else epsilon x:basic_record.
                           x.flag = True /\
                           x.first_value = 3 /\ x.second_value = 69
                      else epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 69
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_1111:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1116:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1116:basic_record) ->
             if (epsilon x:basic_record.
                x.flag = True /\ x.first_value = 3 /\ x.second_value = 69) =
                bOUND_VARIABLE_1116
             then 69 else 5
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5
  Line 28:
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 21-30 : bool = True
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 64-81 : int = 69
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
  Line 29:
    i : int = (- 1)

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 29, characters 21-25:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_931:array basic_record) -> 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_1105:bool) (bOUND_VARIABLE_1106:int)
                      (bOUND_VARIABLE_1107:int) ->
                      if bOUND_VARIABLE_1105
                      then if bOUND_VARIABLE_1106 = 3
                           then if bOUND_VARIABLE_1107 = 5 then epsilon x:
                                basic_record.
                                x.flag = True /\
                                x.first_value = 3 /\ x.second_value = 5
                                else epsilon x:basic_record.
                                x.flag = True /\
                                x.first_value = 3 /\ x.second_value = 69
                           else epsilon x:basic_record.
                           x.flag = True /\
                           x.first_value = 3 /\ x.second_value = 69
                      else epsilon x:basic_record.
                      x.flag = True /\
                      x.first_value = 3 /\ x.second_value = 69
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_1125:basic_record) -> True
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1130:basic_record) -> 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1130:basic_record) ->
             if (epsilon x:basic_record.
                x.flag = True /\ x.first_value = 3 /\ x.second_value = 69) =
                bOUND_VARIABLE_1130
             then 69 else 5
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 5
  Line 28:
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 21-30 : bool = True
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 64-81 : int = 69
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69
  Line 29:
    i : int = (- 1)
    result of call at line 29, characters 64-81 : int = 69
    result of call at line 29, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.flag = True /\ x.first_value = 3 /\ x.second_value = 69

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 29, characters 5-82:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 16:
    elts :
      array
      basic_record
      ->
      int
      ->
      basic_record = fun (bOUND_VARIABLE_954:array basic_record) ->
                      fun (x:int) ->
                       if x = (- 1) then epsilon x1:basic_record.
                       x1.flag = False /\
                       x1.first_value = 2 /\ x1.second_value = (- 2)
                       else epsilon x1:basic_record.
                       x1.flag = False /\
                       x1.first_value = 2 /\ x1.second_value = (- 2)
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_973:array basic_record) -> 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (_arg_1:bool) (_arg_2:int) (_arg_3:int) ->
                      if _arg_1 then epsilon x:basic_record.
                      x.flag = False /\
                      x.first_value = 2 /\ x.second_value = (- 2)
                      else if _arg_2 = 2
                           then if _arg_3 = 69 then epsilon x:basic_record.
                                x.flag = False /\
                                x.first_value = 2 /\ x.second_value = (- 2)
                                else epsilon x:basic_record.
                                x.flag = False /\
                                x.first_value = 2 /\ x.second_value = (- 2)
                           else if _arg_2 = 42
                                then if _arg_3 = (- 2) then epsilon x:
                                     basic_record.
                                     x.flag = False /\
                                     x.first_value = 2 /\
                                     x.second_value = (- 2) else epsilon x:
                                     basic_record.
                                     x.flag = False /\
                                     x.first_value = 2 /\
                                     x.second_value = (- 2)
                                else epsilon x:basic_record.
                                x.flag = False /\
                                x.first_value = 2 /\ x.second_value = (- 2)
  Line 16:
    flag :
      basic_record
      ->
      bool = fun (bOUND_VARIABLE_1152:basic_record) -> False
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1157:basic_record) -> 2
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1157:basic_record) -> (- 2)
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
    result of call at line 27, characters 21-30 : bool = False
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
    result of call at line 27, characters 45-61 : int = 2
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
  Line 28:
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
    result of call at line 28, characters 21-30 : bool = False
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
    result of call at line 28, characters 64-81 : int = (- 2)
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
  Line 29:
    i : int = (- 1)
    result of call at line 29, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
    result of call at line 29, characters 21-30 : bool = False
    result of call at line 29, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)
    result of call at line 29, characters 64-81 : int = (- 2)
    result of call at line 29, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.flag = False /\ x.first_value = 2 /\ x.second_value = (- 2)

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 30, characters 74-78:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1050:array basic_record) -> 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (_arg_1:bool) (_arg_2:int) (_arg_3:int) ->
                      if _arg_1
                      then if _arg_2 = 3
                           then if _arg_3 = 5 then epsilon x:basic_record.
                                x.first_value = 3 /\ x.second_value = 5
                                else if _arg_3 = 69 then epsilon x:
                                     basic_record.
                                     x.first_value = 3 /\ x.second_value = 69
                                     else epsilon x:basic_record.
                                     x.first_value = 23 /\
                                     x.second_value = 69
                           else if _arg_2 = 42
                                then if _arg_3 = 69 then epsilon x:
                                     basic_record.
                                     x.first_value = 42 /\
                                     x.second_value = 69 else epsilon x:
                                     basic_record.
                                     x.first_value = 23 /\
                                     x.second_value = 69
                                else epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                      else if _arg_2 = 23
                           then if _arg_3 = 69 then epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                                else epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                           else epsilon x:basic_record.
                           x.first_value = 23 /\ x.second_value = 69
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1274:basic_record) ->
             if bOUND_VARIABLE_1274 = (epsilon x:basic_record.
                x.first_value = 42 /\ x.second_value = 69)
             then 42
             else if (epsilon x:basic_record.
                     x.first_value = 23 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1274
                  then 23
                  else if (epsilon x:basic_record.
                          x.first_value = 23 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1274
                       then 23 else 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1274:basic_record) ->
             if bOUND_VARIABLE_1274 = (epsilon x:basic_record.
                x.first_value = 42 /\ x.second_value = 69)
             then 69
             else if (epsilon x:basic_record.
                     x.first_value = 3 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1274
                  then 69
                  else if (epsilon x:basic_record.
                          x.first_value = 23 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1274
                       then 69
                       else if (epsilon x:basic_record.
                               x.first_value = 23 /\ x.second_value = 69) =
                               bOUND_VARIABLE_1274
                            then 69 else 5
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
  Line 28:
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 28, characters 21-30 : bool = True
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 64-81 : int = 69
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
  Line 29:
    result of call at line 29, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 29, characters 21-30 : bool = True
    result of call at line 29, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 29, characters 64-81 : int = 69
    result of call at line 29, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
  Line 30:
    i : int = (- 1)

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 30, characters 41-45:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1064:array basic_record) -> 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (_arg_1:bool) (_arg_2:int) (_arg_3:int) ->
                      if _arg_1
                      then if _arg_2 = 3
                           then if _arg_3 = 5 then epsilon x:basic_record.
                                x.first_value = 3 /\ x.second_value = 5
                                else if _arg_3 = 69 then epsilon x:
                                     basic_record.
                                     x.first_value = 3 /\ x.second_value = 69
                                     else epsilon x:basic_record.
                                     x.first_value = 23 /\
                                     x.second_value = 69
                           else if _arg_2 = 42
                                then if _arg_3 = 69 then epsilon x:
                                     basic_record.
                                     x.first_value = 42 /\
                                     x.second_value = 69 else epsilon x:
                                     basic_record.
                                     x.first_value = 23 /\
                                     x.second_value = 69
                                else epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                      else if _arg_2 = 23
                           then if _arg_3 = 69 then epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                                else epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                           else epsilon x:basic_record.
                           x.first_value = 23 /\ x.second_value = 69
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1288:basic_record) ->
             if bOUND_VARIABLE_1288 = (epsilon x:basic_record.
                x.first_value = 42 /\ x.second_value = 69)
             then 42
             else if (epsilon x:basic_record.
                     x.first_value = 23 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1288
                  then 23
                  else if (epsilon x:basic_record.
                          x.first_value = 23 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1288
                       then 23 else 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1288:basic_record) ->
             if bOUND_VARIABLE_1288 = (epsilon x:basic_record.
                x.first_value = 42 /\ x.second_value = 69)
             then 69
             else if (epsilon x:basic_record.
                     x.first_value = 3 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1288
                  then 69
                  else if (epsilon x:basic_record.
                          x.first_value = 23 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1288
                       then 69
                       else if (epsilon x:basic_record.
                               x.first_value = 23 /\ x.second_value = 69) =
                               bOUND_VARIABLE_1288
                            then 69 else 5
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
  Line 28:
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 28, characters 21-30 : bool = True
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 64-81 : int = 69
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
  Line 29:
    result of call at line 29, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 29, characters 21-30 : bool = True
    result of call at line 29, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 29, characters 64-81 : int = 69
    result of call at line 29, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
  Line 30:
    i : int = (- 1)
    result of call at line 30, characters 74-91 : int = 69
    result of call at line 30, characters 74-78 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Checked model 2: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 30, characters 5-92:
Sub-goal Index in array bounds of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1083:array basic_record) -> 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (_arg_1:bool) (_arg_2:int) (_arg_3:int) ->
                      if _arg_1
                      then if _arg_2 = 3
                           then if _arg_3 = 5 then epsilon x:basic_record.
                                x.first_value = 3 /\ x.second_value = 5
                                else if _arg_3 = 69 then epsilon x:
                                     basic_record.
                                     x.first_value = 3 /\ x.second_value = 69
                                     else epsilon x:basic_record.
                                     x.first_value = 23 /\
                                     x.second_value = 69
                           else if _arg_2 = 42
                                then if _arg_3 = 69 then epsilon x:
                                     basic_record.
                                     x.first_value = 42 /\
                                     x.second_value = 69 else epsilon x:
                                     basic_record.
                                     x.first_value = 23 /\
                                     x.second_value = 69
                                else epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                      else if _arg_2 = 23
                           then if _arg_3 = 69 then epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                                else epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                           else epsilon x:basic_record.
                           x.first_value = 23 /\ x.second_value = 69
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1307:basic_record) ->
             if bOUND_VARIABLE_1307 = (epsilon x:basic_record.
                x.first_value = 42 /\ x.second_value = 69)
             then 42
             else if (epsilon x:basic_record.
                     x.first_value = 23 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1307
                  then 23
                  else if (epsilon x:basic_record.
                          x.first_value = 23 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1307
                       then 23 else 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1307:basic_record) ->
             if bOUND_VARIABLE_1307 = (epsilon x:basic_record.
                x.first_value = 42 /\ x.second_value = 69)
             then 69
             else if (epsilon x:basic_record.
                     x.first_value = 3 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1307
                  then 69
                  else if (epsilon x:basic_record.
                          x.first_value = 23 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1307
                       then 69
                       else if (epsilon x:basic_record.
                               x.first_value = 23 /\ x.second_value = 69) =
                               bOUND_VARIABLE_1307
                            then 69 else 5
  Line 23:
    i : int = (- 1)
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
  Line 28:
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 28, characters 21-30 : bool = True
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 64-81 : int = 69
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
  Line 29:
    result of call at line 29, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 29, characters 21-30 : bool = True
    result of call at line 29, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 29, characters 64-81 : int = 69
    result of call at line 29, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
  Line 30:
    i : int = (- 1)
    result of call at line 30, characters 13-92 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 30, characters 41-57 : int = 23
    result of call at line 30, characters 41-45 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 30, characters 74-91 : int = 69
    result of call at line 30, characters 74-78 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69

File "bench/check-ce/array_records_poly.mlw", line 31, characters 13-35:
Sub-goal Assertion of goal var_overwrite'vc.
Prover result is: Valid.

<check-ce-categorization>Categorizations of models:
- Checked model 0: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
- Selected model 1: INCOMPLETE
  - Concrete RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
  - Abstract RAC: INCOMPLETE (terminated because Precondition of `var_overwrite` cannot be evaluated)
File "bench/check-ce/array_records_poly.mlw", line 25, characters 15-36:
Sub-goal Postcondition of goal var_overwrite'vc.
Prover result is: Unknown or time/memory/step limit.
The following counterexample model could not be verified
  (both RAC terminated because Precondition of `var_overwrite` cannot be evaluated):
File array.mlw:
  Line 17:
    length :
      array
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1210:array basic_record) -> 0
File array_records_poly.mlw:
  Line 14:
    basic_record'mk :
      bool
      ->
      int
      ->
      int
      ->
      basic_record = fun (_arg_1:bool) (_arg_2:int) (_arg_3:int) ->
                      if _arg_1
                      then if _arg_2 = 3
                           then if _arg_3 = 5 then epsilon x:basic_record.
                                x.first_value = 3 /\ x.second_value = 5
                                else epsilon x:basic_record.
                                x.first_value = 3 /\ x.second_value = 69
                           else if _arg_2 = 42
                                then if _arg_3 = 69 then epsilon x:
                                     basic_record.
                                     x.first_value = 42 /\
                                     x.second_value = 69 else epsilon x:
                                     basic_record.
                                     x.first_value = 3 /\ x.second_value = 69
                                else if _arg_2 = 23
                                     then if _arg_3 = 69 then epsilon x:
                                          basic_record.
                                          x.first_value = 23 /\
                                          x.second_value = 69 else epsilon x:
                                          basic_record.
                                          x.first_value = 3 /\
                                          x.second_value = 69
                                     else epsilon x:basic_record.
                                     x.first_value = 3 /\ x.second_value = 69
                      else if _arg_2 = 23
                           then if _arg_3 = 69 then epsilon x:basic_record.
                                x.first_value = 23 /\ x.second_value = 69
                                else epsilon x:basic_record.
                                x.first_value = 3 /\ x.second_value = 69
                           else epsilon x:basic_record.
                           x.first_value = 3 /\ x.second_value = 69
  Line 17:
    first_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1479:basic_record) ->
             if (epsilon x:basic_record.
                x.first_value = 23 /\ x.second_value = 69) =
                bOUND_VARIABLE_1479
             then 23
             else if (epsilon x:basic_record.
                     x.first_value = 23 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1479
                  then 23
                  else if (epsilon x:basic_record.
                          x.first_value = 42 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1479
                       then 42 else 3
  Line 18:
    sec_val :
      basic_record
      ->
      int = fun (bOUND_VARIABLE_1479:basic_record) ->
             if (epsilon x:basic_record.
                x.first_value = 23 /\ x.second_value = 69) =
                bOUND_VARIABLE_1479
             then 69
             else if (epsilon x:basic_record.
                     x.first_value = 23 /\ x.second_value = 69) =
                     bOUND_VARIABLE_1479
                  then 69
                  else if (epsilon x:basic_record.
                          x.first_value = 42 /\ x.second_value = 69) =
                          bOUND_VARIABLE_1479
                       then 69
                       else if (epsilon x:basic_record.
                               x.first_value = 3 /\ x.second_value = 69) =
                               bOUND_VARIABLE_1479
                            then 69 else 5
  Line 23:
    i : int = 0
  Line 25:
    i : int = 0
  Line 27:
    result of call at line 27, characters 13-81 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 27, characters 21-30 : bool = True
    result of call at line 27, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
    result of call at line 27, characters 45-61 : int = 3
    result of call at line 27, characters 45-49 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 5
  Line 28:
    result of call at line 28, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 28, characters 21-30 : bool = True
    result of call at line 28, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
    result of call at line 28, characters 64-81 : int = 69
    result of call at line 28, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 3 /\ x.second_value = 69
  Line 29:
    result of call at line 29, characters 13-82 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 29, characters 21-30 : bool = True
    result of call at line 29, characters 21-25 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
    result of call at line 29, characters 64-81 : int = 69
    result of call at line 29, characters 64-68 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 42 /\ x.second_value = 69
  Line 30:
    result of call at line 30, characters 13-92 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 30, characters 41-57 : int = 23
    result of call at line 30, characters 41-45 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69
    result of call at line 30, characters 74-91 : int = 69
    result of call at line 30, characters 74-78 :
      basic_record = epsilon x:
      basic_record.
      x.first_value = 23 /\ x.second_value = 69

