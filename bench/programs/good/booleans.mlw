module M

use import int.Int
use import module ref.Ref

val incr : x:ref int -> { } unit writes x { !x = old !x + 1 }

val x : ref int

val id_not_0 : x:int -> { x <> 0 } int { result = x }

val id : x:int -> { } int { result = x }

let test_and_1 () =
  { }
  if (incr x; !x > 0) && id !x = 1 then !x else 0+1
  { result = 1 }

let test_and_2 () =
  { !x <> 0 }
  if id_not_0 !x >= 1 && !x <= 1 then !x else 0+1
  { result = 1 }

let test_or_1 () =
  { }
  if (incr x; !x > 0) || !x < 0 then 1 else 2
  { result = 1 -> !x <> 0 }

let test_or_2 () =
  { }
  if !x = 0 || !x = 1 then !x else 1
  { 0 <= result <= 1 }

let test_not_1 () =
  { }
  if not (!x = 0) then x := 0
  { !x = 0 }

let test_not_2 () =
  { !x <= 0 }
  while not (!x = 0) do invariant { !x <= 0 } incr x done
  { !x = 0 }

let test_all_1 () =
  { }
  (!x >= 0 && not (!x = 0) || !x >= 1)
  { result=True <-> !x>=1 }

(* from Cesar Munoz's CD3D *)

  function d : int

val vx : ref int
val vy : ref int

val sq : x:int -> {} int { result = x*x }

let test_cd3d () =
 { true }
 if !vx=0 && !vy=0 && sq !vx + sq !vy < sq d  then 1 else 2
 { result=1 -> !vx=0 /\ !vy=0 }

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../../.. bench/programs/good/booleans"
End:
*)

