module M
  use int.Int

  type int_type = Integer int

  goal G : forall x : int_type. match x with Integer y -> y > 0 end

  type t = A | B int

  goal g2: forall x. x = A

  goal g4: forall x. x = B 0

  type u = Au int int

  goal g5: forall x. x = Au 0 0

  type mylist = | Nil | Cons int mylist

  let rec function len l = match l with
  | Nil -> 0
  | Cons _ l' -> 1 + len l'
  end

  goal g1: forall l: mylist. len l = 0

  goal g7: forall l: mylist. l = Nil

  use list.List
  use list.Length

  goal g: forall l: list int. length l = 0


(*
  (*********************************
   ** Non-terminating projections **
   *********************************)
   (* Warning: if definition of the following projections are present,
      the proof of everything below will not terminate. *)
  function projfl "model_trace:.projfl" (l : list int_type) : int
  =
  match l with
  | Nil -> 0
  | Cons (Integer n) _ -> n
  | _ -> 0
  end
  meta "inline : no" function projfl
  meta "model_projection" function projfl

  (* list int_type will be projected using projfl to int,
     int will be projected using projfi, projf1, and projf2
     Warning: does not terminate. *)
  let proj_test ( l "model_projected" : list int_type) : int
  ensures { result > 0  }
  =
  match l with
  | Nil -> 1
  | Cons (Integer n) _ -> n
  | _ -> 1
  end


*)

end
