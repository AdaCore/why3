(* IEEE 754 floating point *)

(* some thoughts on the emulation using floating_point:
   - the emulation cannot deal with infinity or nan
   - the emulation cannot deal with signed zero
*)

theory IEEE_Float
   use export floating_point.Rounding

   use floating_point.GenFloat
   use import real.RealInfix

   type t

   constant bits_in_exponent    : int
   constant bits_in_significand : int
   constant rounding_mode       : mode

   function from_real (x:real) : t
   function to_real (x:t)      : real

   function from_int (x:int) : t
   function to_int (x:t)     : int

   function fp_abs "inline" (x:t) : t =
      (if to_real x <. 0.0 then from_real (-. to_real x) else x)
   (* absolute value, no rounding mode *)

   function fp_neg "inline" (x:t) : t =
      (from_real (-. (to_real x)))
   (* absolute value, no rounding mode *)

   function fp_add "inline" (x:t) (y:t) : t =
      from_real (GenFloat.round rounding_mode
                                ((to_real x) +. (to_real y)))

   function fp_sub "inline" (x:t) (y:t) : t =
      from_real (GenFloat.round rounding_mode
                                ((to_real x) -. (to_real y)))

   function fp_mul "inline" (x:t) (y:t) : t =
      from_real (GenFloat.round rounding_mode
                                ((to_real x) *. (to_real y)))

   function fp_div "inline" (x:t) (y:t) : t =
      from_real (GenFloat.round rounding_mode
                                ((to_real x) /. (to_real y)))


   function fp_fma "inline" (x:t) (y:t) (z:t) : t =
      from_real (GenFloat.round rounding_mode
                                ((to_real x) *. (to_real y) +. (to_real z)))
   (* fused multiplication and addition: x*y+z *)

   function fp_sqrt (x:t) : t

   function fp_rem (x:t) (y:t) : t
   (* x-y*n, where n in Z is nearest to x/y *)

   function roundToIntegral_RNE (x:t) : t
   function roundToIntegral_RNA (x:t) : t
   function roundToIntegral_RTZ (x:t) : t
   (* round to integral *)

   function fp_min (x:t) (y:t) : t =
      (if to_real x <. to_real y then x else y)

   function fp_max (x:t) (y:t) : t =
      (if to_real x >. to_real y then x else y)

   (*** comparison operators ***)

   predicate fp_eq  (x:t) (y:t)
   predicate fp_neq "inline" (x:t) (y:t) = not (fp_eq x y)
   predicate fp_leq "inline" (x:t) (y:t) = (to_real x) <=. (to_real y)
   predicate fp_lt  "inline" (x:t) (y:t) = (to_real x) <. (to_real y)
   predicate fp_geq "inline" (x:t) (y:t) = (to_real x) >=. (to_real y)
   predicate fp_gt  "inline" (x:t) (y:t) = (to_real x) >. (to_real y)

   (*** classification of numbers ***)

   predicate isNormal    t
   predicate isSubnormal t
   predicate isSignMinus t
   predicate isZero      t
   predicate isInfinite  t
   predicate isNaN       t

   (*** some constants ***)
   function fp_constant_zero : t = from_real 0.0

   (*** helper functions required by gnat2why ***)
   function floor (t)   : t
   function ceiling (t) : t

end

theory Single_RNE
   use export floating_point.Rounding

   type single

   constant be : int = 8
   constant sb : int = 24
   constant rm : mode = NearestTiesToEven

   clone export IEEE_Float with
      type t = single,
      constant bits_in_exponent = be,
      constant bits_in_significand = sb,
      constant rounding_mode = rm
end

theory Double_RNE
   use export floating_point.Rounding

   type double

   constant be : int = 11
   constant sb : int = 53
   constant rm : mode = NearestTiesToEven

   clone export IEEE_Float with
      type t = double,
      constant bits_in_exponent = be,
      constant bits_in_significand = sb,
      constant rounding_mode = rm
end

theory Single_RNE_Conversion
   use import Single_RNE
   use import Double_RNE

   function to_single_rne (x : single) : single = x
   function to_double_rne (x : single) : double
end

theory Double_RNE_Conversion
   use import Single_RNE
   use import Double_RNE

   function to_single_rne (x : double) : single
   function to_double_rne (x : double) : double = x
end
