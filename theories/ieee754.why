(* IEEE 754 floating point *)

(* some thoughts on the emulation using floating_point:
   - the emulation cannot deal with infinity or nan
   - the emulation cannot deal with signed zero
*)

theory IEEE_Rounding_Mode

   type mode

   function roundNearestTiesToEven : mode
   function roundNearestTiesToAway : mode
   function roundTowardPositive    : mode
   function roundTowardNegative    : mode
   function roundTowardZero        : mode

end

theory IEEE_Float
   use import IEEE_Rounding_Mode

   type t

   constant bits_in_exponent    : int
   constant bits_in_significand : int
   constant rounding_mode       : mode

   function from_real (x:real) : t
   function to_real (x:t)      : real

   function from_int (x:int) : t
   function to_int (x:t)     : int

   function fp_abs (x:t) : t
   (* absolute value, no rounding mode *)

   function fp_neg (x:t) : t
   (* absolute value, no rounding mode *)

   function fp_add (x:t) (y:t) : t
   function fp_sub (x:t) (y:t) : t
   function fp_mul (x:t) (y:t) : t
   function fp_div (x:t) (y:t) : t
   function fp_fma (x:t) (y:t) (z:t) : t
   (* fused multiplication and addition: x*y+z *)
   function fp_sqrt (x:t) : t
   function fp_rem (x:t) (y:t) : t
   (* x-y*n, where n in Z is nearest to x/y *)

   function roundToIntegral_RNE (x:t) : t
   function roundToIntegral_RNA (x:t) : t
   function roundToIntegral_RTZ (x:t) : t
   (* round to integral *)

   function fp_min (x:t) (y:t) : t
   function fp_max (x:t) (y:t) : t

   (*** comparison operators ***)

   predicate fp_eq  (x:t) (y:t)
   predicate fp_neq "inline" (x:t) (y:t) = not (fp_eq x y)
   predicate fp_leq (x:t) (y:t)
   predicate fp_lt  (x:t) (y:t)
   predicate fp_geq (x:t) (y:t)
   predicate fp_gt  (x:t) (y:t)

   (*** classification of numbers ***)

   predicate isNormal    t
   predicate isSubnormal t
   predicate isSignMinus t
   predicate isZero      t
   predicate isInfinite  t
   predicate isNaN       t

   (*** some constants ***)
   function fp_constant_zero : t = from_real 0.0

   (*** helper functions required by gnat2why ***)
   function floor (t)   : t
   function ceiling (t) : t

end

theory Single_RNE
   use import IEEE_Rounding_Mode

   type single

   constant be : int = 8
   constant sb : int = 24
   constant rm : mode = roundNearestTiesToEven

   clone export IEEE_Float with
      type t = single,
      constant bits_in_exponent = be,
      constant bits_in_significand = sb,
      constant rounding_mode = rm
end

theory Double_RNE
   use import IEEE_Rounding_Mode

   type double

   constant be : int = 11
   constant sb : int = 53
   constant rm : mode = roundNearestTiesToEven

   clone export IEEE_Float with
      type t = double,
      constant bits_in_exponent = be,
      constant bits_in_significand = sb,
      constant rounding_mode = rm
end

theory Single_RNE_Conversion
   use import Single_RNE
   use import Double_RNE

   function to_single_rne (x : single) : single = x
   function to_double_rne (x : single) : double
end

theory Double_RNE_Conversion
   use import Single_RNE
   use import Double_RNE

   function to_single_rne (x : double) : single
   function to_double_rne (x : double) : double = x
end
