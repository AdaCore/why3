(* Beware! Only edit allowed sections below    *)
(* This file is generated by Why3's Coq driver *)
Require Import ZArith.
Require Import Rbase.
Parameter param : Type.

Parameter infix_ls: Z -> Z  -> Prop.


Definition infix_lseq(x:Z) (y:Z): Prop := (infix_ls x y) \/ (x = y).

Parameter infix_pl: Z -> Z  -> Z.


Parameter prefix_mn: Z  -> Z.


Parameter infix_as: Z -> Z  -> Z.


Axiom Unit_def : forall (x:Z), ((infix_pl x 0%Z) = x).

Axiom Assoc : forall (x:Z) (y:Z) (z:Z), ((infix_pl (infix_pl x y)
  z) = (infix_pl x (infix_pl y z))).

Axiom Inv_def : forall (x:Z), ((infix_pl x (prefix_mn x)) = 0%Z).

Axiom Comm : forall (x:Z) (y:Z), ((infix_pl x y) = (infix_pl y x)).

Axiom Assoc1 : forall (x:Z) (y:Z) (z:Z), ((infix_as (infix_as x y)
  z) = (infix_as x (infix_as y z))).

Axiom Mul_distr : forall (x:Z) (y:Z) (z:Z), ((infix_as x (infix_pl y
  z)) = (infix_pl (infix_as x y) (infix_as x z))).

Definition infix_mn(x:Z) (y:Z): Z := (infix_pl x (prefix_mn y)).

Axiom Comm1 : forall (x:Z) (y:Z), ((infix_as x y) = (infix_as y x)).

Axiom Unitary : forall (x:Z), ((infix_as 1%Z x) = x).

Axiom NonTrivialRing : ~ (0%Z = 1%Z).

Axiom Refl : forall (x:Z), (infix_lseq x x).

Axiom Trans : forall (x:Z) (y:Z) (z:Z), (infix_lseq x y) -> ((infix_lseq y
  z) -> (infix_lseq x z)).

Axiom Antisymm : forall (x:Z) (y:Z), (infix_lseq x y) -> ((infix_lseq y x) ->
  (x = y)).

Axiom Total : forall (x:Z) (y:Z), (infix_lseq x y) \/ (infix_lseq y x).

Axiom CompatOrderAdd : forall (x:Z) (y:Z) (z:Z), (infix_lseq x y) ->
  (infix_lseq (infix_pl x z) (infix_pl y z)).

Axiom CompatOrderMult : forall (x:Z) (y:Z) (z:Z), (infix_lseq x y) ->
  ((infix_lseq 0%Z z) -> (infix_lseq (infix_as x z) (infix_as y z))).

Parameter pr: param -> Z  -> Prop.


Parameter num_of: param -> Z -> Z  -> Z.


Axiom Num_of_empty : forall (p:param) (a:Z) (b:Z), (infix_lseq b a) ->
  ((num_of p a b) = 0%Z).

Axiom Num_of_right_no_add : forall (p:param) (a:Z) (b:Z), (infix_ls a b) ->
  ((~ (pr p (infix_mn b 1%Z))) -> ((num_of p a b) = (num_of p a (infix_mn b
  1%Z)))).

Axiom Num_of_right_add : forall (p:param) (a:Z) (b:Z), (infix_ls a b) ->
  ((pr p (infix_mn b 1%Z)) -> ((num_of p a b) = (infix_pl 1%Z (num_of p a
  (infix_mn b 1%Z))))).

Theorem Num_of_non_negative : forall (p:param) (a:Z) (b:Z), (infix_lseq 0%Z
  (num_of p a b)).
(* YOU MAY EDIT THE PROOF BELOW *)
intros p a b.
assert (h: (a > b \/ a <= b)%Z) by omega.
destruct h.
rewrite Num_of_empty; auto with zarith.
   admit. admit.
generalize H; clear H.
generalize b; clear b.
apply Zlt_lower_bound_ind.
intros b Hind Hab.
assert (h: (a = b \/ a < b)%Z) by omega.
destruct h.
rewrite Num_of_empty; auto with zarith.
  admit. admit.
assert (h: (pr p (b - 1) \/ ~ pr p (b - 1))%Z).
  admit.
destruct h.
rewrite Num_of_right_add; auto with zarith.
  admit. admit. admit.
rewrite Num_of_right_no_add; auto with zarith.
  admit. admit. admit.
Qed.
(* DO NOT EDIT BELOW *)


