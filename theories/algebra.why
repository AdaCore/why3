
theory Assoc
  type t
  logic op(t, t) : t
  axiom Assoc : forall x,y,z:t. op (op x y) z = op x (op y z)
end

theory Comm
  type t
  logic op(t, t) : t
  axiom Comm : forall x,y:t. op x y = op y x
end

theory AC
  type t
  logic op(t, t) : t
  clone Assoc with type t = t, logic op = op
  clone Comm  with type t = t, logic op = op
end

theory Group
  type t
       
  logic unit : t
       
  logic op(t,t) : t
  logic inv(t) : t
       
  axiom Unit_def : forall x:t. op x unit = x

  clone Assoc with type t = t, logic op = op

  axiom Inv_def : forall x:t. op x (inv x) = unit
end

theory CommutativeGroup
  clone export Group
  clone Comm with type t = t, logic op = op
end

theory Ring
  type t
  logic zero : t
  logic (+)  (t, t) : t
  logic (-_) (t) : t
  logic (*)  (t, t) : t

  clone CommutativeGroup with type t = t,
                              logic unit = zero,
                              logic op = (+),
                              logic inv = (-_)

  clone Assoc with type t = t, logic op = (*)

  axiom Mul_distr: forall x,y,z:t. x * (y + z) = x * y + x * z

  logic (-) (x:t, y:t) : t = x + -y
end

theory CommutativeRing
  clone export Ring
  clone Comm with type t = t, logic op = (*)
end

theory UnitaryCommutativeRing
  clone export CommutativeRing
  logic one : t
  axiom Unitary : forall x:t. one * x = x
end

theory Field
  clone export UnitaryCommutativeRing 
  logic inv(t) : t
  axiom Inverse : forall x:t. x <> zero -> x * inv x = one
  logic (/) (x:t, y:t) : t = x * inv y
end
