(** {1 Formalization of Floating-Point Arithmetic}

  Full float theory (with infinities and NaN) only RNE rounding mode.
  Special values are not axiomatized.

  A note on intended semantics: we use the same idea as the SMTLIB floating
  point theory, that defers any inconsistencies to the "parent" document.
  Hence, in doubt, the correct axiomatisation is one that implements
  [BTRW14] "An Automatable Formal Semantics for IEEE-754 Floating-Point
  Arithmetic", which in turn defers any inconsistencies to IEE-754.

  This theory is split into two parts: the first part talks about IEEE
  operations and this is what you should use as a user, the second part is
  internal only and is an axiomatisation for the provers that do not
  natively support floating point. You should not use any symbols you find
  there in your verification conditions as solvers with native floating
  point support will leave them uninterpreted.
*)

theory GenericFloat

  use import int.Int
  use real.Abs
  use real.FromInt
  use real.Truncate
  use import real.RealInfix

  (*********************************************************************)
  (* {2 PART I - PUBLIC INTERFACE}                                     *)
  (*********************************************************************)

  (* the number of bits in the exponent.  *)
  constant eb : int
  (* the number of bits in the significand, including the hidden bit. *)
  constant sb : int

  axiom eb_gt_1: 1 < eb
  axiom sb_gt_1: 1 < sb

  (* {3 Sorts} *)

  type t

  (* {3 Constructors and Constants} *)

  constant zeroF     : t   (* +0.0 *)
  constant half      : t   (* 0.5 *)
  (* exp_bia = 2^(sb - 1) - 1 *)
  (* max_finite_exp = 2^sb - 2 - exp_bia = exp_bia *)
  (* max_signifacnd = (2^eb + 2^eb - 1) * 2^(1-eb) *)
  (* max_value = (2^eb + 2^eb - 1) * 2^(1-eb) * 2 ^ max_finite_exp *)
  (* [m;x] = ( 1 + m * 2^(1-eb) ) * 2^( x - exp_bia ) *)
  (* max_value = [2^(eb-1); 2^sb - 2] *)

  (* constructor, perform an unchecked convertion from the binary *)
  (* representation of a float. this is a workaround and should   *)
  (* only be used for literals!                                   *)
  function from_binary int  : t
  function (!)         real : t (* constructor from real literals *)

  (* {3 Operators} *)

  function abs       t   : t
  function (.-_)     t   : t (* fp.neg *)

  function (.+)      t t : t (* fp.add *)
  function (.-)      t t : t (* fp.sub *)
  function (.*)      t t : t (* fp.mul *)
  function (./)      t t : t (* fp.div *)

  function fma     t t t : t (* xy + z *)

  function sqrt      t   : t
  function rem       t t : t

  (* In Ada/SPARK we need sign-preserving floor/ceil in the case of 0,    *)
  (* but luckily this is the case for IEEE floats so we can use the below *)
  (* directly.                                                            *)
  function roundToIntegralTowardsPositive t : t
  function roundToIntegralTowardsNegative t : t
  function roundToIntegralTowardsZero     t : t
  function roundToIntegralTiesToAway      t : t

  (* Min & Max *)
  (* Note that we have to follow IEEE-754 and SMTLIB here. Two things to *)
  (* note in particular:                                                 *)
  (*    1) m?n(-0, 0) is either 0 or -0, there is a choice               *)
  (*    2) if either argument is NaN then the other argument is returned *)
  function min       t t : t
  function max       t t : t

  (** {3 Comparisons} *)

  predicate (.<=) t t (* fp.leq *)
  predicate (.<)  t t (* fp.lt  *)
  predicate (.>=) t t (* fp.geq *)
  predicate (.>)  t t (* fp.gt  *)

  predicate (.=)  t t (* fp.eq, NOT SMTLIB = *)

  (* {3 Classification of numbers} *)

  predicate is_normal    t
  predicate is_subnormal t
  predicate is_zero      (x:t) = x .= zeroF
  predicate is_infinite  t
  predicate is_nan       t
  predicate is_positive  t
  predicate is_negative  t

  (* helper predicate for zero, normal and subnormals. not defined so that *)
  (* the axiomatisation below can use it without talking about subnormals  *)
  predicate is_finite    t

  (* {3 Conversions from other sorts} *)

  (* from bitvec binary interchange                           *)
  (*   partly done with from_binary (for literals only)       *)
  (* from another fp                 - see FloatConverter     *)
  (* from real                                                *)
  (*   partly done with (!) (for literals only)               *)
  (* from unsigned integer bitvector - see Float_BV_Converter *)
  (* from signed integer bitvector                            *)

  (* {3 Conversions to other sorts} *)

  (* to unsigned integer bitvector   - see Float_BV_Converter *)
  (* to signed integer bitvector                              *)
  (* to real *)
  function to_real   t    : real

  (*********************************************************************)
  (* {2 PART II - PRIVATE AXIOMATISATION}                              *)
  (*********************************************************************)

  (* {3 Constructors and Constants} *)
  axiom zeroF_to_real     : to_real zeroF = 0.0
  axiom zeroF_is_positive : is_positive zeroF
  axiom half_to_real      : to_real half  = 0.5

  (* {3 Conversions from other sorts} *)

  (* with mathematical int *)
  (* note that these conversions do not feature in SMTLIB *)

  (* intended semantics for of_int are the same as (_ to_fp eb sb) RNE with *)
  (* a suitably sized bitvector, large enough to hold x                     *)
  (* note values >= than the below should result in infinities              *)
  (*    float32 : 0x1ffffff * 2^103                                         *)
  (*    float64 : 0x3fffffffffffff * 2^970                                  *)
  (* also note that this function never yields a subnormal, or a nan, or -0 *)
  function of_int (x : int) : t

  (* {3 Conversions to other sorts} *)

  (* Intended semantics for to_int are the same as (_ fp.to_sbv) RNE with  *)
  (* a suitably sized bitvector. Safe minimum sizes are given below:       *)
  (*    float32 : 129                                                      *)
  (*    float64 : 1025                                                     *)
  (* In particular this function should be uninterpreted for infinities    *)
  (* and NaN. Take care that no conclusion can be made on the result based *)
  (* on the size of the bitvector chosen in those cases, i.e. this should  *)
  (* not hold:                                                             *)
  (*    to_int +INF < 2 ** 2048     // nope                                *)
  (*    to_int +INF > 0             // nope                                *)
  function to_int (x : t) : int

  axiom zero_of_int : zeroF = of_int 0

  (* {3 Arithmetic} *)

  (* The intended meaning for round is the RNE rounding for floating point *)
  (* as described on p17 of IEEE-754. For results where the corresponding  *)
  (* floating point result would be infinity or NaN this function should   *)
  (* be uninterpreted.                                                     *)
  (*                                                                       *)
  (* Note that this means round (+INF) > 0 is not true.                    *)
  (* Note also this means round (2*INF) > round (INF) is not true either.  *)
  function round real : real

  constant max_real : real (* defined when cloning *)

  predicate in_range (x:real) = -. max_real <=. x <=. max_real

  (* is_finite will guard all axioms, we're not specifying anything
     for special values. It remains uninterpreted for the
     axiomatisation (mapped in the driver tho), axioms have to
     propagate it. The only way to have is_finite x is if x is by
     propagation or by construction (right now only from using a
     constant or a prover with native support). *)

  axiom is_finite: forall x:t (* [in_range (to_real x)] *). is_finite x -> in_range (to_real x)

  axiom zero_is_finite : is_finite zeroF
  axiom half_is_finite : is_finite half

  (* used as a condition to propagate is_finite *)
  predicate no_overflow (x:real) = in_range (round x)

  (* is this correct &| accurate ? *)
  (* FS: seems OK for float32 at least *)
  axiom of_int_is_finite: forall x:int. no_overflow (FromInt.from_int x) ->
        is_finite (of_int x)

  axiom of_int_to_real: forall x:int. no_overflow (FromInt.from_int x) ->
        to_real (of_int x) = round (FromInt.from_int x)

  (* Axioms on round *)

  axiom Bounded_real_no_overflow :
    forall x:real. in_range x -> no_overflow x

  axiom Round_monotonic :
    forall x y:real. x <=. y -> round x <=. round y

  axiom Round_idempotent :
    forall x:real[round(round x)]. round (round x) = round x

  axiom Round_to_real :
    forall x:t[round (to_real x)]. is_finite x -> round (to_real x) = to_real x
    (* removing is_finite x implies that to_real oo & NaN is finite
    float, safe ? worth it ? *)

  constant max_representable_integer : int (* defined when cloning RENAME -> max_safe_integer ? *)

  (* round and integers *)

  axiom Exact_rounding_for_integers:
    forall i:int.
      (- max_representable_integer) <= i <= max_representable_integer ->
        round (FromInt.from_int i) = FromInt.from_int i

  (** {3 Comparisons} *)

  (** Comparison predicates *)

  (* axiomatize eq w.r.t. = ? *)
  (* e.g. is_finite x /\ is_finite y /\ not_is_zero x -> eq x y <-> x = y *)
  axiom eq: forall x y.
    is_finite x /\ is_finite y /\ not (x = zeroF \/ y = zeroF) -> x .= y <-> x = y

  axiom eq_zero: zeroF .= (.- zeroF) /\ (.- zeroF) .= zeroF

  axiom eq_to_real: forall x y.
    is_finite x /\ is_finite y -> x .= y <-> to_real x = to_real y

  axiom lt: forall x y.
    is_finite x /\ is_finite y -> x .< y <-> to_real x <. to_real y

  axiom le: forall x y.
    is_finite x /\ is_finite y -> x .<= y <-> to_real x <=. to_real y

  axiom gt: forall x y.
    is_finite x /\ is_finite y -> x .> y <-> to_real x >. to_real y

  axiom ge: forall x y.
    is_finite x /\ is_finite y -> x .>= y <-> to_real x >=. to_real y

  axiom positive_to_real: forall x[is_positive x|to_real x >=. 0.0].
    is_finite x -> is_positive x -> to_real x >=. 0.0
  axiom to_real_positive: forall x[is_positive x].
    is_finite x -> to_real x >. 0.0 -> is_positive x

  axiom negative_to_real: forall x [is_negative x|to_real x <=. 0.0].
    is_finite x -> is_negative x -> to_real x <=. 0.0
  axiom to_real_negative: forall x [is_negative x].
    is_finite x -> to_real x <. 0.0 -> is_negative x

  axiom negative_xor_positive: forall x. not (is_positive x /\ is_negative x)
  axiom negative_or_positive: forall x. is_finite x -> is_positive x \/ is_negative x

  (** {3 binary operations} *)

  axiom add: forall x y:t [x .+ y].
   is_finite x -> is_finite y -> no_overflow (to_real x +. to_real y) ->
    is_finite (x .+ y) /\ to_real (x .+ y) = round (to_real x +. to_real y)

  axiom sub: forall x y:t.
  is_finite x -> is_finite y -> no_overflow (to_real x -. to_real y) ->
    is_finite (x .- y) /\ to_real (x .- y) = round (to_real x -. to_real y)

  axiom mul: forall x y:t.
  is_finite x -> is_finite y -> no_overflow (to_real x *. to_real y) ->
    is_finite (x .* y) /\ to_real (x .* y) = round (to_real x *. to_real y)

  axiom div: forall x y:t.
  is_finite x -> is_finite y -> no_overflow (to_real x /. to_real y) /\ not is_zero y ->
    is_finite (x ./ y) /\ to_real (x ./ y) = round (to_real x /. to_real y)

  axiom neg: forall x:t.
    is_finite x -> is_finite (.- x) /\ to_real (.- x) = -. to_real x

  axiom abs: forall x:t.
    is_finite x -> is_finite (abs x) /\  to_real (abs x) = Abs.abs (to_real x)

  (* is_positive x -> is_negative (neg x) *)
  (* is_negative x -> is_positive (neg x) *)
  (* is_positive (abs x) *)

  (* sqrt : same as others but without no_overflow *)

  (* magic axioms  *)

  (* those two are wrong, find a correct version *)
  (* axiom sqrt_m : forall a b. *)
  (* is_finite a -> is_finite b -> is_positive b -> no_overflow *)
  (* (to_real a * to_real b) -> *)
  (*     gt (mul a a) b -> ge a (sqrt b) *)

  (* axiom div_m  : forall a b c. *)
  (* is_finite a -> is_finite b -> is_finite c ->
     no_overflow (to_real a * to_real c) -> not is_zero c -> *)
  (*     gt (mul a c) b -> ge a (div b c) *)

  lemma Min_r : forall x y:t. y .<= x -> (min x y) .= y
  lemma Min_l : forall x y:t. x .<= y -> (min x y) .= x
  lemma Max_r : forall x y:t. y .<= x -> (max x y) .= x
  lemma Max_l : forall x y:t. x .<= y -> (max x y) .= y

  (* FS: wrong for 0 and -0. Using eq instead makes them wrong for NaN and *)
  (*     NaN                                                               *)
  (* lemma Min_comm : forall x y:t. min x y = min y x *)
  (* lemma Max_comm : forall x y:t. max x y = max y x *)

  lemma Min_assoc : forall x y z:t. min (min x y) z = min x (min y z)
  lemma Max_assoc : forall x y z:t. max (max x y) z = max x (max y z)

  (* _____________ *)

  use real.Truncate

  (* is_int predicate  *)
  predicate is_int (x:t)

  (* temporary range check on int set to 2^64; TODO find the actual
     max int that don't give INF with of_int for both clones *)
  axiom of_int_is_int: forall x.
    (- 0x10000000000000000) <= x <= 0x10000000000000000
      -> is_int (of_int x)

  axiom is_int_is_finite: forall x. is_int x -> is_finite x

  axiom int_to_real: forall x.
    is_int x -> to_real x = FromInt.from_int (to_int x)

  (** rounded are ints *)

  axiom truncate_is_int: forall x:t. is_finite x ->
    is_int (roundToIntegralTowardsZero x)

  axiom ceil_is_int: forall x:t. is_finite x ->
    is_int (roundToIntegralTowardsPositive x)

  axiom floor_is_int: forall x:t. is_finite x ->
    is_int (roundToIntegralTowardsNegative x)

  axiom round_is_int: forall x. is_finite x ->
    is_int (roundToIntegralTiesToAway x)

  (** rounding ints *)

  axiom truncate_int: forall x:t. is_int x ->
    roundToIntegralTowardsZero x .= x

  axiom ceil_int: forall i:t. is_int i ->
    roundToIntegralTowardsPositive i .= i

  axiom floor_int: forall i:t. is_int i ->
    roundToIntegralTowardsNegative i .= i

  axiom round_int: forall i:t. is_int i ->
    roundToIntegralTiesToAway i .= i

  (** truncate *)

  axiom truncate_neg: forall x:t.
    is_finite x -> is_negative x -> roundToIntegralTowardsZero x = roundToIntegralTowardsPositive x

  axiom truncate_pos: forall x:t.
    is_finite x -> is_positive x -> roundToIntegralTowardsZero x = roundToIntegralTowardsNegative x

  (** ceil *)

  axiom ceil_le: forall x:t. x .<= (roundToIntegralTowardsPositive x)

  axiom ceil_lest: forall x y:t. x .<= y /\ is_int y -> (roundToIntegralTowardsPositive x) .<= y

  axiom ceil_to_real: forall x:t.
    (.- (of_int max_representable_integer)) .<= x .<= (of_int max_representable_integer) ->
      to_real (roundToIntegralTowardsPositive x) = FromInt.from_int (Truncate.ceil (to_real x))

  axiom ceil_to_int: forall x:t.
    (.- (of_int max_representable_integer)) .<= x .<= (of_int max_representable_integer) ->
      to_int (roundToIntegralTowardsPositive x) = Truncate.ceil (to_real x)

  (** floor *)

  axiom floor_le: forall x:t. (roundToIntegralTowardsNegative x) .<= x

  axiom floor_lest: forall x y:t. y .<= x /\ is_int y -> y .<= (roundToIntegralTowardsNegative x)

  axiom floor_to_real: forall x:t.
    (.- (of_int max_representable_integer)) .<= x .<= (of_int max_representable_integer) ->
      to_real (roundToIntegralTowardsNegative x) = FromInt.from_int (Truncate.floor (to_real x))

  axiom floor_to_int: forall x:t.
    (.- (of_int max_representable_integer)) .<= x .<= (of_int max_representable_integer) ->
      to_int (roundToIntegralTowardsNegative x) = Truncate.floor (to_real x)

  (* Rna *)

  axiom RNA_down:
    forall x:t. (x .- (roundToIntegralTowardsNegative x)) .< ((roundToIntegralTowardsPositive x) .- x) ->
      roundToIntegralTiesToAway x = roundToIntegralTowardsNegative x

  axiom RNA_up:
    forall x:t. (x .- (roundToIntegralTowardsNegative x)) .> ((roundToIntegralTowardsPositive x) .- x) ->
      roundToIntegralTiesToAway x = roundToIntegralTowardsPositive x

  axiom RNA_down_tie:
    forall x:t. (x .- (roundToIntegralTowardsNegative x)) .= ((roundToIntegralTowardsPositive x) .- x) -> is_negative x ->
      roundToIntegralTiesToAway x = roundToIntegralTowardsNegative x

  axiom RNA_up_tie:
    forall x:t. ((roundToIntegralTowardsPositive x) .- x) .= (x .- (roundToIntegralTowardsNegative x)) -> is_positive x ->
      roundToIntegralTiesToAway x = roundToIntegralTowardsPositive x

  axiom RNA_near_int:
    forall i x:t. is_int i -> (.- half) .< x .< half ->
      roundToIntegralTiesToAway (i .+ x) = i

  (* axiom rna_to_real: forall x:t. *)
  (*   is_finite x -> *)
  (*     to_real (roundToIntegralTiesToAway x) = FromInt.from_int (to_int x) *)

  (* to_int *)

  axiom to_int_rna: forall x:t.
    to_int x = to_int (roundToIntegralTiesToAway x)

  axiom to_int_monotonic: forall x y:t.
    is_finite y -> is_finite x -> x .<= y -> (to_int x) <= (to_int y)

  axiom to_int_monotonic_int1:
    forall x:t, i:int. is_finite x -> x .<= (of_int i) -> (to_int x) <= i

  axiom to_int_monotonic_int2:
    forall x:t, i:int. is_finite x -> (of_int i) .<= x -> i <= (to_int x)

  axiom to_int_of_int: forall i:int.
    (- max_representable_integer) <= i <= max_representable_integer ->
      to_int (of_int i) = i

  axiom eq_to_int: forall x y. is_finite x -> is_finite y -> x .= y ->
    to_int x = to_int y

  axiom truncate_is_finite  : forall x:t. is_finite x -> is_finite (roundToIntegralTowardsZero x)
  axiom ceil_is_finite      : forall x:t. is_finite x -> is_finite (roundToIntegralTowardsPositive x)
  axiom floor_is_finite     : forall x:t. is_finite x -> is_finite (roundToIntegralTowardsNegative x)
  axiom nearbyInt_is_finite : forall x:t. is_finite x -> is_finite (roundToIntegralTiesToAway x)
end

theory Float_BV_Converter
  use bv.BV8
  use bv.BV16
  use bv.BV32
  use bv.BV64

  (* with unsigned int as bitvector *)
  (* factorise to not have systematically all bv theories used  *)
  type t

  function of_ubv8  BV8.t  : t
  function of_ubv16 BV16.t : t
  function of_ubv32 BV32.t : t
  function of_ubv64 BV64.t : t

  (* /!\ axioms for those *)

  (* the to_[us]bv* functions are used to convert to a modular or integer
     type in ada, and as such the rounding follows the rounding rules in
     Ada, i.e. RNA. Note the reverse ( of_[us]bv* ) will follow RNE
     rounding however. *)

  function to_ubv8  t : BV8.t
  function to_ubv16 t : BV16.t
  function to_ubv32 t : BV32.t
  function to_ubv64 t : BV64.t

  use import real.RealInfix
  use real.FromInt

  predicate is_finite t
  predicate le t t
  function to_real t : real
  function round real : real

  (** of unsigned bv axioms  *)

  axiom of_ubv8_is_finite : forall x. is_finite (of_ubv8  x)
  axiom of_ubv16_is_finite: forall x. is_finite (of_ubv16 x)
  axiom of_ubv32_is_finite: forall x. is_finite (of_ubv32 x)
  axiom of_ubv64_is_finite: forall x. is_finite (of_ubv64 x)

  axiom of_ubv8_monotonic :
    forall x y. BV8.ule  x y -> le (of_ubv8 x)  (of_ubv8 y)
  axiom of_ubv16_monotonic:
    forall x y. BV16.ule x y -> le (of_ubv16 x) (of_ubv16 y)
  axiom of_ubv32_monotonic:
    forall x y. BV32.ule x y -> le (of_ubv32 x) (of_ubv32 y)
  axiom of_ubv64_monotonic:
    forall x y. BV64.ule x y -> le (of_ubv64 x) (of_ubv64 y)

  axiom of_ubv8_to_real : forall x.
    to_real (of_ubv8 x)  = FromInt.from_int (BV8.to_uint x)
  axiom of_ubv16_to_real: forall x.
    to_real (of_ubv16 x) = FromInt.from_int (BV16.to_uint x)
  (* of_ubv32_to_real is defined at cloning *)
  axiom of_ubv64_to_real: forall x.
    to_real (of_ubv64 x) = round (FromInt.from_int (BV64.to_uint x))
end

theory Float32
  use int.Int
  use import real.Real
  (* use bv.BV32 *)

  type t

  (* function from_bv BV32.t : t *)

  constant max_representable_integer : int = 16777216
  constant max_real : real = 0x1.FFFFFEp127

  clone export GenericFloat with
    type t = t,
    constant max_real = max_real,
    constant max_representable_integer = max_representable_integer

  (* axiom half_bv: half = from_bv (BV32.of_uint 0x3F00_0000) *)

  lemma round_bound :
    forall x : real [round x].
      x - 0x1p-24 * Abs.abs(x) - 0x1p-150 <= round x <= x + 0x1p-24 * Abs.abs(x) + 0x1p-150
end

theory Float64
  use bv.BV64
  use int.Int
  use real.FromInt
  use import real.Real

  type t

  (* function from_bv BV64.t : t *)

  constant max_representable_integer : int = 9007199254740992
  constant max_real : real = 0x1.FFFFFFFFFFFFFp1023

  clone export GenericFloat with
    type t = t,
    constant max_real = max_real,
    constant max_representable_integer = max_representable_integer

  (* axiom half_bv: half = from_bv (BV64.of_uint 0x3FE0_0000_0000_0000) *)

  axiom round_bound :
    forall x : real [round x].
      x - 0x1p-53 * Abs.abs(x) - 0x1p-1075 <= round x <= x + 0x1p-53 * Abs.abs(x) + 0x1p-1075
end

theory FloatConverter

  use Float64
  use Float32

  function to_float64 Float32.t : Float64.t
  function to_float32 Float64.t : Float32.t

  lemma round_double_single :
  forall x : real [ Float32.round x ].
    Float64.round (Float32.round x) = Float32.round x

  lemma to_float64_exact:
    forall x:Float32.t. Float32.is_finite x ->
      Float64.is_finite (to_float64 x)
   /\ Float64.to_real (to_float64 x) = Float32.to_real x

  lemma to_float32_conv:
    forall x:Float64.t. Float64.is_finite x -> Float32.no_overflow (Float64.to_real x) ->
      Float32.is_finite (to_float32 x)
   /\ Float32.to_real (to_float32 x) = Float32.round (Float64.to_real x)

end

theory Float32_BV_Converter
  use import Float32

  clone export Float_BV_Converter with
    type t = t,
    predicate is_finite = is_finite,
    predicate le = (.<=),
    function to_real = to_real,
    function round = round

  axiom of_ubv32_to_real : forall x.
    to_real (of_ubv32 x) = round (FromInt.from_int (BV32.to_uint x))
end

theory Float64_BV_Converter
  use import Float64

  clone export Float_BV_Converter with
    type t = t,
    predicate is_finite = is_finite,
    predicate le = (.<=),
    function to_real = to_real,
    function round = round

  axiom of_ubv32_to_real : forall x.
    to_real (of_ubv32 x) = FromInt.from_int (BV32.to_uint x)
end
