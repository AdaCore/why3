(** {1 Formalization of Floating-Point Arithmetic}

  Full float theory (with infinities and NaN) only RNE rounding mode.
  Special values are not axiomatized.

  A note on intended semantics: we use the same idea as the SMTLIB floating
  point theory, that defers any inconsistencies to the "parent" document.
  Hence, in doubt, the correct axiomatisation is one that implements
  [BTRW14] "An Automatable Formal Semantics for IEEE-754 Floating-Point
  Arithmetic", which in turn defers any inconsistencies to IEE-754.

  This theory is split into two parts: the first part talks about IEEE
  operations and this is what you should use as a user, the second part is
  internal only and is an axiomatisation for the provers that do not
  natively support floating point. You should not use any symbols you find
  there in your verification conditions as solvers with native floating
  point support will leave them uninterpreted.
*)

theory GenericFloat

  (*********************************************************************)
  (* {2 PART I - PUBLIC INTERFACE}                                     *)
  (*********************************************************************)

  (* {3 Sorts} *)

  type t

  (* {3 Constructors and Constants} *)

  constant zeroF     : t   (* +0.0 *)
  constant oneF      : t   (* not used here, but used in _gnatprove_standard *)
  constant two       : t   (* 2.0 *)
  constant half      : t   (* 0.5 *)
  constant max_value : t   (* largest positive finite float *)

  (* constructor, perform an unchecked convertion from the binary *)
  (* representation of a float. this is a workaround and should   *)
  (* only be used for literals!                                   *)
  function from_binary int  : t
  function (!)         real : t (* constructor from real literals *)

  (* {3 Operators} *)

  function abs       t   : t
  function (.-_)     t   : t

  function (.+)      t t : t
  function (.-)      t t : t
  function (.*)      t t : t
  function (./)      t t : t

  function fma     t t t : t (* xy + z *)

  function sqrt      t   : t
  function rem       t t : t

  (* In Ada/SPARK we need sign-preserving floor/ceil in the case of 0,    *)
  (* but luckily this is the case for IEEE floats so we can use the below *)
  (* directly.                                                            *)
  function roundToIntegralTowardsPositive t : t
  function roundToIntegralTowardsNegative t : t
  function roundToIntegralTowardsZero     t : t
  function roundToIntegralTiesToAway      t : t

  (* Min & Max *)
  (* Note that we have to follow IEEE-754 and SMTLIB here. Two things to *)
  (* note in particular:                                                 *)
  (*    1) m?n(-0, 0) is either 0 or -0, there is a choice               *)
  (*    2) if either argument is NaN then the other argument is returned *)
  function min       t t : t
  function max       t t : t

  (** {3 Comparisons} *)

  predicate (.<=) t t
  predicate (.<)  t t
  predicate (.>=) t t
  predicate (.>)  t t

  predicate (.=)  t t

  (* {3 Classification of numbers} *)

  predicate is_normal    t
  predicate is_subnormal t
  predicate is_zero      (x:t) = x .= zeroF
  predicate is_infinite  t
  predicate is_nan       t
  predicate is_positive  t
  predicate is_negative  t

  (* helper predicate for zero, normal and subnormals. not defined so that *)
  (* the axiomatisation below can use it without talking about subnormals  *)
  predicate is_finite    t

  (* {3 Conversions from other sorts} *)

  (* from bitvec binary interchange                           *)
  (*   partly done with from_binary (for literals only)       *)
  (* from another fp                 - see FloatConverter     *)
  (* from real                                                *)
  (* from unsigned integer bitvector - see Float_BV_Converter *)
  (* from signed integer bitvector                            *)

  (* {3 Conversions to other sorts} *)

  (* to unsigned integer bitvector   - see Float_BV_Converter *)
  (* to signed integer bitvector                              *)
  (* to real *)
  function to_real   t    : real

  (*********************************************************************)
  (* {2 PART II - PRIVATE AXIOMATISATION}                              *)
  (*********************************************************************)

  (* {3 Constructors and Constants} *)
  axiom zeroF_to_real     : to_real zeroF = 0.0
  axiom zeroF_is_positive : is_positive zeroF
  axiom oneF_to_real      : to_real oneF  = 1.0
  axiom two_to_real       : to_real two   = 2.0
  axiom half_to_real      : to_real half  = 0.5

  (* {3 Conversions from other sorts} *)

  (* with mathematical int *)
  (* note that these conversions do not feature in SMTLIB *)

  (* intended semantics for of_int are the same as (_ to_fp eb sb) RNE with *)
  (* a suitably sized bitvector, large enough to hold x                     *)
  (* note values >= than the below should result in infinities              *)
  (*    float32 : 0x1ffffff * 2^103                                         *)
  (*    float64 : 0x3fffffffffffff * 2^970                                  *)
  (* also note that this function never yields a subnormal, or a nan, or -0 *)
  function of_int (x : int) : t

  (* {3 Conversions to other sorts} *)

  (* Intended semantics for to_int are the same as (_ fp.to_sbv) RNE with  *)
  (* a suitably sized bitvector. Safe minimum sizes are given below:       *)
  (*    float32 : 129                                                      *)
  (*    float64 : 1025                                                     *)
  (* In particular this function should be uninterpreted for infinities    *)
  (* and NaN. Take care that no conclusion can be made on the result based *)
  (* on the size of the bitvector chosen in those cases, i.e. this should  *)
  (* not hold:                                                             *)
  (*    to_int +INF < 2 ** 2048     // nope                                *)
  (*    to_int +INF > 0             // nope                                *)
  function to_int (x : t) : int

  axiom zero_of_int : zeroF = of_int 0
  axiom oneF_of_int : oneF  = of_int 1
  axiom two_of_int  : two   = of_int 2

  (* {3 Arithmetic} *)

  (* The intended meaning for round is the RNE rounding for floating point *)
  (* as described on p17 of IEEE-754. For results where the corresponding  *)
  (* floating point result would be infinity or NaN this function should   *)
  (* be uninterpreted.                                                     *)
  function round real : real

  constant max_real   : real    (* defined when cloning *)

  axiom max_to_real   : max_real = to_real max_value

  use import real.RealInfix
  use real.Abs

  predicate in_range (x:real) = -. max_real <=. x <=. max_real

  (* is_finite will guard all axioms, we're not specifying anything
     for special values. It remains uninterpreted for the
     axiomatisation (mapped in the driver tho), axioms have to
     propagate it. The only way to have is_finite x is if x is by
     propagation or by construction (right now only from using a
     constant or a prover with native support). *)

  axiom is_finite: forall x:t (* [in_range (to_real x)] *). is_finite x -> in_range (to_real x)

  axiom zero_is_finite : is_finite zeroF
  axiom one_is_finite  : is_finite oneF
  axiom two_is_finite  : is_finite two
  axiom half_is_finite : is_finite half
  axiom max_is_finite  : is_finite max_value

  (* used as a condition to propagate is_finite *)
  predicate no_overflow (x:real) = in_range (round x)

  use real.FromInt

  (* is this correct &| accurate ? *)
  (* FS: seems OK for float32 at least *)
  axiom of_int_is_finite: forall x:int. no_overflow (FromInt.from_int x) ->
        is_finite (of_int x)

  axiom of_int_to_real: forall x:int. no_overflow (FromInt.from_int x) ->
        to_real (of_int x) = round (FromInt.from_int x)

  (* to_int and nearbyInt *)
  axiom to_int_nearbyInt: forall x:t.
    is_finite x ->
      FromInt.from_int (to_int x) = to_real (roundToIntegralTiesToAway x)

  (* Axioms on round *)

  axiom Bounded_real_no_overflow :
    forall x:real. in_range x -> no_overflow x

  axiom Round_monotonic :
    forall x y:real. x <=. y -> round x <=. round y

  axiom Round_idempotent :
    forall x:real[round(round x)]. round (round x) = round x

  axiom Round_to_real :
    forall x:t[round (to_real x)]. is_finite x -> round (to_real x) = to_real x
    (* removing is_finite x implies that to_real oo & NaN is finite
    float, safe ? worth it ? *)

  constant max_representable_integer : int (* defined when cloning RENAME -> max_safe_integer ? *)

  (* round and integers *)

  use import int.Int

  axiom Exact_rounding_for_integers:
    forall i:int.
      (- max_representable_integer) <= i <= max_representable_integer ->
        round (FromInt.from_int i) = FromInt.from_int i

  (** {3 Comparisons} *)

  (** Comparison predicates *)

  (* axiomatize eq w.r.t. = ? *)
  (* e.g. is_finite x /\ is_finite y /\ not_is_zero x -> eq x y <-> x = y *)
  axiom eq: forall x y.
    is_finite x /\ is_finite y /\ not (x = zeroF \/ y = zeroF) -> x .= y <-> x = y

  axiom eq_zero: zeroF .= (.- zeroF) /\ (.- zeroF) .= zeroF

  axiom eq_to_real: forall x y.
    is_finite x /\ is_finite y -> x .= y <-> to_real x = to_real y

  axiom lt: forall x y.
    is_finite x /\ is_finite y -> x .< y <-> to_real x <. to_real y

  axiom le: forall x y.
    is_finite x /\ is_finite y -> x .<= y <-> to_real x <=. to_real y

  axiom gt: forall x y.
    is_finite x /\ is_finite y -> x .> y <-> to_real x >. to_real y

  axiom ge: forall x y.
    is_finite x /\ is_finite y -> x .>= y <-> to_real x >=. to_real y

  axiom positive_to_real: forall x[is_positive x|to_real x >=. 0.0].
    is_finite x -> is_positive x -> to_real x >=. 0.0
  axiom to_real_positive: forall x[is_positive x].
    is_finite x -> to_real x >. 0.0 -> is_positive x

  axiom negative_to_real: forall x [is_negative x|to_real x <=. 0.0].
    is_finite x -> is_negative x -> to_real x <=. 0.0
  axiom to_real_negative: forall x [is_negative x].
    is_finite x -> to_real x <. 0.0 -> is_negative x

  axiom negative_xor_positive: forall x. not (is_positive x /\ is_negative x)
  axiom negative_or_positive: forall x. is_finite x -> is_positive x \/ is_negative x

  (** {3 binary operations} *)

  axiom add: forall x y:t [x .+ y].
   is_finite x -> is_finite y -> no_overflow (to_real x +. to_real y) ->
    is_finite (x .+ y) /\ to_real (x .+ y) = round (to_real x +. to_real y)

  axiom sub: forall x y:t.
  is_finite x -> is_finite y -> no_overflow (to_real x -. to_real y) ->
    is_finite (x .- y) /\ to_real (x .- y) = round (to_real x -. to_real y)

  axiom mul: forall x y:t.
  is_finite x -> is_finite y -> no_overflow (to_real x *. to_real y) ->
    is_finite (x .* y) /\ to_real (x .* y) = round (to_real x *. to_real y)

  axiom div: forall x y:t.
  is_finite x -> is_finite y -> no_overflow (to_real x /. to_real y) /\ not is_zero y ->
    is_finite (x ./ y) /\ to_real (x ./ y) = round (to_real x /. to_real y)

  axiom neg: forall x:t.
    is_finite x -> is_finite (.- x) /\ to_real (.- x) = -. to_real x

  axiom abs: forall x:t.
    is_finite x -> is_finite (abs x) /\  to_real (abs x) = Abs.abs (to_real x)

  (* is_positive x -> is_negative (neg x) *)
  (* is_negative x -> is_positive (neg x) *)
  (* is_positive (abs x) *)

  (* sqrt : same as others but without no_overflow *)

  (* magic axioms  *)

  (* those two are wrong, find a correct version *)
  (* axiom sqrt_m : forall a b. *)
  (* is_finite a -> is_finite b -> is_positive b -> no_overflow *)
  (* (to_real a * to_real b) -> *)
  (*     gt (mul a a) b -> ge a (sqrt b) *)

  (* axiom div_m  : forall a b c. *)
  (* is_finite a -> is_finite b -> is_finite c ->
     no_overflow (to_real a * to_real c) -> not is_zero c -> *)
  (*     gt (mul a c) b -> ge a (div b c) *)

  lemma Min_r : forall x y:t. y .<= x -> (min x y) .= y
  lemma Min_l : forall x y:t. x .<= y -> (min x y) .= x
  lemma Max_r : forall x y:t. y .<= x -> (max x y) .= x
  lemma Max_l : forall x y:t. x .<= y -> (max x y) .= y

  (* FS: wrong for 0 and -0. Using eq instead makes them wrong for NaN and *)
  (*     NaN                                                               *)
  (* lemma Min_comm : forall x y:t. min x y = min y x *)
  (* lemma Max_comm : forall x y:t. max x y = max y x *)

  lemma Min_assoc : forall x y z:t. min (min x y) z = min x (min y z)
  lemma Max_assoc : forall x y z:t. max (max x y) z = max x (max y z)

  (* _____________ *)


  axiom eq_to_int: forall x y. is_finite x -> is_finite y -> x .= y ->
    to_int x = to_int y

  use import real.RealInfix
  use real.Truncate

  axiom truncate_neg: forall x:t.
    is_finite x -> is_negative x -> roundToIntegralTowardsZero x = roundToIntegralTowardsPositive x

  axiom truncate_pos: forall x:t.
    is_finite x -> is_positive x -> roundToIntegralTowardsZero x = roundToIntegralTowardsNegative x

  axiom to_int_of_int: forall i:int.
    (- max_representable_integer) <= i <= max_representable_integer ->
      to_int (of_int i) = i

  predicate is_int (x:t)

  (* temporary range check on int set to 2^64; TODO find the actual
     max int that don't give INF with of_int for both clones *)
  axiom of_int_is_int: forall x.
    (- 0x10000000000000000) <= x <= 0x10000000000000000
      -> is_int (of_int x)

  axiom is_int_is_finite: forall x. is_int x -> is_finite x

  (* ceil axioms *)
  axiom ceil_is_int: forall x:t. is_finite x -> is_int (roundToIntegralTowardsPositive x)

  (* zero's sign is kept so '=' instead of eq is OK *)
  (* try is_int i -> ceil i = i *)
  axiom ceil_of_int: forall i:int. roundToIntegralTowardsPositive (of_int i) = of_int i

  axiom ceil_le: forall x:t. x .<= (roundToIntegralTowardsPositive x)

  axiom ceil_lest: forall x y:t. x .<= y /\ is_int y -> (roundToIntegralTowardsPositive x) .<= y

  axiom ceil_to_int: forall x:t.
    (.- (of_int max_representable_integer)) .<= x .<= (of_int max_representable_integer) ->
      (* or ? to_int (roundToIntegralTowardsPositive x) = Truncate.roundToIntegralTowardsPositive (to_real x) *)
      to_real (roundToIntegralTowardsPositive x) = FromInt.from_int (Truncate.ceil (to_real x))

  (* floor axioms *)
  axiom floor_is_int: forall x:t. is_finite x -> is_int (roundToIntegralTowardsNegative x)

  axiom floor_of_int: forall i:int. roundToIntegralTowardsNegative (of_int i) .= of_int i

  axiom floor_le: forall x:t. (roundToIntegralTowardsNegative x) .<= x

  axiom floor_lest: forall x y:t. y .<= x /\ is_int y -> y .<= (roundToIntegralTowardsNegative x)

  axiom floor_to_int: forall x:t.
    (.- (of_int max_representable_integer)) .< x .<= (of_int max_representable_integer) ->
      (*or ? to_int (roundToIntegralTowardsNegative x) = Truncate.roundToIntegralTowardsNegative (to_real x) *)
      to_real (roundToIntegralTowardsNegative x) = FromInt.from_int (Truncate.floor (to_real x))

  (* rounding *)

  axiom to_int_down:
    (* forall x:t. lt x (div (add (roundToIntegralTowardsPositive x) (roundToIntegralTowardsNegative x)) two) -> to_int x = to_int (roundToIntegralTowardsNegative x) *)
    forall x:t. (x .- (roundToIntegralTowardsNegative x)) .< ((roundToIntegralTowardsPositive x) .- x) -> to_int x = to_int (roundToIntegralTowardsNegative x)

  axiom to_int_up:
    (* forall x:t. gt x (div (add (roundToIntegralTowardsPositive x) (roundToIntegralTowardsNegative x)) two) -> to_int x = to_int (roundToIntegralTowardsPositive x) *)
    forall x:t. (x .- (roundToIntegralTowardsNegative x)) .> ((roundToIntegralTowardsPositive x) .- x) -> to_int x = to_int (roundToIntegralTowardsPositive x)

  axiom to_int_down_tie:        (* check if to_int is rounding or RNE *)
    (* forall x:t. eq x (div (add (roundToIntegralTowardsPositive x) (roundToIntegralTowardsNegative x)) two) /\ is_negative x -> *)
    forall x:t. (x .- (roundToIntegralTowardsNegative x)) .= ((roundToIntegralTowardsPositive x) .- x) -> is_negative x ->
      to_int x = to_int (roundToIntegralTowardsNegative x)

  axiom to_int_up_tie:
    (* forall x:t. eq x (div (add (roundToIntegralTowardsPositive x) (roundToIntegralTowardsNegative x)) two) -> is_positive x -> *)
    forall x:t. ((roundToIntegralTowardsPositive x) .- x) .= (x .- (roundToIntegralTowardsNegative x)) -> is_positive x ->
      to_int x = to_int (roundToIntegralTowardsPositive x)

  axiom to_int_near_int:
    forall i x:t. is_int i -> (.- half) .< x .< half ->
      to_int (i .+ x) = to_int i

  axiom to_int_monotonic: forall x y:t.
    is_finite y -> is_finite x -> x .<= y -> (to_int x) <= (to_int y)

  (* are those two really ok ? *)
  axiom to_int_monotonic_int1:
    forall x:t, i:int. is_finite x -> x .<= (of_int i) -> (to_int x) <= i

  axiom to_int_monotonic_int2:
    forall x:t, i:int. is_finite x -> (of_int i) .<= x -> i <= (to_int x)

  axiom truncate_is_finite  : forall x:t. is_finite x -> is_finite (roundToIntegralTowardsZero x)
  axiom ceil_is_finite      : forall x:t. is_finite x -> is_finite (roundToIntegralTowardsPositive x)
  axiom floor_is_finite     : forall x:t. is_finite x -> is_finite (roundToIntegralTowardsNegative x)
  axiom nearbyInt_is_finite : forall x:t. is_finite x -> is_finite (roundToIntegralTiesToAway x)
end

theory Float_BV_Converter
  (* with unsigned int as bitvector *)
  (* factorise to not have systematically all bv theories used  *)
  type t

  use bv.BV8
  use bv.BV16
  use bv.BV32
  use bv.BV64

  function of_ubv8  BV8.t  : t
  function of_ubv16 BV16.t : t
  function of_ubv32 BV32.t : t
  function of_ubv64 BV64.t : t

  (* /!\ axioms for those *)

  (* the to_[us]bv* functions are used to convert to a modular or integer
     type in ada, and as such the rounding follows the rounding rules in
     Ada, i.e. RNA. Note the reverse ( of_[us]bv* ) will follow RNE
     rounding however. *)

  function to_ubv8  t : BV8.t
  function to_ubv16 t : BV16.t
  function to_ubv32 t : BV32.t
  function to_ubv64 t : BV64.t

  use import real.RealInfix
  use real.FromInt

  predicate is_finite t
  predicate le t t
  function to_real t : real
  function round real : real

  (** of unsigned bv axioms  *)

  axiom of_ubv8_is_finite : forall x. is_finite (of_ubv8  x)
  axiom of_ubv16_is_finite: forall x. is_finite (of_ubv16 x)
  axiom of_ubv32_is_finite: forall x. is_finite (of_ubv32 x)
  axiom of_ubv64_is_finite: forall x. is_finite (of_ubv64 x)

  axiom of_ubv8_monotonic :
    forall x y. BV8.ule  x y -> le (of_ubv8 x)  (of_ubv8 y)
  axiom of_ubv16_monotonic:
    forall x y. BV16.ule x y -> le (of_ubv16 x) (of_ubv16 y)
  axiom of_ubv32_monotonic:
    forall x y. BV32.ule x y -> le (of_ubv32 x) (of_ubv32 y)
  axiom of_ubv64_monotonic:
    forall x y. BV64.ule x y -> le (of_ubv64 x) (of_ubv64 y)

  axiom of_ubv8_to_real : forall x.
    to_real (of_ubv8 x)  = FromInt.from_int (BV8.to_uint x)
  axiom of_ubv16_to_real: forall x.
    to_real (of_ubv16 x) = FromInt.from_int (BV16.to_uint x)
  (* of_ubv32_to_real is defined at cloning *)
  axiom of_ubv64_to_real: forall x.
    to_real (of_ubv64 x) = round (FromInt.from_int (BV64.to_uint x))
end

theory Float32
  (* use bv.BV32 *)

  type t

  (* function from_bv BV32.t : t *)

  constant max_representable_integer : int = 16777216
  constant max_real : real = 0x1.FFFFFEp127

  use int.Int
  clone export GenericFloat with
    type t = t,
    constant max_real = max_real,
    constant max_representable_integer = max_representable_integer

  (* axiom oneF_bv : oneF      = from_bv (BV32.of_uint 0x3F80_0000) *)
  (* axiom max_bv  : max_value = from_bv (BV32.of_uint 0x7F7F_FFFF) *)

  (* axiom two_bv : two  = from_bv (BV32.of_uint 0x4000_0000) *)
  (* axiom half_bv: half = from_bv (BV32.of_uint 0x3F00_0000) *)

  use import real.Real
  lemma round_bound :
    forall x : real [round x].
      x - 0x1p-24 * Abs.abs(x) - 0x1p-150 <= round x <= x + 0x1p-24 * Abs.abs(x) + 0x1p-150
end

theory Float64
  use bv.BV64

  type t

  (* function from_bv BV64.t : t *)

  constant max_representable_integer : int = 9007199254740992
  constant max_real : real = 0x1.FFFFFFFFFFFFFp1023

  use int.Int
  use real.FromInt

  clone export GenericFloat with
    type t           = t,
    constant max_real = max_real,
    constant max_representable_integer = max_representable_integer

  (* axiom oneF_bv : oneF      = from_bv (BV64.of_uint 0x3FF0_0000_0000_0000) *)
  (* axiom max_bv  : max_value = from_bv (BV64.of_uint 0x7FEF_FFFF_FFFF_FFFF) *)

  (* axiom two_bv : two  = from_bv (BV64.of_uint 0x4000_0000_0000_0000) *)
  (* axiom half_bv: half = from_bv (BV64.of_uint 0x3FE0_0000_0000_0000) *)

  use import real.Real
  axiom round_bound :
    forall x : real [round x].
      x - 0x1p-53 * Abs.abs(x) - 0x1p-1075 <= round x <= x + 0x1p-53 * Abs.abs(x) + 0x1p-1075
end

theory FloatConverter

  use Float64
  use Float32

  function to_float64 Float32.t : Float64.t
  function to_float32 Float64.t : Float32.t

  lemma round_double_single :
  forall x : real [ Float32.round x ].
    Float64.round (Float32.round x) = Float32.round x

  lemma to_float64_exact:
    forall x:Float32.t. Float32.is_finite x ->
      Float64.is_finite (to_float64 x)
   /\ Float64.to_real (to_float64 x) = Float32.to_real x

  lemma to_float32_conv:
    forall x:Float64.t. Float64.is_finite x -> Float32.no_overflow (Float64.to_real x) ->
      Float32.is_finite (to_float32 x)
   /\ Float32.to_real (to_float32 x) = Float32.round (Float64.to_real x)

end

theory Float32_BV_Converter
  use import Float32

  clone export Float_BV_Converter with
    type t = t,
    predicate is_finite = is_finite,
    predicate le = (.<=),
    function to_real = to_real,
    function round = round

  axiom of_ubv32_to_real : forall x.
    to_real (of_ubv32 x) = round (FromInt.from_int (BV32.to_uint x))
end

theory Float64_BV_Converter
  use import Float64

  clone export Float_BV_Converter with
    type t = t,
    predicate is_finite = is_finite,
    predicate le = (.<=),
    function to_real = to_real,
    function round = round

  axiom of_ubv32_to_real : forall x.
    to_real (of_ubv32 x) = FromInt.from_int (BV32.to_uint x)
end
