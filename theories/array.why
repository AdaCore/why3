
theory Array "Theory of arrays" 

  type t 'a 'b

  logic get (t 'a 'b) 'a : 'b
  logic set (t 'a 'b) 'a 'b : t 'a 'b

  (* syntactic sugar *)
  logic ([]) (a : t 'a 'b) (i : 'a) : 'b = get a i
  logic ([<-]) (a : t 'a 'b) (i : 'a) (v : 'b) : t 'a 'b = set a i v

  axiom Select_eq :
    forall m : t 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [get (set m a1 b) a2].
    a1 = a2 -> get (set m a1 b) a2  = b

  axiom Select_neq :
    forall m : t 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [get (set m a1 b) a2].
    a1 <> a2 -> get (set m a1 b) a2 = get m a2

  logic create_const 'b : t 'a 'b

  axiom Const : forall b:'b, a:'a. get (create_const b) a = b

end

theory ArrayLength "Theory of arrays with length"

  (* these arrays ... *)

  use import int.Int

  use export Array

  type map 'a = t int 'a

  logic length (map 'a) : int

  axiom Length_non_negative (* "Array length is always non negative" *):
    forall a : map 'a. length a >= 0

  axiom Length_set : 
    forall a : map 'a. forall k : int. forall v : 'a.
    length (set a k v) = length a

  logic create_const_length 'a int : map 'a
    (* [create_const_length x n] is the array of length n
       with all cells initialized to x 
       (not specified if n is negative)
    *)     

  axiom Create_const_length_get : 
    forall b:'a. forall n i:int. get (create_const_length b n) i = b

  axiom Create_const_length_length : 
    forall a : 'a. forall n : int. 
      (* premise needed to guaranty length >= 0 invariant *)
       n >= 0 -> length (create_const_length a n) = n

  logic create_length int : map 'a

  axiom Create_length_length : 
    forall n : int. 
      (* premise needed to guaranty length >= 0 invariant *)
      n >=0 -> length (create_length n : map 'a) = n

end

theory ArraySorted

  use import int.Int
  use import ArrayLength

  type elt

  logic le elt elt

  logic sorted_sub (a : map elt) (l u : int) =
    forall i1 i2 : int. l <= i1 <= i2 <= u -> le a[i1] a[i2]

  logic sorted (a : map elt) =
    sorted_sub a 0 (length a - 1)

end

theory ArrayEq

  use import int.Int
  use export ArrayLength

  logic array_eq_sub (a1 a2 : map 'a) (l u : int) = 
    forall i:int. l <= i <= u -> a1[i] = a2[i]

  logic array_eq (a1 a2 : map 'a) =
    length a1 = length a2 and
    forall i:int. 0 <= i < length a1 -> a1[i] = a2[i]

end

theory ArrayPermut

  use import int.Int
  use export ArrayLength

  logic exchange (a1 a2 : map 'a) (i j : int) = 
    length a1 = length a2 and
    a1[i] = a2[j] and a2[i] = a1[j] and
    forall k:int. (k <> i and k <> j) -> a1[k] = a2[k]

  lemma exchange_set :
    forall a : map 'a. forall i j : int.
    exchange a (set (set a i a[j]) j a[i]) i j

  inductive permut (map 'a) (map 'a) int int =
  | permut_refl :
      forall a : map 'a. forall l u : int. permut a a l u
  | permut_sym :
      forall a1 a2 : map 'a. forall l u : int.
      permut a1 a2 l u -> permut a2 a1 l u
  | permut_trans :
      forall a1 a2 a3 : map 'a. forall l u : int.
      permut a1 a2 l u -> permut a2 a3 l u -> permut a1 a3 l u
  | permut_exchange :
      forall a1 a2 : map 'a. forall l u i j : int.
      l <= i <= u -> l <= j <= u -> exchange a1 a2 i j -> permut a1 a2 l u

  lemma permut_weakening :
    forall a1 a2 : map 'a. forall l1 r1 l2 r2 : int.
    l1 <= l2 <= r2 <= r1 -> permut a1 a2 l2 r2 -> permut a1 a2 l1 r1

  lemma permut_eq :
    forall a1 a2 : map 'a. forall l u : int.
    l <= u -> permut a1 a2 l u ->
    forall i:int. (i < l or u < i) -> a2[i] = a1[i]

  lemma permut_length :
    forall a1 a2 : map 'a. forall l u : int.
    permut a1 a2 l u -> length a1 = length a2

  lemma permut_exists :
    forall a1 a2 : map 'a. forall l u : int.
    permut a1 a2 l u -> 
    forall i : int. l <= i <= u ->
    exists j : int. l <= j <= u and a2[i] = a1[j]

  logic permutation (a1 a2 : map 'a) =
    permut a1 a2 0 (length a1 - 1)

  use export ArrayEq

  lemma array_eq_permut :
    forall a1 a2 : map 'a. forall l u : int.
    array_eq_sub a1 a2 l u -> permut a1 a2 l u

end

theory ArrayRich

  use import int.Int
  
  use export ArrayLength

  logic sub (map 'a) int int : map 'a

  axiom Sub_length : 
    forall s : map 'a, ofs len : int.
    len >= 0 ->
    length (sub s ofs len) = len

  axiom Sub_get :
    forall s : map 'a, ofs len i : int. 
    get (sub s ofs len) i = get s (ofs + i)

  logic app (map 'a) (map 'a) : map 'a

  axiom App_length : 
    forall s1 s2 : map 'a. length (app s1 s2) = length s1 + length s2

  axiom App_get :
    forall s1 s2 : map 'a, i : int. 
    get (app s1 s2) i = 
      if i < length s1 then get s1 i else get s2 (i - length s1)

end

theory BitVector

  use export bool.Bool
  use import int.Int

  logic size : int 

  type bv

  logic nth bv int: bool
  
  logic bvzero : bv
  axiom Nth_zero: 
    forall n:int. 0 <= n < size -> nth bvzero n = False

  logic bvone : bv
  axiom Nth_one: 
    forall n:int. 0 <= n < size -> nth bvone n = True

  logic eq (v1 v2 : bv) =
    forall n:int. 0 <= n < size -> nth v1 n = nth v2 n

  logic bw_and (v1 v2 : bv) : bv
  axiom Nth_bw_and: 
    forall v1 v2:bv, n:int. 0 <= n < size -> 
      nth (bw_and v1 v2) n = andb (nth v1 n) (nth v2 n)

  (* logical shift right *)
  logic lsr bv int : bv

  axiom Lsr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (lsr b s) n = nth b (n+s)

  axiom Lsr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (lsr b s) n = False

  (* arithmetic shift right *)
  logic asr bv int : bv

  axiom Asr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (asr b s) n = nth b (n+s)

  axiom Asr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (asr b s) n = nth b (size-1)

  (* logical shift left *)
  logic lsl bv int : bv

  axiom Lsl_nth_high:
    forall b:bv,n s:int. 0 <= n-s < size -> nth (lsl b s) n = nth b (n-s)

  axiom Lsl_nth_low:
    forall b:bv,n s:int. n-s < 0 -> nth (lsl b s) n = False

end


theory BV32

  logic size : int = 32

  clone export BitVector with logic size = size

end


theory TestBv32

  use import BV32

  lemma Test1:
    let b = bw_and bvzero bvone in nth b 1 = False

  lemma Test2:
    let b = lsr bvone 16 in nth b 15 = True
     
  lemma Test3:
    let b = lsr bvone 16 in nth b 16 = False

  lemma Test4:
    let b = asr bvone 16 in nth b 15 = True
     
  lemma Test5:
    let b = asr bvone 16 in nth b 16 = True

  lemma Test6:
    let b = asr (lsr bvone 1) 16 in nth b 16 = False
     
end 


(*
Local Variables: 
compile-command: "make -C .. theories/array"
End: 
*)
