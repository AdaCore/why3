
theory Array

  type ('a,'b) t

  logic select (('a,'b) t, 'a) : 'b
  logic store (('a,'b) t, 'a, 'b) : ('a,'b) t
  
  axiom Select_eq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. 
    forall b : 'b [select (store m a1 b) a2].
    a1 = a2 -> select (store m a1 b) a2  = b

  axiom Select_neq : 
    forall m : ('a,'b) t. forall a1,a2 : 'a. 
    forall b : 'b [select (store m a1 b) a2].
    a1 <> a2 -> select (store m a1 b) a2 = select m a2

  logic const('b) : ('a,'b) t

  axiom Const : forall b:'b, a:'a. select (const b) a = b

end

theory ArrayKey

  type key

  type 'a t

  logic select ('a t, key) : 'a
  logic store ('a t, key, 'a) : 'a t
  
  axiom Select_eq : 
    forall m : 'a t. forall a1,a2 : key. 
    forall b : 'a [select (store m a1 b) a2].
    a1 = a2 -> select (store m a1 b) a2 = b

  axiom Select_neq : 
    forall m : 'a t. forall a1,a2 : key. 
    forall b : 'a [select (store m a1 b) a2].
    a1 <> a2 -> select (store m a1 b) a2 = select m a2

  logic const('a) : 'a t

  axiom Const : forall b:'a. forall a:key. select (const b) a = b

end

theory ArrayLength

  clone export ArrayKey with type key = int

  logic length('a t) : int

  logic const_length('a, int) : 'a t

  axiom Const_contents : 
    forall b:'a. forall n,i:int. select (const_length b n) i = b

  axiom Length_const : 
    forall a : 'a. forall n : int. length (const_length a n) = n

  axiom Length_store : 
    forall a : 'a t. forall k : int. forall v : 'a.
    length (store a k v) = length a

end

theory BitVector

  use export bool.Bool
  use import int.Int

  logic size : int 

  type bv

  logic nth(bv,int): bool
  
  logic bvzero : bv
  axiom Nth_zero: 
    forall n:int. 0 <= n < size -> nth bvzero n = False

  logic bvone : bv
  axiom Nth_one: 
    forall n:int. 0 <= n < size -> nth bvone n = True

  logic eq(v1:bv,v2:bv) =
    forall n:int. 0 <= n < size -> nth v1 n = nth v2 n

  logic bw_and(v1:bv,v2:bv) : bv
  axiom Nth_bw_and: 
    forall v1,v2:bv,n:int. 0 <= n < size -> 
      nth (bw_and v1 v2) n = andb (nth v1 n) (nth v2 n)

  (* logical shift right *)
  logic lsr(bv,int) : bv

  axiom Lsr_nth_low:
    forall b:bv,n,s:int. 0 <= n+s < size -> nth (lsr b s) n = nth b (n+s)

  axiom Lsr_nth_high:
    forall b:bv,n,s:int. n+s >= size -> nth (lsr b s) n = False

  (* arithmetic shift left *)
  logic asr(bv,int) : bv

  axiom Asr_nth_low:
    forall b:bv,n,s:int. 0 <= n+s < size -> nth (asr b s) n = nth b (n+s)

  axiom Asr_nth_high:
    forall b:bv,n,s:int. n+s >= size -> nth (asr b s) n = nth b (size-1)

  (* logical shift left *)
  logic lsl(bv,int) : bv

  axiom Lsl_nth_high:
    forall b:bv,n,s:int. 0 <= n-s < size -> nth (lsl b s) n = nth b (n-s)

  axiom Lsl_nth_low:
    forall b:bv,n,s:int. n-s < 0 -> nth (lsl b s) n = False

end


theory BV32

  logic size : int = 32

  clone export BitVector with logic size = size

end


theory TestBv32

  use import BV32

  lemma Test1:
    let b = bw_and bvzero bvone in nth b 1 = False

  lemma Test2:
    let b = lsr bvone 16 in nth b 15 = True
     
  lemma Test3:
    let b = lsr bvone 16 in nth b 16 = False

  lemma Test4:
    let b = asr bvone 16 in nth b 15 = True
     
  lemma Test5:
    let b = asr bvone 16 in nth b 16 = True

  lemma Test6:
    let b = asr (lsr bvone 1) 16 in nth b 16 = False
     
end 


(*
Local Variables: 
compile-command: "cd ..; bin/why.opt theories/array.why"
End: 
*)
