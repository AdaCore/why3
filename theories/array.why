
theory ArrayPoly

  type t 'a 'b

  logic get (t 'a 'b) 'a : 'b
  logic set (t 'a 'b) 'a 'b : t 'a 'b
  
  axiom Select_eq : 
    forall m : t 'a 'b. forall a1 a2 : 'a. 
    forall b : 'b [get (set m a1 b) a2].
    a1 = a2 -> get (set m a1 b) a2  = b

  axiom Select_neq : 
    forall m : t 'a 'b. forall a1 a2 : 'a. 
    forall b : 'b [get (set m a1 b) a2].
    a1 <> a2 -> get (set m a1 b) a2 = get m a2

  logic const 'b : t 'a 'b

  axiom Const : forall b:'b, a:'a. get (const b) a = b

end

(* arrays with monomorphic keys *)

theory Array

  type key

  type t 'a

  logic get (t 'a) key : 'a
  logic set (t 'a) key 'a : t 'a
  
  axiom Select_eq : 
    forall m : t 'a. forall a1 a2 : key. 
    forall b : 'a [get (set m a1 b) a2].
    a1 = a2 -> get (set m a1 b) a2 = b

  axiom Select_neq : 
    forall m : t 'a. forall a1 a2 : key. 
    forall b : 'a [get (set m a1 b) a2].
    a1 <> a2 -> get (set m a1 b) a2 = get m a2

  logic create_const 'a : t 'a

  axiom Create_const_get : 
    forall b:'a. forall a:key. get (create_const b) a = b

end

theory ArrayLength

  clone export Array with type key = int

  logic length (t 'a) : int

  axiom Length_set : 
    forall a : t 'a. forall k : int. forall v : 'a.
    length (set a k v) = length a

  logic create_const_length 'a int : t 'a

  axiom Create_const_length_get : 
    forall b:'a. forall n i:int. get (create_const_length b n) i = b

  axiom Create_const_length_length : 
    forall a : 'a. forall n : int. length (create_const_length a n) = n

  logic create_length int : t 'a

  axiom Create_length_length : 
    forall n : int. length (create_length n : t 'a) = n

end

theory ArrayRich

  use import int.Int
  
  clone export ArrayLength

  logic sub (t 'a) int int : t 'a

  axiom Sub_length : 
    forall s : t 'a, ofs len : int. length (sub s ofs len) = len

  axiom Sub_get :
    forall s : t 'a, ofs len i : int. 
    get (sub s ofs len) i = get s (ofs + i)

  logic app (t 'a) (t 'a) : t 'a

  axiom App_length : 
    forall s1 s2 : t 'a. length (app s1 s2) = length s1 + length s2

  axiom App_get :
    forall s1 s2 : t 'a, i : int. 
    get (app s1 s2) i = 
      if i < length s1 then get s1 i else get s2 (i - length s1)

end

(* monomorphic versions (the type of elements is elt) *)

theory ArrayMono

  type key

  type elt

  type t

  logic get t key : elt
  logic set t key elt : t
  
  axiom Select_eq : 
    forall m : t. forall a1 a2 : key. 
    forall b : elt [get (set m a1 b) a2].
    a1 = a2 -> get (set m a1 b) a2 = b

  axiom Select_neq : 
    forall m : t. forall a1 a2 : key. 
    forall b : elt [get (set m a1 b) a2].
    a1 <> a2 -> get (set m a1 b) a2 = get m a2

  logic create_const elt : t

  axiom Create_const_get : 
    forall b:elt. forall a:key. get (create_const b) a = b

end

theory ArrayMonoLength

  clone export ArrayMono with type key = int

  logic length t : int

  axiom Length_set : 
    forall a : t. forall k : int. forall v : elt.
    length (set a k v) = length a

  logic create_const_length elt int : t

  axiom Create_const_length_get : 
    forall b:elt. forall n i:int. get (create_const_length b n) i = b

  axiom Create_const_length_length : 
    forall a : elt. forall n : int. length (create_const_length a n) = n

  logic create_length int : t

  axiom Create_length_length : 
    forall n : int. length (create_length n : t) = n

end

theory ArrayMonoRich

  use import int.Int
  
  clone export ArrayMonoLength

  logic sub t int int : t

  axiom Sub_length : 
    forall s : t, ofs len : int. length (sub s ofs len) = len

  axiom Sub_get :
    forall s : t, ofs len i : int. 
    get (sub s ofs len) i = get s (ofs + i)

  logic app t t : t

  axiom App_length : 
    forall s1 s2 : t. length (app s1 s2) = length s1 + length s2

  axiom App_get :
    forall s1 s2 : t, i : int. 
    get (app s1 s2) i = 
      if i < length s1 then get s1 i else get s2 (i - length s1)

end

theory BitVector

  use export bool.Bool
  use import int.Int

  logic size : int 

  type bv

  logic nth bv int: bool
  
  logic bvzero : bv
  axiom Nth_zero: 
    forall n:int. 0 <= n < size -> nth bvzero n = False

  logic bvone : bv
  axiom Nth_one: 
    forall n:int. 0 <= n < size -> nth bvone n = True

  logic eq (v1 v2 : bv) =
    forall n:int. 0 <= n < size -> nth v1 n = nth v2 n

  logic bw_and (v1 v2 : bv) : bv
  axiom Nth_bw_and: 
    forall v1 v2:bv, n:int. 0 <= n < size -> 
      nth (bw_and v1 v2) n = andb (nth v1 n) (nth v2 n)

  (* logical shift right *)
  logic lsr bv int : bv

  axiom Lsr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (lsr b s) n = nth b (n+s)

  axiom Lsr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (lsr b s) n = False

  (* arithmetic shift right *)
  logic asr bv int : bv

  axiom Asr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (asr b s) n = nth b (n+s)

  axiom Asr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (asr b s) n = nth b (size-1)

  (* logical shift left *)
  logic lsl bv int : bv

  axiom Lsl_nth_high:
    forall b:bv,n s:int. 0 <= n-s < size -> nth (lsl b s) n = nth b (n-s)

  axiom Lsl_nth_low:
    forall b:bv,n s:int. n-s < 0 -> nth (lsl b s) n = False

end


theory BV32

  logic size : int = 32

  clone export BitVector with logic size = size

end


theory TestBv32

  use import BV32

  lemma Test1:
    let b = bw_and bvzero bvone in nth b 1 = False

  lemma Test2:
    let b = lsr bvone 16 in nth b 15 = True
     
  lemma Test3:
    let b = lsr bvone 16 in nth b 16 = False

  lemma Test4:
    let b = asr bvone 16 in nth b 15 = True
     
  lemma Test5:
    let b = asr bvone 16 in nth b 16 = True

  lemma Test6:
    let b = asr (lsr bvone 1) 16 in nth b 16 = False
     
end 


(*
Local Variables: 
compile-command: "cd ..; bin/why.opt theories/array.why"
End: 
*)
