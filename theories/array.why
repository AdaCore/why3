
theory Array "Theory of arrays" 

  type t 'a 'b

  logic get (t 'a 'b) 'a : 'b
  logic set (t 'a 'b) 'a 'b : t 'a 'b

  axiom Select_eq :
    forall m : t 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [get (set m a1 b) a2].
    a1 = a2 -> get (set m a1 b) a2  = b

  axiom Select_neq :
    forall m : t 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [get (set m a1 b) a2].
    a1 <> a2 -> get (set m a1 b) a2 = get m a2

  logic create_const 'b : t 'a 'b

  axiom Const : forall b:'b, a:'a. get (create_const b) a = b

end

theory ArrayLength "Theory of arrays with length"

  (* these arrays ... *)

  use import int.Int

  use export Array

  logic length (t int 'a) : int

  axiom Length_non_negative (* "Array length is always non negative" *):
    forall a : t int 'a. length a >= 0

  axiom Length_set : 
    forall a : t int 'a. forall k : int. forall v : 'a.
    length (set a k v) = length a

  logic create_const_length 'a int : t int 'a
    (* [create_const_length x n] is the array of length n
       with all cells initialized to x 
       (not specified if n is negative)
    *)     

  axiom Create_const_length_get : 
    forall b:'a. forall n i:int. get (create_const_length b n) i = b

  axiom Create_const_length_length : 
    forall a : 'a. forall n : int. 
      (* premise needed to guaranty length >= 0 invariant *)
       n >= 0 -> length (create_const_length a n) = n

  logic create_length int : t int 'a

  axiom Create_length_length : 
    forall n : int. 
      (* premise needed to guaranty length >= 0 invariant *)
      n >=0 -> length (create_length n : t int 'a) = n

end

theory ArrayRich

  use import int.Int
  
  use export ArrayLength

  logic sub (t int 'a) int int : t int 'a

  axiom Sub_length : 
    forall s : t int 'a, ofs len : int. length (sub s ofs len) = len

  axiom Sub_get :
    forall s : t int 'a, ofs len i : int. 
    get (sub s ofs len) i = get s (ofs + i)

  logic app (t int 'a) (t int 'a) : t int 'a

  axiom App_length : 
    forall s1 s2 : t int 'a. length (app s1 s2) = length s1 + length s2

  axiom App_get :
    forall s1 s2 : t int 'a, i : int. 
    get (app s1 s2) i = 
      if i < length s1 then get s1 i else get s2 (i - length s1)

end

theory BitVector

  use export bool.Bool
  use import int.Int

  logic size : int 

  type bv

  logic nth bv int: bool
  
  logic bvzero : bv
  axiom Nth_zero: 
    forall n:int. 0 <= n < size -> nth bvzero n = False

  logic bvone : bv
  axiom Nth_one: 
    forall n:int. 0 <= n < size -> nth bvone n = True

  logic eq (v1 v2 : bv) =
    forall n:int. 0 <= n < size -> nth v1 n = nth v2 n

  logic bw_and (v1 v2 : bv) : bv
  axiom Nth_bw_and: 
    forall v1 v2:bv, n:int. 0 <= n < size -> 
      nth (bw_and v1 v2) n = andb (nth v1 n) (nth v2 n)

  (* logical shift right *)
  logic lsr bv int : bv

  axiom Lsr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (lsr b s) n = nth b (n+s)

  axiom Lsr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (lsr b s) n = False

  (* arithmetic shift right *)
  logic asr bv int : bv

  axiom Asr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (asr b s) n = nth b (n+s)

  axiom Asr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (asr b s) n = nth b (size-1)

  (* logical shift left *)
  logic lsl bv int : bv

  axiom Lsl_nth_high:
    forall b:bv,n s:int. 0 <= n-s < size -> nth (lsl b s) n = nth b (n-s)

  axiom Lsl_nth_low:
    forall b:bv,n s:int. n-s < 0 -> nth (lsl b s) n = False

end


theory BV32

  logic size : int = 32

  clone export BitVector with logic size = size

end


theory TestBv32

  use import BV32

  lemma Test1:
    let b = bw_and bvzero bvone in nth b 1 = False

  lemma Test2:
    let b = lsr bvone 16 in nth b 15 = True
     
  lemma Test3:
    let b = lsr bvone 16 in nth b 16 = False

  lemma Test4:
    let b = asr bvone 16 in nth b 15 = True
     
  lemma Test5:
    let b = asr bvone 16 in nth b 16 = True

  lemma Test6:
    let b = asr (lsr bvone 1) 16 in nth b 16 = False
     
end 


(*
Local Variables: 
compile-command: "cd ..; bin/why.opt theories/array.why"
End: 
*)
