
theory Set

  type t 'a 

  logic mem 'a (t 'a)

  logic empty : t 'a

  logic is_empty (s : t 'a) = forall x : 'a. not mem x s

  axiom Empty_def1 : is_empty(empty : t 'a)

  logic add 'a (t 'a) : t 'a

  axiom Add_def1 : 
    forall x y : 'a. forall s : t 'a.
    mem x (add y s) <-> x = y or mem x s

  logic remove 'a (t 'a) : t 'a

  axiom Remove_def1 :
    forall x y : 'a. forall s : t 'a.
    mem x (remove y s) <-> x <> y and mem x s

  logic union (t 'a) (t 'a) : t 'a

  axiom Union_def1 : 
    forall s1 s2 : t 'a. forall x : 'a.
    mem x (union s1 s2) <-> mem x s1 or mem x s2

  logic inter (t 'a) (t 'a) : t 'a

  axiom Inter_def1 : 
    forall s1 s2 : t 'a. forall x : 'a.
    mem x (inter s1 s2) <-> mem x s1 and mem x s2

  logic diff (t 'a) (t 'a) : t 'a

  axiom Diff_def1 : 
    forall s1 s2 : t 'a. forall x : 'a.
    mem x (diff s1 s2) <-> mem x s1 and not mem x s2

  logic equal(s1 s2 : t 'a) = forall x : 'a. mem x s1 <-> mem x s2

  logic subset(s1 s2 : t 'a) = forall x : 'a. mem x s1 -> mem x s2

end

(* finite sets *)
theory Fset
  use import int.Int
  clone export Set
  
  logic cardinal (t 'a) : int

  axiom Cardinal_nonneg : forall s : t 'a. cardinal s >= 0

  axiom Cardinal_empty : cardinal(empty : t 'a) = 0

  axiom Cardinal_add : 
    forall x : 'a. forall s : t 'a. 
    not mem x s -> cardinal (add x s) = 1 + cardinal s

  axiom Cardinal_remove : 
    forall x : 'a. forall s : t 'a. 
    mem x s -> cardinal s = 1 + cardinal (remove x s)

  axiom Cardinal_subset :
    forall s1 s2 : t 'a. subset s1 s2 -> cardinal s1 <= cardinal s2

end

theory FsetExt
 
  use export Fset

  axiom ext: forall s1 s2 : t 'a.
    s1 = s2 <-> (forall x : 'a. mem x s1 <-> mem x s2)

end

theory SetArray
  use import array.Array as A
  use import bool.Bool

  type t 'a = A.t 'a bool

  logic mem (x:'a) (s:t 'a) = get s x = True

  logic empty : t 'a = create_const False

  logic is_empty (s : t 'a) = forall x : 'a. not mem x s

  goal Empty_def1 : is_empty(empty : t 'a)

  logic add (x:'a) (s:t 'a) : t 'a = set s x True

  logic remove (x:'a) (s:t 'a) : t 'a =  set s x False

  logic union (t 'a) (t 'a) : t 'a

  axiom Union_def :
    forall s1 s2 : t 'a. forall x : 'a.
    get (union s1 s2) x = orb (get s1 x) (get s2 x)

  logic inter (t 'a) (t 'a) : t 'a

  axiom Inter_def :
    forall s1 s2 : t 'a. forall x : 'a.
    get (inter s1 s2) x = andb (get s1 x) (get s2 x)

  logic diff (t 'a) (t 'a) : t 'a

  axiom Diff_def1 :
    forall s1 s2 : t 'a. forall x : 'a.
    get (diff s1 s2) x = xorb (get s1 x) (get s2 x)

  logic equal(s1 s2 : t 'a) = forall x : 'a. get s1 x = get s2 x

  axiom Equal_is_eq : forall s1 s2 : t 'a. equal s1 s2 -> s1 = s2

  logic subset(s1 s2 : t 'a) = forall x : 'a. mem x s1 -> mem x s2

  logic complement (t 'a) : t 'a

  axiom Complement_def :
    forall s : t 'a. forall x : 'a.
    get (complement s) x = notb (get s x)

end