

(* definition of IEEE-754 rounding modes *)
theory Rounding

  type mode = NearestTiesToEven | ToZero | Up | Down | NearTiesToAway
    (** nearest ties to even, to zero, upward, downward, nearest ties to away *)

end


(* handling of IEEE-754 special values +\infty, -\infty, NaN, +0, -0 *)
theory SpecialValues
 
  type class = Finite | Infinite | NaN 

  type sign = Neg | Pos

  use import real.Real

  inductive same_sign_real(sign,real) =
    | Neg_case: forall x:real. x < 0.0 -> same_sign_real Neg x
    | Pos_case: forall x:real. x > 0.0 -> same_sign_real Pos x

end

theory GenFloat

  use import Rounding
  use import real.Real
  use import real.Abs
  use import real.FromInt
  use int.Int

  type t

  logic round(mode,real) : real
  logic round_logic(mode,real) : t

  logic value(t) : real
  logic exact(t) : real
  logic model(t) : real

  logic round_error(x:t) : real = abs (value x - exact x)
  logic total_error(x:t) : real = abs (value x - model x)

  logic max : real

  logic no_overflow(m:mode,x:real) = abs (round m x) <= max

  axiom Bounded_real_no_overflow :
    forall m:mode, x:real. abs x <= max -> no_overflow m x

  axiom Round_monotonic :
    forall m:mode, x y:real. x <= y -> round m x <= round m y

  logic max_representable_integer : int

  axiom Exact_rounding_for_integers:
    forall m:mode,i:int.
      Int.(<=) (Int.(-_) max_representable_integer) i and 
      Int.(<=) i max_representable_integer ->
        round m (from_int i) = from_int i

  (* rounding up and down *)
  axiom Round_down_le: 
    forall x:real. round Down x <= x
  axiom Round_up_ge: 
    forall x:real. round Up x >= x
  axiom Round_down_neg: 
    forall x:real. round Down (-x) = - round Up x
  axiom Round_up_neg:
    forall x:real. round Up (-x) = - round Down x

end

theory GenFloatFull

  use import GenFloat
  use import SpecialValues

  (* special values *)
  logic class(t) : class
  logic sign(t)  : sign

end

theory Single

  type single

  logic max_single : real = 0x1.FFFFFEp127
  logic max_int : int = 16777216 (* 2^24 *)

  clone export GenFloat with 
    type t = single, 
    logic max = max_single, 
    logic max_representable_integer = max_int

end



theory Double

  type double

  logic max_double : real = 0x1.FFFFFFFFFFFFFp1023
  logic max_int : int = 9007199254740992 (* 2^23 *)

  clone export GenFloat with 
    type t = double, 
    logic max = max_double,
    logic max_representable_integer = max_int

end

theory Test

  use import Rounding
  use import Single

  lemma Round_01: round NearestTiesToEven 0.1 = 0x0.199999Ap0

end

