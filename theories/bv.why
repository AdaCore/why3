
(** {1 Bit vectors} *)

(** {2 Generic theory (arbitrary length)} *)

theory BitVector

  use export bool.Bool
  use import int.Int

  constant size : int

  (* useful ? *)
  axiom size_pos: size > 0

  type t

  function nth t int: bool
  (** [nth b n] is the n-th bit of x (0 <= n < size). bit 0 is
      the least significant bit *)

  function nth_bv t t : bool

  predicate eq (v1 v2 : t) =
    forall n:int. 0 <= n < size -> nth v1 n = nth v2 n

  axiom Extensionality: forall x y : t. eq x y -> x = y

  constant zero : t
  axiom Nth_zero:
    forall n:int. 0 <= n < size -> nth zero n = False

  constant ones : t
  axiom Nth_ones:
    forall n:int. 0 <= n < size -> nth ones n = True

  function bw_and (v1 v2 : t) : t
  axiom Nth_bw_and:
    forall v1 v2:t, n:int. 0 <= n < size ->
      nth (bw_and v1 v2) n = andb (nth v1 n) (nth v2 n)

  function bw_or (v1 v2 : t) : t
  axiom Nth_bw_or:
    forall v1 v2:t, n:int. 0 <= n < size ->
      nth (bw_or v1 v2) n = orb (nth v1 n) (nth v2 n)

  function bw_xor (v1 v2 : t) : t
  axiom Nth_bw_xor:
    forall v1 v2:t, n:int. 0 <= n < size ->
      nth (bw_xor v1 v2) n = xorb (nth v1 n) (nth v2 n)

  function bw_not (v : t) : t
  axiom Nth_bw_not:
    forall v:t, n:int. 0 <= n < size ->
      nth (bw_not v) n = notb (nth v n)

  function rotate_left (v : t) : t

  function rotate_right (v : t) : t

  (** logical shift right *)
  function lsr t int : t

  axiom Lsr_nth_low:
    forall b:t,n s:int. 0 <= s < size -> 0 <= n < size -> n+s < size -> 
      nth (lsr b s) n = nth b (n+s)

  axiom Lsr_nth_high:
    forall b:t,n s:int. 0 <= s < size -> 0 <= n < size -> n+s >= size -> 
      nth (lsr b s) n = False

  function lsr_bv t t : t

  (** arithmetic shift right *)
  function asr t int : t

  axiom Asr_nth_low:
    forall b:t,n s:int. 0 <= s < size -> 0 <= n < size -> 0 <= n+s < size -> nth (asr b s) n = nth b (n+s)

  axiom Asr_nth_high:
    forall b:t,n s:int. 0 <= s < size -> 0 <= n < size -> n+s >= size -> nth (asr b s) n = nth b (size-1)

  function asr_bv t t : t

  (** logical shift left *)
  function lsl t int : t

  axiom Lsl_nth_high:
    forall b:t,n s:int. 0 <= s < size -> 0 <= n < size -> 0 <= n-s < size -> nth (lsl b s) n = nth b (n-s)

  axiom Lsl_nth_low:
    forall b:t,n s:int. 0 <= s < size -> 0 <= n < size -> n-s < 0 -> nth (lsl b s) n = False

  function lsl_bv t t : t

  (** conversion to unsigned integers *)
  function to_uint t: int

  (* TODO? axiom 0 <= to_int b < power 2 size *)

  (** conversion to signed integers *)
  function to_int t: int

  (* TODO? axiom - power 2 (size-1) <= to_int b < power 2 (size-1) *)

  (** conversion from integers. The (infinitary) 2-complement binary
  representation of the argument is truncated to [size] bits *)
  function of_int int: t

  constant one : t = of_int 1

  (* TODO? axioms related to_int/to_unit and of_int *)

  use import int.Power
  use import int.EuclideanDivision

  (** addition modulo 2^m *) 
  function add (v1 v2 : t) : t
  (* axiom Add_is_add: *)
  (*   forall v1 v2:t. add v1 v2 = of_int( mod (to_int (v1) + to_int (v2)) (power 2 32)) *)
  
  (** 2's complement subtraction modulo 2^m *)
  function sub (v1 v2 : t) : t
  (* axiom Min_is_min: *)
  (*   forall v1 v2:t. sub v1 v2 = of_int( mod (to_int (v1) - to_int (v2)) (power 2 32)) *)
      
  (** 2's complement unary minus *)
  function neg (v1 : t) : t
  (* axiom Neg_is_neg: *)
  (*   forall v:t. neg v = of_int( mod (-to_int (v)) (power 2 32)) *)
  
  (** multiplication modulo 2^m *)	
  function mul (v1 v2 : t) : t
  (* axiom Mul_is_mul: *)
  (*   forall v1 v2:t. mul v1 v2 = of_int( mod (to_int (v1) * to_int (v2)) (power 2 32)) *)

  (** unsigned division, truncating towards 0 (undefined if divisor is 0) *)  
  function udiv (v1 v2 : t) : t
  (* axiom Udiv_is_udiv: *)
  (*   forall v1 v2:t. udiv v1 v2 = of_int (to_uint (v1) / to_uint (v2)) *)

  (** unsigned remainder from truncating division (undefined if divisor is 0) *)
  function urem (v1 v2 : t) : t

  (** 2's complement signed division *)
  function sdiv (v1 v2 : t) : t

  (** 2's complement signed remainder (sign follows dividend) *)
  function srem (v1 v2 : t) : t

  (** 2's complement signed remainder (sign follows divisor) *)
  function smod (v1 v2 : t) : t

  (** binary predicate for signed less than *)
  predicate slt (v1 v2 : t) =
    (to_int v1) < (to_int v2)

  (** binary predicate for signed less than or equal *)
  predicate sle (v1 v2 : t) =
    (to_int v1) <= (to_int v2)

  (**  binary predicate for signed greater than *)
  predicate sgt (v1 v2 : t) =
    (to_int v1) > (to_int v2)

  (**  binary predicate for signed greater than or equal *)
  predicate sge (v1 v2 : t) =
    (to_int v1) >= (to_int v2)

  (** binary predicate for unsigned less than *)
  predicate ult (v1 v2 : t) =
    (to_uint v1) < (to_uint v2)

  (** binary predicate for unsigned less than or equal *)
  predicate ule (v1 v2 : t) =
    (to_uint v1) <= (to_uint v2)

  (**  binary predicate for unsigned greater than *)
  predicate ugt (v1 v2 : t) =
    (to_uint v1) > (to_uint v2)

  (**  binary predicate for unsigned greater than or equal *)
  predicate uge (v1 v2 : t) =
    (to_uint v1) >= (to_uint v2)

end

(** {2 31-bits Bitvectors} *)

theory BV31
  constant size: int = 31
  clone export BitVector with constant size = size, goal size_pos
end

(** {2 32-bits Bitvectors} *)

theory BV32
  constant size: int = 32
  clone export BitVector with constant size = size, goal size_pos
end

(** {2 63-bits Bitvectors} *)

theory BV63
  constant size: int = 63
  clone export BitVector with constant size = size, goal size_pos
end

(** {2 64-bits Bitvectors} *)

theory BV64
  constant size: int = 64
  clone export BitVector with constant size = size, goal size_pos
end


