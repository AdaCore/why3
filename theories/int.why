
theory Int 

  logic zero : int = 0
  logic one  : int = 1
  
  clone export algebra.UnitaryCommutativeRing with 
     type t = int, logic zero = zero, logic one = one

  logic (< ) (int, int)
  logic (<=) (x:int, y:int) = x < y or x = y
  logic (> ) (x:int, y:int) = y < x
  logic (>=) (x:int, y:int) = y <= x

  clone export relations.TotalOrder with
    type t = int, logic rel = (<=)

end


theory Abs

  use import Int

  logic abs(x:int) : int = if x >= 0 then x else -x

  lemma Abs_pos: forall x:int. abs x >= 0

end

(*
theory MinMax

  use import Int

  logic min(x:int,y:int) : int = if x <= y then x else y
  logic max(x:int,y:int) : int = if x <= y then y else x

  lemma Max_is_ge   : forall x y:int. max x y >= x and max x y >= y
  lemma Max_is_some : forall x y:int. max x y = x or max x y = y
  lemma Min_is_le   : forall x y:int. min x y <= x and min x y <= y
  lemma Min_is_some : forall x y:int. min x y = x or min x y = y

end
*)


theory EuclideanDivision

  use import Int
  use import Abs

  logic div(int,int) : int
  logic mod(int,int) : int

  axiom Div_mod: 
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Mod_bound: 
    forall x y:int. y <> 0 -> 0 <= mod x y < abs y

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory ComputerDivision

  use import Int
  use import Abs

  logic div(int,int) : int
  logic mod(int,int) : int

  axiom Div_mod: 
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Mod_bound: 
    forall x y:int. y <> 0 -> -abs y < mod x y < abs y

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

