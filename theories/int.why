
theory Int

  logic zero : int = 0
  logic one  : int = 1

  logic (< ) int int
  logic (> ) (x y : int) = y < x
  logic (<=) (x y : int) = x < y or x = y

  clone export algebra.OrderedUnitaryCommutativeRing with
     type t = int, logic zero = zero, logic one = one, logic (<=) = (<=)

end


theory Abs

  use import Int

  logic abs (x:int) : int = if x >= 0 then x else -x

  lemma Abs_pos: forall x:int. abs x >= 0

end

theory MinMax

  use import Int
  clone export comparison.MinMax with type t = int, logic ge = (>=)

end

theory EuclideanDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod:
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Div_bound:
    forall x y:int. x >= 0 and y > 0 -> 0 <= div x y <= x

  axiom Mod_bound:
    forall x y:int. y <> 0 -> 0 <= mod x y < abs y

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory ComputerDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod:
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Div_bound:
    forall x y:int. x >= 0 and y > 0 -> 0 <= div x y <= x

  axiom Mod_bound:
    forall x y:int. y <> 0 -> - abs y < mod x y < abs y

  axiom Div_sign_pos:
    forall x y:int. x >= 0 and y > 0 -> div x y >= 0

  axiom Div_sign_neg:
    forall x y:int. x <= 0 and y > 0 -> div x y <= 0

  axiom Mod_sign_pos:
    forall x y:int. x >= 0 and y <> 0 -> mod x y >= 0

  axiom Mod_sign_neg:
    forall x y:int. x <= 0 and y <> 0 -> mod x y <= 0

  lemma Rounds_toward_zero:
    forall x y:int. y <> 0 -> abs (div x y * y) <= abs x

  lemma Div_1: forall x:int. div x 1 = x

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_inf: forall x y:int. 0 <= x < y -> div x y = 0

  lemma Mod_inf: forall x y:int. 0 <= x < y -> mod x y = x

  lemma Div_mult: forall x y z:int [div (x * y + z) x]. 
          x > 0 and y >= 0 and z >= 0 ->
          div (x * y + z) x = y + div z x

  lemma Mod_mult: forall x y z:int [mod (x * y + z) x]. 
          x > 0 and y >= 0 and z >= 0 ->
          mod (x * y + z) x = mod z x

end

theory Exponentiation
  use import Int

  type t
  logic one : t
  logic (*) t t : t
  
  logic power t int : t

  axiom Power_0 : forall x: t. power x 0 = one

  axiom Power_s : forall x: t, n: int. n >= 0 -> power x (n+1) = x * power x n

end

theory Power

  use import Int

  clone export 
    Exponentiation with type t = int, logic one = one, logic (*) = (*)

  lemma Power_1 : forall x : int. power x 1 = x

  lemma Power_sum : forall x n m : int. 0 <= n -> 0 <= m ->
    power x (n + m) = power x n * power x m

  lemma Power_mult : forall x n m : int. 0 <= n -> 0 <= m ->
    power x (n * m) = power (power x n) m


end

theory NumOfParam

  type param

  use import Int

  logic pr param int

  (** number of [n] such that [a <= n < b] and [pr(p,n)] *)
  logic num_of (p : param) (a b : int) : int

  axiom Num_of_empty :
    forall p : param, a b : int.
    b <= a -> num_of p a b = 0

  axiom Num_of_right_no_add :
    forall p : param, a b : int.
    a < b -> not pr p (b-1) -> num_of p a b = num_of p a (b-1)
  axiom Num_of_right_add :
    forall p : param, a b : int.
    a < b -> pr p (b-1) -> num_of p a b = 1 + num_of p a (b-1)

  lemma Num_of_non_negative :
    forall p : param, a b : int. 0 <= num_of p a b
    (* direct when a>=b, by induction on b when a <= b *)

  lemma Num_of_append :
    forall p : param, a b c : int.
    a <= b <= c -> num_of p a c = num_of p a b + num_of p b c
    (* by induction on c *)

  lemma Num_of_left_no_add :
    forall p : param, a b : int.
    a < b -> not pr p a -> num_of p a b = num_of p (a+1) b
    (* by Num_of_append *)
  lemma Num_of_left_add :
    forall p : param, a b : int.
    a < b -> pr p a -> num_of p a b = 1 + num_of p (a+1) b
    (* by Num_of_append *)

  lemma Empty :
    forall p : param, a b : int.
    (forall n : int. a <= n < b -> not pr p n) -> num_of p a b = 0
    (* by induction on b *)

  lemma num_of_increasing:
    forall p : param, i j k : int.
    i <= j <= k -> num_of p i j <= num_of p i k
    (* by Num_of_append and Num_of_non_negative *)

  lemma num_of_strictly_increasing:
    forall p : param, i j k l : int.
    i <= j <= k < l -> pr p k -> num_of p i j < num_of p i l
    (* by Num_of_append and num_of_increasing *)

end

theory NumOf

  logic pr int

  logic pr0 () (n : int) = pr n

  clone NumOfParam as N with type param = tuple0, logic pr = pr0

  logic num_of (a b : int) : int = N.num_of () a b

end

(* number theory *)

theory Divisibility

  use import Int

  logic divides (a b : int) = exists q : int. b = q * a

  lemma Divides_x_zero: forall x:int. divides x 0 

  lemma Divides_one_x: forall x:int. divides 1 x 

  (* todo: divides x y <-> if y=0 then true else x mod y = 0 *)
end

theory Gcd

  use import Int
  use import Divisibility

  logic gcd (a b g : int) =
    divides g a and
    divides g b and
    forall x : int. divides x a -> divides x b -> divides x g

  lemma Gcd_sym : forall a b g : int. gcd a b g -> gcd b a g

  lemma Gcd_0 : forall a : int. gcd a 0 a

  lemma Gcd_euclid : forall a b q g : int. gcd a (b - q * a) g -> gcd a b g

  use ComputerDivision

  lemma Gcd_computer_mod : 
    forall a b g : int [gcd a (ComputerDivision.mod a b) g]. 
      b <> 0 -> gcd a (ComputerDivision.mod a b) g -> gcd a b g

  use EuclideanDivision

  lemma Gcd_euclidean_mod : 
    forall a b g : int [gcd a (EuclideanDivision.mod a b) g]. 
      b <> 0 -> gcd a (EuclideanDivision.mod a b) g -> gcd a b g

end

theory Induction
  use import Int

  logic p int

  axiom Induction :
    (forall n:int. 0 <= n -> (forall k:int. 0 <= k < n -> p k) -> p n) ->
    forall n:int. 0 <= n -> p n

end

(*
Local Variables:
compile-command: "make -C .. theories/int.gui"
End:
*)
