
theory Int 

  logic zero : int = 0
  logic one  : int = 1
  
  clone export algebra.UnitaryCommutativeRing with 
     type t = int, logic zero = zero, logic one = one

  logic (< ) int int
  logic (<=) (x y : int) = x < y or x = y
  logic (> ) (x y : int) = y < x
  logic (>=) (x y : int) = y <= x

  clone export relations.TotalOrder with
    type t = int, logic rel = (<=)

end


theory Abs

  use import Int

  logic abs (x:int) : int = if x >= 0 then x else -x

  lemma Abs_pos: forall x:int. abs x >= 0

end

(*
theory MinMax

  use import Int

  logic min (x y : int) : int = if x <= y then x else y
  logic max (x y : int) : int = if x <= y then y else x

  lemma Max_is_ge   : forall x y:int. max x y >= x and max x y >= y
  lemma Max_is_some : forall x y:int. max x y = x or max x y = y
  lemma Min_is_le   : forall x y:int. min x y <= x and min x y <= y
  lemma Min_is_some : forall x y:int. min x y = x or min x y = y

end
*)


theory EuclideanDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod: 
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Mod_bound: 
    forall x y:int. y <> 0 -> 0 <= mod x y < abs y

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory ComputerDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod: 
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Mod_bound: 
    forall x y:int. y <> 0 -> - abs y < mod x y < abs y

  axiom Mod_sign_pos:
    forall x y:int. x >= 0 and y <> 0 -> mod x y >= 0

  axiom Mod_sign_neg:
    forall x y:int. x <= 0 and y <> 0 -> mod x y <= 0

  lemma Rounds_toward_zero:
    forall x y:int. y <> 0 -> abs (div x y * y) <= abs x

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory Power

  use import Int

  logic power (x n : int) : int =
    if n = 0 then 1 else x * power x (n-1)

end

theory NumOfParam

  type param

  use import Int

  logic pr param int

  (* number of n st a <= n < b and pr(p,n) *)
  logic num_of (p : param) (a b : int) : int

  axiom Num_of_empty : 
    forall p : param, a b : int. 
    b <= a -> num_of p a b = 0

  axiom Num_of_left_no_add : 
    forall p : param, a b : int. 
    a < b -> not pr p a -> num_of p a b = num_of p (a+1) b
  axiom Num_of_left_add : 
    forall p : param, a b : int. 
    a < b -> pr p a -> num_of p a b = 1 + num_of p (a+1) b

  axiom Num_of_right_no_add : 
    forall p : param, a b : int. 
    a < b -> not pr p (b-1) -> num_of p a b = num_of p a (b-1)
  axiom Num_of_right_add : 
    forall p : param, a b : int. 
    a < b -> pr p (b-1) -> num_of p a b = 1 + num_of p a (b-1)

  axiom Num_of_append :
    forall p : param, a b c : int. 
    a <= b <= c -> num_of p a c = num_of p a b + num_of p b c

  axiom Empty :
    forall p : param, a b : int.
    (forall n : int. a <= n < b -> not pr p n) -> num_of p a b = 0

end

theory NumOf

  logic pr int

  logic pr0 () (n : int) = pr n

  clone NumOfParam as N with type param = tuple0, logic pr = pr0

  logic num_of (a b : int) : int = N.num_of () a b

end

(* number theory *)

theory Divisibility

  use import Int

  logic divides (a b : int) = exists q : int. b = q * a

end

theory Gcd 

  use import Int
  use import Divisibility

  logic gcd (a b g : int) = 
    divides g a and 
    divides g b and
    forall x : int. divides x a -> divides x b -> divides x g

  lemma Gcd_sym : forall a b g : int. gcd a b g -> gcd b a g
 
  lemma Gcd_0 : forall a : int. gcd a 0 a

  lemma Gcd_euclid : forall a b q g : int. gcd a (b - q * a) g -> gcd a b g

end

(*
Local Variables: 
compile-command: "../bin/why.opt int.why"
End: 
*)
