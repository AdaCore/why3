
theory Int 

  logic zero : int = 0
  logic one  : int = 1
  
  clone export algebra.UnitaryCommutativeRing with 
     type t = int, logic zero = zero, logic one = one

  logic (< ) int int
  logic (<=) (x y : int) = x < y or x = y
  logic (> ) (x y : int) = y < x
  logic (>=) (x y : int) = y <= x

  clone export relations.TotalOrder with
    type t = int, logic rel = (<=)

end


theory Abs

  use import Int

  logic abs (x:int) : int = if x >= 0 then x else -x

  lemma Abs_pos: forall x:int. abs x >= 0

end

(*
theory MinMax

  use import Int

  logic min (x y : int) : int = if x <= y then x else y
  logic max (x y : int) : int = if x <= y then y else x

  lemma Max_is_ge   : forall x y:int. max x y >= x and max x y >= y
  lemma Max_is_some : forall x y:int. max x y = x or max x y = y
  lemma Min_is_le   : forall x y:int. min x y <= x and min x y <= y
  lemma Min_is_some : forall x y:int. min x y = x or min x y = y

end
*)


theory EuclideanDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod: 
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Mod_bound: 
    forall x y:int. y <> 0 -> 0 <= mod x y < abs y

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory ComputerDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod: 
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Mod_bound: 
    forall x y:int. y <> 0 -> -abs y < mod x y < abs y

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory Power

  use import Int

  logic power (x n : int) : int =
    if n = 0 then 1 else x * power x (n-1)

end

theory NumOf

  use import Int

  logic p int

  (* number of n st a <= n < b and p(n) *)
  logic num_of (a b : int) : int

  axiom Num_of_empty : 
    forall a b : int. b <= a -> num_of a b = 0
  axiom Num_of_zero : 
    forall a b : int. a < b -> not p a -> num_of a b = num_of (a+1) b
  axiom Num_of_one : 
    forall a b : int. a < b -> p a -> num_of a b = 1 + num_of (a+1) b
  axiom Num_of_append :
    forall a b c : int. a < b < c -> num_of a c = num_of a b + num_of b c

end

theory NumOfDep

  type dep

  use import Int

  logic p dep int

  (* number of n st a <= n < b and p(d,n) *)
  logic num_of dep (a b : int) : int

  axiom Num_of_empty : 
    forall d : dep, a b : int. 
    b <= a -> num_of d a b = 0
  axiom Num_of_zero : 
    forall d : dep, a b : int. 
    a < b -> not p d a -> num_of d a b = num_of d (a+1) b
  axiom Num_of_one : 
    forall d : dep, a b : int. 
    a < b -> p d a -> num_of d a b = 1 + num_of d (a+1) b
  axiom Num_of_append :
    forall d : dep, a b c : int. 
    a < b < c -> num_of d a c = num_of d a b + num_of d b c

end
