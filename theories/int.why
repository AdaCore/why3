
theory Int

  logic zero : int = 0
  logic one  : int = 1

  clone export algebra.UnitaryCommutativeRing with
     type t = int, logic zero = zero, logic one = one

  logic (< ) int int
  logic (<=) (x y : int) = x < y or x = y
  logic (> ) (x y : int) = y < x
  logic (>=) (x y : int) = y <= x

  clone export relations.TotalOrder with
    type t = int, logic rel = (<=)

end


theory Abs

  use import Int

  logic abs (x:int) : int = if x >= 0 then x else -x

  lemma Abs_pos: forall x:int. abs x >= 0

end

theory MinMax

  use import Int
  clone export comparison.MinMax with type t = int, logic ge = (>=)

end

theory EuclideanDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod:
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Div_bound:
    forall x y:int. x >= 0 and y > 0 -> 0 <= div x y <= x

  axiom Mod_bound:
    forall x y:int. y <> 0 -> 0 <= mod x y < abs y

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory ComputerDivision

  use import Int
  use import Abs

  logic div int int : int
  logic mod int int : int

  axiom Div_mod:
    forall x y:int. y <> 0 -> x = y * div x y + mod x y

  axiom Div_bound:
    forall x y:int. x >= 0 and y > 0 -> 0 <= div x y <= x

  axiom Mod_bound:
    forall x y:int. y <> 0 -> - abs y < mod x y < abs y

  axiom Div_sign_pos:
    forall x y:int. x >= 0 and y > 0 -> div x y >= 0

  axiom Div_sign_neg:
    forall x y:int. x <= 0 and y > 0 -> div x y <= 0

  axiom Mod_sign_pos:
    forall x y:int. x >= 0 and y <> 0 -> mod x y >= 0

  axiom Mod_sign_neg:
    forall x y:int. x <= 0 and y <> 0 -> mod x y <= 0

  lemma Rounds_toward_zero:
    forall x y:int. y <> 0 -> abs (div x y * y) <= abs x

  lemma Mod_1: forall x:int. mod x 1 = 0

  lemma Div_1: forall x:int. div x 1 = x

end

theory Power

  use import Int

  logic power (x n : int) : int =
    if n = 0 then 1 else x * power x (n-1)

end

theory NumOfParam

  type param

  use import Int

  logic pr param int

  (* number of n st a <= n < b and pr(p,n) *)
  logic num_of (p : param) (a b : int) : int

  axiom Num_of_empty :
    forall p : param, a b : int.
    b <= a -> num_of p a b = 0

  axiom Num_of_left_no_add :
    forall p : param, a b : int.
    a < b -> not pr p a -> num_of p a b = num_of p (a+1) b
  axiom Num_of_left_add :
    forall p : param, a b : int.
    a < b -> pr p a -> num_of p a b = 1 + num_of p (a+1) b

  axiom Num_of_right_no_add :
    forall p : param, a b : int.
    a < b -> not pr p (b-1) -> num_of p a b = num_of p a (b-1)
  axiom Num_of_right_add :
    forall p : param, a b : int.
    a < b -> pr p (b-1) -> num_of p a b = 1 + num_of p a (b-1)

  axiom Num_of_append :
    forall p : param, a b c : int.
    a <= b <= c -> num_of p a c = num_of p a b + num_of p b c

  axiom Empty :
    forall p : param, a b : int.
    (forall n : int. a <= n < b -> not pr p n) -> num_of p a b = 0

end

theory NumOf

  logic pr int

  logic pr0 () (n : int) = pr n

  clone NumOfParam as N with type param = tuple0, logic pr = pr0

  logic num_of (a b : int) : int = N.num_of () a b

end

(* number theory *)

theory Divisibility

  use import Int

  logic divides (a b : int) = exists q : int. b = q * a

end

theory Gcd

  use import Int
  use import Divisibility

  logic gcd (a b g : int) =
    divides g a and
    divides g b and
    forall x : int. divides x a -> divides x b -> divides x g

  lemma Gcd_sym : forall a b g : int. gcd a b g -> gcd b a g

  lemma Gcd_0 : forall a : int. gcd a 0 a

  lemma Gcd_euclid : forall a b q g : int. gcd a (b - q * a) g -> gcd a b g

end

(*
Local Variables:
compile-command: "../bin/why.opt int.why"
End:
*)
