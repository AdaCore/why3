
theory Map "Theory of maps"

  type map 'a 'b

  logic get (map 'a 'b) 'a : 'b
  logic set (map 'a 'b) 'a 'b : map 'a 'b

  (* syntactic sugar *)
  logic ([])   (a : map 'a 'b) (i : 'a) : 'b = get a i
  logic ([<-]) (a : map 'a 'b) (i : 'a) (v : 'b) : map 'a 'b = set a i v

  axiom Select_eq :
    forall m : map 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [m[a1 <- b][a2]].
    a1 = a2 -> m[a1 <- b][a2]  = b

  axiom Select_neq :
    forall m : map 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [m[a1 <- b][a2]].
    a1 <> a2 -> m[a1 <- b][a2] = m[a2]

  logic const 'b : map 'a 'b

  axiom Const : forall b:'b, a:'a. (const b)[a] = b

end

theory MapSorted

  use import int.Int
  use import Map

  type elt

  logic le elt elt

  (* a[l..u) is sorted for le *)
  logic sorted_sub (a : map int elt) (l u : int) =
    forall i1 i2 : int. l <= i1 <= i2 < u -> le a[i1] a[i2]

end

theory MapEq

  use import int.Int
  use export Map

  logic map_eq_sub (a1 a2 : map int 'a) (l u : int) =
    forall i:int. l <= i < u -> a1[i] = a2[i]

end

theory MapPermut

  use import int.Int
  use export Map
  use import MapEq

  logic exchange (a1 a2 : map int 'a) (i j : int) =
    a1[i] = a2[j] and a2[i] = a1[j] and
    forall k:int. (k <> i and k <> j) -> a1[k] = a2[k]

  lemma exchange_set :
    forall a : map int 'a. forall i j : int.
    exchange a a[i <- a[j]][j <- a[i]] i j

  inductive permut_sub (map int 'a) (map int 'a) int int =
  | permut_refl :
      forall a1 a2 : map int 'a. forall l u : int.
      map_eq_sub a1 a2 l u -> permut_sub a1 a2 l u
  | permut_sym :
      forall a1 a2 : map int 'a. forall l u : int.
      permut_sub a1 a2 l u -> permut_sub a2 a1 l u
  | permut_trans :
      forall a1 a2 a3 : map int 'a. forall l u : int.
      permut_sub a1 a2 l u -> permut_sub a2 a3 l u -> permut_sub a1 a3 l u
  | permut_exchange :
      forall a1 a2 : map int 'a. forall l u i j : int.
      l <= i < u -> l <= j < u -> exchange a1 a2 i j -> permut_sub a1 a2 l u

  lemma permut_weakening :
    forall a1 a2 : map int 'a. forall l1 r1 l2 r2 : int.
    l1 <= l2 <= r2 <= r1 -> permut_sub a1 a2 l2 r2 -> permut_sub a1 a2 l1 r1

  lemma permut_eq :
    forall a1 a2 : map int 'a. forall l u : int.
    l <= u -> permut_sub a1 a2 l u ->
    forall i:int. (i < l or u <= i) -> a2[i] = a1[i]

  lemma permut_exists :
    forall a1 a2 : map int 'a. forall l u : int.
    permut_sub a1 a2 l u ->
    forall i : int. l <= i < u ->
    exists j : int. l <= j < u and a2[i] = a1[j]

end

theory MapSum

  use import int.Int
  use export Map

  (* [sum m l h] is the sum of m[i] for l <= i < h *)

  type container = map int int
  clone export sum.Sum with type container = container, logic f = get

end

theory BitVector

  use export bool.Bool
  use import int.Int

  logic size : int

  type bv

  logic nth bv int: bool

  logic bvzero : bv
  axiom Nth_zero:
    forall n:int. 0 <= n < size -> nth bvzero n = False

  logic bvone : bv
  axiom Nth_one:
    forall n:int. 0 <= n < size -> nth bvone n = True

  logic eq (v1 v2 : bv) =
    forall n:int. 0 <= n < size -> nth v1 n = nth v2 n

  logic bw_and (v1 v2 : bv) : bv
  axiom Nth_bw_and:
    forall v1 v2:bv, n:int. 0 <= n < size ->
      nth (bw_and v1 v2) n = andb (nth v1 n) (nth v2 n)

  (* logical shift right *)
  logic lsr bv int : bv

  axiom Lsr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (lsr b s) n = nth b (n+s)

  axiom Lsr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (lsr b s) n = False

  (* arithmetic shift right *)
  logic asr bv int : bv

  axiom Asr_nth_low:
    forall b:bv,n s:int. 0 <= n+s < size -> nth (asr b s) n = nth b (n+s)

  axiom Asr_nth_high:
    forall b:bv,n s:int. n+s >= size -> nth (asr b s) n = nth b (size-1)

  (* logical shift left *)
  logic lsl bv int : bv

  axiom Lsl_nth_high:
    forall b:bv,n s:int. 0 <= n-s < size -> nth (lsl b s) n = nth b (n-s)

  axiom Lsl_nth_low:
    forall b:bv,n s:int. n-s < 0 -> nth (lsl b s) n = False

end


theory BV32

  logic size : int = 32

  clone export BitVector with logic size = size

end


theory TestBv32

  use import BV32

  lemma Test1:
    let b = bw_and bvzero bvone in nth b 1 = False

  lemma Test2:
    let b = lsr bvone 16 in nth b 15 = True

  lemma Test3:
    let b = lsr bvone 16 in nth b 16 = False

  lemma Test4:
    let b = asr bvone 16 in nth b 15 = True

  lemma Test5:
    let b = asr bvone 16 in nth b 16 = True

  lemma Test6:
    let b = asr (lsr bvone 1) 16 in nth b 16 = False

end


(*
Local Variables:
compile-command: "make -C .. theories/map"
End:
*)
