(** {1 Formalization of Floating-Point Arithmetic} *)

theory GenericFloat

  type t

  (** Constants *)

  constant zeroF : t
  constant oneF  : t
  constant max   : t

  (**  arithemtic functions *)

  function abs  t   : t
  function neg  t   : t

  function add  t t : t
  function sub  t t : t
  function mul  t t : t
  function div  t t : t
  function sqrt t   : t
  function rem  t t : t

  (** Classifying predicates *)

  predicate is_normal    t
  predicate is_subnormal t
  predicate is_zero      t
  predicate is_infinite  t
  predicate is_nan       t

  predicate is_finite "inline" (x:t) = not (is_infinite x \/ is_nan x)

  (*** Conversion to/from other sorts ***)

  (* unchecked convertion from bv type of equivalent size *)
  type bv

  function from_bv bv : t

  (* with unsigned *)

  use bv.BV8
  use bv.BV16
  use bv.BV32
  use bv.BV64

  function from_sbv8  BV8.t  : t
  function from_sbv16 BV16.t : t
  function from_sbv32 BV32.t : t
  function from_sbv64 BV64.t : t

  function to_bv8  t : BV8.t
  function to_bv16 t : BV16.t
  function to_bv32 t : BV32.t
  function to_bv64 t : BV64.t

  (* with int *)

  function from_int int : t
  function to_int t : int

  (* with real *)

  function from_real real : t
  function to_real   t    : real

  (**  *)

  (* axiom zeroF_def: zeroF = from_real 0.0 *)
  axiom oneF_def : oneF  = from_real 1.0

  (** arithmetic axiomatisations *)

  function round real : real

  constant max_real "inline" : real = to_real max

  use import real.Real
  use real.Abs

  predicate no_overflow (x:real) = Abs.abs (round x) <= max_real

  axiom no_overflow_is_finite:
    forall x:real. no_overflow x ->
      is_finite (from_real x)

  lemma from_real_le : forall x:real.
    is_finite (from_real x) -> Abs.abs (to_real (from_real x)) <= max_real

  (* Axioms on round *)

  (* use real.Real *)

  axiom round_no_overflow:
    forall x:real. no_overflow x ->
      to_real (from_real x) = round x

  axiom Bounded_real_no_overflow :
    forall x:real. Abs.abs x <= max_real -> no_overflow x

  axiom Round_monotonic :
    forall x y:real. x <= y -> round x <= round y

  axiom Round_idempotent :
    forall x:real. round (round x) = round x

  axiom Round_to_real :
    forall x:t. round (to_real x) = to_real x

  axiom Bounded_to_real :
    forall x:t. Abs.abs (to_real x) <= max_real

  constant max_representable_integer : int

  (* round and integers *)

  use int.Int

  axiom Exact_rounding_for_integers:
    forall i:int.
      Int.(<=) (Int.(-_) max_representable_integer) i /\
      Int.(<=) i max_representable_integer ->
        round (to_real (from_int i)) = to_real (from_int i)

  lemma round_of_zero : to_real (from_real 0.0) = 0.0

  (** {3 binary operations} *)

  axiom add: forall x y:t.
  no_overflow (to_real x + to_real y) ->
    to_real (add x y) = round (to_real x + to_real y)

  axiom sub: forall x y:t.
  no_overflow (to_real x - to_real y) ->
    to_real (sub x y) = round (to_real x - to_real y)

  axiom mul: forall x y:t.
  no_overflow (to_real x * to_real y) ->
    to_real (mul x y) = round (to_real x * to_real y)

  axiom div: forall x y:t.
  not is_zero y ->
    to_real (div x y) = round (to_real x / to_real y)

  axiom neg: forall x:t.
    to_real (neg x) = - to_real x

  (** {3 Comparisons} *)

  (** Comparison predicates *)

  predicate eq (x:t) (y:t) =
    (* no_overflow x -> *)
      to_real x = to_real y

  predicate lt (x:t) (y:t) =
    to_real x < to_real y

  predicate le (x:t) (y:t) =
    to_real x <= to_real y

  predicate gt (x:t) (y:t) =
    to_real x > to_real y

  predicate ge (x:t) (y:t) =
    to_real x >= to_real y

  (* For now, 0 is mapped to 0+ in smtlib drivers and we use the fact
  that Spark2014 does not differentiate between the two *)

end

theory Float32
  use bv.BV32

  type t

  function from_bv BV32.t : t

  constant zeroF   : t = from_bv BV32.zero
  constant oneF    : t = from_bv (BV32.of_int 0x3F80_0000)
  constant max     : t = from_bv (BV32.of_int 0x7F7F_FFFF)
  constant max_int : int = 16777216 (* 2^24 *)

  clone export GenericFloat with
    type t           = t,
    type bv          = BV32.t,
    constant zeroF   = zeroF,
    constant oneF    = oneF,
    constant max     = max,
    constant max_representable_integer = max_int,
    function from_bv = from_bv
end

theory Float64
  use bv.BV64

  type t

  function from_bv BV64.t : t

  constant zeroF   : t = from_bv BV64.zero
  constant oneF    : t = from_bv (BV64.of_int 0x3FF0_0000_0000_0000)
  constant max     : t = from_bv (BV64.of_int 0x7F7F_FFFF_FFFF_FFFF)
  constant max_int : int = 9007199254740992 (* 2^53 *)

  clone export GenericFloat with
    type t           = t,
    type bv          = BV64.t,
    constant zeroF   = zeroF,
    constant oneF    = oneF,
    constant max     = max,
    constant max_representable_integer = max_int,
    function from_bv = from_bv
end

theory FloatConverter
  use Float32
  use Float64

  function to_float32 Float64.t : Float32.t
  function to_float64 Float32.t : Float64.t

  (* axioms ?*)
end
