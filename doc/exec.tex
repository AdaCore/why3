
\chapter{Executing \whyml Programs}
\label{chap:exec}\index{whyml@\whyml}

This chapter shows how \whyml code can be executed, either by being
interpreted or compiled to some existing programming language.

\begin{latexonly}
Let us consider the program in Figure~\ref{fig:MaxAndSum}
on page~\pageref{fig:MaxAndSum} that computes the maximum and the sum
of an array of integers.
\end{latexonly}
\begin{htmlonly}
Let us consider the program of Section~\ref{sec:MaxAndSum} that computes
the maximum and the sum of an array of integers.
\end{htmlonly}
Let us assume it is contained in a file \texttt{maxsum.mlw}.

\section{Interpreting \whyml Code}
\label{sec:execute}
\index{execute@\texttt{execute}}\index{interpretation!of \whyml}
\index{testing \whyml code}

To test function \texttt{max\_sum}, we can introduce a \whyml test function
in module \texttt{MaxAndSum}
\begin{whycode}
  let test () =
    let n = 10 in
    let a = make n 0 in
    a[0] <- 9; a[1] <- 5; a[2] <- 0; a[3] <- 2;  a[4] <- 7;
    a[5] <- 3; a[6] <- 2; a[7] <- 1; a[8] <- 10; a[9] <- 6;
    max_sum a n
\end{whycode}
and then we use the \texttt{execute} command to interpret this function,
as follows:
\begin{verbatim}
> why3 execute maxsum.mlw MaxAndSum.test
Execution of MaxAndSum.test ():
     type: (int, int)
   result: (45, 10)
  globals:
\end{verbatim}
We get the expected output, namely the pair \texttt{(45, 10)}.

\section{Compiling \whyml to OCaml}
\label{sec:extract}
\index{OCaml}\index{extraction}
\index{extract@\texttt{extract}}

An alternative to interpretation is to compile \whyml to OCaml.
We do so using the \texttt{extract} command, as follows:
\begin{verbatim}
> why3 extract -D ocaml64 maxsum.mlw -o max_sum.ml
\end{verbatim}
The \texttt{extract} command requires the name of a driver, which indicates
how theories/modules from the \why standard library are translated to
OCaml. Here we assume a 64-bit architecture and thus we pass
\texttt{ocaml64}. We also specify an output file using option
\verb+-o+, namely \texttt{max\_sum.ml}.
After this command, the file \texttt{max\_sum.ml} contains an OCaml
code for function \texttt{max\_sum}.
To compile it, we create a file \texttt{main.ml}
containing a call to \texttt{max\_sum}, \emph{e.g.},
\begin{whycode}
let a = Array.map Z.of_int [| 9; 5; 0; 2; 7; 3; 2; 1; 10; 6 |]
let m, s = Max_sum.max_sum a (Z.of_int 10)
let () = Format.printf "sum=%s, max=%s@." (Z.to_string s) (Z.to_string m)
\end{whycode}
It is convenient to use \texttt{ocamlbuild} to compile and link both
files \texttt{max\_sum.ml} and \texttt{main.ml}:
\begin{verbatim}
> ocamlbuild -pkg zarith main.native
\end{verbatim}
Since Why3's type
\texttt{int} is translated to OCaml arbitrary precision integers using
the \texttt{ZArith} library, we have to pass option \texttt{-pkg
  zarith} to \texttt{ocamlbuild}. In order to get extracted code that
uses OCaml's native integers instead, one has to use Why3's types for
63-bit integers from libraries \texttt{mach.int.Int63} and
\texttt{mach.array.Array63}.


%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "manual"
%%% End:
