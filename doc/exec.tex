
\chapter{Executing \whyml Programs}
\label{chap:exec}\index{whyml@\whyml}

This chapter shows how \whyml code can be executed, either by being
interpreted or compiled to some existing programming language.

\begin{latexonly}
Let us consider the program in Figure~\ref{fig:MaxAndSum}
on page~\pageref{fig:MaxAndSum} that computes the maximum and the sum
of an array of integers.
\end{latexonly}
\begin{htmlonly}
Let us consider the program of Section~\ref{sec:MaxAndSum} that computes
the maximum and the sum of an array of integers.
\end{htmlonly}
Let us assume it is contained in a file \texttt{maxsum.mlw}.

\section{Interpreting \whyml Code}
\label{sec:execute}
\index{execute@\texttt{execute}}\index{interpretation!of \whyml}
\index{testing \whyml code}

To test function \texttt{max\_sum}, we can introduce a \whyml test function
in module \texttt{MaxAndSum}
\begin{whycode}
  let test () =
    let n = 10 in
    let a = make n 0 in
    a[0] <- 9; a[1] <- 5; a[2] <- 0; a[3] <- 2;  a[4] <- 7;
    a[5] <- 3; a[6] <- 2; a[7] <- 1; a[8] <- 10; a[9] <- 6;
    max_sum a n
\end{whycode}
and then we use the \texttt{execute} command to interpret this function,
as follows:
\begin{verbatim}
> why3 execute maxsum.mlw MaxAndSum.test
Execution of MaxAndSum.test ():
     type: (int, int)
   result: (45, 10)
  globals:
\end{verbatim}
We get the expected output, namely the pair \texttt{(45, 10)}.

\section{Compiling \whyml to OCaml}
\label{sec:extract}
\index{OCaml}\index{extraction}
\index{extract@\texttt{extract}}

An alternative to interpretation is to compile \whyml to OCaml.
We do so using the \texttt{extract} command, as follows:
\begin{verbatim}
> why3 extract -D ocaml64 maxsum.mlw -o max_sum.ml
\end{verbatim}
The \texttt{extract} command requires the name of a driver, which indicates
how theories/modules from the \why standard library are translated to
OCaml. Here we assume a 64-bit architecture and thus we pass
\texttt{ocaml64}. We also specify an output file using option
\verb+-o+, namely \texttt{max\_sum.ml}.
After this command, the file \texttt{max\_sum.ml} contains an OCaml
code for function \texttt{max\_sum}.
To compile it, we create a file \texttt{main.ml}
containing a call to \texttt{max\_sum}, \emph{e.g.},
\begin{whycode}
let a = Array.map Z.of_int [| 9; 5; 0; 2; 7; 3; 2; 1; 10; 6 |]
let m, s = Max_sum.max_sum a (Z.of_int 10)
let () = Format.printf "sum=%s, max=%s@." (Z.to_string s) (Z.to_string m)
\end{whycode}
It is convenient to use \texttt{ocamlbuild} to compile and link both
files \texttt{max\_sum.ml} and \texttt{main.ml}:
\begin{verbatim}
> ocamlbuild -pkg zarith main.native
\end{verbatim}
Since \why's type
\texttt{int} is translated to OCaml arbitrary precision integers using
the \texttt{ZArith} library, we have to pass option \texttt{-pkg
  zarith} to \texttt{ocamlbuild}. In order to get extracted code that
uses OCaml's native integers instead, one has to use \why's types for
63-bit integers from libraries \texttt{mach.int.Int63} and
\texttt{mach.array.Array63}.

\paragraph{Extraction starting point} The \texttt{extract} command accepts three
different targets for extraction: a \whyml file, a module, or a symbol
(function, type, exception). To extract all the symbols from every module of a
file named \texttt{f.mlw}, one should write
\begin{verbatim}
> why3 extract -D <driver> f.mlw
\end{verbatim}
To extract only the symbols from module \texttt{M} of file \texttt{f.mlw}, one
should write
\begin{verbatim}
> why3 extract -D <driver> -L <dir> f.M
\end{verbatim}
To extract only the symbol \texttt{s} (a function, a type, or an exception) from
module \texttt{M} of file \texttt{f.mlw}, one should write
\begin{verbatim}
> why3 extract -D <driver> -L <dir> f.M.s
\end{verbatim}
Note the use of~\texttt{-L <dir>}, for both extraction of a module and a symbol,
in order to state the location of file \texttt{f.mlw}.

\paragraph{Options}
\begin{description}
\item[\texttt{-{}-flat}] performs a flat extraction, \emph{i.e.}, everything is
  extracted into a single file. This is the default behavior. The \texttt{-o}
  option should be given the name of a file or, if omitted, the result of
  extraction is printed to the standard output.
\item[\texttt{-{}-modular}] each module is extracted in its own, separated
  file. The \texttt{-o} option cannot be omitted, and it should be given the
  name of an existing directory. This directory will be populated with the
  resulting OCaml files.
\item[\texttt{-{}-recursive}] recursively extracts all the dependencies of the
  chosen entry point. This option is valid for both \texttt{modular} and
  \texttt{flat} options.
\end{description}

\paragraph{Examples}
We discuss different uses of the \texttt{extract} command though some examples.
Consider the program in Figure~\ref{fig:NQueens2} on
page~\pageref{fig:NQueens2}, where function \texttt{queens} computes a solution for
the \texttt{N}-Queens problem. If we are only interested in extracting this
function, we can proceed as follows:
\begin{verbatim}
> why3 extract -D ocaml64 -L . queens.NQueens.queens -o queens.ml
\end{verbatim}
Here we assume the program is contained in a file \texttt{queens.mlw} and that
we invoke \texttt{extract} from the directory where this file is stored. File
\texttt{queens.ml} now contains the following OCaml code:
\begin{whycode}
let queens (board: Z.t array) (n: Z.t) : unit =
  bt_queens board n (Z.of_string "0")
\end{whycode}
This code cannot be type-checked by the OCaml compiler, as it depends on
function \texttt{bt\_queens} whose definition is not given. In order to obtain a
\emph{correct} OCaml implementation, we perform a recursive extraction:
\begin{verbatim}
> why3 extraction --recursive -D ocaml64 -L . \
    queens.NQueens.queens -o queens.ml
\end{verbatim}
File \texttt{queens.ml} contents is updated to the code shown in
Figure~\ref{fig:extract-queens}.
\begin{figure}
\begin{whycode}
exception Solution

exception Inconsistent of Z.t

let check_is_consistent (board: Z.t array) (pos: Z.t) : bool =
  begin try
    begin
      let rec for_loop_to (q: Z.t) : unit =
        if Z.leq q (Z.sub pos (Z.of_string "1"))
        then begin
          begin
            let bq = board.(Z.to_int q) in
            let bpos = board.(Z.to_int pos) in
            begin
              if Z.equal bq bpos then begin raise (Inconsistent q) end;
              if Z.equal (Z.sub bq bpos) (Z.sub pos q)
              then begin
                raise (Inconsistent q) end;
              if Z.equal (Z.sub bpos bq) (Z.sub pos q)
              then begin
                raise (Inconsistent q) end
            end; for_loop_to (Z.add q (Z.of_string "1"))
          end end in
      for_loop_to (Z.of_string "0"); true
    end with
  | Inconsistent q -> false
  end

let rec bt_queens (board: Z.t array) (n: Z.t) (pos: Z.t) : unit =
  begin
    if Z.equal pos n then begin raise Solution end;
    let rec for_loop_to1 (i: Z.t) : unit =
      if Z.leq i (Z.sub n (Z.of_string "1"))
      then begin
        begin
          board.(Z.to_int pos) <- i;
          if check_is_consistent board pos
          then begin
            bt_queens board n (Z.add pos (Z.of_string "1")) end;
          for_loop_to1 (Z.add i (Z.of_string "1"))
        end end in
    for_loop_to1 (Z.of_string "0")
  end

let queens (board: Z.t array) (n: Z.t) : unit =
  bt_queens board n (Z.of_string "0")
\end{whycode}
\label{fig:extract-queens}
\caption{Recursive extraction of \texttt{queens} function.}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "manual"
%%% End:
