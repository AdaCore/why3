\chapter{The Why3ML Programming Language}
\label{chap:whyml}

This chapter describes the \whyml\ programming language.
A \whyml\ input text contains a list of theories (see
chapter~\ref{chap:syntax}) and/or modules.
Modules extend theories with \emph{programs}.
Programs can use all types, symbols, and constructs from the logic.
They also provide extra features:
\begin{itemize}
\item
  In a record type declaration, some fields can be declared
  \texttt{mutable}.
\item
  There are programming constructs with no counterpart in the logic:
  \begin{itemize}
  \item mutable field assignment;
  \item sequence;
  \item loops;
  \item exceptions;
  \item local and anonymous functions;
  \item annotations: pre- and postconditions, assertions, loop invariants.
  \end{itemize}
\item
  A program function can be non-terminating or can be proved
  to be terminating using a variant (a term together with a well-founded
  order relation).
\item
  An abstract program type $t$ can be introduced with a logical
  \emph{model} $\tau$: inside programs, $t$ is abstract, and inside
  annotations, $t$ is an alias for $\tau$.
\end{itemize}
%
Programs are contained in files with suffix \verb|.mlw|.
They are handled by the tool \texttt{why3ml}, which has a command line
similar to \texttt{why3}. For instance
\begin{verbatim}
  % why3ml myfile.mlw
\end{verbatim}
will display the verification conditions extracted from modules in
file \texttt{myfile.mlw}, as a set of corresponding theories, and
\begin{verbatim}
  % why3ml -P alt-ergo myfile.mlw
\end{verbatim}
will run the SMT solver Alt-Ergo on these verification conditions.
Program files are also handled by the GUI tool \texttt{why3ide}.
See Chapter~\ref{chap:manpages} for more details regarding command lines.

\medskip
As an introduction to \whyml, we use the five problems from the VSTTE
2010 verification competition~\cite{vstte10comp}.
The source code for all these examples is contained in \why's
distribution, in dub-directory \texttt{examples/programs/}.

\subsection{Problem 1: Sum and Maximum}

The first problem is stated as follows:
\begin{quote}
  Given an $N$-element array of natural numbers,
  write a program to compute the sum and the maximum of the
  elements in the array.
\end{quote}
We  assume $N \ge 0$ and $a[i] \ge 0$ for $0 \le i < N$, as precondition,
and we have to prove the following postcondition:
\begin{displaymath}
  sum \le N \times max.
\end{displaymath}
In a file \verb|max_sum.mlw|, we start a new module:
\begin{verbatim}
  module MaxAndSum
\end{verbatim}
We are obviously needing arithmetic, so we import the corresponding
theory, exactly as we would do within a theory definition:
\begin{verbatim}
    use import int.Int
\end{verbatim}
We are also going to use references and arrays from \whyml's standard
library, so we import the corresponding modules, with a similar
declaration:
\begin{verbatim}
    use import module ref.Ref
    use import module array.Array
\end{verbatim}
The additional keyword \texttt{module} means that we are looking for
\texttt{.mlw} files from the standard library (namely \texttt{ref.mlw}
and \texttt{array.mlw} here), instead of \texttt{.why} files.
Modules \texttt{Ref} and \texttt{Array} respectively provide a type
\texttt{ref 'a} for references and a type \texttt{array 'a} for
arrays (see Chapter~\ref{chap:mllibrary}), together with useful
operations and traditional syntax.

We are now in position to define a program function
\verb|max\_sum|. A function definition is introduced with the keyword
\texttt{let}. In our case, it introduces a function with two argument,
an array \texttt{a} and its size \texttt{n}:
\begin{verbatim}
    let max_sum (a: array int) (n: int) = ...
\end{verbatim}
(There is a function \texttt{length} to get the size of an array but
we add this extra parameter \texttt{n} to stay close to the original
problem statement.) The function body is a Hoare triple, that is a
precondition, a program expression, and a postcondition.
\begin{verbatim}
    let max_sum (a: array int) (n: int) =
      { 0 <= n = length a and forall i:int. 0 <= i < n -> a[i] >= 0 }
       ... expression ...
      { let (sum, max) = result in sum <= n * max }
\end{verbatim}
The precondition expresses that \texttt{n} is non-negative and is
equal to the length of \texttt{a} (this will be needed for
verification conditions related to array bound checking), and that all
elements of \texttt{a} are non-negative.
The postcondition assumes that the value returned by the function,
denoted \texttt{result}, is a pair of integers, and decomposes it as
the pair \texttt{(sum, max)} to expresse the required property.

We are now left with the function body itself, that is a code
computing the sum and the maximum of all elements in \texttt{a}. With
no surpise, it is as simple as introducing two local references
\begin{verbatim}
    let sum = ref 0 in
    let max = ref 0 in
\end{verbatim}
scanning the array with a \texttt{for} loop, updating \texttt{max}
and \texttt{sum}
\begin{verbatim}
    for i = 0 to n - 1 do
      if !max < a[i] then max := a[i];
      sum := !sum + a[i]
    done;
\end{verbatim}
and finally returning the pair of the values contained in \texttt{sum}
and \texttt{max}:
\begin{verbatim}
    (!sum, !max)
\end{verbatim}
This completes the code for function \texttt{max\_sum}.
As such, it cannot be proved correct, since the loop is still lacking
a loop invariant. In this case, the loop invariant is as simple as
\verb|!sum <= i * !max|, since the postcondition only requires to prove
\verb|sum <= n * max|. The loop invariant is introduced with the
keyword \texttt{invariant}, immediately after the keyword \texttt{do}.
\begin{verbatim}
      for i = 0 to n - 1 do
        invariant { !sum <= i * !max }
        ...
      done
\end{verbatim}
There is no need to introduce a variant, as the termination of a
\texttt{for} loop is automatically guaranteed.
This completes module \texttt{MaxAndSum}.
Figure~\ref{fig:MaxAndSum} shows the whole code.
\begin{figure}
  \centering
\begin{verbatim}
module MaxAndSum

  use import int.Int
  use import module ref.Ref
  use import module array.Array

  let max_sum (a: array int) (n: int) =
    { 0 <= n = length a and forall i:int. 0 <= i < n -> a[i] >= 0 }
    let sum = ref 0 in
    let max = ref 0 in
    for i = 0 to n - 1 do
      invariant { !sum <= i * !max }
      if !max < a[i] then max := a[i];
      sum := !sum + a[i]
    done;
    (!sum, !max)
    { let (sum, max) = result in sum <= n * max }

end
\end{verbatim}
\vspace*{-2em}\hrulefill
  \caption{Solution for VSTTE'10 competition problem 1.}
  \label{fig:MaxAndSum}
\end{figure}
We can now proceed to its verification.
Running \texttt{why3ml}, or better \texttt{why3ide}, on file
\verb|max_sum.mlw| will show a single verification condition with name
\verb|WP_parameter_max_sum|.
Discharging this verification condition with an automated theorem
prover will not succeed, most likely, as it involves non-linear
arithmetic. Repeated applications of goal splitting and calls to
SMT solvers (within \texttt{why3ide}) will typically leave a single,
unsolved goal, which reduces to proving the following sequent:
\begin{displaymath}
  s \le i \times max, ~ max < a[i] \vdash s + a[i] \le (i+1) \times a[i].
\end{displaymath}
This is easily discharged using an interactive proof assistant such as
Coq, and thus completes the verification.

\subsection{Problem 2: Inverting an Injection}

The second problem is stated as follows:
\begin{quote}
  Invert an injective array $A$ on $N$ elements in the
  subrange from $0$ to $N - 1$, i.e., the output array $B$ must be
  such that $B[A[i]] = i$ for $0 \le i < N$.
\end{quote}
We may assume that $A$ is surjective and we have to prove
that the resulting array is also injective.
The code is immediate, since it is as simple as
\begin{verbatim}
    for i = 0 to n - 1 do b[a[i]] <- i done
\end{verbatim}
so it is more a matter of specification and of getting the proof done
with as much automation as possible. In a new file, we start a new
module and we import arithmetic and arrays:
\begin{verbatim}
  module InvertingAnInjection
    use import int.Int
    use import module array.Array
\end{verbatim}
It is convenient to introduce predicate definitions for the properties
of being injective and surjective. These are purely logical
declarations:
\begin{verbatim}
    logic injective (a: array int) (n: int) =
      forall i j: int. 0 <= i < n -> 0 <= j < n -> i <> j -> a[i] <> a[j]

    logic surjective (a: array int) (n: int) =
      forall i: int. 0 <= i < n -> exists j: int. (0 <= j < n and a[j] = i)
\end{verbatim}
It is also convenient to introduce the predicate ``being in the
subrange from 0 to $n-1$'':
\begin{verbatim}
    logic range (a: array int) (n: int) =
      forall i: int. 0 <= i < n -> 0 <= a[i] < n
\end{verbatim}
Using these predicates, we can formulate the assumption that any
injective array of size $n$ within the range $0..n-1$ is also surjective:
\begin{verbatim}
    lemma injective_surjective:
      forall a: array int, n: int.
      injective a n -> range a n -> surjective a n
\end{verbatim}
We declare it as a lemma rather than as an axiom, since it is actually
provable. It requires induction and can be proved using the Coq proof
assistant for instance.
Finally we can give the code a specification, with a loop invariant
which simply expresses the values assigned to array \texttt{b} so far:
\begin{verbatim}
    let inverting (a: array int) (b: array int) (n: int) =
      { 0 <= n = length a = length b and injective a n and range a n }
      for i = 0 to n - 1 do
        invariant { forall j: int. 0 <= j < i -> b[a[j]] = j }
        b[a[i]] <- i
      done
      { injective b n }
\end{verbatim}
Here we chose to have array \texttt{b} as argument; returning a
freshly allocated array would be equally simple.
The whole module is given Figure~\ref{fig:Inverting}.
The verification conditions for function \texttt{inverting} are easily
discharged automatically, thanks to the lemma.
\begin{figure}
  \centering
\begin{verbatim}
module InvertingAnInjection

  use import int.Int
  use import module array.Array

  logic injective (a: array int) (n: int) =
    forall i j: int. 0 <= i < n -> 0 <= j < n -> i <> j -> a[i] <> a[j]

  logic surjective (a: array int) (n: int) =
    forall i: int. 0 <= i < n -> exists j: int. (0 <= j < n and a[j] = i)

  logic range (a: array int) (n: int) =
    forall i: int. 0 <= i < n -> 0 <= a[i] < n

  lemma injective_surjective:
    forall a: array int, n: int.
    injective a n -> range a n -> surjective a n

  let inverting (a: array int) (b: array int) (n: int) =
    { 0 <= n = length a = length b and injective a n and range a n }
    for i = 0 to n - 1 do
      invariant { forall j: int. 0 <= j < i -> b[a[j]] = j }
      b[a[i]] <- i
    done
    { injective b n }

end
\end{verbatim}
\vspace*{-2em}\hrulefill
  \caption{Solution for VSTTE'10 competition problem 2.}
  \label{fig:Inverting}
\end{figure}

\subsection{Problem 3: Searching a Linked List}

The third problem is stated as follows:
\begin{quote}
  Given a linked list representation of a list of integers,
  find the index of the first element that is equal to 0.
\end{quote}
More precisely, the specification says
\begin{quote}
  You have to show that the program returns an index $i$ equal to the
  length of the list if there is no such element. Otherwise, the $i$-th
  element of the list must be equal to 0, and all the preceding
  elements must be non-zero.
\end{quote}
Since the list is not mutated, we can use the algebraic data type of
polymorphic lists from \why's standard library, defined in theory
\texttt{list.List}. It comes with other handy theories:
\texttt{list.Length}, which provides a function \texttt{length}, and
\texttt{list.Nth}, which provides a function \texttt{nth}
for the $n$-th element of a list. The latter returns an option type,
depending on whether the index is meaningful or not.
\begin{verbatim}
  module SearchingALinkedList
    use import int.Int
    use export list.List
    use export list.Length
    use export list.Nth
\end{verbatim}
It is helpful to introduce two predicates: a first one
for a successful search,
\begin{verbatim}
    logic zero_at (l: list int) (i: int) =
      nth i l = Some 0 and forall j:int. 0 <= j < i -> nth j l <> Some 0
\end{verbatim}
and a another for a non-successful search,
\begin{verbatim}
    logic no_zero (l: list int) =
      forall j:int. 0 <= j < length l -> nth j l <> Some 0
\end{verbatim}
We are now in position to give the code for the search function.
We write it as a recursive function \texttt{search} which scans a list
for the first zero value:
\begin{verbatim}
    let rec search (i: int) (l: list int) = match l with
      | Nil      -> i
      | Cons x r -> if x = 0 then i else search (i+1) r
      end
\end{verbatim}
Passing an index \texttt{i} as first argument allows to perform a tail
call. A simpler code (yet less efficient) would return 0 in the first
branch and \texttt{1 + search ...} in the second one, avoiding the
extra argument \texttt{i}.

We first prove the termination of this recursive function. It amounts
to give it a \emph{variant}, that is an term integer term which stays
non-negative and strictly decreases at each recursive call. Here it is
as simple as the length of \texttt{l}:
\begin{verbatim}
    let rec search (i: int) (l: list int) variant { length l } = ...
\end{verbatim}
(It is worth pointing out that variants are not limited to natural
numbers. Any other type equipped with a well-founded order relation
can be used instead.)
There is no precondition for function \texttt{search}.
The postcondition expresses that either a zero value is found, and
consequently the value returned is bounded accordingly,
\begin{verbatim}
  i <= result < i + length l and zero_at l (result - i)
\end{verbatim}
or no zero value was found, and thus the returned value is exactly
\texttt{i} plus the length of \texttt{l}:
\begin{verbatim}
  result = i + length l and no_zero l
\end{verbatim}
Solving the problem is simply a matter of calling \texttt{search} with
0 as first argument.
The code is given Figure~\ref{fig:LinkedList}. The verification
conditions are all discharged automatically.
\begin{figure}
  \centering
\begin{verbatim}
module SearchingALinkedList

  use import int.Int
  use export list.List
  use export list.Length
  use export list.Nth

  logic zero_at (l: list int) (i: int) =
    nth i l = Some 0 and forall j:int. 0 <= j < i -> nth j l <> Some 0

  logic no_zero (l: list int) =
    forall j:int. 0 <= j < length l -> nth j l <> Some 0

  let rec search (i: int) (l: list int) variant { length l } =
    {}
    match l with
    | Nil -> i
    | Cons x r -> if x = 0 then i else search (i+1) r
    end
    { (i <= result < i + length l and zero_at l (result - i))
      or
      (result = i + length l and no_zero l) }

  let search_list (l: list int) =
    { }
    search 0 l
    { (0 <= result < length l and zero_at l result)
      or
      (result = length l and no_zero l) }

end
\end{verbatim}
\vspace*{-2em}\hrulefill
  \caption{Solution for VSTTE'10 competition problem 3.}
  \label{fig:LinkedList}
\end{figure}

Alternatively, we can implement the search with a \texttt{while} loop.
To do this, we need to import references from the standard library,
together with theory \texttt{list.HdTl} which defines function
\texttt{hd} and \texttt{tl} over lists.
\begin{verbatim}
    use import module ref.Ref
    use import list.HdTl
\end{verbatim}
Being partial functions, \texttt{hd} and \texttt{tl} return options.
For the purpose of our code, though, it is simpler to have functions
which do not return options, but have preconditions instead. Such a
function \texttt{head} is defined as follows:
\begin{verbatim}
    let head (l: list 'a) =
      { l <> Nil }
      match l with Nil -> absurd | Cons h _ -> h end
      { hd l = Some result }
\end{verbatim}
The program construct \texttt{absurd} denotes an unreachable piece of
code. It generates the verification condition \texttt{false}, which is
here provable using the precondition (the list cannot be \texttt{Nil}).
Function \texttt{tail} is defined similarly:
\begin{verbatim}
    let tail (l : list 'a) =
      { l <> Nil }
      match l with Nil -> absurd | Cons _ t -> t end
      { tl l = Some result }
\end{verbatim}
Using \texttt{head} and \texttt{tail}, it is straightforward to
implement the search as a \texttt{while} loop.
It uses a local reference \texttt{i} to store the index and another
local reference \texttt{s} to store the list being scanned.
As long as \texttt{s} is not empty and its head is not zero, it
increments \texttt{i} and advances in \texttt{s} using function \texttt{tail}.
\begin{verbatim}
    let search_loop l =
      { }
      let i = ref 0 in
      let s = ref l in
      while !s <> Nil && head !s <> 0 do
        invariant { ... }
        variant   { length !s }
        i := !i + 1;
        s := tail !s
      done;
      !i
      { ... same postcondition as search_list ... }
\end{verbatim}
The postcondition is exactly the same as for function \verb|search_list|.
The termination of the \texttt{while} loop is ensured using a variant,
exactly as for a recursive function. Such a variant must strictly decrease at
each execution of the loop body. The reader is invited to figure out
the loop invariant.

\subsection{Problem 4: N-Queens}

\begin{figure}
  \centering
\begin{verbatim}
\end{verbatim}
\vspace*{-2em}\hrulefill
  \caption{Solution for VSTTE'10 competition problem 4.}
  \label{fig:NQueens}
\end{figure}

\subsection{Problem 5: Amortized Queue}

The last problem consists in verifying the implementation of a
well-known purely applicative data structure for queues.
A queue is composed of two lists, \textit{front} and \textit{rear}.
We push elements at the head of list \textit{rear} and pop them off
the head of list \textit{front}. We maintain that the length of
\textit{front} is always greater or equal to the length of \textit{rear}.
(See for instance Okasaki's \emph{Purely Functional Data
  Structures}~\cite{okasaki98} for more details.)

We have to implement operations \texttt{empty}, \texttt{head},
\texttt{tail}, and \texttt{enqueue} over this data type,
to show that the invariant over lengths is maintained, and finally
\begin{quote}
  to show that a client invoking these operations
  observes an abstract queue given by a sequence.
\end{quote}
In a new module, we import arithmetic and theory
\texttt{list.ListRich}, a combo theory which imports all list
operations we will require: length, reversal, and concatenation.
\begin{verbatim}
  module AmortizedQueue
    use import int.Int
    use export list.ListRich
\end{verbatim}
The queue data type is naturally introduced as a polymorphic record type.
The two list lengths are explicitly stored, for better efficiency.
\begin{verbatim}
    type queue 'a = {| front: list 'a; lenf: int;
                       rear : list 'a; lenr: int; |}
\end{verbatim}
We start with the definition of the data type invariant, as a
predicate \texttt{inv}. It makes use of the ability to chain
several equalities and inequalities.
\begin{verbatim}
    logic inv (q: queue 'a) =
      length q.front = q.lenf >= length q.rear = q.lenr
\end{verbatim}
For the purpose of the specification, it is convenient to introduce a function
\texttt{sequence} which builds the sequence of a queue elements, that
is the front list concatenated to reversed rear list.
\begin{verbatim}
    logic sequence (q: queue 'a) : list 'a =
      q.front ++ reverse q.rear
\end{verbatim}
It is worth pointing out that this function will only be used in
specifications.
We start with the easiest operation: building the empty queue.
\begin{verbatim}
  let empty () =
    {}
    {| front = Nil; lenf = 0; rear = Nil; lenr = 0 |} : queue 'a
    { inv result and sequence result = Nil }
\end{verbatim}
The postcondition is twofold: the returned queue satisfies its
invariant and represents the empty sequence.
Note the cast to type \texttt{queue 'a}. It is required, for the
type checker not to complain about an undefined type variable.

The next operation is \texttt{head}, which returns the first element from
a given queue \texttt{q}. It naturally requires the queue to be non
empty, which is conveniently expressed as \texttt{sequence q} not
being \texttt{Nil}.
\begin{verbatim}
  let head (q: queue 'a) =
    { inv q and sequence q <> Nil }
    match q.front with
      | Nil      -> absurd
      | Cons x _ -> x
    end
    { hd (sequence q) = Some result }
\end{verbatim}
Note the presence of the invariant in the precondition, which is
required to prove the absurdity of the first branch (if
\texttt{q.front} is \texttt{Nil}, then so should be \texttt{sequence q}).

The next operation is \texttt{tail}, which removes the first element
from a given queue. This is more subtle than \texttt{head}, since we
may have to re-structure the queue to maintain the invariant.
Since we will have to perform a similar operation when implementation
operation \texttt{enqueue}, it is a good idea to introduce a smart
constructor \texttt{create} which builds a queue from two lists, while
ensuring the invariant. The list lengths are also passed as arguments,
to avoid unnecessary computations.
\begin{verbatim}
    let create (f: list 'a) (lf: int) (r: list 'a) (lr: int) =
      { lf = length f and lr = length r }
      if lf >= lr then
        {| front = f; lenf = lf; rear = r; lenr = lr |}
      else
        let f = f ++ reverse r in
        {| front = f; lenf = lf + lr; rear = Nil; lenr = 0 |}
      { inv result and sequence result = f ++ reverse r }
\end{verbatim}
If the invariant already holds, it is simply a matter of building the
record. Otherwise, we empty the rear list and build a new front list
as the concatenation of list \texttt{f} and the reversal of list \texttt{r}.
The principle of this implementation is that the cost of this reversal
will be amortized over all queue operations. Implementing function
\texttt{tail} is now straightforward and follows the structure of
function \texttt{head}.
\begin{verbatim}
    let tail (q: queue 'a) =
      { inv q and sequence q <> Nil }
      match q.front with
        | Nil      -> absurd
        | Cons _ r -> create r (q.lenf - 1) q.rear q.lenr
      end
      { inv result and tl (sequence q) = Some (sequence result) }
\end{verbatim}
The last operation is \texttt{enqueue}, which pushes a new element in
a given queue. Reusing the smart constructor \texttt{create} makes it
a one line code.
\begin{verbatim}
    let enqueue (x: 'a) (q: queue 'a) =
      { inv q }
      create q.front q.lenf (Cons x q.rear) (q.lenr + 1)
      { inv result and sequence result = sequence q ++ Cons x Nil }
\end{verbatim}
The code is given Figure~\ref{fig:AQueue}. The verification conditions
are all discharged automatically.
\begin{figure}
  \centering
\begin{verbatim}
module AmortizedQueue
  use import int.Int
  use export list.ListRich

  type queue 'a = {| front: list 'a; lenf: int;
                     rear : list 'a; lenr: int; |}

  logic inv (q: queue 'a) =
    length q.front = q.lenf >= length q.rear = q.lenr

  logic sequence (q: queue 'a) : list 'a =
    q.front ++ reverse q.rear

  let empty () =
    {}
    {| front = Nil; lenf = 0; rear = Nil; lenr = 0 |} : queue 'a
    { inv result and sequence result = Nil }

  let head (q: queue 'a) =
    { inv q and sequence q <> Nil }
    match q.front with
      | Nil      -> absurd
      | Cons x _ -> x
    end
    { hd (sequence q) = Some result }

  let create (f: list 'a) (lf: int) (r: list 'a) (lr: int) =
    { lf = length f and lr = length r }
    if lf >= lr then
      {| front = f; lenf = lf; rear = r; lenr = lr |}
    else
      let f = f ++ reverse r in
      {| front = f; lenf = lf + lr; rear = Nil; lenr = 0 |}
    { inv result and sequence result = f ++ reverse r }

  let tail (q: queue 'a) =
    { inv q and sequence q <> Nil }
    match q.front with
      | Nil      -> absurd
      | Cons _ r -> create r (q.lenf - 1) q.rear q.lenr
    end
    { inv result and tl (sequence q) = Some (sequence result) }

  let enqueue (x: 'a) (q: queue 'a) =
    { inv q }
    create q.front q.lenf (Cons x q.rear) (q.lenr + 1)
    { inv result and sequence result = sequence q ++ Cons x Nil }
end
\end{verbatim}
\vspace*{-2em}\hrulefill
  \caption{Solution for VSTTE'10 competition problem 5.}
  \label{fig:AQueue}
\end{figure}

% other examples: same fringe ?

%%% Local Variables:
%%% compile-command: "make -C .. doc"
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "manual"
%%% End:

% LocalWords:  surjective
