\chapter{Technical Informations}
%HEVEA\cutname{technical.html}

\section{Structure of Session Files}

The proof session state is stored in an XML file named
\texttt{\textsl{<dir>}/why3session.xml}, where \texttt{\textsl{<dir>}}
is the directory of the project.
The XML file follows the DTD given in \texttt{share/why3session.dtd} and reproduced below.
\lstinputlisting{../share/why3session.dtd}


\section{Prover Detection}
\label{sec:proverdetecttiondata}

The data configuration for the automatic detection of
installed provers is stored in the file
\texttt{provers-detection-data.conf} typically located in directory
\verb|/usr/local/share/why3| after installation. The content of this
file is reproduced below.
%BEGIN LATEX
{\footnotesize
%END LATEX
\lstinputlisting[language={},morecomment={[l]\#},morestring={[b]"}]{../share/provers-detection-data.conf}
%BEGIN LATEX
}
%END LATEX

\section{The \texttt{why3.conf} Configuration File}
\label{sec:whyconffile}
\index{why3.conf@\texttt{why3.conf}}\index{configuration file}

One can use a custom configuration file. The \why
tools look for it in the following order:
\begin{enumerate}
\item the file specified by the \texttt{-C} or \texttt{-{}-config} options,
\item the file specified by the environment variable
  \texttt{WHY3CONFIG} if set,
\item the file \texttt{\$HOME/.why3.conf}
  (\texttt{\$USERPROFILE/.why3.conf} under Windows) or, in the case of
  local installation, \texttt{why3.conf} in the top directory of \why sources.
\end{enumerate}
If none of these files exist, a built-in default configuration is used.

A section begins with a header inside square brackets and ends at the
beginning of the next section. The header of a section can be a single
identifier, \eg \texttt{[main]}, or it can be composed by a family name
and a single family argument, \eg \texttt{[prover alt-ergo]}.

Sections contain associations \texttt{key=value}. A value is either
an integer (\eg \texttt{-555}), a boolean (\texttt{true}, \texttt{false}),
or a string (\eg \texttt{"emacs"}). Some specific keys can be attributed
multiple values and are
thus allowed to occur several times inside a given section. In that
case, the relative order of these associations matters.

\section{Drivers for External Provers}
\label{sec:drivers}

Drivers for external provers are readable files located in the
\texttt{drivers} directory. They describe how \why should interact
with external provers.

% Experienced users can modify them to
% change the way \why interacts with external provers.

%  namely the need
% for printer section, any other ?

% , in particular which transformations
% are applied to goals.


Files with \texttt{.drv} extension represent drivers that might be
associated to a specific solver in the \texttt{why3.conf}
configuration file (see \ref{sec:whyconffile} for more information);
files with \texttt{.gen} extension are intended to be imported by
other drivers; finally, files with \texttt{.aux} extension are
automatically generated from the main \texttt{Makefile}.
%
\input{./generated/drivers_dependency.tex}
%
The most important drivers dependencies are shown in
Figs.~\driversref. Fig.~\ref{fig:drv:smt} shows the drivers files
related to the \texttt{SMT} solvers, Fig.~\ref{fig:drv:coq} the files
for \texttt{Coq}, Fig.~\ref{fig:drv:tptp} the files for \texttt{TPTP},
Fig.~\ref{fig:drv:isabelle} the files for \texttt{Isabelle}, and
finally Fig.~\ref{fig:drv:pvs} shows the files for \texttt{PVS}.

\section{Transformations}
\label{sec:transformations}

This section documents the available transformations. We first
describe the most important ones, and then we provide a quick
documentation of the others, first the non-splitting ones, \eg those
which produce exactly one goal as result, and the others which produce any
number of goals.

Notice that the set of available transformations in your own
installation is given by
\begin{verbatim}
why3 --list-transforms
\end{verbatim}
\index{list-transforms@\verb+--list-transforms+}

\subsection{Inlining definitions}

Those transformations generally amount to replace some applications of
function or predicate symbols with its definition.

\begin{description}

\item[inline\_trivial]
  expands and removes definitions of the form
\begin{whycode}
function  f x_1 ... x_n = (g e_1 ... e_k)
predicate p x_1 ... x_n = (q e_1 ... e_k)
\end{whycode}
when each $e_i$ is either a ground term or one of the $x_j$, and
each $x_1 \dots x_n$ occurs at most once in all the $e_i$.

The attribute \texttt{[@inline:trivial]} is used to tag functions that
the transformation will force expand (not using the conditions above). This can
be used to ensure that some specific functions are inlined for automatic
provers (inline\_trivial is used in many drivers).

\index{inline-trivial@\verb+inline_trivial+}

\item[inline\_goal] expands all outermost symbols of the goal that
  have a non-recursive definition.
\index{inline-goal@\verb+inline_goal+}

\item[inline\_all]
  expands all non-recursive definitions.
\index{inline-all@\verb+inline_all+}

\end{description}


\subsection{Induction Transformations}

\begin{description}
\item[induction\_ty\_lex]
  \index{induction-ty-lex@\verb+induction_ty_lex+}
  performs structural, lexicographic induction on
  goals involving universally quantified variables of algebraic data
  types, such as lists, trees, etc. For instance, it transforms the
  following goal
\begin{whycode}
goal G: forall l: list 'a. length l >= 0
\end{whycode}
  into this one:
\begin{whycode}
goal G :
  forall l:list 'a.
     match l with
     | Nil -> length l >= 0
     | Cons a l1 -> length l1 >= 0 -> length l >= 0
     end
\end{whycode}
  When induction can be applied to several variables, the transformation
  picks one heuristically. The \verb|[@induction]| attribute can be used to
  force induction over one particular variable, \eg with
\begin{whycode}
goal G: forall l1 [@induction] l2 l3: list 'a.
        l1 ++ (l2 ++ l3) = (l1 ++ l2) ++ l3
\end{whycode}
induction will be applied on \verb|l1|. If this attribute is attached to
several variables, a lexicographic induction is performed on these
variables, from left to right.

%\item[] Induction on inductive predicates.

%[TO BE COMPLETED]

% TODO: implement also induction on int !

\end{description}

\subsection{Simplification by Computation}

These transformations simplify the goal by applying several kinds of
simplification, described below. The transformations differ only by
the kind of rules they apply:
\begin{description}
\item[compute\_in\_goal] aggressively applies all known
  computation/simplification rules.
  \index{compute-in-goal@\verb+compute_in_goal+}

\item[compute\_specified] performs rewriting using only built-in
  operators and user-provided rules.
  \index{compute-specified@\verb+compute_specified+}
\end{description}

The kinds of simplification are as follows.
\begin{itemize}
\item Computations with built-in symbols, \eg operations on integers,
  when applied to explicit constants, are evaluated. This includes
  evaluation of equality when a decision can be made (on integer
  constants, on constructors of algebraic data types), Boolean
  evaluation, simplification of pattern-matching/conditional expression,
  extraction of record fields, and beta-reduction.
  At best, these computations reduce the goal to
  \verb|true| and the transformations thus does not produce any sub-goal.
  For example, a goal
  like \verb|6*7=42| is solved by those transformations.
\item Unfolding of definitions, as done by \verb|inline_goal|. Transformation
  \verb|compute_in_goal| unfolds all definitions, including recursive ones.
  For \verb|compute_specified|, the user can enable unfolding of a specific
  logic symbol by attaching the meta \verb|rewrite_def| to the symbol.
\begin{whycode}
function sqr (x:int) : int = x * x
meta "rewrite_def" function sqr
\end{whycode}
\item Rewriting using axioms or lemmas declared as rewrite rules. When
  an axiom (or a lemma) has one of the forms
\begin{whycode}
axiom a: forall ... t1 = t2
\end{whycode}
  or
\begin{whycode}
axiom a: forall ... f1 <-> f2
\end{whycode}
  then the user can declare
\begin{whycode}
meta "rewrite" prop a
\end{whycode}
  to turn this axiom into a rewrite rule. Rewriting is always done
  from left to right. Beware that there is no check for termination
  nor for confluence of the set of rewrite rules declared.
\end{itemize}
Instead of using a meta, it is possible to declare an axiom as a
rewrite rule by adding the \verb|[@rewrite]| attribute on the axiom name or
on the axiom itself, e.g.:
\begin{whycode}
axiom a [@rewrite]: forall ... t1 = t2
lemma b: [@rewrite] forall ... f1 <-> f2
\end{whycode}
The second form allows some form of local rewriting, e.g.
\begin{whycode}
lemma l: forall x y. ([@rewrite] x = y) -> f x = f y
\end{whycode}
can be proved by \verb|introduce_premises| followed by \verb|compute_specified|.

\paragraph{Bound on the number of reductions}
The computations performed by these transformations can take an
arbitrarily large number of steps, or even not terminate. For this
reason, the number of steps is bounded by a maximal value, which is
set by default to 1000. This value can be increased by another meta,
\eg
\begin{whycode}
meta "compute_max_steps" 1_000_000
\end{whycode}
When this upper limit is reached, a warning is issued, and the
partly-reduced goal is returned as the result of the transformation.


\subsection{Other Non-Splitting Transformations}

\begin{description}

\item[eliminate\_algebraic] replaces algebraic data types by first-order
definitions~\cite{paskevich09rr}.
\index{eliminate-algebraic@\verb+eliminate_algebraic+}

\item[eliminate\_builtin] removes definitions of symbols that are
  declared as builtin in the driver, \ie with a ``syntax'' rule.
\index{eliminate-builtin@\verb+eliminate_builtin+}

\item[eliminate\_definition\_func]
  replaces all function definitions with axioms.
\index{eliminate-definition-func@\verb+eliminate_definition_func+}

\item[eliminate\_definition\_pred]
  replaces all predicate definitions with axioms.
\index{eliminate-definition-pred@\verb+eliminate_definition_pred+}

\item[eliminate\_definition]
  applies both transformations above.
\index{eliminate-definition@\verb+eliminate_definition+}

\item[eliminate\_mutual\_recursion]
  replaces mutually recursive definitions with axioms.
\index{eliminate-mutual-recursion@\verb+eliminate_mutual_recursion+}

\item[eliminate\_recursion]
  replaces all recursive definitions with axioms.
\index{eliminate-recursion@\verb+eliminate_recursion+}

\item[eliminate\_if\_term] replaces terms of the form \texttt{if
    formula then t2 else t3} by lifting them at the level of formulas.
  This may introduce \texttt{if then else} in formulas.
\index{eliminate-if-term@\verb+eliminate_if_term+}

\item[eliminate\_if\_fmla] replaces formulas of the form \texttt{if f1 then f2
  else f3} by an equivalent formula using implications and other
  connectives.
\index{eliminate-if-fmla@\verb+eliminate_if_fmla+}

\item[eliminate\_if]
  applies both transformations above.
\index{eliminate-if@\verb+eliminate_if+}

\item[eliminate\_inductive] replaces inductive predicates by
  (incomplete) axiomatic definitions, \ie construction axioms and
  an inversion axiom.
\index{eliminate-inductive@\verb+eliminate_inductive+}

\item[eliminate\_let\_fmla]
  eliminates \texttt{let} by substitution, at the predicate level.
\index{eliminate-let-fmla@\verb+eliminate_let_fmla+}

\item[eliminate\_let\_term]
  eliminates \texttt{let} by substitution, at the term level.
\index{eliminate-let-term@\verb+eliminate_let_term+}

\item[eliminate\_let]
  applies both transformations above.
\index{eliminate-let@\verb+eliminate_let+}

% \item[encoding\_decorate\_mono]

% \item[encoding\_enumeration]

\item[encoding\_smt]
  encodes polymorphic types into monomorphic types~\cite{conchon08smt}.
\index{encoding-smt@\verb+encoding_smt+}

\item[encoding\_tptp]
  encodes theories into unsorted logic. %~\cite{cruanes10}.
\index{encoding-tptp@\verb+encoding_tptp+}

% \item[filter\_trigger] *)

% \item[filter\_trigger\_builtin] *)

% \item[filter\_trigger\_no\_predicate] *)

% \item[hypothesis\_selection] *)
%   Filter hypothesis of goals~\cite{couchot07ftp,cruanes10}. *)

\item[introduce\_premises] moves antecedents of implications and
  universal quantifications of the goal into the premises of the task.
\index{introduce-premises@\verb+introduce_premises+}

% \item[remove\_triggers] *)
%   removes the triggers in all quantifications. *)

\item[simplify\_array] automatically rewrites the task using the lemma
  \verb|Select_eq| of theory \verb|map.Map|.
\index{simplify-array@\verb+simplify_array+}

\item[simplify\_formula] reduces trivial equalities $t=t$ to true and
  then simplifies propositional structure: removes true, false, simplifies
  $f \land f$ to $f$, etc.
\index{simplify-formula@\verb+simplify_formula+}

\item[simplify\_recursive\_definition] reduces mutually recursive
  definitions if they are not really mutually recursive, \eg
\begin{whycode}
function f : ... = ... g ...
with g : ... = e
\end{whycode}
becomes
\begin{whycode}
function g : ... = e
function f : ... = ... g ...
\end{whycode}
if $f$ does not occur in $e$.
\index{simplify-recursive-definition@\verb+simplify_recursive_definition+}

\item[simplify\_trivial\_quantification]
  simplifies quantifications of the form
\begin{whycode}
forall x, x = t -> P(x)
\end{whycode}
into
\begin{whycode}
P(t)
\end{whycode}
  when $x$ does not occur in $t$.
  More generally, this simplification is applied whenever $x=t$ or
  $t=x$ appears in negative position.
\index{simplify-trivial-quantification@\verb+simplify_trivial_quantification+}

\item[simplify\_trivial\_quantification\_in\_goal]
  is the same as above but it applies only in the goal.
\index{simplify-trivial-quantification-in-goal@\verb+simplify_trivial_quantification_in_goal+}

\item[split\_premise] replaces axioms in conjunctive form
  by an equivalent collection of axioms.
  In absence of case analysis attributes (see \texttt{split\_goal} for details),
  the number of axiom generated per initial axiom is
  linear in the size of that initial axiom.
\index{split-premise@\verb+split_premise+}

\item[split\_premise\_full] is similar to \texttt{split\_premise}, but it
  also converts the axioms to conjunctive normal form. The number of
  axioms generated per initial axiom may be exponential in the size of
  the initial axiom.
\index{split-premise-full@\verb+split_premise_full+}

\end{description}

\subsection{Other Splitting Transformations}
\label{tech:trans:split}

\begin{description}

\item[simplify\_formula\_and\_task] is the same as \texttt{simplify\_formula}
  but it also removes the goal if it is equivalent to true.
\index{simplify-formula-and-task@\verb+simplify_formula_and_task+}

\item[split\_goal] changes conjunctive goals into the
  corresponding set of subgoals. In absence of case analysis attributes,
  the number of subgoals generated is linear in the size of the initial goal.

  \paragraph{Behavior on asymmetric connectives and
    \texttt{by}/\texttt{so}}

  The transformation treats specially asymmetric and
  \texttt{by}/\texttt{so} connectives. Asymmetric conjunction
  \verb|A && B| in goal position is handled as syntactic sugar for
  \verb|A /\ (A -> B)|.  The conclusion of the first subgoal can then
  be used to prove the second one.

  Asymmetric disjunction \verb+A || B+ in hypothesis position is handled as
  syntactic sugar for \verb|A \/ ((not A) /\ B)|.
  In particular, a case analysis on such hypothesis would give the negation of
  the first hypothesis in the second case.

  The \texttt{by} connective is treated as a proof indication. In
  hypothesis position, \verb|A by B| is treated as if it were
  syntactic sugar for its regular interpretation \verb|A|. In goal
  position, it is treated as if \verb|B| was an intermediate step for
  proving \verb|A|. \verb|A by B| is then replaced by \verb|B| and the
  transformation also generates a side-condition subgoal \verb|B -> A|
  representing the logical cut.

  Although splitting stops at disjunctive points like symmetric
  disjunction and left-hand sides of implications, the occurrences of
  the \texttt{by} connective are not restricted. For instance:
  \begin{itemize}
  \item Splitting
\begin{whycode}
goal G : (A by B) && C
\end{whycode}
generates the subgoals
\begin{whycode}
goal G1 : B
goal G2 : A -> C
goal G3 : B -> A (* side-condition *)
\end{whycode}
\item Splitting
\begin{whycode}
goal G : (A by B) \/ (C by D)
\end{whycode}
generates
\begin{whycode}
goal G1 : B \/ D
goal G2 : B -> A (* side-condition *)
goal G3 : D -> C (* side-condition *)
\end{whycode}
\item Splitting
\begin{whycode}
goal G : (A by B) || (C by D)
\end{whycode}
generates
\begin{whycode}
goal G1 : B || D
goal G2 : B -> A        (* side-condition *)
goal G3 : B || (D -> C) (* side-condition *)
\end{whycode}
Note that due to the asymmetric disjunction, the disjunction is kept in the
second side-condition subgoal.
\item Splitting
\begin{whycode}
goal G : exists x. P x by x = 42
\end{whycode}
generates
\begin{whycode}
goal G1 : exists x. x = 42
goal G2 : forall x. x = 42 -> P x (* side-condition *)
\end{whycode}
Note that in the side-condition subgoal, the context is universally closed.
\end{itemize}

The \texttt{so} connective plays a similar role in hypothesis position, as it serves as a consequence indication. In goal position, \verb|A so B| is treated as if it were syntactic sugar for its regular interpretation \verb|A|. In hypothesis position, it is treated as if both \verb|A| and \verb|B| were true because \verb|B| is a consequence of \verb|A|. \verb|A so B| is replaced by \verb|A /\ B| and the transformation also generates a side-condition subgoal \verb|A -> B| corresponding to the consequence relation between formula.

As with the \texttt{by} connective, occurrences of \texttt{so} are
unrestricted. For instance:
\begin{itemize}
\item Splitting
\begin{whycode}
goal G : (((A so B) \/ C) -> D) && E
\end{whycode}
generates
\begin{whycode}
goal G1 : ((A /\ B) \/ C) -> D
goal G2 : (A \/ C -> D) -> E
goal G3 : A -> B               (* side-condition *)
\end{whycode}
\item Splitting
\begin{whycode}
goal G : A by exists x. P x so Q x so R x by T x
(* reads: A by (exists x. P x so (Q x so (R x by T x))) *)
\end{whycode}
generates
\begin{whycode}
goal G1 : exists x. P x
goal G2 : forall x. P x -> Q x               (* side-condition *)
goal G3 : forall x. P x -> Q x -> T x        (* side-condition *)
goal G4 : forall x. P x -> Q x -> T x -> R x (* side-condition *)
goal G5 : (exists x. P x /\ Q x /\ R x) -> A (* side-condition *)
\end{whycode}
In natural language, this corresponds to the following proof scheme
for \verb|A|: There exists a \verb|x| for which \verb|P| holds. Then,
for that witness \verb|Q| and \verb|R| also holds. The last one holds
because \verb|T| holds as well. And from those three conditions on
\verb|x|, we can deduce \verb|A|.
\end{itemize}

\paragraph{Attributes controlling the transformation}

The transformations in the split family can be controlled by using
attributes on formulas.

The \verb|[@stop_split]| attribute can be used to block the splitting of a
formula.  The attribute is removed after blocking, so applying the
transformation a second time will split the formula. This is can be
used to decompose the splitting process in several steps. Also, if a
formula with this attribute is found in non-goal position, its
\texttt{by}/\texttt{so} proof indication will be erased by the
transformation. In a sense, formulas tagged by \verb|[@stop_split]| are
handled as if they were local lemmas.

The \verb|[@case_split]| attribute can be used to force case analysis on hypotheses.
For instance, applying \texttt{split\_goal} on
\begin{whycode}
goal G : ([@case_split] A \/ B) -> C
\end{whycode}
generates the subgoals
\begin{whycode}
goal G1 : A -> C
goal G2 : B -> C
\end{whycode}
Without the attribute, the transformation does nothing because undesired case analysis
may easily lead to an exponential blow-up.

Note that the precise behavior of splitting transformations in presence of
the \verb|[@case_split]| attribute is not yet specified
and is likely to change in future versions.

\index{split-goal@\verb+split_goal+}

\item[split\_all]
  performs both \texttt{split\_premise} and \texttt{split\_goal}.
\index{split-all@\verb+split_all+}

\item[split\_intro]
  performs both \texttt{split\_goal} and \texttt{introduce\_premises}.
\index{split-intro@\verb+split_intro+}

\item[split\_goal\_full]
  has a behavior similar
  to \texttt{split\_goal}, but also converts the goal to conjunctive normal form.
  The number of subgoals generated may be exponential in the size of the initial goal.
\index{split-goal-full@\verb+split_goal_full+}

\item[split\_all\_full]
  performs both \texttt{split\_premise} and \texttt{split\_goal\_full}.
\index{split-all-full@\verb+split_all_full+}


\end{description}

\subsection{Transformations with arguments}

Transformations with arguments are transformations that can use symbols and
expressions found in the task as arguments. This section contains a description
and examples of usage for every transformations with arguments.

\begin{description}

\item[apply] applies an hypothesis to the goal of the task using a
  \textit{modus ponens} rule. The hypothesis should be an implication whose
  conclusion can be matched with the goal.
  The intuitive behavior of \texttt{apply} can be translated as follows:\\
  $\Gamma, h: f1 \rightarrow f2 \vdash G: f2$\\
  \texttt{apply h} generates a new task:\\
  $\Gamma, h: f1 \rightarrow f2 \vdash G: f1$\\

  In practice, the transformation also manages to instantiate some variables
  with the appropriate terms. In \why code, an example is:
\begin{whycode}
predicate is_even int
predicate is_zero int
axiom zero_is_even: forall x: int. is_zero x -> is_even x
goal G: is_even 0
\end{whycode}
Applying the transformation:
\begin{transwhy3}
apply zero_is_even
\end{transwhy3}

A new goal is created:
\begin{whycode}
predicate is_even int
predicate is_zero int
axiom zero_is_even: forall x:int. is_zero x -> is_even x
goal G: is_zero 0
\end{whycode}
The transformation first matched the goal against the hypothesis and
instantiated \texttt{x} with \texttt{0}. It then applied the
\textit{modus ponens} rule to generate the new goal.

This transformation helps automated provers when they don't know which
hypothesis to use in order to prove a goal.


\index{apply@\verb+apply+}

\item[apply ... with ...] is a variant of \texttt{apply} (described above). It
  is intended to be used in contexts where \texttt{apply} cannot infer what
  terms to use for variables given in the applied hypothesis.
  For example, on the following task:
\begin{whycode}
axiom ac: a = c
axiom cb: c = b
axiom transitivity : forall x y z:int. x = y -> y = z -> x = z
goal G1 : a = b
\end{whycode}

\begin{transwhy3}
apply transitivity
\end{transwhy3}

Applying transitivity raises the following error:

\begin{transwhy3}
apply: Unable to infer arguments (try using "with") for: y
\end{transwhy3}

It means that the tool is not able to infer the right term to
instantiate symbol \texttt{y}. In our case, the user knows that the term
\texttt{c} should work.
So, we can apply a new transformation using the \texttt{with} syntax:

\begin{transwhy3}
apply transitivity with c
\end{transwhy3}

This generates two goals which are easily provable with hypotheses \texttt{ac}
and \texttt{cb}.

When multiple variables are needed, they should be provided as a list in the
transformation. For the sake of the example, we overcomplexify the
\texttt{transitivity} hypothesis:
\begin{whycode}
axiom t : forall x y z k:int. k = k -> x = y -> y = z -> x = z
\end{whycode}
With this new example, we can provide a new value for \texttt{k} as follows:

\begin{transwhy3}
apply t with c,0
\end{transwhy3}

\item[assert] allows to make an intermediate proof. This is comparable
  \texttt{assert}s written in the \whyml code. Here, the intent is only to help
  provers by specifying one key argument of the reasoning they should use.
  For example:

\begin{transwhy3}
assert (n = 0)
\end{transwhy3}

From a goal of the form $\Gamma \vdash G$, and with $h$ the new name of
hypothesis $n = 0$. The transformation produces the following two tasks:\\
$\Gamma \vdash h$\\
$\Gamma, h \vdash G$

This effectively adds $h$ as an intermediate goal to prove.

  \index{assert@\verb+assert+}

\item[assert ... as ...] is derived from \texttt{assert}: it allows to give
  a name to the new hypothesis.
  For example:
\begin{transwhy3}
assert (x = 0) as x0
\end{transwhy3}

\item[case] is the destruction of the \textit{excluded middle} rule on a given
  formula \texttt{f}. It splits the task in two: the first assumes \texttt{f}
  and the other one assumes \texttt{not f}.
  On the task $\Gamma \vdash G$, with $f$ the term provided, \texttt{case}
  produces the two tasks:\\
$\Gamma, h : f \vdash G$\\
$\Gamma, h : \neg f \vdash G$

In \why code, an example is:
\begin{whycode}
constant x : int
constant y : int
goal G: if x = 0 then y = 2 else y = 3
\end{whycode}

\begin{transwhy3}
case (x = 0)
\end{transwhy3}

The transformation generates the two new following goals:

\begin{whycode}
constant x : int
constant y : int
axiom h : x = 0
goal G : if x = 0 then y = 2 else y = 3
\end{whycode}
and:
\begin{whycode}
constant x : int
constant y : int
axiom h : not x = 0
goal G : if x = 0 then y = 2 else y = 3
\end{whycode}

The intention is again to simplify the job of automated provers by giving them a
key argument of the reasoning behind the proof of a subgoal.

\index{case@\verb+case+}

\item[case ... as ...] is derived from \texttt{case}: it allows to name the
  introduced hypotheses.

\item[clear\_but] removes all hypotheses except those specified in
  the arguments. This is useful when a prover fails to use the relevant
  hypotheses in a very big context.
  For example:
\begin{transwhy3}
clear_but h23,h55
\end{transwhy3}

\index{clear_but@\verb+clear_but+}

\item[compute\_hyp] applies the transformation \texttt{compute} on the given
  hypothesis.

\index{compute_hyp@\verb+compute_hyp+}

\item[compute\_hyp\_specified] applies the transformation
  \texttt{compute\_specified} on the given hypothesis.

\index{compute_hyp_specified@\verb+compute_hyp_specified+}

\item[cut] is the same as \texttt{assert} with the order of generated subgoals
  reversed.

\index{cut@\verb+cut+}

\item[destruct] is used to eliminate the head logical symbol of an hypothesis
  such as $\wedge$, $\vee$, or $\rightarrow$.
  For example, on the following goal:
\begin{whycode}
constant p1 : bool
predicate p2 int
axiom h : p1 = True /\ (forall x:int. p2 x)
goal G : p2 0
\end{whycode}

\begin{transwhy3}
destruct h
\end{transwhy3}


The task is transformed into:
\begin{whycode}
constant p1 : bool
predicate p2 int
axiom h1 : p1 = True
axiom h : forall x:int. p2 x
goal G : p2 0
\end{whycode}

The logical operator $\wedge$ is effectively removed.
\texttt{destruct} can be applied to a lot of head logical constructions
producing the expected new tasks:
\begin{itemize}
\item \whyf{false}
\item \whyf{true}
\item \whyf{/\\}
\item \whyf{\\/}
\item \whyf{->}
\item \whyf{exists}
\item \whyf{not}
\item \whyf{if ... then ... else}
\item \whyf{match ... with ... end}
\item (in)equality on constructors of the same type
\end{itemize}

\index{destruct@\verb+destruct+}

\item[destruct\_rec] recursively calls \texttt{destruct} on new generated
  hypotheses. The recursivity on implication and \texttt{match} stops after the
  first occurence of a different symbol.
  For example, on the following goal:
\begin{whycode}
predicate a
predicate b
predicate c
axiom H : (a -> b) /\ (b /\ c)
goal G : false
\end{whycode}

\begin{transwhy3}
destruct_rec H
\end{transwhy3}

The transformation will not destruct the implication symbol because it occurs
as a subterms of an already destructed symbol. This stop applies only to
implication and \texttt{match}: the other symbols are destructed recursively.
In the generated task, we can see that the second \whyf{/\\} is simplified but
not the \whyf{->}:
\begin{whycode}
predicate a
predicate b
predicate c
axiom H2 : a -> b
axiom H1 : b
axiom H: c
goal G : false
\end{whycode}

\index{destruct-rec@\verb+destruct_rec+}

\item[destruct\_term] destructs an expression according to the type of the
  expression. The transformation produces all possible outcomes of a
  destruction of the algebraic type.
  For example,
\begin{whycode}
type t = | A | B int
constant a : t
goal G : a = A
\end{whycode}

\begin{transwhy3}
destruct_term a
\end{transwhy3}

returns the two following goals (for constructor \texttt{B}):

\begin{whycode}
type t = | A | B int
constant a : t
constant x : int
axiom h : a = B x
goal G : a = A
\end{whycode}

and (for constructor \texttt{A}):
\begin{whycode}
type t = | A | B int
constant a : t
axiom h : a = A
goal G : a = A
\end{whycode}

The term was destructed according to all the possible outcomes in the
type. Note that, during destruction, a new constant \texttt{x} has been
introduced for the argument of constructor \texttt{B}.

\index{destruct-term@\verb+destruct_term+}

\item[destruct\_term ... using ..] is a way to give names to constants that were
  generated by \texttt{destruct\_term}.

\item[destruct\_term\_subst] has the same behavior as \texttt{destruct\_term}
  except that it also substitutes the created term.

\index{destruct-term-subst@\verb+destruct_term_subst+}

\item[exists] is a way to give a witness term to a goal that starts with an
  existential quantification.
  For example, on the following goal:
\begin{whycode}
goal G : exists x:int. x = 0
\end{whycode}
We can apply the following transformation:

\begin{transwhy3}
exists 0
\end{transwhy3}

This instantiates the symbol \texttt{x} with \texttt{0}. The goal becomes:

\begin{whycode}
goal G : 0 = 0
\end{whycode}

\index{exists@\verb+exists+}

\item[hide] is used to hide a complex term: it creates a new constant equal to
  the term and then replaces all occurences of the term in the context by this
  constant.
  For example, on the task:
\begin{whycode}
constant y : int
axiom h : forall x:int. x = (1 + 1)
goal G : (y - (1 + 1)) = ((1 + 1) - (1 + 1))
\end{whycode}

\begin{transwhy3}
hide t (1 + 1)
\end{transwhy3}

The transformation generates the new following task:
\begin{whycode}
constant y : int
constant t : int
axiom H : t = (1 + 1)
axiom h : forall x:int. x = t
goal G : (y - t) = (t - t)
\end{whycode}

All occurences of \whyf{(1 + 1)} have been replaced by \whyf{t}.

\index{hide@\verb+hide+}

\item[hide\_and\_clear] first applies \texttt{hide} then removes the
  equality between the hidden term and the introduced constant. This means that
  the hidden term completely disappears and cannot be recovered.

\index{hide-and-clear@\verb+hide_and_clear+}

\item[induction] generates a reasoning by induction for the current goal.
  For example, on the following goal, trying to prove that \texttt{p1} implies
  \texttt{p} by induction on \texttt{n}:
\begin{whycode}
constant n : int
predicate p int
predicate p1 int
axiom h : p1 n
goal G : p n
\end{whycode}

\begin{transwhy3}
induction n
\end{transwhy3}

This does an induction starting at \texttt{0} generating the two following
goals. The base case:
\begin{whycode}
constant n : int
predicate p int
predicate p1 int
axiom h : p1 n
axiom Init : n <= 0
goal G : p n
\end{whycode}

And, the recursive case:

\begin{whycode}
constant n : int
predicate p int
predicate p1 int
axiom h : p1 n
axiom Init : 0 < n
axiom Hrec : forall n1:int. n1 < n -> p1 n1 -> p n1
goal G : p n
\end{whycode}

\index{induction@\verb+induction+}

\item[induction ... from ...] is the same as \texttt{induction} but it starts
  the induction from a given integer instead of \texttt{0}.

\item[induction\_arg\_pr] does \texttt{induction\_pr} on the given
  hypothesis/goal symbol.

\index{induction-arg-pr@\verb+induction_arg_pr+}

\item[induction\_arg\_ty\_lex] does \texttt{induction\_ty\_lex} on the given
  symbol.

\index{induction-arg-ty-lex@\verb+induction_arg_ty_lex+}

\item[instantiate] generates a new hypothesis with quantified variables
  replaced by the given terms. For example, on the following:

\begin{whycode}
predicate p int
axiom h : forall x:int, y:int. x <= y -> p x /\ p y
goal G : p 0
\end{whycode}

\begin{transwhy3}
instantiate h 0, 1
\end{transwhy3}

generates this new hypothesis:
\begin{whycode}
predicate p int
axiom h : forall x:int, y:int. x <= y -> p x /\ p y
axiom Hinst : 0 <= 1 -> p 0 /\ p 1
goal G : p 0
\end{whycode}

This is used to help automatic provers that are generally better at working on
instantiated hypothesis.

\index{instantiate@\verb+instantiate+}

\item[inst\_rem] first does \texttt{instantiate} then removes the original
  instantiated hypothesis.

\index{inst-rem@\verb+inst_rem+}

\item[intros] allows to name introduced elements.
  For example,
\begin{whycode}
predicate p int int int
goal G : forall x:int, y:int, z:int. p x y z
\end{whycode}

\begin{transwhy3}
intros n, m
\end{transwhy3}

returns:
\begin{whycode}
predicate p int int int
constant n : int
constant m : int
goal G : forall z:int. p n m z
\end{whycode}

\index{intros@\verb+intros+}

\item[intros\_n] introduces the \texttt{n} first quantified variables or
  premises.
  For example,
\begin{whycode}
predicate p int int int
goal G : forall x:int, y:int, z:int. p x y z
\end{whycode}

\begin{transwhy3}
intros_n 2
\end{transwhy3}

returns:

\begin{whycode}
predicate p int int int
constant x : int
constant y : int
goal G : forall z:int. p x y z
\end{whycode}

\index{intros-n@\verb+intros_n+}

\item[inversion\_arg\_pr] does \texttt{inversion\_pr} on the given
  hypothesis/goal symbol.

\index{inversion-arg-pr@\verb+inversion_arg_pr+}

\item[left] removes the right part of a goal head disjonction.
  For example,
\begin{whycode}
constant x : int
goal G : x = 0 \/ x = 1
\end{whycode}

\begin{transwhy3}
left
\end{transwhy3}

returns:

\begin{whycode}
constant x : int
goal G : x = 0
\end{whycode}

\index{left@\verb+left+}

\item[pose] adds a new constant equal to the given term.
  For example,
\begin{whycode}
constant x : int
goal G : true
\end{whycode}

\begin{transwhy3}
pose t (x + 2)
\end{transwhy3}

returns:
\begin{whycode}
constant x : int
constant t : int
axiom H : t = (x + 2)
goal G : true
\end{whycode}

\index{pose@\verb+pose+}

\item[remove] removes an hypothesis from the context.

\begin{whycode}
axiom h : true
goal G : true
\end{whycode}

\begin{transwhy3}
remove h
\end{transwhy3}


returns:
\begin{whycode}
goal G : true
\end{whycode}

\index{remove@\verb+remove+}

\item[replace] replaces a term with another one in an hypothesis or in the
  goal. This generates a new goal which asks for the proof of the equality.
  For example,
\begin{whycode}
constant x : int
constant y : int
axiom h : x >= (y + 1)
goal G : true
\end{whycode}

\begin{transwhy3}
replace (y + 1) (x + 2) in h
\end{transwhy3}

The transformation generates two subgoals:
\begin{whycode}
constant x : int
constant y : int
axiom h : x >= (x + 2)
goal G : true
\end{whycode}

and:
\begin{whycode}
constant x : int
constant y : int
axiom h : x >= (y + 1)
goal G : (y + 1) = (x + 2)
\end{whycode}

It can be seen as the combination of \texttt{assert} and \texttt{rewrite}.

\index{replace@\verb+replace+}

\item[revert] is the opposite of \texttt{intros}. It takes hypotheses/constants
  and quantifies them in the goal.
  For example,

\begin{whycode}
constant x : int
constant y : int
axiom h : x = y
goal G : true
\end{whycode}

\begin{transwhy3}
revert x
\end{transwhy3}

returns:

\begin{whycode}
constant y : int
goal G : forall x:int. x = y -> true
\end{whycode}

\index{revert@\verb+revert+}

\item[rewrite] rewrites using an equality hypothesis.
  For example,
\begin{whycode}
function a int : bool
function b int : bool
constant y : int
axiom eq : forall x:int. not x = 0 -> a x = b x
goal G : a y = True
\end{whycode}

\begin{transwhy3}
rewrite eq
\end{transwhy3}

The transformation modifies the goal:

\begin{whycode}
function a int : bool
function b int : bool
constant y : int
axiom eq : forall x:int. not x = 0 -> a x = b x
goal G : b y = True
\end{whycode}

and adds new generated premises (as for \texttt{apply}):
\begin{whycode}
function a int : bool
function b int : bool
constant y : int
axiom eq : forall x:int. not x = 0 -> a x = b x
goal G : not y = 0
\end{whycode}

\index{rewrite@\verb+rewrite+}

\item[rewrite ... with ...] is a variant of \texttt{rewrite}. As for
  \texttt{apply}, symbols that could not be instantiated can be provided by the
  user after the \texttt{with}.

  For example:
\begin{whycode}
function a int : bool
function b int : bool
constant y : int
axiom eq : forall x:int, z:int. z = 0 -> not x = 0 -> a x = b x
goal G : a y = True
\end{whycode}

The following transformation can be applied:

\begin{transwhy3}
rewrite eq with 0
\end{transwhy3}

In this case, a value was provided for the symbol \texttt{z} modifying the goal
and generating two new ones for the premises of the equality hypothesis:
\begin{whycode}
function a int : bool
function b int : bool
constant y : int
axiom eq : forall x:int, z:int. z = 0 -> not x = 0 -> a x = b x
goal G : b y = True
\end{whycode}

\begin{whycode}
function a int : bool
function b int : bool
constant y : int
axiom eq : forall x:int, z:int. z = 0 -> not x = 0 -> a x = b x
goal G : 0 = 0
\end{whycode}

\begin{whycode}
function a int : bool
function b int : bool
constant y : int
axiom eq : forall x:int, z:int. z = 0 -> not x = 0 -> a x = b x
goal G : not y = 0
\end{whycode}



\item[rewrite\_list] is a variant of \texttt{rewrite} which allows
  simultaneous rewriting in a list of hypothesis/goals.

\index{rewrite-list@\verb+rewrite_list+}

\item[right] removes the left part of a goal head disjonction.
  For example,
\begin{whycode}
constant x : int
goal G : x = 0 \/ x = 1
\end{whycode}

\begin{transwhy3}
right
\end{transwhy3}

The transformation returns:

\begin{whycode}
constant x : int
goal G : x = 1
\end{whycode}

\index{right@\verb+right+}

%TODO not documenting step and steps which are limited version of
%compute ?

\item[subst] substitutes a constant \whyf{c} with a term \whyf{t} using an
  equality of the form \whyf{c = t} in the context. The constant is removed.
  For example,
\begin{whycode}
constant x : int
constant y : int
constant z : int
axiom h : x = y + 1
axiom h1 : z = (x + y)
goal G : x = z
\end{whycode}

\begin{transwhy3}
subst x
\end{transwhy3}

The transformation first finds the hypothesis \texttt{h} that can be used to
rewrite \texttt{x}. Then, it replaces every occurences of \texttt{x} with
\texttt{y + 1} and finally, it removes \texttt{h} and \texttt{x}.
The result is as follows:

\begin{whycode}
constant y : int
constant z : int
axiom h1 : z = ((y + 1) + y)
goal G : (y + 1) = z
\end{whycode}

This transformation is used to make the task more easily readable by a human
during debugging. This transformation should not help automatic provers at all
as they generally implement substitution rules in their logic.

\index{subst@\verb+subst+}


\item[subst\_all] tries to substitute all variables that can be substituted.

  For example,
\begin{whycode}
constant x : int
constant x1 : int
constant y : int
constant z : int
axiom h : x = (y + 1)
axiom hx1 : x = x1
axiom h1 : z = (x + y)
goal G : x = z
\end{whycode}

\begin{transwhy3}
subst_all
\end{transwhy3}

The returned tasks with \texttt{x}, \texttt{x1}, and \texttt{z} removed is:
\begin{whycode}
constant y : int
goal G : (y + 1) = ((y + 1) + y)
\end{whycode}

Note that the order in which constants are substituted is not specified.

\index{subst-all@\verb+subst_all+}

\item[unfold ... in ...] unfolds the definition of a logical symbol in the
  given hypothesis.
  For example,
\begin{whycode}
predicate p (x:int) = x <= 22
axiom h : forall x:int. p x -> p (x - 1)
goal G : p 21
\end{whycode}

\begin{transwhy3}
unfold p
\end{transwhy3}

This unfolds \whyf{p} in the goal:

\begin{whycode}
predicate p (x:int) = x <= 22
axiom h : forall x:int. p x -> p (x - 1)
goal G : 21 <= 22
\end{whycode}

But, we could also unfold in an hypothesis:

\begin{transwhy3}
unfold p in h
\end{transwhy3}

\begin{whycode}
predicate p (x:int) = x <= 22
axiom h : forall x:int. x <= 22 -> (x - 1) <= 22
goal G : 21 <= 22
\end{whycode}

\index{unfold@\verb+unfold+}


\item[use\_th] imports a theory inside the current context. This is used, in
  some rare case, to reduced the size of the context in other goals (it avoids
  importing a theory in the \whyml code thus making the theory available in all
  goals whereas the theory is only needed in one specific goal).
  For example,
\begin{whycode}
predicate p int
goal G : p 5
\end{whycode}

\begin{transwhy3}
use_th int.Int
\end{transwhy3}

This imports the \texttt{Int} theory. So, one is able to use the addition over
integers for example:

\begin{transwhy3}
replace 5 (2 + 3)
\end{transwhy3}

Any lemma appearing in the imported theory can also be used.

Note that axioms are also imported. So, this transformation should be used
with care. We recommend to use only theories that do not contain any axioms
because this transformation could easily makes the context incoherent.

\index{use-th@\verb+use_th+}

\end{description}

\section{Proof Strategies}
\label{sec:strategies}

As seen in Section~\ref{sec:ideref}, the IDE provides a few buttons
that trigger the run of simple proof strategies on the selected goals.
Proof strategies can be defined using a basic assembly-style language,
and put into the Why3 configuration file. The commands of this basic
language are:
\begin{itemize}
\item \texttt{c $p$ $t$ $m$} calls the prover $p$ with a time limit
  $t$ and memory limit $m$. On success, the strategy ends, it
  continues to next line otherwise
\item \texttt{t $n$ $lab$} applies the transformation $n$. On success,
  the strategy continues to label $lab$, and is applied to each
  generated sub-goals.  It continues to next line otherwise.
\item \texttt{g $lab$} inconditionally jumps to label $lab$
\item \texttt{$lab$:} declares the label $lab$. The default label
  \texttt{exit} allows to stop the program.
\end{itemize}

To examplify this basic programming language, we give below the
default strategies that are attached to the default buttons of the
IDE, assuming that the provers Alt-Ergo 1.30, CVC4 1.5 and Z3 4.5.0
were detected by the \verb|why3 config --detect| command
\begin{description}
\item[Split] is bound to the 1-line strategy
\begin{verbatim}
t split_goal_wp exit
\end{verbatim}

\item[Auto level 0] is bound to
\begin{verbatim}
c Z3,4.5.0, 1 1000
c Alt-Ergo,1.30, 1 1000
c CVC4,1.5, 1 1000
\end{verbatim}
  The three provers are tried for a time limit of 1 second and memory
  limit of 1~Gb, each in turn. This is a perfect strategy for a first
  attempt to discharge a new goal.

\item[Auto level 1] is bound to
\begin{verbatim}
c Z3,4.5.0, 5 1000
c Alt-Ergo,1.30, 5 1000
c CVC4,1.5, 5 1000
\end{verbatim}
  The three provers are tried for a time limit of 5 seconds and memory
  limit of 1~Gb, each in turn.

\item[Auto level 2] is bound to
\begin{verbatim}
start:
c Z3,4.5.0, 1 1000
c Alt-Ergo,1.30, 1 1000
c CVC4,1.5, 1 1000
t split_goal_wp start
c Z3,4.5.0, 10 4000
c Alt-Ergo,1.30, 10 4000
c CVC4,1.5, 10 4000
\end{verbatim}
  The three provers are first tried for a time limit of 1 second and
  memory limit of 1~Gb, each in turn. If none of them succeed, a
  split is attempted. If the split works then the same strategy is
  retried on each sub-goals. If the split does not succeed, the provers
  are tried again with a larger limits.

\item[Auto level 3] is bound to
\begin{verbatim}
start:
c Z3,4.5.0, 1 1000
c Eprover,2.0, 1 1000
c Spass,3.7, 1 1000
c Alt-Ergo,1.30, 1 1000
c CVC4,1.5, 1 1000
t split_goal_wp start
c Z3,4.5.0, 5 2000
c Eprover,2.0, 5 2000
c Spass,3.7, 5 2000
c Alt-Ergo,1.30, 5 2000
c CVC4,1.5, 5 2000
t introduce_premises afterintro
afterintro:
t inline_goal afterinline
g trylongertime
afterinline:
t split_goal_wp start
trylongertime:
c Z3,4.5.0, 30 4000
c Eprover,2.0, 30 4000
c Spass,3.7, 30 4000
c Alt-Ergo,1.30, 30 4000
c CVC4,1.5, 30 4000
\end{verbatim}
  Notice that now 5 provers are used.  The provers are first tried for
  a time limit of 1 second and memory limit of 1~Gb, each in turn. If
  none of them succeed, a split is attempted. If the split works then
  the same strategy is retried on each sub-goals. If the split does
  not succeed, the prover are tried again with limits of 5 s and 2
  Gb. If all fail, we attempt the transformation of introduction of
  premises in the context, followed by an inlining of the definitions
  in the goals. We then attempt a split again, if the split succeeds,
  we restart from the beginning, if it fails then provers are tried
  again with 30s and 4 Gb.

\end{description}

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "manual"
%%% End:
