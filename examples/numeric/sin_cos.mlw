module SinCosSingle
  use real.RealInfix
  use real.Abs
  use ufloat.USingle
  use ufloat.USingleLemmas
  use real.Trigonometry

  constant sin_error:real
  axiom sin_error_bounds : 0. <=. sin_error
  val function sin_approx (x:usingle) : usingle
    ensures {
      abs (to_real result -. sin (to_real x)) <=. abs (sin (to_real x)) *. sin_error
    }

  constant cos_error:real
  axiom cos_error_bounds : 0. <=. cos_error
  val function cos_approx (x:usingle) : usingle
    ensures {
      abs (to_real result -. cos (to_real x)) <=. abs (cos (to_real x)) *. cos_error
    }


  let ghost sin_simple_example (x y :usingle)
    ensures {
      abs (to_real result -. sin(to_real x +. to_real y))
      <=. sin_error *. abs (sin (to_real x +. to_real y))
       +. eps *. abs (to_real x +. to_real y) *. (1. +. sin_error)
    }
  = sin_approx(x ++. y)

  let ghost cos_simple_example (x y :usingle)
    ensures {
      abs (to_real result -. cos(to_real x -. to_real y))
      <=. cos_error *. abs (cos (to_real x -. to_real y))
       +. eps *. abs (to_real x -. to_real y) *. (1. +. cos_error)
    }
  = cos_approx(x --. y)

  lemma cos_square_plus_sine_square : forall x. cos x *. cos x +. sin x *. sin x = 1.

  let ghost cos_and_sine_example (a :usingle)
    ensures {
      let t = 1. +. eps in
      abs (to_real result -. 1.)
      <=. (3. *. eps +. t *.
             (2. *. sin_error +. sin_error *. sin_error +.
              2. *. cos_error +. cos_error *. cos_error))
       +. eta *. 
          (2. +. 4. *. eps +. 
           t *.
             (2. *. sin_error +. sin_error *. sin_error +.
              2. *. cos_error +. cos_error *. cos_error)
          )
    }
  = cos_approx a **. cos_approx a ++. sin_approx a **. sin_approx a

constant zeropointfive:usingle
axiom zeropointfive_val : to_real zeropointfive = 0.5

constant twopoint5:usingle
axiom twopoint5_val : to_real twopoint5 = 2.5

let ghost kinematics (theta1 theta2:usingle)
  ensures {
    let t1 = 1.0 +. eps in
    let t2 = to_real theta1 +. to_real theta2 in
    let t3 = 0.5 *. sin (to_real theta1) in
    let t4 = eps +. (sin_error *. t1) in
    let t5 = 2.5 *. sin t2 in
    let t6 = t1 +. t4 in
    let exact = t3 +. t5 in
    abs (to_real result -. exact)
    <=.
    (* Relative part of the error *)
    (((t4 +. t4) +. eps) *. (abs t3 +. abs t5)) +.
    (* Absolute part of the error *)
    t6 *. eta +.
    t6 *. (2.5 *. t1 *. eps *. abs t2 *. (1.0 +. sin_error) +. eta)
  }
= zeropointfive **. sin_approx (theta1) ++. twopoint5 **. sin_approx(theta1 ++. theta2)

let ghost raytracer (theta phi nx ny nz:usingle)
  ensures {
    let t1 = sin (to_real phi) in
    let t2 = cos (to_real phi) in
    let t3 = cos (to_real theta) in
    let t4 = 1.0 +. eps in
    let t5 = to_real ny *. sin (to_real theta) in
    let t6 = eps +. (cos_error *. t4) in
    let t7 = eps +. (sin_error *. t4) in
    let t8 = (to_real nz *. t3) *. t1 in
    let t9 = (to_real nx *. t3) *. t2 in
    let t10 = eps +. (((t6 +. cos_error) +. (t6 *. cos_error)) *. t4) in
    let t11 = eps +. (((t6 +. sin_error) +. (t6 *. sin_error)) *. t4) in
    let t12 = (t10 +. t7) +. eps in
    abs (to_real result -. ((t9 +. t5) +. t8))
    <=.
    (* Relative part of the error *)
    (t12 +. t11 +. eps) *. (abs t9 +. abs t5 +. abs t8) +.
    (* Absolute part of the error *)
    (t4 +. t11) *.
      ((t4 +. t7) *. (t4 *. (eta +. eta *. cos_error) *. abs t2 +. eta)
      +. (t4 +. t10) *. eta) +.
    (t4 +. t12) *. ((t4 *. (eta +. eta *. sin_error) *. abs t1) +. eta)
  }
=
  nx **. cos_approx theta **. cos_approx phi
  ++. ny **. sin_approx theta
  ++. nz **. cos_approx theta **. sin_approx phi
end

module SinCosDouble
  use real.RealInfix
  use real.Abs
  use ufloat.UDouble
  use ufloat.UDoubleLemmas
  use real.Trigonometry

  constant sin_error:real
  axiom sin_error_bounds : 0. <=. sin_error <=. 1.
  val function sin_approx (x:udouble) : udouble
    ensures {
      abs (to_real result -. sin (to_real x)) <=. abs (sin (to_real x)) *. sin_error
    }

  constant cos_error:real
  axiom cos_error_bounds : 0. <=. cos_error <=. 1.
  val function cos_approx (x:udouble) : udouble
    ensures {
      abs (to_real result -. cos (to_real x)) <=. abs (cos (to_real x)) *. cos_error
    }


  let ghost sin_simple_example (x y :udouble)
    ensures {
      abs (to_real result -. sin(to_real x +. to_real y))
      <=. sin_error *. abs (sin (to_real x +. to_real y))
       +. eps *. abs (to_real x +. to_real y) *. (1. +. sin_error)
    }
  = sin_approx(x ++. y)

  let ghost cos_simple_example (x y :udouble)
    ensures {
      abs (to_real result -. cos(to_real x -. to_real y))
      <=. cos_error *. abs (cos (to_real x -. to_real y))
       +. eps *. abs (to_real x -. to_real y) *. (1. +. cos_error)
    }
  = cos_approx(x --. y)

  lemma cos_square_plus_sine_square : forall x. cos x *. cos x +. sin x *. sin x = 1.

  let ghost cos_and_sine_example (a :udouble)
    ensures {
      let t = 1. +. eps in
      abs (to_real result -. 1.)
      <=. (3. *. eps +. t *.
             (2. *. sin_error +. sin_error *. sin_error +.
              2. *. cos_error +. cos_error *. cos_error))
       +. eta *. 
          (2. +. 4. *. eps +. 
           t *.
             (2. *. sin_error +. sin_error *. sin_error +.
              2. *. cos_error +. cos_error *. cos_error)
          )
    }
  = cos_approx a **. cos_approx a ++. sin_approx a **. sin_approx a

constant zeropointfive:udouble
axiom zeropointfive_val : to_real zeropointfive = 0.5

constant twopoint5:udouble
axiom twopoint5_val : to_real twopoint5 = 2.5

let ghost kinematics (theta1 theta2:udouble)
  ensures {
    let t1 = 1.0 +. eps in
    let t2 = to_real theta1 +. to_real theta2 in
    let t3 = 0.5 *. sin (to_real theta1) in
    let t4 = eps +. (sin_error *. t1) in
    let t5 = 2.5 *. sin t2 in
    let t6 = t1 +. t4 in
    let exact = t3 +. t5 in
    abs (to_real result -. exact)
    <=.
    (* Relative part of the error *)
    (((t4 +. t4) +. eps) *. (abs t3 +. abs t5)) +.
    (* Absolute part of the error *)
    t6 *. eta +.
    t6 *. (2.5 *. t1 *. eps *. abs t2 *. (1.0 +. sin_error) +. eta)
  }
= zeropointfive **. sin_approx (theta1) ++. twopoint5 **. sin_approx(theta1 ++. theta2)

let ghost raytracer (theta phi nx ny nz:udouble)
  ensures {
    let t1 = sin (to_real phi) in
    let t2 = cos (to_real phi) in
    let t3 = cos (to_real theta) in
    let t4 = 1.0 +. eps in
    let t5 = to_real ny *. sin (to_real theta) in
    let t6 = eps +. (cos_error *. t4) in
    let t7 = eps +. (sin_error *. t4) in
    let t8 = (to_real nz *. t3) *. t1 in
    let t9 = (to_real nx *. t3) *. t2 in
    let t10 = eps +. (((t6 +. cos_error) +. (t6 *. cos_error)) *. t4) in
    let t11 = eps +. (((t6 +. sin_error) +. (t6 *. sin_error)) *. t4) in
    let t12 = (t10 +. t7) +. eps in
    abs (to_real result -. ((t9 +. t5) +. t8))
    <=.
    (* Relative part of the error *)
    (t12 +. t11 +. eps) *. (abs t9 +. abs t5 +. abs t8) +.
    (* Absolute part of the error *)
    (t4 +. t11) *.
      ((t4 +. t7) *. (t4 *. (eta +. eta *. cos_error) *. abs t2 +. eta)
      +. (t4 +. t10) *. eta) +.
    (t4 +. t12) *. ((t4 *. (eta +. eta *. sin_error) *. abs t1) +. eta)
  }
=
  nx **. cos_approx theta **. cos_approx phi
  ++. ny **. sin_approx theta
  ++. nz **. cos_approx theta **. sin_approx phi
end
