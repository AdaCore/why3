(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Inductive operator  :=
  | Oplus : operator 
  | Ominus : operator 
  | Omult : operator .

Inductive term  :=
  | Tconst : Z -> term 
  | Tvar : Z -> term 
  | Tderef : Z -> term 
  | Tbin : term -> operator -> term -> term .

Inductive fmla  :=
  | Fterm : term -> fmla 
  | Fand : fmla -> fmla -> fmla 
  | Fnot : fmla -> fmla 
  | Fimplies : fmla -> fmla -> fmla 
  | Flet : term -> fmla -> fmla 
  | Fforall : fmla -> fmla .

Inductive value  :=
  | Vint : Z -> value 
  | Vbool : bool -> value .

Inductive list (a:Type) :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.
Implicit Arguments Cons.

Inductive state  :=
  | mk_state : (list value) -> (list value) -> state .

Definition ref_env(u:state): (list value) :=
  match u with
  | (mk_state _ ref_env1) => ref_env1
  end.

Definition var_env(u:state): (list value) :=
  match u with
  | (mk_state var_env1 _) => var_env1
  end.

Definition eval_bin(x:value) (op:operator) (y:value) (res:value): Prop :=
  match (x,
  y) with
  | ((Vint x1), (Vint y1)) =>
      match op with
      | Oplus => (res = (Vint (x1 + y1)%Z))
      | Ominus => (res = (Vint (x1 - y1)%Z))
      | Omult => (res = (Vint (x1 * y1)%Z))
      end
  | (_, _) => False
  end.

Inductive get_env : Z -> (list value) -> value -> Prop :=
  | Get_first : forall (x:value) (l:(list value)), (get_env 0%Z (Cons x l) x)
  | Get_next : forall (i:Z) (x:value) (r:value) (l:(list value)),
      (0%Z <  i)%Z -> ((get_env (i - 1%Z)%Z l r) -> (get_env i (Cons x l) x)).

Inductive eval_term : state -> term -> value -> Prop :=
  | eval_const : forall (s:state) (n:Z), (eval_term s (Tconst n) (Vint n))
  | eval_var : forall (s:state) (i:Z) (res:value), (get_env i (var_env s)
      res) -> (eval_term s (Tvar i) res)
  | eval_deref : forall (s:state) (i:Z) (res:value), (get_env i (ref_env s)
      res) -> (eval_term s (Tderef i) res)
  | eval_bin1 : forall (s:state) (op:operator) (t1:term) (t2:term) (r1:value)
      (r2:value) (r:value), (eval_term s t1 r1) -> ((eval_term s t2 r2) ->
      ((eval_bin r1 op r2 r) -> (eval_term s (Tbin t1 op t2) r))).

(* YOU MAY EDIT THE CONTEXT BELOW *)

(* DO NOT EDIT BELOW *)

Theorem Test55 : (eval_term (mk_state (Cons (Vint 42%Z) (Nil:(list value)))
  (Nil:(list value))) (Tbin (Tvar 0%Z) Oplus (Tconst 13%Z)) (Vint 55%Z)).
(* YOU MAY EDIT THE PROOF BELOW *)
apply eval_bin1 with (r1:=Vint 42) (r2:=Vint 13).
constructor.
constructor.
constructor.
constructor.
Qed.
(* DO NOT EDIT BELOW *)


