(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Inductive operator  :=
  | Oplus : operator 
  | Ominus : operator 
  | Omult : operator .

Inductive term  :=
  | Tconst : Z -> term 
  | Tvar : Z -> term 
  | Tderef : Z -> term 
  | Tbin : term -> operator -> term -> term .

Inductive fmla  :=
  | Fterm : term -> fmla 
  | Fand : fmla -> fmla -> fmla 
  | Fnot : fmla -> fmla 
  | Fimplies : fmla -> fmla -> fmla 
  | Flet : term -> fmla -> fmla 
  | Fforall : fmla -> fmla .

Inductive value  :=
  | Vint : Z -> value 
  | Vbool : bool -> value .

Inductive list (a:Type) :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.
Implicit Arguments Cons.

Inductive state  :=
  | mk_state : (list value) -> (list value) -> state .

Definition ref_env(u:state): (list value) :=
  match u with
  | (mk_state _ ref_env1) => ref_env1
  end.

Definition var_env(u:state): (list value) :=
  match u with
  | (mk_state var_env1 _) => var_env1
  end.

Definition eval_bin(x:value) (op:operator) (y:value) (res:value): Prop :=
  match (x,
  y) with
  | ((Vint x1), (Vint y1)) =>
      match op with
      | Oplus => (res = (Vint (x1 + y1)%Z))
      | Ominus => (res = (Vint (x1 - y1)%Z))
      | Omult => (res = (Vint (x1 * y1)%Z))
      end
  | (_, _) => False
  end.

Inductive option (a:Type) :=
  | None : option a
  | Some : a -> option a.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.
Implicit Arguments Some.

Parameter nth: forall (a:Type), Z -> (list a) -> (option a).

Implicit Arguments nth.

Axiom nth_def : forall (a:Type), forall (n:Z) (l:(list a)),
  match l with
  | Nil => ((nth n l) = (None:(option a)))
  | (Cons x r) => ((n = 0%Z) -> ((nth n l) = (Some x))) /\ ((~ (n = 0%Z)) ->
      ((nth n l) = (nth (n - 1%Z)%Z r)))
  end.

Definition get_env(i:Z) (env:(list value)) (res:value): Prop := match (nth i
  env) with
  | None => False
  | (Some v) => (v = res)
  end.

Inductive eval_term : state -> term -> value -> Prop :=
  | eval_const : forall (s:state) (n:Z), (eval_term s (Tconst n) (Vint n))
  | eval_var : forall (s:state) (i:Z) (res:value), (get_env i (var_env s)
      res) -> (eval_term s (Tvar i) res)
  | eval_deref : forall (s:state) (i:Z) (res:value), (get_env i (ref_env s)
      res) -> (eval_term s (Tderef i) res)
  | eval_bin1 : forall (s:state) (op:operator) (t1:term) (t2:term) (r1:value)
      (r2:value) (r:value), (eval_term s t1 r1) -> ((eval_term s t2 r2) ->
      ((eval_bin r1 op r2 r) -> (eval_term s (Tbin t1 op t2) r))).

(* YOU MAY EDIT THE CONTEXT BELOW *)

(* DO NOT EDIT BELOW *)

Theorem Test55 : (eval_term (mk_state (Cons (Vint 42%Z) (Nil:(list value)))
  (Nil:(list value))) (Tbin (Tvar 0%Z) Oplus (Tconst 13%Z)) (Vint 55%Z)).
(* YOU MAY EDIT THE PROOF BELOW *)
apply eval_bin1 with (r1:=Vint 42) (r2:=Vint 13).
constructor.
red; simpl.
generalize (nth_def _ 0 (Cons (Vint 42) Nil)).
SearchAbout nth.
unfold eval_bin; simpl.
unfold get_env; simpl.
generalize (nth_def _ 0 (Cons (Vint 42) Nil)).
intros (H,_).
rewrite H; auto.
Qed.
(* DO NOT EDIT BELOW *)


