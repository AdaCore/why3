(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Inductive operator  :=
  | Oplus : operator 
  | Ominus : operator 
  | Omult : operator .

Inductive term  :=
  | Tconst : Z -> term 
  | Tvar : Z -> term 
  | Tderef : Z -> term 
  | Tbin : term -> operator -> term -> term .

Inductive fmla  :=
  | Fterm : term -> fmla 
  | Fand : fmla -> fmla -> fmla 
  | Fnot : fmla -> fmla 
  | Fimplies : fmla -> fmla -> fmla 
  | Flet : term -> fmla -> fmla 
  | Fforall : fmla -> fmla .

Inductive value  :=
  | Verror : value 
  | Vint : Z -> value 
  | Vbool : bool -> value .

Inductive list (a:Type) :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.
Implicit Arguments Cons.

Inductive state  :=
  | mk_state : (list value) -> (list value) -> state .

Definition ref_env(u:state): (list value) :=
  match u with
  | (mk_state _ ref_env1) => ref_env1
  end.

Definition var_env(u:state): (list value) :=
  match u with
  | (mk_state var_env1 _) => var_env1
  end.

Definition eval_bin(x:value) (op:operator) (y:value): value := match (x,
  y) with
  | ((Vint x1), (Vint y1)) =>
      match op with
      | Oplus => (Vint (x1 + y1)%Z)
      | Ominus => (Vint (x1 - y1)%Z)
      | Omult => (Vint (x1 * y1)%Z)
      end
  | (_, _) => Verror
  end.

Inductive option (a:Type) :=
  | None : option a
  | Some : a -> option a.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.
Implicit Arguments Some.

Parameter nth: forall (a:Type), Z -> (list a) -> (option a).

Implicit Arguments nth.

Axiom nth_def : forall (a:Type), forall (n:Z) (l:(list a)),
  match l with
  | Nil => ((nth n l) = (None:(option a)))
  | (Cons x r) => ((n = 0%Z) -> ((nth n l) = (Some x))) /\ ((~ (n = 0%Z)) ->
      ((nth n l) = (nth (n - 1%Z)%Z r)))
  end.

Definition get_env(i:Z) (env:(list value)): value := match (nth i
  env) with
  | None => Verror
  | (Some v) => v
  end.

Set Implicit Arguments.
Fixpoint eval_term(s:state) (t:term) {struct t}: value :=
  match t with
  | (Tconst n) => (Vint n)
  | (Tvar i) => (get_env i (var_env s))
  | (Tderef i) => (get_env i (ref_env s))
  | (Tbin t1 op t2) => (eval_bin (eval_term s t1) op (eval_term s t2))
  end.
Unset Implicit Arguments.

(* YOU MAY EDIT THE CONTEXT BELOW *)

(* DO NOT EDIT BELOW *)

Theorem Test55 : ((eval_term (mk_state (Cons (Vint 42%Z) (Nil:(list value)))
  (Nil:(list value))) (Tbin (Tvar 0%Z) Oplus (Tconst 13%Z))) = (Vint 55%Z)).
(* YOU MAY EDIT THE PROOF BELOW *)
simpl.
unfold eval_bin; simpl.
unfold get_env; simpl.
generalize (nth_def _ 0 (Cons (Vint 42) Nil)).
intros (H,_).
rewrite H; auto.
Qed.
(* DO NOT EDIT BELOW *)


