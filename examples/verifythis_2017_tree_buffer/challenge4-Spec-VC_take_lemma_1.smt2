;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

;; CompatOrderMult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

(declare-sort list 1)

(declare-fun list1 (ty) ty)

(declare-fun Nil (ty) uni)

;; Nil_sort
  (assert (forall ((a ty)) (sort (list1 a) (Nil a))))

(declare-sort a 0)

(declare-fun a1 () ty)

(declare-fun Cons (ty uni uni) uni)

;; Cons_sort
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (x1 uni)) (sort (list1 a2) (Cons a2 x x1)))))

(declare-fun Cons1 (a (list a)) (list a))

(declare-fun match_list (ty ty uni uni uni) uni)

;; match_list_sort
  (assert
  (forall ((a2 ty) (a3 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort a3 (match_list a3 a2 x x1 x2)))))

;; match_list_Nil
  (assert
  (forall ((a2 ty) (a3 ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a3 z) (= (match_list a3 a2 (Nil a2) z z1) z)))))

(declare-fun t2tb ((list a)) uni)

;; t2tb_sort
  (assert (forall ((x (list a))) (sort (list1 a1) (t2tb x))))

(declare-fun tb2t (uni) (list a))

;; BridgeL
  (assert
  (forall ((i (list a))) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

;; match_list_Cons
  (assert
  (forall ((a2 ty))
  (forall ((z uni) (z1 uni) (u a) (u1 (list a)))
  (=> (sort a2 z1) (= (match_list a2 a1 (t2tb (Cons1 u u1)) z z1) z1)))))

;; match_list_Cons
  (assert
  (forall ((a2 ty) (a3 ty))
  (forall ((z uni) (z1 uni) (u uni) (u1 uni))
  (=> (sort a3 z1) (= (match_list a3 a2 (Cons a2 u u1) z z1) z1)))))

(declare-fun index_list (ty uni) Int)

;; index_list_Nil
  (assert (forall ((a2 ty)) (= (index_list a2 (Nil a2)) 0)))

;; index_list_Cons
  (assert
  (forall ((u a) (u1 (list a)))
  (! (= (index_list a1 (t2tb (Cons1 u u1))) 1) :pattern ((Cons1 u u1)) )))

;; index_list_Cons
  (assert
  (forall ((a2 ty))
  (forall ((u uni) (u1 uni))
  (! (= (index_list a2 (Cons a2 u u1)) 1) :pattern ((Cons a2 u u1)) ))))

(declare-fun Cons_proj_1 (ty uni) uni)

;; Cons_proj_1_sort
  (assert (forall ((a2 ty)) (forall ((x uni)) (sort a2 (Cons_proj_1 a2 x)))))

(declare-fun t2tb1 (a) uni)

;; t2tb_sort
  (assert (forall ((x a)) (sort a1 (t2tb1 x))))

(declare-fun tb2t1 (uni) a)

;; BridgeL
  (assert (forall ((i a)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort a1 j) (= (t2tb1 (tb2t1 j)) j)) :pattern ((t2tb1 (tb2t1 j))) )))

;; Cons_proj_1_def
  (assert
  (forall ((u a) (u1 (list a)))
  (= (tb2t1 (Cons_proj_1 a1 (t2tb (Cons1 u u1)))) u)))

;; Cons_proj_1_def
  (assert
  (forall ((a2 ty))
  (forall ((u uni) (u1 uni))
  (=> (sort a2 u) (= (Cons_proj_1 a2 (Cons a2 u u1)) u)))))

(declare-fun Cons_proj_2 (ty uni) uni)

;; Cons_proj_2_sort
  (assert
  (forall ((a2 ty)) (forall ((x uni)) (sort (list1 a2) (Cons_proj_2 a2 x)))))

;; Cons_proj_2_def
  (assert
  (forall ((u a) (u1 (list a)))
  (= (tb2t (Cons_proj_2 a1 (t2tb (Cons1 u u1)))) u1)))

;; Cons_proj_2_def
  (assert
  (forall ((a2 ty))
  (forall ((u uni) (u1 uni)) (= (Cons_proj_2 a2 (Cons a2 u u1)) u1))))

;; list_inversion
  (assert
  (forall ((u (list a)))
  (or (= u (tb2t (Nil a1)))
  (= u (Cons1 (tb2t1 (Cons_proj_1 a1 (t2tb u)))
       (tb2t (Cons_proj_2 a1 (t2tb u))))))))

;; list_inversion
  (assert
  (forall ((a2 ty))
  (forall ((u uni))
  (or (= u (Nil a2)) (= u (Cons a2 (Cons_proj_1 a2 u) (Cons_proj_2 a2 u)))))))

(declare-fun is_nil (ty uni) Bool)

;; is_nil_def
  (assert
  (and (is_nil a1 (Nil a1))
  (forall ((x a) (x1 (list a))) (not (is_nil a1 (t2tb (Cons1 x x1)))))))

;; is_nil_def
  (assert
  (forall ((a2 ty))
  (and (is_nil a2 (Nil a2))
  (forall ((x uni) (x1 uni)) (not (is_nil a2 (Cons a2 x x1)))))))

;; is_nil_spec
  (assert
  (forall ((a2 ty)) (forall ((l uni)) (= (is_nil a2 l) (= l (Nil a2))))))

(declare-sort buf 1)

(declare-fun buf1 (ty) ty)

(declare-fun mk_buf (ty Int uni) uni)

;; mk buf_sort
  (assert
  (forall ((a2 ty))
  (forall ((x Int) (x1 uni)) (sort (buf1 a2) (mk_buf a2 x x1)))))

(declare-fun h (ty uni) Int)

;; h_def
  (assert
  (forall ((a2 ty))
  (forall ((u Int) (u1 uni)) (= (h a2 (mk_buf a2 u u1)) u))))

(declare-fun xs (ty uni) uni)

;; xs_sort
  (assert (forall ((a2 ty)) (forall ((x uni)) (sort (list1 a2) (xs a2 x)))))

;; xs_def
  (assert
  (forall ((a2 ty))
  (forall ((u Int) (u1 uni)) (= (xs a2 (mk_buf a2 u u1)) u1))))

;; buf_inversion
  (assert
  (forall ((a2 ty)) (forall ((u uni)) (= u (mk_buf a2 (h a2 u) (xs a2 u))))))

(declare-fun take (ty Int uni) uni)

;; take_sort
  (assert
  (forall ((a2 ty))
  (forall ((x Int) (x1 uni)) (sort (list1 a2) (take a2 x x1)))))

(declare-fun take1 (Int (list a)) (list a))

;; take_def
  (assert
  (forall ((n Int))
  (and (= (take1 n (tb2t (Nil a1))) (tb2t (Nil a1)))
  (forall ((x a) (xs1 (list a)))
  (let ((l (Cons1 x xs1)))
  (ite (= n 0) (= (take1 n l) (tb2t (Nil a1)))
  (= (take1 n l) (Cons1 x (take1 (- n 1) xs1)))))))))

;; take_def
  (assert
  (forall ((a2 ty))
  (forall ((n Int))
  (and (= (take a2 n (Nil a2)) (Nil a2))
  (forall ((x uni) (xs1 uni))
  (let ((l (Cons a2 x xs1)))
  (ite (= n 0) (= (take a2 n l) (Nil a2))
  (= (take a2 n l) (Cons a2 x (take a2 (- n 1) xs1))))))))))

(declare-fun add (ty uni uni) uni)

;; add_sort
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (x1 uni)) (sort (buf1 a2) (add a2 x x1)))))

(declare-fun t2tb2 ((buf a)) uni)

;; t2tb_sort
  (assert (forall ((x (buf a))) (sort (buf1 a1) (t2tb2 x))))

(declare-fun tb2t2 (uni) (buf a))

;; BridgeL
  (assert
  (forall ((i (buf a))) (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb2 (tb2t2 j)) j) :pattern ((t2tb2 (tb2t2 j))) )))

;; add_def
  (assert
  (forall ((x a) (b (buf a)))
  (= (tb2t2 (add a1 (t2tb1 x) (t2tb2 b))) (tb2t2
                                          (mk_buf a1 (h a1 (t2tb2 b))
                                          (t2tb
                                          (Cons1 x (tb2t (xs a1 (t2tb2 b))))))))))

;; add_def
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (b uni))
  (= (add a2 x b) (mk_buf a2 (h a2 b) (Cons a2 x (xs a2 b)))))))

(declare-fun get (ty uni) uni)

;; get_sort
  (assert (forall ((a2 ty)) (forall ((x uni)) (sort (list1 a2) (get a2 x)))))

;; get_def
  (assert
  (forall ((b (buf a)))
  (= (tb2t (get a1 (t2tb2 b))) (take1 (h a1 (t2tb2 b))
                               (tb2t (xs a1 (t2tb2 b)))))))

;; get_def
  (assert
  (forall ((a2 ty))
  (forall ((b uni)) (= (get a2 b) (take a2 (h a2 b) (xs a2 b))))))

(declare-fun infix_plpl (ty uni uni) uni)

;; infix ++_sort
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (x1 uni)) (sort (list1 a2) (infix_plpl a2 x x1)))))

(declare-fun infix_plpl1 ((list a) (list a)) (list a))

;; infix ++_def
  (assert
  (forall ((l2 (list a)))
  (and (= (infix_plpl1 (tb2t (Nil a1)) l2) l2)
  (forall ((x1 a) (r1 (list a)))
  (= (infix_plpl1 (Cons1 x1 r1) l2) (Cons1 x1 (infix_plpl1 r1 l2)))))))

;; infix ++_def
  (assert
  (forall ((a2 ty))
  (forall ((l2 uni))
  (and (= (infix_plpl a2 (Nil a2) l2) l2)
  (forall ((x1 uni) (r1 uni))
  (= (infix_plpl a2 (Cons a2 x1 r1) l2) (Cons a2 x1 (infix_plpl a2 r1 l2))))))))

;; Append_assoc
  (assert
  (forall ((l1 (list a)) (l2 (list a)) (l3 (list a)))
  (= (infix_plpl1 l1 (infix_plpl1 l2 l3)) (infix_plpl1 (infix_plpl1 l1 l2)
                                          l3))))

;; Append_assoc
  (assert
  (forall ((a2 ty))
  (forall ((l1 uni) (l2 uni) (l3 uni))
  (= (infix_plpl a2 l1 (infix_plpl a2 l2 l3)) (infix_plpl a2
                                              (infix_plpl a2 l1 l2) l3)))))

;; Append_l_nil
  (assert (forall ((l (list a))) (= (infix_plpl1 l (tb2t (Nil a1))) l)))

;; Append_l_nil
  (assert
  (forall ((a2 ty)) (forall ((l uni)) (= (infix_plpl a2 l (Nil a2)) l))))

(declare-fun length (ty uni) Int)

(declare-fun length1 ((list a)) Int)

;; length_def
  (assert
  (and (= (length1 (tb2t (Nil a1))) 0)
  (forall ((x a) (x1 (list a)))
  (= (length1 (Cons1 x x1)) (+ 1 (length1 x1))))))

;; length_def
  (assert
  (forall ((a2 ty))
  (and (= (length a2 (Nil a2)) 0)
  (forall ((x uni) (x1 uni))
  (= (length a2 (Cons a2 x x1)) (+ 1 (length a2 x1)))))))

;; Length_nonnegative
  (assert (forall ((l (list a))) (<= 0 (length1 l))))

;; Length_nonnegative
  (assert (forall ((a2 ty)) (forall ((l uni)) (<= 0 (length a2 l)))))

;; Length_nil
  (assert
  (forall ((l (list a))) (= (= (length1 l) 0) (= l (tb2t (Nil a1))))))

;; Length_nil
  (assert
  (forall ((a2 ty))
  (forall ((l uni)) (= (= (length a2 l) 0) (= l (Nil a2))))))

;; Append_length
  (assert
  (forall ((l1 (list a)) (l2 (list a)))
  (= (length1 (infix_plpl1 l1 l2)) (+ (length1 l1) (length1 l2)))))

;; Append_length
  (assert
  (forall ((a2 ty))
  (forall ((l1 uni) (l2 uni))
  (= (length a2 (infix_plpl a2 l1 l2)) (+ (length a2 l1) (length a2 l2))))))

(declare-fun mem (ty uni uni) Bool)

;; mem_def
  (assert
  (forall ((x a))
  (and (not (mem a1 (t2tb1 x) (Nil a1)))
  (forall ((y a) (r (list a)))
  (= (mem a1 (t2tb1 x) (t2tb (Cons1 y r)))
  (or (= x y) (mem a1 (t2tb1 x) (t2tb r))))))))

;; mem_def
  (assert
  (forall ((a2 ty))
  (forall ((x uni))
  (=> (sort a2 x)
  (and (not (mem a2 x (Nil a2)))
  (forall ((y uni) (r uni))
  (=> (sort a2 y) (= (mem a2 x (Cons a2 y r)) (or (= x y) (mem a2 x r))))))))))

;; mem_append
  (assert
  (forall ((x a) (l1 (list a)) (l2 (list a)))
  (= (mem a1 (t2tb1 x) (t2tb (infix_plpl1 l1 l2)))
  (or (mem a1 (t2tb1 x) (t2tb l1)) (mem a1 (t2tb1 x) (t2tb l2))))))

;; mem_append
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (l1 uni) (l2 uni))
  (= (mem a2 x (infix_plpl a2 l1 l2)) (or (mem a2 x l1) (mem a2 x l2))))))

;; mem_decomp
  (assert
  (forall ((x a) (l (list a)))
  (=> (mem a1 (t2tb1 x) (t2tb l))
  (exists ((l1 (list a)) (l2 (list a))) (= l (infix_plpl1 l1 (Cons1 x l2)))))))

;; mem_decomp
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (l uni))
  (=> (mem a2 x l)
  (exists ((l1 uni) (l2 uni))
  (and (sort (list1 a2) l1)
  (and (sort (list1 a2) l2) (= l (infix_plpl a2 l1 (Cons a2 x l2))))))))))

(assert
;; VC_take_lemma
 ;; File "challenge4/../challenge4.mlw", line 31, characters 16-26
  (not
  (forall ((l1 (list a)) (l2 (list a)) (l3 (list a)) (n Int))
  (=> (and (<= 0 n) (<= n (length1 l1)))
  (=> (exists ((x a) (x1 (list a))) (and (= l1 (Cons1 x x1)) (not (< 0 n))))
  (= (take1 n (infix_plpl1 l1 l2)) (take1 n (infix_plpl1 l1 l3))))))))
(check-sat)
