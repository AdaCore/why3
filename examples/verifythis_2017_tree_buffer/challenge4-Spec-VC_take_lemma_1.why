(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(* this is a prelude for Alt-Ergo integer arithmetic *)
logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

type 'a list

logic Nil : 'a list

logic Cons : 'a, 'a list -> 'a list

logic match_list : 'a list, 'a1, 'a1 -> 'a1

axiom match_list_Nil :
  (forall z:'a. forall z1:'a. (match_list((Nil : 'a1 list), z, z1) = z))

axiom match_list_Cons :
  (forall z:'a. forall z1:'a. forall u:'a1. forall u1:'a1 list.
  (match_list(Cons(u, u1), z, z1) = z1))

logic index_list : 'a list -> int

axiom index_list_Nil : (index_list((Nil : 'a list)) = 0)

axiom index_list_Cons :
  (forall u:'a. forall u1:'a list [Cons(u, u1)]. (index_list(Cons(u,
  u1)) = 1))

logic Cons_proj_1 : 'a list -> 'a

axiom Cons_proj_1_def :
  (forall u:'a. forall u1:'a list. (Cons_proj_1(Cons(u, u1)) = u))

logic Cons_proj_2 : 'a list -> 'a list

axiom Cons_proj_2_def :
  (forall u:'a. forall u1:'a list. (Cons_proj_2(Cons(u, u1)) = u1))

axiom list_inversion :
  (forall u:'a list. ((u = (Nil : 'a list)) or (u = Cons(Cons_proj_1(u),
  Cons_proj_2(u)))))

predicate is_nil(l: 'a list) =
  (forall x:'a. forall x1:'a list. (not (l = Cons(x, x1))))

axiom is_nil_spec : (forall l:'a list. (is_nil(l) -> (l = (Nil : 'a list))))

axiom is_nil_spec1 : (forall l:'a list. ((l = (Nil : 'a list)) -> is_nil(l)))

type 'a buf = { h : int; xs : 'a list
}

logic take : int, 'a list -> 'a list

axiom take_def : (forall n:int. (take(n, (Nil : 'a list)) = (Nil : 'a list)))

axiom take_def1 :
  (forall n:int.
  (forall x:'a. forall xs1:'a list. ((n = 0) -> (take(n, Cons(x,
  xs1)) = (Nil : 'a list)))))

axiom take_def2 :
  (forall n:int.
  (forall x:'a. forall xs1:'a list. ((not (n = 0)) -> (take(n, Cons(x,
  xs1)) = Cons(x, take((n - 1), xs1))))))

function add(x: 'a, b: 'a buf) : 'a buf = { h = (b).h; xs = Cons(x, (b).xs) }

function get(b: 'a buf) : 'a list = take((b).h, (b).xs)

logic infix_plpl : 'a list, 'a list -> 'a list

axiom infix_plpl_def :
  (forall l2:'a list. (infix_plpl((Nil : 'a list), l2) = l2))

axiom infix_plpl_def1 :
  (forall l2:'a list.
  (forall x1:'a. forall r1:'a list. (infix_plpl(Cons(x1, r1), l2) = Cons(x1,
  infix_plpl(r1, l2)))))

axiom Append_assoc :
  (forall l1:'a list. forall l2:'a list. forall l3:'a list. (infix_plpl(l1,
  infix_plpl(l2, l3)) = infix_plpl(infix_plpl(l1, l2), l3)))

axiom Append_l_nil : (forall l:'a list. (infix_plpl(l, (Nil : 'a list)) = l))

logic length : 'a list -> int

axiom length_def : (length((Nil : 'a list)) = 0)

axiom length_def1 :
  (forall x:'a. forall x1:'a list. (length(Cons(x, x1)) = (1 + length(x1))))

axiom Length_nonnegative : (forall l:'a list. (0 <= length(l)))

axiom Length_nil :
  (forall l:'a list. ((length(l) = 0) -> (l = (Nil : 'a list))))

axiom Length_nil1 :
  (forall l:'a list. ((l = (Nil : 'a list)) -> (length(l) = 0)))

axiom Append_length :
  (forall l1:'a list. forall l2:'a list. (length(infix_plpl(l1,
  l2)) = (length(l1) + length(l2))))

logic mem : 'a, 'a list -> prop

axiom mem_def : (forall x:'a. (not mem(x, (Nil : 'a list))))

axiom mem_def1 :
  (forall x:'a.
  (forall y:'a. forall r:'a list. (mem(x, Cons(y, r)) -> ((x = y) or mem(x,
  r)))))

axiom mem_def2 :
  (forall x:'a.
  (forall y:'a. forall r:'a list. (((x = y) or mem(x, r)) -> mem(x, Cons(y,
  r)))))

axiom mem_append :
  (forall x:'a. forall l1:'a list. forall l2:'a list. (mem(x, infix_plpl(l1,
  l2)) -> (mem(x, l1) or mem(x, l2))))

axiom mem_append1 :
  (forall x:'a. forall l1:'a list. forall l2:'a list. ((mem(x, l1) or mem(x,
  l2)) -> mem(x, infix_plpl(l1, l2))))

axiom mem_decomp :
  (forall x:'a. forall l:'a list. (mem(x, l) ->
  (exists l1:'a list. exists l2:'a list. (l = infix_plpl(l1, Cons(x, l2))))))

goal VC_take_lemma :
  (forall l1:'a list. forall l2:'a list. forall l3:'a list. forall n:int.
  (((0 <= n) and (n <= length(l1))) ->
  ((exists x:'a. exists x1:'a list. ((l1 = Cons(x, x1)) and (not (0 <  n)))) ->
  (take(n, infix_plpl(l1, l2)) = take(n, infix_plpl(l1, l3))))))
