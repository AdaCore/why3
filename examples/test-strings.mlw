
module Harness

  use newstring.String
  use int.Int

  goal Empty: "" = ""

  goal Empty2: empty = ""

  goal Test1:
    let s = "abcdef" in substring s 2 3 = "cde"

  goal TestConcat2:
    let s1 = "abc" in
    let s2 = "defg" in
    concat2 s1 s2 = "abcdefg"

  goal TestConcat3:
    let s1 = "abc" in
    let s2 = "defg" in
    let s3 = "hij" in
    concat3 s1 s2 s3 = "abcdefghij"

  goal TestConcat4:
    let s1 = "abc" in
    let s2 = "defg" in
    let s3 = "hij" in
    let s4 = "klmnop" in
    concat4 s1 s2 s3 s4 = "abcdefghijklmnop"

  goal TestConcat5:
    let s1 = "abc" in
    let s2 = "defg" in
    let s3 = "hij" in
    let s4 = "klmnop" in
    let s5 = "qrst" in
    concat5 s1 s2 s3 s4 s5 = "abcdefghijklmnopqrst"

  goal TestConcat6:
    concat2 "" "" = ""

  lemma concat2_assoc: forall s1 s2 s3.
    concat2 (concat2 s1 s2) s3 = concat2 s1 (concat2 s2 s3)

  lemma concat3_concat2: forall s1 s2 s3.
    concat3 s1 s2 s3 = concat2 s1 (concat2 s2 s3)

  lemma concat4_concat2: forall s1 s2 s3 s4.
    concat4 s1 s2 s3 s4 = concat2 s1 (concat2 s2 (concat2 s3 s4))

  lemma concat5_concat2: forall s1 s2 s3 s4 s5.
    concat5 s1 s2 s3 s4 s5 = concat2 s1 (concat2 s2 (concat2 s3 (concat2 s4 s5)))

  lemma concat_empty: forall s.
    concat2 s empty = concat2 empty s = s

  goal TestLength1: length "a" = 1
  goal TestLength2: length "ab" = 2
  goal TestLength3: length "abc" = 3
  goal TestLength4: length (concat2 "ab" "12") = 4

  lemma length_empty: length "" = 0

  lemma length_concat: forall s1 s2.
    length (concat2 s1 s2) = length s1 + length s2

  goal TestLt1: lt "" "a"
  goal TestLt2: lt "a" "b"
  goal TestLt3: lt "ab" "b"
  goal TestLt4: lt "abcde" "b"
  goal TestLt5: lt "a" "1"
  goal TestLt6: lt "A" "a"

  lemma lt_empty: forall s.
    s <> empty -> lt empty s

  lemma lt_transitive: forall s1 s2 s3. (* CHECK - not proved *)
    lt s1 s2 && lt s2 s3 -> lt s1 s3

  lemma lt_not_com: forall s1 s2.
    lt s1 s2 -> not (lt s2 s1)

  lemma le: forall s1.
    le s1 s1

  lemma lt_le: forall s1 s2.
    lt s1 s2 -> le s1 s2

  lemma lt_le_eq: forall s1 s2.
    le s1 s2 -> lt s1 s2 || s1 = s2

  lemma le_transitive: forall s1 s2 s3. (* CHECK - not proved *)
    le s1 s2 && le s2 s3 -> le s1 s3

  lemma at_out_of_range: forall s i.
    i >= length s || i < 0 -> s[i] = empty

  lemma at_empty: forall i.
    empty[i] = empty

  goal TestSubstring1: forall i x.
    substring "" i x = ""

  goal TestSubstring2: forall s i x.
    i < 0 -> substring s i x = ""

  goal TestSubstring3: forall s i x.
    i > length s -> substring s i x = ""

  goal TestSubstring4:
    substring "abcdef" 1 3 = "bcd"

  goal TestSubstring5:
    substring "abcdef" 1 10 = "bcdef"

  lemma substring_of_length_zero: forall s i.
    substring s i 0 = ""

  lemma substring_out_of_range: forall s i x.
    i < 0 || i >= length s -> substring s i x = empty

  lemma substring_smaller: forall s i x.
    length (substring s i x) <= length s

  lemma substring_smaller_x: forall s i x.
    i + x >= length s -> length (substring s i x) < x

  (* continue here *)




  goal TestIndefof1:
    indexof "" "" 0 = 0

  goal TestIndefof2:
    indexof "a" "" 0 = 0

  goal TestIndefof3:
    indexof "" "a" 0 = -1

  goal TestIndefof4: (* CHECK THIS *)
    indexof "a" "" 1 = 1

  goal TestIndefof5:
    indexof "a" "" 2 = -1

  goal TestIndefof6: (* CHECK THIS *)
    indexof "ab" "" 2 = 2

  goal TestIndefof7:
    indexof "abcdef" "c" 0 = 2

  goal TestIndefof8:
    indexof "abcdef" "c" 2 = 2

  goal TestIndefof9:
    indexof "abcdef" "c" 3 = -1

  goal TestIndefof10:
    indexof "abcdef" "cdef" 0 = 2

  goal TestIndexof11: forall s1.
    indexof s1 "" 0 = 0

  goal TestIndexof12: forall s2.
    s2 <> "" -> indexof "" s2 0 = -1

  goal TestIndexof13: (* check this *)
    indexof "abc" "c" (-1) = -1

  goal TestIndefof14:
    indexof "abcdefgh" "" 4 = 4

  goal TestIndefof15:
    indexof "ab" "" 4 = -1

  goal TestReplace1: forall s2 s3.
   s2 <> "" -> replace "" s2 s3 = ""

  goal TestReplace2: forall s1 s3. (* check standard to see if this makes sense *)
   replace s1 "" s3 = concat2 s3 s1

  goal TestReplace3:
   replace "abcde" "bc" "1234" = "a1234de"

  goal TestReplace4:
   replace "abcdefg" "fg" "" = "abcde"

  goal TestReplace5:
   replace "abcdefabcdef" "bc" "123" = "a123defabcdef"

  goal TestReplaceAll1: forall s1 s3. (* it has not the same behavior as replace *)
    s1 <> "" -> replaceall s1 "" s3 = concat2 s3 s1

  goal TestReplaceAll2:
    replaceall "abcdefabcdefabcdef" "de" "1234" = "abc1234fabc1234fabc1234f"



  lemma replace_substring_indexof: forall s t1 t2.
    let i = indexof s t1 0 in
    replace s t1 t2 =
      if i < 0 then s else
        concat3 (substring s 0 i)
                t2
                (substring s (i + length t1) (length s - i - length t1))

  lemma substring_indexof: forall s t i.
    let j = indexof s t i in
    j >= 0 && 0 <= i <= length s ->
      substring s j (length t) = t

  lemma y: forall s i.
    0 <= i <= length s -> indexof s "" i = i

  lemma z: forall i s t.
    not (0 <= i <= length s) -> indexof s t i = -1

  lemma w: forall i s t.
    0 <= i <= length s ->
      indexof s t i = -1 || i <= indexof s t i <= length s

  (* goal ConcatAssoc: forall s1 s2 s3. *)
  (*   concat2 s1 (concat2 s2 s3) = concat2 (concat2 s1 s2) s3 *)

end
