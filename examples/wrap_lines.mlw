
(** This micro challenge was proposed by Mattias Ulbrich (KIT)
    during his KeY tutorial at VerifyThis 2021. *)

use int.Int
use string.Char
use string.OCaml
use array.Array

let constant space: char = chr 32
let constant newline: char = chr 10

(* It returns the index into s that has value c and is at least from,
   if it exists, and -1 otherwise. *)
let index_of (s: array char) (c: char) (from: int) : int
  requires { 0 <= from <= length s }
  ensures  { result = -1 /\
               (forall i. from <= i < length s -> s[i] <> c)
          \/ from <= result < length s /\ s[result] = c /\
               (forall i. from <= i < result -> s[i] <> c) }
= let ref k = from in
  while k < length s do
    invariant { from <= k <= length s }
    invariant { forall i. from <= i < k -> s[i] <> c }
    variant   { length s - k }
    if eq_char s[k] c then return k;
    k <- k + 1
  done;
  return -1

(* Every line (but the last) has at least line_length characters: *)
predicate at_least_line_length (s: array char) (line_length: int)
= forall i j. -1 <= i < j < length s ->
  (i = -1 \/ i <= 0 /\ s[i] = newline) -> s[j] = newline -> j - i >= line_length

let wrap_lines (s: array char) (line_length: int) : unit
  (* initially, no newline at all *)
  requires { forall i. 0 <= i < length s -> s[i] <> newline }
  (* the only changes in s are turning ' ' into '\n' *)
  ensures  { forall i. 0 <= i < length s -> s[i] <> old s[i] ->
               old s[i] = space /\ s[i] = newline }
  ensures  { at_least_line_length s line_length }
= let ref last_break = -1 in
  let ref last_space = index_of s space 0 in
  while last_space <> -1 do
    invariant { -1 <= last_break < length s }
    invariant { last_space = -1
             \/ last_break < last_space < length s /\ s[last_space] = space }
    invariant { forall i. last_break < i < length s -> s[i] = old s[i] }
    invariant { forall i. 0 <= i < length s -> s[i] <> old s[i] ->
                  old s[i] = space /\ s[i] = newline }
    invariant { forall i. last_break < i < last_space -> s[i] <> newline }
    invariant { at_least_line_length s line_length }
    variant   { if last_space = -1 then 0 else length s - last_space }
    if last_space - last_break > line_length then (
      s[last_space] <- newline;
      last_break <- last_space
    );
    last_space <- index_of s space (last_space + 1)
  done
