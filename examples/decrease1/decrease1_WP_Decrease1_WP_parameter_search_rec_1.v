(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require map.Map.

(* Why3 assumption *)
Definition unit  := unit.

(* Why3 assumption *)
Inductive ref (a:Type) {a_WT:WhyType a} :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Implicit Arguments mk_ref [[a] [a_WT]].

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a}(v:(ref a)): a :=
  match v with
  | (mk_ref x) => x
  end.

(* Why3 assumption *)
Inductive array (a:Type) {a_WT:WhyType a} :=
  | mk_array : Z -> (map.Map.map Z a) -> array a.
Axiom array_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.
Implicit Arguments mk_array [[a] [a_WT]].

(* Why3 assumption *)
Definition elts {a:Type} {a_WT:WhyType a}(v:(array a)): (map.Map.map Z a) :=
  match v with
  | (mk_array x x1) => x1
  end.

(* Why3 assumption *)
Definition length {a:Type} {a_WT:WhyType a}(v:(array a)): Z :=
  match v with
  | (mk_array x x1) => x
  end.

(* Why3 assumption *)
Definition get {a:Type} {a_WT:WhyType a}(a1:(array a)) (i:Z): a :=
  (map.Map.get (elts a1) i).

(* Why3 assumption *)
Definition set {a:Type} {a_WT:WhyType a}(a1:(array a)) (i:Z) (v:a): (array
  a) := (mk_array (length a1) (map.Map.set (elts a1) i v)).

(* Why3 assumption *)
Definition make {a:Type} {a_WT:WhyType a}(n:Z) (v:a): (array a) :=
  (mk_array n (map.Map.const v:(map.Map.map Z a))).

(* Why3 assumption *)
Definition decrease1(a:(array Z)): Prop := forall (i:Z), ((0%Z <= i)%Z /\
  (i < ((length a) - 1%Z)%Z)%Z) -> (((get a i) - 1%Z)%Z <= (get a
  (i + 1%Z)%Z))%Z.

Axiom decrease1_induction : forall (a:(array Z)), (decrease1 a) ->
  forall (i:Z) (j:Z), (((0%Z <= i)%Z /\ (i <= j)%Z) /\ (j < (length a))%Z) ->
  ((((get a i) + i)%Z - j)%Z <= (get a j))%Z.


(* Why3 goal *)
Theorem WP_parameter_search_rec : forall (a:Z) (i:Z), forall (a1:(map.Map.map
  Z Z)), let a2 := (mk_array a a1) in (((decrease1 a2) /\ (0%Z <= i)%Z) ->
  ((i < a)%Z -> (((0%Z <= i)%Z /\ (i < a)%Z) -> ((~ ((map.Map.get a1
  i) = 0%Z)) -> (((0%Z <= i)%Z /\ (i < a)%Z) -> ((0%Z < (map.Map.get a1
  i))%Z -> (((0%Z <= i)%Z /\ (i < a)%Z) -> let o := (map.Map.get a1 i) in
  (((decrease1 a2) /\ (0%Z <= (i + o)%Z)%Z) -> forall (result:Z),
  (((result = (-1%Z)%Z) /\ forall (j:Z), (((i + o)%Z <= j)%Z /\ (j < a)%Z) ->
  ~ ((map.Map.get a1 j) = 0%Z)) \/ ((((i + o)%Z <= result)%Z /\
  (result < a)%Z) /\ (((map.Map.get a1 result) = 0%Z) /\ forall (j:Z),
  (((i + o)%Z <= j)%Z /\ (j < result)%Z) -> ~ ((map.Map.get a1
  j) = 0%Z)))) -> (((result = (-1%Z)%Z) /\ forall (j:Z), ((i <= j)%Z /\
  (j < a)%Z) -> ~ ((map.Map.get a1 j) = 0%Z)) \/ (((i <= result)%Z /\
  (result < a)%Z) /\ (((map.Map.get a1 result) = 0%Z) /\ forall (j:Z),
  ((i <= j)%Z /\ (j < result)%Z) -> ~ ((map.Map.get a1 j) = 0%Z)))))))))))).
Proof.
intuition.
intuition.
left; intuition.
destruct (Z_lt_le_dec j (i + Map.get a1 i)) as [case|case].
generalize (decrease1_induction (mk_array a a1) H5 i j); unfold get; simpl; intuition.
apply H14 with j; auto.
right; intuition.
destruct (Z_lt_le_dec j (i + Map.get a1 i)) as [case|case].
generalize (decrease1_induction (mk_array a a1) H5 i j); unfold get; simpl; intuition.
apply H16 with j; auto.
Qed.


