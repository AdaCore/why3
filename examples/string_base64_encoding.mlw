module Spec
  use mach.int.Int
  use mach.int.Int63
  use string.OCaml

  function next_m3 (i: int) : int
  = if mod i 3 = 0 then i else if mod i 3 = 1 then i + 2 else i + 1

  function next_m4 (i: int) : int
  = if mod i 4 = 0 then i else if mod i 4 = 1 then i + 3 else if mod i 4 = 2 then i + 2 else i + 1

  val next_m4 (i: int63): int63
    ensures { result = next_m4 i }

  function int2b64 (i: int) : char =
    if 0 <= i <= 25 then chr (i + 65) else
    if 26 <= i <= 51 then chr (i - 26 + 97) else
    if 52 <= i <= 61 then chr (i - 52 + 48) else
    if i = 62 then chr 43 else if i = 63 then chr 47
    else chr 0

  let int2b64 (i: int63) : char
    requires { 0 <= i < 64 }
    ensures  { result = int2b64 i }
  =
    if 0 <= i <= 25 then chr (i + 65) else
    if 26 <= i <= 51 then chr (i - 26 + 97) else
    if 52 <= i <= 61 then chr (i - 52 + 48) else
    if i = 62 then chr 43 else if i = 63 then chr 47
    else (assert { false }; chr 64)

  lemma concat_first: forall s1 s2.
    let s3 = concat s1 s2 in
    forall i. 0 <= i < length s1 ->
      get s3 i = get s1 i

  lemma concat_second: forall s1 s2.
    let s3 = concat s1 s2 in
    forall i. length s1 <= i < length s1 + length s2 ->
      get s3 i = get s2 (i - length s1)

  let function char_eq : char = chr 61

  (* **** *)

  predicate valid_64_char (c: char) =
    65 <= code c <= 90 || 97 <= code c <= 122 || 48 <= code c <= 57 ||
    code c = 43 || code c = 47

  lemma int2b64_valid_4_char: forall i. 0 <= i < 64 -> valid_64_char (int2b64 i)

  function b642int (c: char) : int =
    if 65 <= code c <= 90  then code c - 65      else (* 0  - 25 *)
    if 97 <= code c <= 122 then code c - 97 + 26 else (* 26 - 51 *)
    if 48 <= code c <= 57  then code c - 48 + 52 else (* 52 - 61 *)
    if code c = 43         then 62               else (* 62 *)
    if code c = 47         then 63               else (* 63 *)
    if c = char_eq         then 0                else (* 0 *)
    64                                                (* 64 *)

  let b642int (c: char) : int63
    requires { valid_64_char c || c = char_eq }
    ensures  { result = b642int c }
  = if 65 <= code c <= 90  then code c - 65      else
    if 97 <= code c <= 122 then code c - 97 + 26 else
    if 48 <= code c <= 57  then code c - 48 + 52 else
    if code c = 43         then 62               else
    if code c = 47         then 63               else
    if eq_char c char_eq   then 0                else
    (assert { false }; 64 )

  lemma b642int_int2b64: forall i. 0 <= i < 64 -> b642int (int2b64 i) = i

  function get_pad (s: string): int =
    if length s >= 1 && s[length s - 1] = char_eq then
        (if length s >= 2 && s[length s - 2] = char_eq then 2 else 1)
    else 0

  let get_pad (s: string): int63
    ensures { result = get_pad s }
  = if length s >= 1 && eq_char s[length s - 1] char_eq then
        (if length s >= 2 && eq_char s[length s - 2] char_eq then 2 else 1)
    else 0

  function calc_pad (s: string): int =
    if mod (length s) 3 = 1 then 2 else
      if mod (length s) 3 = 2 then 1 else 0

  let calc_pad (s: string): int63
    ensures { result = calc_pad s }
  = if length s % 3 = 1 then 2 else
      if length s % 3 = 2 then 1 else 0
end

module Base64
  use mach.int.Int
  use mach.int.Int63
  use string.OCaml
  use Spec

  let function encode (s: string) : string
    ensures { length result = div (next_m3 (length s) * 4) 3 }
    ensures { mod (length result) 4 = 0 }
    ensures { forall i. 0 <= i < div (length result) 4 ->
      let a1, a2, a3 = s[i*3], s[i*3+1], s[i*3+2] in
      result[i*4] = int2b64 (div (code a1)  4) /\
      if i * 3 + 1 < length s then
        ( result[i*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) &&
          ( if i * 3 + 2 < length s then
              result[i*4+2] = int2b64 (mod (code a2) 16 * 4 + div (code a3) 64) &&
              result[i*4+3] = int2b64 (mod (code a3) 64)
            else (result[i*4+2] = int2b64 (mod (code a2) 16 * 4) && result[i*4+3] = char_eq)
          )
        )
      else
        ( result[i*4+1] = int2b64 (mod (code a1) 4 * 16)
          && result[i*4+2] = char_eq && result[i*4+3] = char_eq)
    }
    ensures { get_pad result = calc_pad s }
  = let padding = calc_pad s in
    let sp = concat s (make padding (chr 0)) in
    let ref i = 0 in
    let ref r = "" in
    let ghost ref b = 0 : int in
    while i < length sp do
      variant {length sp - i}
      invariant { i = b * 3 }
      invariant { length r = b * 4 }
      invariant { 0 <= i <= length sp }
      invariant { forall j. 0 <= j < b ->
        let a1, a2, a3 = sp[j*3], sp[j*3+1], sp[j*3+2] in
        r[j*4]   = int2b64 (div (code a1)  4) &&
        r[j*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) &&
        r[j*4+2] = int2b64 (mod (code a2) 16 * 4 + div (code a3) 64) &&
        r[j*4+3] = int2b64 (mod (code a3) 64)
      }
      let c1,c2,c3 = sp[i], sp[i+1], sp[i+2] in
      let b1 = code c1 / 4 in
      let b2 = (code c1 % 4) * 16 + code c2 / 16 in
      let b3 = (code c2 % 16) * 4 + code c3 / 64 in
      let b4 = code c3 % 64 in
      label L in
      r <- concat r (int2b64 b1).content;
      r <- concat r (int2b64 b2).content;
      r <- concat r (int2b64 b3).content;
      r <- concat r (int2b64 b4).content;
      i <- i + 3;
      ghost (b <- b + 1);
      assert { r[length r - 4] = int2b64 (div (code c1) 4)  &&
               r[length r - 3] = int2b64 (mod (code c1) 4 * 16 + div (code c2) 16) &&
               r[length r - 2] = int2b64 (mod (code c2) 16 * 4 + div (code c3) 64) &&
               r[length r - 1] = int2b64 (mod (code c3) 64) };
      assert { forall j. 0 <= j < length r - 4 -> r[j] = (r at L)[j] };
    done;
    concat (sub r 0 (length r - padding)) (make padding char_eq)

  let function decode (s: string) : string
    requires { mod (length s) 4 = 0 }
    requires { forall i. 0 <= i < length s - get_pad s -> valid_64_char s[i] }
    requires { forall i. length s - get_pad s <= i < length s -> s[i] = char_eq }
    ensures  { length result = div (length s * 3) 4 - get_pad s}
    ensures  { forall i. 0 <= i < div (next_m3 (length result)) 3 ->
      let b1,b2,b3,b4 = s[4*i], s[4*i+1],s[4*i+2], s[4*i+3] in
      result[i*3] = chr (b642int b1 * 4 + div (b642int b2) 16) &&
      (i * 3 + 1 < length result ->
        result[i*3+1] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4)) &&
      (i * 3 + 2 < length result ->
        result[i*3+2] = chr (mod (b642int b3) 4 * 64 + b642int b4))
    }
  = let ref i = 0 in
    let ref r = "" in
    let ghost ref b = 0:int in
    while i < length s do
      variant { length s - i }
      invariant { 0 <= i <= length s }
      invariant { i = b * 4 }
      invariant { length r = b * 3 }
      invariant { forall j. 0 <= j < b ->
        let b1,b2,b3,b4 = s[4*j], s[4*j+1], s[4*j+2], s[4*j+3] in
        r[j*3]   = chr (b642int b1 * 4 + div (b642int b2) 16) &&
        r[j*3+1] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4) &&
        r[j*3+2] = chr (mod (b642int b3) 4 * 64 + b642int b4)
      }
      label L in
      let b1,b2,b3,b4 = s[i], s[i+1], s[i+2], s[i+3] in
      let a1 = b642int b1 * 4 + b642int b2 / 16 in
      let a2 = b642int b2 % 16 * 16 + b642int b3 / 4 in
      let a3 = b642int b3 % 4 * 64 + b642int b4 in
      r <- concat r (chr a1).content;
      r <- concat r (chr a2).content;
      r <- concat r (chr a3).content;
      i <- i + 4;
      ghost (b <- b + 1);
      assert { r[length r - 3] = chr (b642int b1 * 4 + div (b642int b2) 16) &&
               r[length r - 2] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4) &&
               r[length r - 1] = chr (mod (b642int b3) 4 * 64 + b642int b4) };
      assert { forall j. 0 <= j < length r - 3 -> r[j] =  (r at L)[j]}
    done;
    sub r 0 (length r - get_pad s)

  let lemma decode_encode (s: string) : unit
    ensures { decode (encode s) = s }
  = let s1 = encode s in

    assert { length s = div (length s1) 4 * 3 - get_pad s1};

    assert { forall i. 0 <= i < div (length s) 3 ->
      (valid_64_char s1[i*4] && valid_64_char s1[i*4+1] &&
      valid_64_char s1[i*4+2] && valid_64_char s1[i*4+3])
    };

    assert { mod (length s) 3 <> 0 ->
      let last = div (length s) 3 in
      valid_64_char s1[last*4] && valid_64_char s1[last*4+1] &&
      if last * 3 + 1 = length s then
        s1[last*4+2] = char_eq && s1[last*4+3] = char_eq
      else valid_64_char s1[last*4+2] && s1[last*4+3] = char_eq
    };

    assert { forall i.
      (0 <= i < length s1 - get_pad s1 -> valid_64_char s1[i]) &&
      (length s1 - get_pad s1 <= i < length s1 -> s1[i] = char_eq) };

    let s2 = decode s1 in

    assert { length s2 = length s by length s = div (length s1 * 3) 4 - get_pad s1 };

    assert { forall i. 0 <= i < div (next_m3 (length s)) 3 ->
      s[i*3] = s2[i*3] &&
      (i * 3 + 1 < length s -> s[i*3+1] = s2[i*3+1]) &&
      (i * 3 + 2 < length s -> s[i*3+2] = s2[i*3+2]) };

    assert { forall i. 0 <= i < length s -> s[i] = s2[i] };
    assert { eq_string s s2 }

  (* let test1 = let s = "" in let r = encode s in assert {r = s}
  let test2 = let s = "a" in let r = encode s in assert {decode r = s}
  let test3 = let s = "h" in let r = encode s in assert {decode r = s}
  let test4 = let s = "abc" in let r = encode s in assert {decode r = s}
  let test5 = let s = "1s1" in let r = encode s in assert {decode r = s}
  let test6 = let s = "141fh" in let r = encode s in assert {decode r = s}
  let test7 = let s = "\123as" in let r = encode s in assert {decode r = s}
  let test8 = let s = "" in decode s
  (* let test9 = let s = (chr 65).content in decode s *)
  let test10 =
    let a,b,c,d = chr 65, chr 66, chr 67, chr 68 in
    let s = concat a.content (concat b.content (concat c.content d.content)) in decode s
  let test11 =
    let a,b,c,d = chr 65, chr 66, chr 67, char_eq in
    let s = concat a.content (concat b.content (concat c.content d.content)) in decode s
  let test12 =
    let a,b,c,d = chr 65, chr 66, char_eq, char_eq in
    let s = concat a.content (concat b.content (concat c.content d.content)) in decode s
  *)
  (* let test13 =
    let a,b,c,d = chr 65, chr 66, char_eq, chr 68 in
    let s = concat a.content (concat b.content (concat c.content d.content)) in decode s*)

end

(* module Base64NoPadding *)
(*   use mach.int.Int *)
(*   use mach.int.Int63 *)
(*   use string.OCaml *)
(*   use Spec *)

(*   let function encode (s: string) : string *)
(*     ensures { length result = div (next_m3 (length s) * 4) 3 - calc_pad s } *)
(*     ensures { forall i. 0 <= i < div (length s) 3 -> *)
(*       let a1, a2, a3 = s[i*3], s[i*3+1], s[i*3+2] in *)
(*       result[i*4]   = int2b64 (div (code a1)  4) && *)
(*       result[i*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) && *)
(*       result[i*4+2] = int2b64 (mod (code a2) 16 * 4 + div (code a3) 64) && *)
(*       result[i*4+3] = int2b64 (mod (code a3) 64) *)
(*     } *)
(*     ensures { mod (length s) 3 <> 0 -> *)
(*       let i = div (length s) 3 in *)
(*       let a1 = s[i*3] in *)
(*       result[i*4] = int2b64 (div (code a1)  4) && *)
(*       if i * 3 + 1 = length s then result[i*4+1] = int2b64 (mod (code a1) 4 * 16) *)
(*       else *)
(*         let a2 = s[i*3+1] in *)
(*         result[i*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) && *)
(*         result[i*4+2] = int2b64 (mod (code a2) 16 * 4) *)
(*     } *)
(*   = let padding = calc_pad s in *)
(*     let sp = concat s (make padding (chr 0)) in *)
(*     let ref i = 0 in *)
(*     let ref r = "" in *)
(*     while i < length sp do *)
(*       variant {length sp - i} *)
(*       invariant { mod i 3 = 0 } *)
(*       invariant { mod (length r) 4 = 0 } *)
(*       invariant { 0 <= i <= length sp } *)
(*       invariant { length r = div (i * 4) 3 } *)
(*       invariant { forall j. 0 <= j < div i 3 -> *)
(*         let a1, a2, a3 = sp[j*3], sp[j*3+1], sp[j*3+2] in *)
(*         r[j*4]   = int2b64 (div (code a1)  4) && *)
(*         r[j*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) && *)
(*         r[j*4+2] = int2b64 (mod (code a2) 16 * 4 + div (code a3) 64) && *)
(*         r[j*4+3] = int2b64 (mod (code a3) 64) *)
(*       } *)
(*       let c1,c2,c3 = sp[i], sp[i+1], sp[i+2] in *)
(*       let b1 = code c1 / 4 in *)
(*       let b2 = (code c1 % 4) * 16 + code c2 / 16 in *)
(*       let b3 = (code c2 % 16) * 4 + code c3 / 64 in *)
(*       let b4 = code c3 % 64 in *)
(*       label L in *)
(*       r <- concat r (int2b64 b1).content; *)
(*       assert { forall j. 0 <= j < length r - 1 -> r[j] = (r at L)[j] }; *)
(*       assert { r[length r - 1] = int2b64 (div (code c1) 4) }; *)
(*       r <- concat r (int2b64 b2).content; *)
(*       assert { forall j. 0 <= j < length r - 2 -> r[j] = (r at L)[j] }; *)
(*       assert { r[length r - 1] = int2b64 (mod (code c1) 4 * 16 + div (code c2) 16) }; *)
(*       r <- concat r (int2b64 b3).content; *)
(*       assert { forall j. 0 <= j < length r - 3 -> r[j] = (r at L)[j] }; *)
(*       assert { r[length r - 1] = int2b64 (mod (code c2) 16 * 4 + div (code c3) 64) }; *)
(*       r <- concat r (int2b64 b4).content; *)
(*       assert { forall j. 0 <= j < length r - 4 -> r[j] = (r at L)[j] }; *)
(*       assert { r[length r - 4] = int2b64 (div (code c1) 4) && *)
(*                r[length r - 3] = int2b64 (mod (code c1) 4 * 16 + div (code c2) 16) && *)
(*                r[length r - 2] = int2b64 (mod (code c2) 16 * 4 + div (code c3) 64) && *)
(*                r[length r - 1] = int2b64 (mod (code c3) 64) }; *)
(*       i <- i + 3; *)
(*       assert { forall j. j = div i 3 - 1 -> *)
(*         let a1, a2, a3 = sp[j*3], sp[j*3+1], sp[j*3+2] in *)
(*         r[j*4]   = int2b64 (div (code a1)  4) && *)
(*         r[j*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) && *)
(*         r[j*4+2] = int2b64 (mod (code a2) 16 * 4 + div (code a3) 64) && *)
(*         r[j*4+3] = int2b64 (mod (code a3) 64) *)
(*       }; *)
(*       assert { forall j. 0 <= j < length r - 4 -> r[j] = (r at L)[j] } *)
(*     done; *)
(*     assert { forall j. 0 <= j < div (length sp) 3 -> *)
(*       let a1, a2, a3 = sp[j*3], sp[j*3+1], sp[j*3+2] in *)
(*       r[j*4]   = int2b64 (div (code a1)  4) && *)
(*       r[j*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) && *)
(*       r[j*4+2] = int2b64 (mod (code a2) 16 * 4 + div (code a3) 64) && *)
(*       r[j*4+3] = int2b64 (mod (code a3) 64) *)
(*     }; *)
(*     label L2 in *)
(*     r <- sub r 0 (length r - padding); *)
(*     assert { forall j. 0 <= j < length s -> s[j] = sp[j]}; *)
(*     assert { forall j. 0 <= j < div (length s) 3 -> *)
(*       let a1, a2, a3 = s[j*3], s[j*3+1], s[j*3+2] in *)
(*       r[j*4]   = int2b64 (div (code a1)  4) && *)
(*       r[j*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) && *)
(*       r[j*4+2] = int2b64 (mod (code a2) 16 * 4 + div (code a3) 64) && *)
(*       r[j*4+3] = int2b64 (mod (code a3) 64) *)
(*     }; *)
(*     assert { length s < next_m3 (length s) -> *)
(*       let i = div (length s) 3 in *)
(*       let a1, a2, a3 = sp[i*3], sp[i*3+1], sp[i*3+2] in *)
(*       r[i*4] = int2b64 (div (code a1)  4) && *)
(*       if i * 3 + 1 >= length s then *)
(*         div (code a2) 16 = 0 && *)
(*         r[i*4+1] = int2b64 (mod (code a1) 4 * 16) *)
(*       else *)
(*         div (code a3) 64 = 0 && *)
(*         r[i*4+1] = int2b64 (mod (code a1) 4 * 16 + div (code a2) 16) && *)
(*         r[i*4+2] = int2b64 (mod (code a2) 16 * 4) *)
(*     }; *)
(*     r *)

(*   let function decode (s: string) : string *)
(*     requires { let m = mod (length s) 4 in m = 0 || m = 2 || m = 3 } *)
(*     requires { forall i. 0 <= i < length s -> valid_64_char s[i] } *)
(*     ensures  { length result = div (length s * 3) 4 } *)
(*     ensures  { forall i. 0 <= i < div (next_m3 (length result)) 3 -> *)
(*       let b1,b2,b3,b4 = s[4*i], s[4*i+1],s[4*i+2], s[4*i+3] in *)
(*       result[i*3] = chr (b642int b1 * 4 + div (b642int b2) 16) && *)
(*       (i * 3 + 1 < length result -> *)
(*         result[i*3+1] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4)) && *)
(*       (i * 3 + 2 < length result -> *)
(*         result[i*3+2] = chr (mod (b642int b3) 4 * 64 + b642int b4)) *)
(*     } *)
(*   = let padding = next_m4 (length s) - length s in *)
(*     let sp = concat s (make padding (chr 0)) in *)
(*     let ref i = 0 in *)
(*     let ref r = "" in *)
(*     while i < length sp do *)
(*       variant { length sp - i } *)
(*       invariant { 0 <= i <= length sp } *)
(*       invariant { mod i 4 = 0 } *)
(*       invariant { mod (length r) 3 = 0} *)
(*       invariant { length r = div (i * 3) 4 } *)
(*       invariant { forall j. 0 <= j < div i 4 -> *)
(*         let b1,b2,b3,b4 = sp[4*j], sp[4*j+1], sp[4*j+2], sp[4*j+3] in *)
(*         r[j*3] = chr (b642int b1 * 4 + div (b642int b2) 16) && *)
(*         r[j*3+1] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4) && *)
(*         r[j*3+2] = chr (mod (b642int b3) 4 * 64 + b642int b4) *)
(*       } *)
(*       label L in *)
(*       let b1,b2,b3,b4 = sp[i], sp[i+1], sp[i+2], sp[i+3] in *)
(*       let a1 = b642int b1 * 4 + b642int b2 / 16 in *)
(*       let a2 = b642int b2 % 16 * 16 + b642int b3 / 4 in *)
(*       let a3 = b642int b3 % 4 * 64 + b642int b4 in *)
(*       r <- concat r (chr a1).content; *)
(*       assert { length r = length (r at L) + 1}; *)
(*       assert { forall j. 0 <= j < length r - 1 -> r[j] =  (r at L)[j]}; *)
(*       assert { r[length r - 1] = chr (b642int b1 * 4 + div (b642int b2) 16) }; *)
(*       r <- concat r (chr a2).content; *)
(*       assert { length r = length (r at L) + 2}; *)
(*       assert { forall j. 0 <= j < length r - 2 -> r[j] =  (r at L)[j]}; *)
(*       assert {r[length r - 1] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4)}; *)
(*       r <- concat r (chr a3).content; *)
(*       assert { forall j. 0 <= j < length r - 3 -> r[j] =  (r at L)[j]}; *)
(*       assert {r[length r - 3] = chr (b642int b1 * 4 + div (b642int b2) 16) && *)
(*               r[length r - 2] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4) && *)
(*               r[length r - 1] = chr (mod (b642int b3) 4 * 64 + b642int b4) *)
(*       }; *)
(*       i <- i + 4 *)
(*     done; *)
(*     assert { forall i. 0 <= i < div (length sp) 4 -> *)
(*       let b1,b2,b3,b4 = sp[4*i], sp[4*i+1], sp[4*i+2], sp[4*i+3] in *)
(*       r[i*3] = chr (b642int b1 * 4 + div (b642int b2) 16) && *)
(*       r[i*3+1] = chr (mod (b642int b2) 16 * 16 + div (b642int b3) 4) && *)
(*       r[i*3+2] = chr (mod (b642int b3) 4 * 64 + b642int b4) *)
(*     }; *)
(*     assert { forall i. 0 <= i < length s -> s[i] =  sp[i]}; *)
(*     sub r 0 (length r - padding) *)

(*   let lemma decode_encode (s: string) : unit *)
(*     ensures { decode (encode s) = s } *)
(*   = let s1 = encode s in *)

(*     assert { get_pad s1 = calc_pad s }; *)

(*     assert { length s = div (length s1) 4 * 3 - get_pad s1}; *)
(*     assert { length s1 = div (next_m3 (length s)) 3 * 4}; *)

(*     assert { forall i. 0 <= i < div (length s) 3 -> *)
(*       (valid_64_char s1[i*4] && valid_64_char s1[i*4+1] && *)
(*       valid_64_char s1[i*4+2] && valid_64_char s1[i*4+3]) *)
(*     }; *)

(*     assert { mod (length s) 3 <> 0 -> *)
(*       let last = div (length s) 3 in *)
(*       valid_64_char s1[last*4] && valid_64_char s1[last*4+1] && *)
(*       if last * 3 + 1 = length s then *)
(*         s1[last*4+2] = char_eq && s1[last*4+3] = char_eq *)
(*       else valid_64_char s1[last*4+2] && s1[last*4+3] = char_eq *)
(*     }; *)

(*     assert { forall i. 0 <= i < length s1 -> *)
(*       valid_64_char s1[i] || s1[i] = char_eq }; *)

(*     assert { forall i. *)
(*       (0 <= i < length s1 - get_pad s1 -> valid_64_char s1[i]) && *)
(*       (length s1 - get_pad s1 <= i < length s1 -> s1[i] = char_eq) }; *)

(*     let s2 = decode s1 in *)

(*     assert { length s2 = length s by length s = div (length s1 * 3) 4 - get_pad s1 }; *)

(*     assert { forall i. 0 <= i < div (length s1) 4 -> s[i*3] = s2[i*3] && *)
(*       s[i*3+1] = s2[i*3+1] && s[i*3+2] = s2[i*3+2] }; *)

(*     assert { forall i. 0 <= i < length s -> s[i] = s2[i] }; *)
(*     assert { eq_string s s2 } *)

(*   let test1 = let s = "" in let r = encode s in assert {r = s} *)
(*   let test2 = let s = "a" in let r = encode s in assert {decode r = s} *)
(*   let test3 = let s = "h" in let r = encode s in assert {decode r = s} *)
(*   let test4 = let s = "abc" in let r = encode s in assert {decode r = s} *)
(*   let test5 = let s = "1s1" in let r = encode s in assert {decode r = s} *)
(*   let test6 = let s = "141fh" in let r = encode s in assert {decode r = s} *)
(*   let test7 = let s = "\123as" in let r = encode s in assert {decode r = s} *)
(*   let test8 = let s = "" in decode s *)
(*   (\* let test9 = let s = (chr 65).content in decode s *\) *)
(*   let test10 = *)
(*     let a,b,c,d = chr 65, chr 66, chr 67, chr 68 in *)
(*     let s = concat a.content (concat b.content (concat c.content d.content)) in decode s *)
(*   let test11 = *)
(*     let a,b,c,d = chr 65, chr 66, chr 67, char_eq in *)
(*     let s = concat a.content (concat b.content (concat c.content d.content)) in decode s *)
(*   let test12 = *)
(*     let a,b,c,d = chr 65, chr 66, char_eq, char_eq in *)
(*     let s = concat a.content (concat b.content (concat c.content d.content)) in decode s *)
(*   (\* let test13 = *)
(*     let a,b,c,d = chr 65, chr 66, char_eq, chr 68 in *)
(*     let s = concat a.content (concat b.content (concat c.content d.content)) in decode s*\) *)

(* end *)