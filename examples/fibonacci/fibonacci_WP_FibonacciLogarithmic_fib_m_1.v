(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.

(* Why3 assumption *)
Definition unit := unit.

Parameter fib: Z -> Z.

Axiom fib_def : forall (n:Z), (0%Z <= n)%Z -> (((n = 0%Z) ->
  ((fib n) = 0%Z)) /\ ((~ (n = 0%Z)) -> (((n = 1%Z) -> ((fib n) = 1%Z)) /\
  ((~ (n = 1%Z)) ->
  ((fib n) = ((fib (n - 1%Z)%Z) + (fib (n - 2%Z)%Z))%Z))))).

(* Why3 assumption *)
Inductive t :=
  | mk_t : Z -> Z -> Z -> Z -> t.
Axiom t_WhyType : WhyType t.
Existing Instance t_WhyType.

(* Why3 assumption *)
Definition a22 (v:t): Z := match v with
  | (mk_t x x1 x2 x3) => x3
  end.

(* Why3 assumption *)
Definition a21 (v:t): Z := match v with
  | (mk_t x x1 x2 x3) => x2
  end.

(* Why3 assumption *)
Definition a12 (v:t): Z := match v with
  | (mk_t x x1 x2 x3) => x1
  end.

(* Why3 assumption *)
Definition a11 (v:t): Z := match v with
  | (mk_t x x1 x2 x3) => x
  end.

(* Why3 assumption *)
Definition mult (x:t) (y:t): t :=
  (mk_t (((a11 x) * (a11 y))%Z + ((a12 x) * (a21 y))%Z)%Z
  (((a11 x) * (a12 y))%Z + ((a12 x) * (a22 y))%Z)%Z
  (((a21 x) * (a11 y))%Z + ((a22 x) * (a21 y))%Z)%Z
  (((a21 x) * (a12 y))%Z + ((a22 x) * (a22 y))%Z)%Z).

Axiom Assoc : forall (x:t) (y:t) (z:t), ((mult (mult x y) z) = (mult x
  (mult y z))).

Axiom Unit_def_l : forall (x:t), ((mult (mk_t 1%Z 0%Z 0%Z 1%Z) x) = x).

Axiom Unit_def_r : forall (x:t), ((mult x (mk_t 1%Z 0%Z 0%Z 1%Z)) = x).

Axiom Comm : forall (x:t) (y:t), ((mult x y) = (mult y x)).

Parameter power: t -> Z -> t.

Axiom Power_0 : forall (x:t), ((power x 0%Z) = (mk_t 1%Z 0%Z 0%Z 1%Z)).

Axiom Power_s : forall (x:t) (n:Z), (0%Z <= n)%Z -> ((power x
  (n + 1%Z)%Z) = (mult x (power x n))).

Axiom Power_s_alt : forall (x:t) (n:Z), (0%Z < n)%Z -> ((power x n) = (mult x
  (power x (n - 1%Z)%Z))).

Axiom Power_1 : forall (x:t), ((power x 1%Z) = x).

Axiom Power_sum : forall (x:t) (n:Z) (m:Z), (0%Z <= n)%Z -> ((0%Z <= m)%Z ->
  ((power x (n + m)%Z) = (mult (power x n) (power x m)))).

Axiom Power_mult : forall (x:t) (n:Z) (m:Z), (0%Z <= n)%Z -> ((0%Z <= m)%Z ->
  ((power x (n * m)%Z) = (power (power x n) m))).

Axiom Power_mult2 : forall (x:t) (y:t) (n:Z), (0%Z <= n)%Z -> ((power (mult x
  y) n) = (mult (power x n) (power y n))).


(* Why3 goal *)
Theorem fib_m : forall (n:Z), (0%Z <= n)%Z -> let p := (power (mk_t 1%Z 1%Z
  1%Z 0%Z) n) in (((fib (n + 1%Z)%Z) = (a11 p)) /\ ((fib n) = (a21 p))).
(* Why3 intros n h1 p. *)
(* YOU MAY EDIT THE PROOF BELOW *)
intros n hn.
pattern n; apply natlike_ind; intuition.
rewrite Power_0.
unfold a11, a21; simpl; auto.
replace (Zsucc  x) with (x+1)%Z by omega.
rewrite Power_s; auto.
destruct H0 as (h1,h2).
split.
rewrite fibn; try omega.
ring_simplify (x+1+1-1)%Z.
ring_simplify (x+1+1-2)%Z.
unfold a11, mult.
rewrite <- h1. rewrite <- h2.
unfold a11, a12. ring.
unfold a21, mult.
rewrite <- h1. rewrite <- h2.
unfold a21, a22. ring.
Qed.

