;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; generated by SMT-LIB strings
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun string () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

;; CompatOrderMult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

(declare-fun abs1 (Int) Int)

;; abs'def
  (assert
  (forall ((x Int)) (ite (<= 0 x) (= (abs1 x) x) (= (abs1 x) (- x)))))

;; Abs_le
  (assert
  (forall ((x Int) (y Int)) (= (<= (abs1 x) y) (and (<= (- y) x) (<= x y)))))

;; Abs_pos
  (assert (forall ((x Int)) (<= 0 (abs1 x))))

(declare-fun div1 (Int Int) Int)

(declare-fun mod1 (Int Int) Int)

;; Div_mod
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; Div_bound
  (assert
  (forall ((x Int) (y Int))
  (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (div1 x y)) (<= (div1 x y) x)))))

;; Mod_bound
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0))
  (and (< (- (abs1 y)) (mod1 x y)) (< (mod1 x y) (abs1 y))))))

;; Div_sign_pos
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; Div_sign_neg
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; Mod_sign_pos
  (assert
  (forall ((x Int) (y Int))
  (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; Mod_sign_neg
  (assert
  (forall ((x Int) (y Int))
  (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; Rounds_toward_zero
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; Div_1
  (assert (forall ((x Int)) (= (div1 x 1) x)))

;; Mod_1
  (assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; Div_inf
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; Mod_inf
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; Div_mult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (! (=> (and (< 0 x) (and (<= 0 y) (<= 0 z)))
     (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                            (+ (* x y) z) x)) )))

;; Mod_mult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (! (=> (and (< 0 x) (and (<= 0 y) (<= 0 z)))
     (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1 (+ (* x y) z) x)) )))

(declare-sort int63 0)

(declare-fun int631 () ty)

(declare-fun int63qtint (int63) Int)

;; int63'axiom
  (assert
  (forall ((i int63))
  (and (<= (- 4611686018427387904) (int63qtint i))
  (<= (int63qtint i) 4611686018427387903))))

(declare-fun in_bounds (Int) Bool)

;; in_bounds'def
  (assert
  (forall ((n Int))
  (= (in_bounds n)
  (and (<= (- 4611686018427387904) n) (<= n 4611686018427387903)))))

;; to_int_in_bounds
  (assert (forall ((n int63)) (in_bounds (int63qtint n))))

;; extensionality
  (assert
  (forall ((x int63) (y int63))
  (=> (= (int63qtint x) (int63qtint y)) (= x y))))

(declare-fun max_int () int63)

;; max_int'def
  (assert (= (int63qtint max_int) 4611686018427387903))

(declare-fun min_int () int63)

;; min_int'def
  (assert (= (int63qtint min_int) (- 4611686018427387904)))

(declare-fun lt (String String) Bool)

;; lt_empty
  (assert (forall ((s String)) (=> (not (= s "")) (lt "" s))))

;; lt_not_com
  (assert
  (forall ((s1 String) (s2 String)) (=> (lt s1 s2) (not (lt s2 s1)))))

;; lt_ref
  (assert (forall ((s1 String)) (not (lt s1 s1))))

;; lt_trans
  (assert
  (forall ((s1 String) (s2 String) (s3 String))
  (=> (and (lt s1 s2) (lt s2 s3)) (lt s1 s3))))

(declare-fun le (String String) Bool)

;; le_empty
  (assert (forall ((s String)) (le "" s)))

;; le_ref
  (assert (forall ((s1 String)) (le s1 s1)))

;; lt_le
  (assert (forall ((s1 String) (s2 String)) (=> (lt s1 s2) (le s1 s2))))

;; lt_le_eq
  (assert
  (forall ((s1 String) (s2 String))
  (=> (le s1 s2) (or (lt s1 s2) (= s1 s2)))))

;; le_trans
  (assert
  (forall ((s1 String) (s2 String) (s3 String))
  (=> (and (le s1 s2) (le s2 s3)) (le s1 s3))))

;; substring_substring
  (assert
  (forall ((s String) (ofs Int) (len Int) (ofsqt Int) (lenqt Int))
  (=> (and (<= 0 ofs) (<= ofs (str.len s)))
  (=> (<= 0 len)
  (=> (<= (+ ofs len) (str.len s))
  (=> (and (<= 0 ofsqt) (<= ofsqt len))
  (=> (<= 0 lenqt)
  (=> (<= (+ ofsqt lenqt) len)
  (= (str.substr (str.substr s ofs len) ofsqt lenqt) (str.substr s (+ ofs ofsqt) lenqt))))))))))

;; concat_substring
  (assert
  (forall ((s String) (ofs Int) (len Int) (lenqt Int))
  (=> (and (<= 0 ofs) (<= ofs (str.len s)))
  (=> (<= 0 len)
  (=> (<= (+ ofs len) (str.len s))
  (=> (<= 0 lenqt)
  (=>
  (and (<= 0 (+ (+ ofs len) lenqt)) (<= (+ (+ ofs len) lenqt) (str.len s)))
  (= (str.++ (str.substr s ofs len) (str.substr s (+ ofs len) lenqt)) (str.substr s ofs (+ len lenqt))))))))))

(declare-fun replaceall (String String String) String)

;; replaceall_empty1
  (assert (forall ((s1 String) (s3 String)) (= (replaceall s1 "" s3) s1)))

;; not_contains_replaceall
  (assert
  (forall ((s1 String) (s2 String) (s3 String))
  (=> (not (str.contains s1 s2)) (= (replaceall s1 s2 s3) s1))))

(declare-fun is_digit (String) Bool)

;; is_digit'def
  (assert
  (forall ((s String))
  (= (is_digit s)
  (and (and (<= 0 (str.to.int s)) (<= (str.to.int s) 9)) (= (str.len s) 1)))))

(declare-sort char 0)

(declare-fun char1 () ty)

(declare-fun content (char) String)

;; char'invariant
  (assert
  (forall ((self char))
  (! (= (str.len (content self)) 1) :pattern ((content self)) )))

;; char_eq
  (assert
  (forall ((c1 char) (c2 char)) (=> (= (content c1) (content c2)) (= c1 c2))))

(declare-fun code (char) Int)

;; code
  (assert (forall ((c char)) (and (<= 0 (code c)) (< (code c) 256))))

(declare-fun chr (Int) char)

;; code_chr
  (assert
  (forall ((n Int)) (=> (and (<= 0 n) (< n 256)) (= (code (chr n)) n))))

;; chr_code
  (assert (forall ((c char)) (= (chr (code c)) c)))

(declare-fun get (String Int) char)

;; get
  (assert
  (forall ((s String) (i Int))
  (=> (and (<= 0 i) (< i (str.len s))) (= (content (get s i)) (str.at s i)))))

;; substring_get
  (assert
  (forall ((s String) (ofs Int) (len Int) (i Int))
  (=> (and (<= 0 ofs) (<= ofs (str.len s)))
  (=> (<= 0 len)
  (=> (<= (+ ofs len) (str.len s))
  (=> (and (<= 0 i) (< i len))
  (= (get (str.substr s ofs len) i) (get s (+ ofs i)))))))))

(declare-fun eq_string (String String) Bool)

;; eq_string'def
  (assert
  (forall ((s1 String) (s2 String))
  (= (eq_string s1 s2)
  (and (= (str.len s1) (str.len s2))
  (forall ((i Int))
  (=> (and (<= 0 i) (< i (str.len s1))) (= (get s1 i) (get s2 i))))))))

;; extensionality
  (assert
  (forall ((s1 String) (s2 String)) (=> (eq_string s1 s2) (= s1 s2))))

(declare-fun make (Int char) String)

;; make_length
  (assert
  (forall ((size Int) (v char))
  (=> (<= 0 size) (= (str.len (make size v)) size))))

;; make_content
  (assert
  (forall ((size Int) (v char))
  (=> (<= 0 size)
  (forall ((i Int))
  (=> (and (<= 0 i) (< i size)) (= (get (make size v) i) v))))))

(declare-fun next_m3 (Int) Int)

;; next_m3'def
  (assert
  (forall ((i Int))
  (ite (= (mod1 i 3) 0) (= (next_m3 i) i)
  (ite (= (mod1 i 3) 1) (= (next_m3 i) (+ i 2)) (= (next_m3 i) (+ i 1))))))

(declare-fun next_m4 (Int) Int)

;; next_m4'def
  (assert
  (forall ((i Int))
  (ite (= (mod1 i 4) 0) (= (next_m4 i) i)
  (ite (= (mod1 i 4) 1) (= (next_m4 i) (+ i 3))
  (ite (= (mod1 i 4) 2) (= (next_m4 i) (+ i 2)) (= (next_m4 i) (+ i 1)))))))

(declare-fun int2b64 (Int) char)

;; int2b64'def
  (assert
  (forall ((i Int))
  (ite (and (<= 0 i) (<= i 25)) (= (int2b64 i) (chr (+ i 65)))
  (ite (and (<= 26 i) (<= i 51)) (= (int2b64 i) (chr (+ (- i 26) 97)))
  (ite (and (<= 52 i) (<= i 61)) (= (int2b64 i) (chr (+ (- i 52) 48)))
  (ite (= i 62) (= (int2b64 i) (chr 43))
  (ite (= i 63) (= (int2b64 i) (chr 47)) (= (int2b64 i) (chr 0)))))))))

;; concat_first
  (assert
  (forall ((s1 String) (s2 String))
  (forall ((i Int))
  (=> (and (<= 0 i) (< i (str.len s1)))
  (= (get (str.++ s1 s2) i) (get s1 i))))))

;; concat_second
  (assert
  (forall ((s1 String) (s2 String))
  (forall ((i Int))
  (=> (and (<= (str.len s1) i) (< i (+ (str.len s1) (str.len s2))))
  (= (get (str.++ s1 s2) i) (get s2 (- i (str.len s1))))))))

(declare-fun valid_64_char (char) Bool)

;; valid_64_char'def
  (assert
  (forall ((c char))
  (= (valid_64_char c)
  (or (and (<= 65 (code c)) (<= (code c) 90))
  (or (and (<= 97 (code c)) (<= (code c) 122))
  (or (and (<= 48 (code c)) (<= (code c) 57))
  (or (= (code c) 43) (= (code c) 47))))))))

;; int2b64_valid_4_char
  (assert
  (forall ((i Int)) (=> (and (<= 0 i) (< i 64)) (valid_64_char (int2b64 i)))))

(declare-fun b642int (char) Int)

;; b642int'def
  (assert
  (forall ((c char))
  (ite (and (<= 65 (code c)) (<= (code c) 90))
  (= (b642int c) (- (code c) 65))
  (ite (and (<= 97 (code c)) (<= (code c) 122))
  (= (b642int c) (+ (- (code c) 97) 26))
  (ite (and (<= 48 (code c)) (<= (code c) 57))
  (= (b642int c) (+ (- (code c) 48) 52))
  (ite (= (code c) 43) (= (b642int c) 62)
  (ite (= (code c) 47) (= (b642int c) 63)
  (ite (= c (chr 61)) (= (b642int c) 0) (= (b642int c) 64)))))))))

;; b642int_int2b64
  (assert
  (forall ((i Int)) (=> (and (<= 0 i) (< i 64)) (= (b642int (int2b64 i)) i))))

(declare-fun get_pad (String) Int)

;; get_pad'def
  (assert
  (forall ((s String))
  (ite (and (<= 1 (str.len s)) (= (get s (- (str.len s) 1)) (chr 61)))
  (ite (and (<= 2 (str.len s)) (= (get s (- (str.len s) 2)) (chr 61)))
  (= (get_pad s) 2) (= (get_pad s) 1)) (= (get_pad s) 0))))

(declare-fun calc_pad (String) Int)

;; calc_pad'def
  (assert
  (forall ((s String))
  (ite (= (mod1 (str.len s) 3) 1) (= (calc_pad s) 2)
  (ite (= (mod1 (str.len s) 3) 2) (= (calc_pad s) 1) (= (calc_pad s) 0)))))

(declare-fun ref (ty) ty)

(declare-fun refqtmk (ty uni) uni)

;; ref'mk_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (refqtmk a x)))))

(declare-fun contents (ty uni) uni)

;; contents_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; contents'def
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort a u) (= (contents a (refqtmk a u)) u)))))

;; ref_inversion
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort (ref a) u) (= u (refqtmk a (contents a u)))))))

(declare-fun encode (String) String)

;; encode'spec
  (assert
  (forall ((s String))
  (and (= (str.len (encode s)) (div1 (* (next_m3 (str.len s)) 4) 3))
  (and (= (mod1 (str.len (encode s)) 4) 0)
  (and
  (forall ((i Int))
  (=> (and (<= 0 i) (< i (div1 (str.len s) 3)))
  (let ((a1 (get s (* i 3))))
  (let ((a2 (get s (+ (* i 3) 1))))
  (let ((a3 (get s (+ (* i 3) 2))))
  (and (= (get (encode s) (* i 4)) (int2b64 (div1 (code a1) 4)))
  (and
  (= (get (encode s) (+ (* i 4) 1)) (int2b64
                                    (+ (* (mod1 (code a1) 4) 16) (div1
                                                                 (code a2)
                                                                 16))))
  (and
  (= (get (encode s) (+ (* i 4) 2)) (int2b64
                                    (+ (* (mod1 (code a2) 16) 4) (div1
                                                                 (code a3)
                                                                 64))))
  (= (get (encode s) (+ (* i 4) 3)) (int2b64 (mod1 (code a3) 64)))))))))))
  (and
  (=> (not (= (mod1 (str.len s) 3) 0))
  (let ((i (div1 (str.len s) 3)))
  (let ((a1 (get s (* i 3))))
  (and (= (get (encode s) (* i 4)) (int2b64 (div1 (code a1) 4)))
  (ite (= (+ (* i 3) 1) (str.len s))
  (and (= (get (encode s) (+ (* i 4) 1)) (int2b64 (* (mod1 (code a1) 4) 16)))
  (and (= (get (encode s) (+ (* i 4) 2)) (chr 61))
  (= (get (encode s) (+ (* i 4) 3)) (chr 61))))
  (let ((a2 (get s (+ (* i 3) 1))))
  (and (= (str.len s) (+ (* i 3) 2))
  (and
  (= (get (encode s) (+ (* i 4) 1)) (int2b64
                                    (+ (* (mod1 (code a1) 4) 16) (div1
                                                                 (code a2)
                                                                 16))))
  (and (= (get (encode s) (+ (* i 4) 2)) (int2b64 (* (mod1 (code a2) 16) 4)))
  (= (get (encode s) (+ (* i 4) 3)) (chr 61)))))))))))
  (= (get_pad (encode s)) (calc_pad s))))))))

(declare-fun s () String)

;; Requires
  (assert (= (mod1 (str.len s) 4) 0))

;; Requires
  (assert
  (forall ((i Int))
  (=> (and (<= 0 i) (< i (- (str.len s) (get_pad s)))) (valid_64_char
  (get s i)))))

;; Requires
  (assert
  (forall ((i Int))
  (=> (and (<= (- (str.len s) (get_pad s)) i) (< i (str.len s)))
  (= (get s i) (chr 61)))))

(declare-fun r () String)

(declare-fun i () int63)

;; H
  (assert (<= 0 (int63qtint i)))

;; H
  (assert (<= (int63qtint i) (str.len s)))

;; LoopInvariant
  (assert (= (mod1 (int63qtint i) 4) 0))

;; LoopInvariant
  (assert (= (mod1 (str.len r) 3) 0))

;; LoopInvariant
  (assert (= (str.len r) (div1 (* (int63qtint i) 3) 4)))

;; LoopInvariant
  (assert
  (forall ((j Int))
  (=> (and (<= 0 j) (< j (div1 (int63qtint i) 4)))
  (let ((b2 (get s (+ (* 4 j) 1))))
  (let ((b3 (get s (+ (* 4 j) 2))))
  (and
  (= (get r (* j 3)) (chr
                     (+ (* (b642int (get s (* 4 j))) 4) (div1 (b642int b2)
                                                        16))))
  (and
  (= (get r (+ (* j 3) 1)) (chr
                           (+ (* (mod1 (b642int b2) 16) 16) (div1
                                                            (b642int b3) 4))))
  (= (get r (+ (* j 3) 2)) (chr
                           (+ (* (mod1 (b642int b3) 4) 64) (b642int
                                                           (get s
                                                           (+ (* 4 j) 3)))))))))))))

(declare-fun o () int63)

;; Ensures
  (assert (= (int63qtint o) (str.len s)))

;; H
  (assert (not (< (int63qtint i) (int63qtint o))))

;; Assert
  (assert
  (forall ((i1 Int))
  (=> (and (<= 0 i1) (< i1 (div1 (str.len s) 4)))
  (let ((b2 (get s (+ (* 4 i1) 1))))
  (let ((b3 (get s (+ (* 4 i1) 2))))
  (and
  (= (get r (* i1 3)) (chr
                      (+ (* (b642int (get s (* 4 i1))) 4) (div1 (b642int b2)
                                                          16))))
  (and
  (= (get r (+ (* i1 3) 1)) (chr
                            (+ (* (mod1 (b642int b2) 16) 16) (div1
                                                             (b642int b3) 4))))
  (= (get r (+ (* i1 3) 2)) (chr
                            (+ (* (mod1 (b642int b3) 4) 64) (b642int
                                                            (get s
                                                            (+ (* 4 i1) 3)))))))))))))

;; Assert
  (assert (= (str.len r) (div1 (* (str.len s) 3) 4)))

(declare-fun o1 () int63)

;; Ensures
  (assert (= (int63qtint o1) (get_pad s)))

(declare-fun o2 () int63)

;; Ensures
  (assert (= (int63qtint o2) (str.len r)))

(declare-fun o3 () int63)

;; Ensures
  (assert (= (int63qtint o3) (- (int63qtint o2) (int63qtint o1))))

;; h
  (assert
  (= (str.len (str.substr r 0 (int63qtint o3))) (- (div1 (* (str.len s) 3) 4) 
  (get_pad s))))

(assert
;; decodeqtvc
 ;; File "/home/claudio/why3/examples/string_base64_encoding.mlw", line 209, characters 15-21
  (not (= (str.len s) 0)))
(check-sat)
