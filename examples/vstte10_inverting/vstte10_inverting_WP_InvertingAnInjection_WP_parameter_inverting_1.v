(* This file is generated by Why3's Coq 8.4 driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require map.Map.
Require map.MapInjection.

(* Why3 assumption *)
Definition unit := unit.

(* Why3 assumption *)
Inductive array
  (a:Type) {a_WT:WhyType a} :=
  | mk_array : Z -> (@map.Map.map Z _ a a_WT) -> array a.
Axiom array_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.
Implicit Arguments mk_array [[a] [a_WT]].

(* Why3 assumption *)
Definition elts {a:Type} {a_WT:WhyType a} (v:(@array a a_WT)): (@map.Map.map
  Z _ a a_WT) := match v with
  | (mk_array x x1) => x1
  end.

(* Why3 assumption *)
Definition length {a:Type} {a_WT:WhyType a} (v:(@array a a_WT)): Z :=
  match v with
  | (mk_array x x1) => x
  end.

(* Why3 assumption *)
Definition get {a:Type} {a_WT:WhyType a} (a1:(@array a a_WT)) (i:Z): a :=
  (map.Map.get (elts a1) i).

(* Why3 assumption *)
Definition set {a:Type} {a_WT:WhyType a} (a1:(@array a a_WT)) (i:Z)
  (v:a): (@array a a_WT) := (mk_array (length a1) (map.Map.set (elts a1) i
  v)).

(* Why3 assumption *)
Definition make {a:Type} {a_WT:WhyType a} (n:Z) (v:a): (@array a a_WT) :=
  (mk_array n (map.Map.const v:(@map.Map.map Z _ a a_WT))).

(* Why3 assumption *)
Definition injective (a:(@array Z _)) (n:Z): Prop :=
  (map.MapInjection.injective (elts a) n).

(* Why3 assumption *)
Definition surjective (a:(@array Z _)) (n:Z): Prop :=
  (map.MapInjection.surjective (elts a) n).

(* Why3 assumption *)
Definition range (a:(@array Z _)) (n:Z): Prop := (map.MapInjection.range
  (elts a) n).

(* Why3 goal *)
Theorem WP_parameter_inverting : forall (a:Z) (a1:(@map.Map.map Z _ Z _))
  (b:Z) (n:Z), (((0%Z <= a)%Z /\ (0%Z <= b)%Z) /\ (((n = a) /\ (a = b)) /\
  ((map.MapInjection.injective a1 n) /\ (map.MapInjection.range a1 n)))) ->
  let o := (n - 1%Z)%Z in ((0%Z <= o)%Z -> forall (b1:(@map.Map.map Z _
  Z _)), (forall (j:Z), ((0%Z <= j)%Z /\ (j < (o + 1%Z)%Z)%Z) ->
  ((map.Map.get b1 (map.Map.get a1 j)) = j)) -> ((0%Z <= b)%Z ->
  (map.MapInjection.injective b1 n))).
(* Why3 intros a a1 b n ((h1,h2),((h3,h4),(h5,h6))) o h7 b1 h8 h9. *)
intuition.
intuition.
red; intros.
unfold get; simpl.
assert (MapInjection.surjective a1 n).
apply MapInjection.injective_surjective; assumption.
generalize (H11 i H8); unfold get; simpl; intros (i1, (Hi1,Hi2)).
generalize (H11 j H9); unfold get; simpl; intros (j1, (Hj1,Hj2)).
rewrite <- Hi2.
rewrite <- Hj2.
rewrite H6; try omega.
rewrite H6; try omega.
intro.
apply H10.
subst.
auto.
Qed.

