
(** Computing both the minimum and the maximum of an array of integers

    Authors: Jean-Christophe Filli√¢tre (CNRS)
             Guillaume Melquiond       (Inria) *)

use int.Int
use array.Array

(** `m` is the minimum of `a[0..n[` *)
predicate is_min (m: int) (a: array int) (n: int) =
  (exists i. 0 <= i < n <= length a /\ a[i] = m) /\
  (forall i. 0 <= i < n -> m <= a[i])

(** `m` is the maximum of `a[0..n[` *)
predicate is_max (m: int) (a: array int) (n: int) =
  (exists i. 0 <= i < n <= length a /\ a[i] = m) /\
  (forall i. 0 <= i < n -> m >= a[i])

(** first, an obvious implementation *)

let min_max (a: array int) : (int, int)
  requires { 1 <= length a }
  returns  { min, max -> is_min min a (length a) /\ is_max max a (length a) }
= let ref min = a[0] in
  let ref max = a[0] in
  for i = 1 to length a - 1 do
    invariant { is_min min a i /\ is_max max a i }
    if a[i] < min then min <- a[i];
    if a[i] > max then max <- a[i]
  done;
  min, max

(* then a better implementation that considers the values two by two,
   to save 25% of comparisons *)

use mach.int.Int
use ref.Refint

let a_better_min_max (a: array int) : (int, int)
  requires { 1 <= length a }
  returns  { min, max -> is_min min a (length a) /\ is_max max a (length a) }
= [@vc:sp]
  let n = length a in
  let ref min = a[0] in
  let ref max = a[0] in
  let ref i = if n % 2 = 0 then 2 else 1 in
  if i = 2 then if a[0] < a[1] then max <- a[1] else min <- a[1];
  while i < n do
    variant   { n - i }
    invariant { mod i 2 = mod n 2 }
    invariant { is_min min a i /\ is_max max a i }
    if a[i] < a[i+1] then begin
      if a[i]   < min then min <- a[i];
      if a[i+1] > max then max <- a[i+1]
    end else begin
      if a[i+1] < min then min <- a[i+1];
      if a[i]   > max then max <- a[i]
    end;
    i += 2
  done;
  min, max
