module Hex1

  use mach.int.Int
  use mach.int.Int63
  use string.OCaml

  let function encode (s: string) : string
    ensures { length result = 2 * length s }
    ensures { forall i. 0 <= i < length s ->
                result[2 * i] = chr (div (code s[i]) 16) &&
                result[2 * i + 1] = chr (mod (code s[i]) 16) }
  = let ref i = 0 in
    let ref r = "" in
    while i < OCaml.length s do
      variant { length s - i }
      invariant { 0 <= i <= OCaml.length s }
      invariant { length r = 2 * i }
      invariant { forall j. 0 <= j < i  ->
                    r[2 * j] = chr (div (code s[j]) 16) &&
                    r[2 * j + 1] = chr (mod (code s[j]) 16) }
      let v = code s[i] in
      r <- concat r (chr (v / 16)).content;
      r <- concat r (chr (v % 16)).content;
      i <- i + 1
    done;
    r

  let function decode (s: string) : string
    requires { mod (length s) 2 = 0 }
    requires { forall i. 0 <= i < length s -> 0 <= code s[i] < 16 }
    ensures  { length result = div (length s) 2 }
    ensures  { forall i. 0 <= i < div (length s) 2 ->
                 result[i] = chr (code s[2 * i] * 16 + code s[2 * i + 1]) }
  = let ref i = 0 in
    let ref r = "" in
    while i < length s do
      variant {length s - i}
      invariant { mod i 2 = 0 }
      invariant { 0 <= i <= length s }
      invariant { length r = div i 2 }
      invariant { forall j. 0 <= j < div i 2 ->
                    r[j] = chr (code s[2 * j] * 16 + code s[2 * j + 1]) }
      let v_i = code s[i] in
      let v_ii = code s[i + 1] in
      r <- concat r (chr (v_i * 16 + v_ii)).content;
      i <- i + 2
    done;
    r

  let test1 = let s = ""  in let r = encode s in assert {r = s}
  let test2 = let s = "a" in let r = encode s in assert {length r = 2 && decode r = s}
  let test3 = let s = "b" in let r = encode s in assert {length r = 2 && decode r = s}

  let test4 = let s = "\006\001" in let r = decode s in assert { length r = 1 && r = "a" }
  let test5 = let s = "\006\002"    in let r = decode s in assert { length r = 1 && r = "b" }

  lemma decode_encode: forall s. decode (encode s) = s

end

module Hex2

  use mach.int.Int
  use mach.int.Int63
  use string.OCaml

  function hex (i: int) : char =
    if 0 <= i < 10 then chr (i + 48)
    else if 10 <= i < 16 then chr (i + 55)
    else "\000"[0]

  (* lemma hex_bounds: forall i. 0 <= i < 16 -> *)
  (*   48 <= code (hex i) < 58 || 65 <= code (hex i) < 71 *)

  let hex (i: int63) : char
    requires { 0 <= i < 16 }
    ensures  { result = hex i }
  = if i < 10 then chr (i + 48) else chr (i + 55)

  function xeh (i: int) : int =
    if 48 <= i < 58 then i - 48
    else if 65 <= i < 71 then i - 55
    else -1

  (* lemma xeh_bounds: forall i. 48 <= i < 58 || 65 <= i < 71 -> *)
  (*   0 <= xeh i < 16 *)

  (* lemma hex_xeh: forall i. 48 <= i < 58 || 65 <= i < 71 -> code (hex (xeh i)) = i *)

  (* lemma xeh_hex: forall i. 0 <= i < 16 -> xeh (code (hex i)) = i *)

  let xeh (i: int63) : int63
    requires { 48 <= i < 58 || 65 <= i < 71 }
    ensures  { result = xeh i }
  = if 48 <= i < 58 then i - 48
    else i - 55

  let function encode (s: string) : string
    ensures { length result = 2 * length s }
    ensures { forall i. 0 <= i < length s ->
                result[2 * i] = hex (div (code s[i]) 16) &&
                result[2 * i + 1] = hex (mod (code s[i]) 16) &&
                (48 <= code result[2*i] < 58 || 65 <= code result[2*i] < 71) && 
                (48 <= code result[2*i+1] < 58 || 65 <= code result[2*i+1] < 71) }
  = let ref i = 0 in
    let ref r = "" in
    while i < OCaml.length s do
      variant { length s - i }
      invariant { 0 <= i <= OCaml.length s }
      invariant { length r = 2 * i }
      invariant { forall j. 0 <= j < i  ->
                    r[2 * j] = hex (div (code s[j]) 16) &&
                    r[2 * j + 1] = hex (mod (code s[j]) 16)
      }
      let v = code s[i] in
      r <- concat r (hex (v / 16)).content;
      r <- concat r (hex (v % 16)).content;
      assert { let h = code r[length r - 1] in 48 <= h < 58 || 65 <= h < 71 };
      assert { let h = code r[length r - 2] in 48 <= h < 58 || 65 <= h < 71 };
      i <- i + 1
    done;
    r

  let function decode (s: string) : string
    requires { mod (length s) 2 = 0 }
    requires { forall i. 0 <= i < length s ->
                 48 <= code s[i] < 58 || 65 <= code s[i] < 71 }
    requires { forall i. 0 <= i < length s -> 0 <= xeh (code s[i]) < 16 }
    ensures  { length result = div (length s) 2 }
    ensures  { forall i. 0 <= i < div (length s) 2 ->
                 result[i] = chr (xeh (code s[2 * i]) * 16 + xeh (code s[2 * i + 1])) }
  = let ref i = 0 in
    let ref r = "" in
    while i < length s do
      variant {length s - i}
      invariant { mod i 2 = 0 }
      invariant { 0 <= i <= length s }
      invariant { length r = div i 2 }
      invariant { forall j. 0 <= j < div i 2 ->
                    r[j] = chr (xeh (code s[2 * j]) * 16 + xeh (code s[2 * j + 1])) }
      let v_i = xeh (code s[i]) in
      let v_ii = xeh (code s[i + 1]) in
      r <- concat r (chr (v_i * 16 + v_ii)).content;
      i <- i + 2
    done;
    r

  let lemma decode_encode (s: string) : unit
    ensures { decode (encode s) = s }
  = let s1 = encode s in
    assert { forall i. 0 <= i < length s1 ->
               48 <= code s1[i] < 58 || 65 <= code s1[i] < 71 };
    let s2 = decode s1 in
    assert { length s2 = length s };
    assert { forall i. 0 <= i < length s ->
             s[i] = s2[i] }

  let test1 = let s = "" in let r = encode s in assert {r = s}
  let test2 = let s = "a" in let r = encode s in assert {decode r = s}
  let test3 = let s = "h" in let r = encode s in assert {decode r = s}
  let test4 = let s = "abc" in let r = encode s in assert {decode r = s}
  let test5 = let s = "1s1" in let r = encode s in assert {decode r = s}
  let test6 = let s = "141fh" in let r = encode s in assert {decode r = s}
  let test7 = let s = "\123as" in let r = encode s in assert {decode r = s}

end

module Base64

  use mach.int.Int
  use mach.int.Int63
  use string.OCaml

  let function encode (s: string) : string
    ensures { length result <= div ((length s + 2) * 4) 3 }
    ensures { mod (length result) 4 = 0 }
    ensures { forall i. 0 <= i < div (length result) 4 ->
                let a1, a2, a3 = s[i*3], s[i*3+1], s[i*3+2] in
                let b1, b2 = result[i*4], result[i*4+1] in
                let b3, b4 = result[i*4+2], result[i*4+3] in
                b1 = chr (div (code a1)  4) &&
                b2 = chr (mod (code a1) 4 * 16 + div (code a2) 16) &&
                b3 = chr (mod (code a2) 16 * 4 + div (code a3) 64) &&
                b4 = chr (mod (code a3) 64)
    }
  = let len_m = (length s) % 3 in
    let sp = if len_m = 1 then concat s "\000\000" else
             if len_m = 2 then concat s "\000" else s in
    assert { length sp <= length s + 2 };
    let ref i = 0 in
    let ref r = "" in
    while i < length sp do
      variant {length sp - i}
      invariant { 0 <= i <= length sp }
      invariant { mod i 3 = 0 }
      invariant { length r = div (i * 4) 3 }
      invariant { forall j. 0 <= j < i - 2 ->
        let a1, a2, a3 = sp[j*3], sp[j*3+1], sp[j*3+2] in
        let b1, b2, b3, b4 = r[j*4], r[j*4+1], r[j*4+2], r[j*4+3] in
        b1 = chr (div (code a1)  4) &&
        b2 = chr (mod (code a1) 4 * 16 + div (code a2) 16) &&
        b3 = chr (mod (code a2) 16 * 4 + div (code a3) 64) &&
        b4 = chr (mod (code a3) 64) }
      let c1,c2,c3 = sp[i], sp[i+1], sp[i+2] in
      let b1 = code c1 / 4 in
      let b2 = (code c1 % 4) * 16 + code c2 / 16 in
      let b3 = (code c2 % 16) * 4 + code c3 / 64 in
      let b4 = code c3 % 64 in
      r <- concat r (chr b1).content;
      assert { r[length r - 1] = chr (div (code c1) 4) };
      r <- concat r (chr b2).content;
      assert { r[length r - 1] = chr (mod (code c1) 4 * 16 + div (code c2) 16) };
      r <- concat r (chr b3).content;
      assert { r[length r - 1] = chr (mod (code c2) 16 * 4 + div (code c3) 64) };
      r <- concat r (chr b4).content;
      assert { r[length r - 1] = chr (mod (code c3) 64) };
      i <- i + 3
    done;
    r (* TODO padding *)

end