
module AssocList

  use list.List
  use option.Option

  type assoc 'a 'b = list ('a,'b)

  function add (x: 'a) (y: 'b) (l: assoc 'a 'b) : assoc 'a 'b =
    Cons (x,y) l

  function get_fst (x: 'a) (l: assoc 'a 'b) : option 'b =
    match l with
    | Cons (x',y) l' -> if x = x' then Some y else get_fst x l'
    | Nil -> None
    end

  function get_snd (y: 'b) (l: assoc 'a 'b) : option 'a =
    match l with
    | Cons (x,y') l' -> if y = y' then Some x else get_snd y l'
    | Nil -> None
    end

end

module Hex

  (* constant h0 : string = "0" *)
  (* constant h1 : string = "1" *)
  (* constant h2 : string = "2" *)
  (* constant h3 : string = "3" *)
  (* constant h4 : string = "4" *)
  (* constant h5 : string = "5" *)
  (* constant h6 : string = "6" *)
  (* constant h7 : string = "7" *)
  (* constant h8 : string = "8" *)
  (* constant h9 : string = "9" *)
  (* constant hA : string = "A" *)
  (* constant hB : string = "B" *)
  (* constant hC : string = "C" *)
  (* constant hD : string = "D" *)
  (* constant hE : string = "E" *)
  (* constant hF : string = "F" *)

  (* let to_hex (n : int) : Char.char = *)
  (*   requires { n >= 0 && n < 16 } *)
  (*   if n < 10 then chr (n + code (get "0" 0)) else chr (n + 55) *)

  (* let encode (n: int) : string = *)
  (*   requires { n >= 0 } *)
  (*   let h = ref "" in *)
  (*   let x = ref n in *)
  (*   while !x > 15 do *)
  (*     let r = mod !x 16 in *)
  (*     h := h  *)

  use mach.int.Int
  use mach.int.Int63
  use string.OCaml
  use string.Char
  use ref.Ref

  (* lemma get_content: forall s. *)
  (*   length s = 1 -> s[0].content = s *)

  (* lemma concat_char_length: forall s c. *)
  (*   length (concat s c.content) = length s + 1 *)

  (* lemma get_content3: forall c1 c2. c1 = c2 <-> c1.content = c2.content *)

  (* lemma get_content2: forall s c. *)
  (*   let r = concat s c.content in *)
  (*   length r = length s + 1 && r[length s] = c *)

  let function encode (s: string) : string
    requires { length s < max_int } (* maybe div max_ind 2 *)
    ensures { length result = 2 * length s }
    ensures { forall i. 0 <= i < length s ->
                result[2 * i] = Char.chr (div (code s[i]) 16) &&
                result[2 * i + 1] = Char.chr (mod (code s[i]) 16) }
  = let i = ref 0 in
    let r = ref "" in
    while !i < OCaml.length s do
      variant { length s - !i }
      invariant { 0 <= !i <= OCaml.length s }
      invariant { length !r = 2 * !i }
      invariant { forall j. 0 <= j < !i  ->
                    !r[2 * j] = Char.chr (div (code s[j]) 16) &&
                    !r[2 * j + 1] = Char.chr (mod (code s[j]) 16) }
      let v = code s[!i] in
      r := concat !r (chr (v / 16)).content;
      (* assert { !r[!i] = chr (div v 16) }; *)
      r := concat !r (chr (v % 16)).content;
      i := !i + 1
    done;
    !r

  (* val function decode (s: string) : string *)
  (*   requires { mod (length s) 2 = 0 } *)
  (*   ensures  { length result = div (length s) 2 } *)
  (*   ensures  { forall i. 0 <= i < div (length s) 2 -> *)
  (*                get result i = Char.chr (code (get s (2 * i)) * 16 + *)
  (*                                    code (get s (2 * i + 1))) } *)

  (* lemma decode_encode: forall s. decode (encode s) = s *)

  (* let id (s: string): string *)
  (*   ensures { result = s } *)
  (* = decode (encode s) *)

  (* let test1 () = let x = rev "" in assert {x = ""} *)
  (* let test2 () = let x = rev "a" in assert {x = "a"} *)
  (* let test3 () = let x = rev "ab" in assert {x = "ba"} *)
  (* let test4 () = let x = rev "abc" in assert {x = "cba"} *)
  (* let test5 () = let x = rev "abcd" in assert {x = "dcba"} *)

end

module Test

  use string.Char

  goal G1: forall c:char. chr (code c) = c

end