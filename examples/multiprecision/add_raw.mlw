module Raw

  use mach.c.C
  use lemmas.Lemmas
  use int.Int
  use mach.int.Int32
  use import mach.int.UInt64GMP as Limb
  use types.Types
  use map.Map
  use array.Array


  type raw_ptr = abstract { addr : int;
                            ofs : int;
                            len : int;
                            min : int;
                            max : int;
                   mutable zone : zone }
                 invariant { 0 <= min <= ofs <= max <= len /\ 0 <= addr }

  val raw_null () : raw_ptr
    ensures { result.addr = 0 /\ result.len = 0 /\ result.zone = null_zone}
  (* FIXME: ensures not in the task if raw_null has 0 arguments? *)

  (* FIXME: cannot make memslice abstract or the setters fail typing? *)
  type memslice = { data : array limb;
                       r : raw_ptr;
                       x : raw_ptr;
                       y : raw_ptr }
                  invariant { 0 <= r.addr + r.len <= data.length
                              /\ 0 <= x.addr + x.len <= data.length
                              /\ 0 <= y.addr + y.len <= data.length }
                  by { data = make 0 0; r = raw_null ();
                       x = raw_null (); y = raw_null () }

  function mvalue_sub (m:memslice) (addr1 addr2:int) : int
    = value_sub m.data.elts addr1 addr2

  function mvalue_r (m:memslice) (sz:int) : int
    = mvalue_sub m (m.r.addr + m.r.ofs) (m.r.addr + m.r.ofs + sz)

  function mvalue_x (m:memslice) (sz:int) : int
    = mvalue_sub m (m.x.addr + m.x.ofs) (m.x.addr + m.x.ofs + sz)

  function mvalue_y (m:memslice) (sz:int) : int
    = mvalue_sub m (m.y.addr + m.y.ofs) (m.y.addr + m.y.ofs + sz)

  predicate valid_raw (p:raw_ptr) (sz:int) =
    in_bounds sz /\ 0 <= sz /\ 0 <= p.min <= p.ofs
    /\ p.ofs + sz <= p.max <= len p

  predicate separated (a b:raw_ptr) =
    a.addr + a.len <= b.addr \/ b.addr + b.len <= a.addr

  predicate all_separated (m:memslice) =
    separated m.r m.x /\ separated m.r m.y /\ separated m.x m.y

  predicate conform (x:ptr limb) (raw:raw_ptr) =
    raw.ofs = x.offset /\ raw.len = plength x
    /\ raw.min = x.C.min /\ raw.max = x.C.max /\ raw.zone = x.C.zone
(*
  val get_x (m:memslice) : limb
    requires { m.x.min <= m.x.ofs <= m.x.max }
    ensures { result = m.data[m.x.addr + m.x.ofs] }

  val get_y (m:memslice) : limb
    requires { m.y.min <= m.y.ofs <= m.y.max }
    ensures { result = m.data[m.y.addr + m.y.ofs] }

  val get_r (m:memslice) : limb
    requires { m.r.min <= m.r.ofs <= m.r.max }
    ensures { result = m.data[m.r.addr + m.r.ofs] }
*)
  val get_x_ofs (m:memslice) (ofs:int32) : limb
    requires { m.x.min <= m.x.ofs + ofs <= m.x.max }
    ensures { result = m.data[m.x.addr + m.x.ofs + ofs] }

  val get_y_ofs (m:memslice) (ofs:int32) : limb
    requires { m.y.min <= m.y.ofs + ofs <= m.y.max }
    ensures { result = m.data[m.y.addr + m.y.ofs + ofs] }

  val get_r_ofs (m:memslice) (ofs:int32) : limb
    requires { m.r.min <= m.r.ofs + ofs <= m.r.max }
    ensures { result = m.data[m.r.addr + m.r.ofs + ofs] }

  val set_r_ofs (m:memslice) (ofs:int32) (v:limb) : unit
    requires { m.r.min <= m.r.ofs + ofs <= m.r.max }
    writes { m.data.elts }
    ensures { m.data.elts = Map.set (old m.data.elts)
                                    (m.r.addr + m.r.ofs + ofs) v }

  val open_sep (r x y:ptr limb) : memslice
    requires { writable r }
    requires { valid r 0 /\ valid x 0 /\ valid y 0 }
    writes { r.C.max, r.C.data, x.C.max, x.C.data, y.C.max, y.C.data }
    ensures { plength r = old plength r /\ plength x = old plength x
              /\ plength y = old plength y }
    ensures { separated result.r result.x /\ separated result.r result.y }
    ensures { conform (old r) result.r /\ conform (old x) result.x
              /\ conform (old y) result.y }
    ensures { map_eq_sub_shift result.data.elts (old pelts r)
              result.r.addr 0 (plength r) }
    ensures { map_eq_sub_shift result.data.elts (old pelts x)
              result.x.addr 0 (plength x) }
    ensures { map_eq_sub_shift result.data.elts (old pelts y)
              result.y.addr 0 (plength y) }

  val open_rx (r y: ptr limb) : memslice
    requires { writable r }
    requires { valid r 0 /\ valid y 0 }
    writes { r.C.max, r.C.data, y.C.max, y.C.data }
    ensures { plength r = old plength r
              /\ plength y = old plength y }
    ensures { separated result.r result.y }
    ensures { result.r = result.x }
    ensures { conform (old r) result.r
              /\ conform (old y) result.y }
    ensures { map_eq_sub_shift result.data.elts (old pelts r)
              result.r.addr 0 (plength r) }
    ensures { map_eq_sub_shift result.data.elts (old pelts y)
              result.y.addr 0 (plength y) }

  val open_ry (r x: ptr limb) : memslice
    requires { writable r }
    requires { valid r 0 /\ valid x 0 }
    writes { r.C.max, r.C.data, x.C.max, x.C.data }
    ensures { plength r = old plength r
              /\ plength x = old plength x }
    ensures { separated result.r result.x }
    ensures { result.r = result.y }
    ensures { conform (old r) result.r
              /\ conform (old x) result.x }
    ensures { map_eq_sub_shift result.data.elts (old pelts r)
              result.r.addr 0 (plength r) }
    ensures { map_eq_sub_shift result.data.elts (old pelts x)
              result.x.addr 0 (plength x) }

  val open_rxy (x:ptr limb) : memslice
    requires { writable x }
    requires { valid x 0 }
    writes { x.C.max, x.C.data }
    ensures { plength x = old plength x }
    ensures { result.r = result.x = result.y }
    ensures { conform (old x) result.x }
    ensures { map_eq_sub_shift result.data.elts (old pelts x)
              result.x.addr 0 (plength x) }

  val close_sep (r x y:ptr limb) (m:memslice) : unit
    requires { writable r }
    requires { C.zone r = m.r.zone /\ C.zone x = m.x.zone
               /\ C.zone y = m.y.zone }
    writes   { r.C.max, r.C.data, x.C.max, x.C.data, y.C.max, y.C.data,
               m.data, m.r, m.x, m.y }
    ensures  { conform r (old m).r /\ conform x (old m).r
               /\ conform y (old m).y }
    ensures  { plength r = old plength r /\ plength x = old plength x
               /\ plength y = old plength y }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts r)
               (old m).r.addr 0 (plength r) }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts x)
               (old m).x.addr 0 (plength x) }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts y)
               (old m).y.addr 0 (plength y) }

  val close_rx (r y:ptr limb) (m:memslice) : unit
    requires { writable r }
    requires { C.zone r = m.r.zone /\ C.zone y = m.y.zone }
    writes   { r.C.max, r.C.data, y.C.max, y.C.data, m.data, m.r, m.x, m.y }
    ensures  { conform r (old m).r /\ conform y (old m).y }
    ensures  { plength r = old plength r /\ plength y = old plength y }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts r)
               (old m).r.addr 0 (plength r) }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts y)
               (old m).y.addr 0 (plength y) }

  val close_ry (r x:ptr limb) (m:memslice) : unit
    requires { writable r }
    requires { C.zone r = m.r.zone /\ C.zone x = m.x.zone }
    writes   { r.C.max, r.C.data, x.C.max, x.C.data, m.data, m.r, m.x, m.y }
    ensures  { conform r (old m).r /\ conform x (old m).x }
    ensures  { plength r = old plength r /\ plength x = old plength x }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts r)
               (old m).r.addr 0 (plength r) }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts x)
               (old m).x.addr 0 (plength x) }

  val close_rxy (x:ptr limb) (m:memslice) : unit
    requires { writable x }
    requires { C.zone x = m.x.zone }
    writes   { x.C.max, x.C.data, m.data, m.r, m.x, m.y }
    ensures  { conform x (old m).x }
    ensures  { plength x = old plength x }
    ensures  { map_eq_sub_shift (old m).data.elts (pelts x)
               (old m).x.addr 0 (plength x) }

end

module TestRaw

  use map.Map
  use map.MapEq
  use lemmas.Lemmas
  use mach.c.C
  use Raw
  use types.Types

  let id (r x y: ptr limb)
    requires { writable r /\ writable x /\ writable y }
    requires { valid r 0 /\ valid x 0 /\ valid y 0 }
    ensures  { map_eq_sub (pelts r) (old pelts r) 0 (plength r)
               /\ map_eq_sub (pelts x) (old pelts x) 0 (plength x)
               /\ map_eq_sub (pelts y) (old pelts y) 0 (plength y) }
    ensures  { plength r = old plength r /\ plength y = old plength y
               /\ plength x = old plength x }
  =
    let m = open_sep r x y in
    close_sep r x y m;
    let m' = open_rx r y in
    close_rx r y m';
    close_rxy x (open_rxy x);
    close_rxy y (open_rxy y)

(*

  let double_open (r x y: ptr limb
    requires { valid r 0 /\ valid x 0 /\ valid y 0 }
  =
    let m = open_sep r x y in
    let m' = open_sep r x y in (* invalid precondition valid _ 0 *)
    close_sep r x y m

  let double_free (r x y: ptr limb)
    requires { writable r }
    requires { valid r 0 /\ valid x 0 /\ valid y 0 }
  =
    let m = open_sep r x y in
    close_sep r x y m;
    close_sep r x y m (* invalid precondition on zones *)

  let use_after_open (r x y: ptr limb)
    requires { valid x 1 }
  =
    let x' = incr x 0 in
    let m = open_sep r x y in
    let a = C.get x' in (* Illegal alias *)
    close_sep r x y m
*)

end

module Add_raw

  use int.Int
  use mach.int.Int32
  use import mach.int.UInt64GMP as Limb
  use int.Power
  use ref.Ref
  use mach.c.C
  use array.Array
  use map.Map
  use map.MapEq
  use types.Types
  use lemmas.Lemmas
  use Raw

  let add_raw_n (m:memslice) (sz:int32) : limb
    requires { 0 <= sz }
    requires { valid_raw m.r sz /\ valid_raw m.x sz /\ valid_raw m.y sz }
    requires { m.r = m.x \/ separated m.r m.x }
    requires { m.r = m.y \/ separated m.r m.y }
    ensures  { mvalue_r m sz + power radix sz * result
               = old (mvalue_x m sz + mvalue_y m sz) }
    ensures  { 0 <= result <= 1 }
    ensures  { forall j. j < m.r.addr + m.r.ofs \/ m.r.addr + m.r.ofs + sz <= j
               -> m.data.elts[j] = old m.data.elts[j] }
  =
    label Start in
    let ref lx = 0 in
    let ref ly = 0 in
    let ref c = 0 in
    let ref i = 0 in
    let om = pure { m } in
    while i < sz do
      variant { sz - i }
      invariant { 0 <= i <= sz }
      invariant { mvalue_r m i + power radix i * c
                  = mvalue_x om i + mvalue_y om i }
      invariant { forall j. j < m.r.addr + m.r.ofs
                            \/ m.r.addr + m.r.ofs + i <= j
                   -> m.data.elts[j] = old m.data.elts[j] }
      invariant { 0 <= c <= 1 }
      label StartLoop in
      lx <- get_x_ofs m i;
      ly <- get_y_ofs m i;
      let ghost olx = get_x_ofs om i in
      let ghost oly = get_y_ofs om i in
      assert { olx = lx };
      assert { oly = ly };
      let res, carry = add_with_carry lx ly c in
      value_sub_update_no_change m.data.elts (m.r.addr + m.r.ofs + int32'int i)
         (m.r.addr + m.r.ofs) (m.r.addr + m.r.ofs + int32'int i) res;
      set_r_ofs m i res;
      assert { mvalue_r m i = mvalue_r m i at StartLoop };
      assert { mvalue_r m i + power radix i * c
                  = (mvalue_x m i + mvalue_y m i) at Start };
      c <- carry;
      value_sub_tail m.data.elts (m.r.addr + m.r.ofs)
                                 (m.r.addr + m.r.ofs + int32'int i);
      value_sub_tail om.data.elts (om.x.addr + om.x.ofs)
                                  (om.x.addr + om.x.ofs + int32'int i);
      value_sub_tail om.data.elts (om.y.addr + om.y.ofs)
                                  (om.y.addr + om.y.ofs + int32'int i);
      assert { mvalue_x om (i+1) = mvalue_x om i + power radix i * lx };
      assert { mvalue_y om (i+1) = mvalue_y om i + power radix i * ly };
      assert { mvalue_r m (i+1) = mvalue_r m i + power radix i * res };
      assert { mvalue_r m (i+1) + power radix (i+1) * c
               = mvalue_x om (i+1) + mvalue_y om (i+1) };
      i <- i+1;
    done;
    c

  let add_raw (m:memslice) (sx sy:int32) : limb
    requires { 0 <= sy <= sx }
    requires { valid_raw m.r sx /\ valid_raw m.x sx /\ valid_raw m.y sy }
    requires { m.r = m.x \/ separated m.r m.x }
    requires { m.r = m.y \/ separated m.r m.y }
    ensures  { mvalue_r m sx + power radix sx * result
               = old (mvalue_x m sx + mvalue_y m sy) }
    ensures  { 0 <= result <= 1 }
    ensures  { forall j. j < m.r.addr + m.r.ofs \/ m.r.addr + m.r.ofs + sx <= j
               -> m.data.elts[j] = old m.data.elts[j] }
  (*  ensures  { m.r = m.x \/ mvalue_x m sx = old mvalue_x m sx } *)
  =
    label Start in
    let ref lx = 0 in
    let om = pure { m } in
    let ref c = add_raw_n m sy in
    assert { mvalue_r m sy + power radix sy * c
             = mvalue_x om sy + mvalue_y om sy };
    let ref i = sy in
    if (c <> 0)
    then begin
      while i < sx do
        variant { sx - i }
        invariant { sy <= i <= sx }
        invariant { mvalue_r m i + power radix i * c
                    = mvalue_x om i + mvalue_y om sy }
        invariant { forall j. j < m.r.addr + m.r.ofs
                              \/ m.r.addr + m.r.ofs + i <= j
                     -> m.data.elts[j] = old m.data.elts[j] }
        invariant { 0 <= c <= 1 }
        invariant { i = sx \/ c = 1 }
        label StartLoop in
        assert { c = 1 };
        lx <- get_x_ofs m i;
        let ghost olx = get_x_ofs om i in
        assert { olx = lx };
        let res = add_mod lx 1 in
        value_sub_update_no_change m.data.elts
          (m.r.addr + m.r.ofs + int32'int i)
          (m.r.addr + m.r.ofs) (m.r.addr + m.r.ofs + int32'int i) res;
        set_r_ofs m i res;
        assert { mvalue_r m i = mvalue_r m i at StartLoop };
        assert { mvalue_r m i + power radix i * c
                 = mvalue_x om i + mvalue_y om sy };
        value_sub_tail m.data.elts (m.r.addr + m.r.ofs)
                                   (m.r.addr + m.r.ofs + int32'int i);
        value_sub_tail om.data.elts (om.x.addr + om.x.ofs)
                                    (om.x.addr + om.x.ofs + int32'int i);
        assert { mvalue_x om (i+1) = mvalue_x om i + power radix i * lx };
        assert { mvalue_r m (i+1) = mvalue_r m i + power radix i * res };
        i <- i+1;
        if res <> 0
        then begin
          c <- 0;
          assert { res = lx + 1 };
          assert { mvalue_r m i = mvalue_x om i + mvalue_y om sy };
          break
        end
        else begin
          assert { lx + 1 = radix };
          assert { mvalue_r m i + power radix i * c
                   = mvalue_x om i + mvalue_y om sy };
        end
      done
    end;
    while i < sx do
      variant { sx - i }
      invariant { sy <= i <= sx }
      invariant { i = sx \/ c = 0 }
      invariant { mvalue_r m i + power radix i * c
                  = mvalue_x om i + mvalue_y om sy }
      invariant { forall j. j < m.r.addr + m.r.ofs
                              \/ m.r.addr + m.r.ofs + i <= j
                     -> m.data.elts[j] = old m.data.elts[j] }
      label StartLoop2 in
      assert { c = 0 by i < sx };
      lx <- get_x_ofs m i;
      let ghost olx = get_x_ofs om i in
      assert { olx = lx };
      value_sub_update_no_change m.data.elts
        (m.r.addr + m.r.ofs + int32'int i)
        (m.r.addr + m.r.ofs) (m.r.addr + m.r.ofs + int32'int i) lx;
      set_r_ofs m i lx;
      assert { mvalue_r m i = mvalue_r m i at StartLoop2 };
      assert { mvalue_r m i + power radix i * c
               = (mvalue_x m i + mvalue_y m sy) at Start };
      value_sub_tail m.data.elts (m.r.addr + m.r.ofs)
                                 (m.r.addr + m.r.ofs + int32'int i);
      value_sub_tail om.data.elts (om.x.addr + om.x.ofs)
                                  (om.x.addr + om.x.ofs + int32'int i);
      assert { mvalue_r m (i+1) = mvalue_r m i + power radix i * lx };
      assert { mvalue_r m i = mvalue_x om i + mvalue_y om sy };
      assert { mvalue_r m (i+1) + power radix (i+1) * c
               = mvalue_x om (i+1) + mvalue_y om sy };
      i <- i + 1;
    done;
    c

  let lemma map_eq_sub_shift_w (x y: map int 'a) (xi1 xi2 yi1 yi2 sz1 sz2:int)
    requires { map_eq_sub_shift x y xi1 yi1 sz1 }
    requires { xi1 <= xi2 /\ xi2 + sz2 <= xi1 + sz1 }
    requires { yi1 <= yi2 /\ yi2 + sz2 <= yi1 + sz1 }
    requires { xi2 - xi1 = yi2 - yi1 }
    ensures  { map_eq_sub_shift x y xi2 yi2 sz2 }
  = assert { forall i. 0 <= i < sz2 -> x[xi2 + i] = y[yi2 + i]
             by let j = (xi2 + i) - xi1 in
                j >= i >= 0
             so j < xi2 + sz2 - xi1 <= sz1
             so x[xi1 + j] = y[yi1 + j]
             so xi1 + j = xi2 + i
             so j = yi2 - yi1 + i
             so yi1 + j = yi2 + i }

  let wmpn_add (rp xp:ptr limb) (sx:int32) (yp:ptr limb) (sy:int32) : limb
    requires { 0 <= sy <= sx }
    requires { valid xp sx }
    requires { valid yp sy }
    requires { valid rp sx }
    requires { writable rp }
    ensures { value xp sx = old value xp sx }
    ensures { value yp sy = old value yp sy }
    ensures { value rp sx + (power radix sx) * result =
              value xp sx + value yp sy }
    ensures { forall j. (0 <= j < offset rp \/ offset rp + sx <= j < plength rp)
              -> (pelts rp)[j] = old (pelts rp)[j] }
    ensures { forall j. (0 <= j < plength xp)
              -> (pelts xp)[j] = old (pelts xp)[j] }
    ensures { forall j. (0 <= j < plength yp)
              -> (pelts yp)[j] = old (pelts yp)[j] }
    ensures { 0 <= result <= 1 }
  =
    let ox = pure { xp } in
    let oy = pure { yp } in
    let or = pure { rp } in
    let m = open_sep rp xp yp in
    assert { separated m.r m.x /\ separated m.r m.y };
    let om = pure { m } in
    let res = add_raw m sx sy in
    assert { map_eq_sub m.data.elts om.data.elts
               m.x.addr (m.x.addr + m.x.len) };
    assert { map_eq_sub m.data.elts om.data.elts
               m.y.addr (m.y.addr + m.y.len) };
    let cm = pure { m } in
    label Close in
    close_sep rp xp yp m;
    assert { forall j. 0 <= j < plength xp ->
                    (pelts xp)[j] = (cm.data.elts)[cm.x.addr + j]
                                  = (om.data.elts)[om.x.addr + j]
                                  = (pelts ox)[j]
                     by separated om.x om.r };
    value_sub_frame (pelts xp) (pelts ox)
                    (offset xp) (offset xp + int32'int sx);
    assert { value xp sx = value ox sx };
    assert { forall j. 0 <= j < plength yp ->
                    (pelts yp)[j] = (cm.data.elts)[cm.y.addr + j]
                                  = (om.data.elts)[om.y.addr + j]
                                  = (pelts oy)[j]
                     by separated om.y om.r };
    value_sub_frame (pelts yp) (pelts oy)
                    (offset yp) (offset yp + int32'int sy);
    assert { value yp sy = value oy sy };
    assert { forall j. 0 <= j < offset rp \/ offset rp + sx <= j < plength rp ->
                    (pelts rp)[j] = (cm.data.elts)[cm.r.addr + j]
                                  = (om.data.elts)[om.r.addr + j]
                                  = (pelts or)[j] };
    map_eq_sub_shift_w (pelts ox) om.data.elts 0 xp.offset
                          om.x.addr (om.x.addr + om.x.ofs)
                          (plength ox) (int32'int sx);
    map_eq_sub_shift_w (pelts oy) om.data.elts 0 oy.offset
                          om.y.addr (om.y.addr + om.y.ofs)
                          (plength oy) (int32'int sy);
    map_eq_sub_shift_w (pelts rp) cm.data.elts 0 rp.offset
                          cm.r.addr (cm.r.addr + cm.r.ofs)
                          (plength rp) (int32'int sx);
    value_sub_frame_shift (pelts ox) om.data.elts ox.offset
                          (om.x.addr + om.x.ofs) (int32'int sx);
    value_sub_frame_shift (pelts oy) om.data.elts oy.offset
                          (om.y.addr + om.y.ofs) (int32'int sy);
    value_sub_frame_shift (pelts rp) cm.data.elts rp.offset
                          (cm.r.addr + cm.r.ofs) (int32'int sx);
    assert { value ox sx = mvalue_x om sx };
    assert { value oy sy = mvalue_y om sy };
    assert { value rp sx = mvalue_r m sx at Close };
    assert { value rp sx + power radix sx * res
             = value xp sx + value yp sy };
    res


  let wmpn_add_rx (xp:ptr limb) (sx:int32) (yp:ptr limb) (sy:int32) : limb
    requires { 0 <= sy <= sx }
    requires { valid xp sx }
    requires { valid yp sy }
    requires { writable xp }
    ensures { value yp sy = old value yp sy }
    ensures { value xp sx + (power radix sx) * result =
              value (old xp) sx + value yp sy }
    ensures { forall j. (0 <= j < offset xp \/ offset xp + sx <= j < plength xp)
              -> (pelts xp)[j] = old (pelts xp)[j] }
    ensures { forall j. (0 <= j < plength yp)
              -> (pelts yp)[j] = old (pelts yp)[j] }
    ensures { 0 <= result <= 1 }
  =
    let ox = pure { xp } in
    let oy = pure { yp } in
    let m = open_rx xp yp in
    assert { separated m.r m.y };
    let om = pure { m } in
    let res = add_raw m sx sy in
    assert { map_eq_sub m.data.elts om.data.elts
               m.y.addr (m.y.addr + m.y.len) };
    let cm = pure { m } in
    label Close in
    close_rx xp yp m;
    assert { forall j. 0 <= j < plength yp ->
                    (pelts yp)[j] = (cm.data.elts)[cm.y.addr + j]
                                  = (om.data.elts)[om.y.addr + j]
                                  = (pelts oy)[j]
                     by separated om.y om.r };
    value_sub_frame (pelts yp) (pelts oy)
                    (offset yp) (offset yp + int32'int sy);
    assert { value yp sy = value oy sy };
    assert { forall j. 0 <= j < offset xp \/ offset xp + sx <= j < plength xp ->
                    (pelts xp)[j] = (cm.data.elts)[cm.r.addr + j]
                                  = (om.data.elts)[om.r.addr + j]
                                  = (pelts ox)[j] };
    map_eq_sub_shift_w (pelts xp) cm.data.elts 0 xp.offset
                          cm.x.addr (cm.x.addr + cm.x.ofs)
                          (plength xp) (int32'int sx);
    map_eq_sub_shift_w (pelts oy) om.data.elts 0 oy.offset
                          om.y.addr (om.y.addr + om.y.ofs)
                          (plength oy) (int32'int sy);
    map_eq_sub_shift_w (pelts ox) om.data.elts 0 ox.offset
                          om.x.addr (om.x.addr + om.x.ofs)
                          (plength ox) (int32'int sx);
    value_sub_frame_shift (pelts xp) cm.data.elts xp.offset
                          (cm.x.addr + cm.x.ofs) (int32'int sx);
    value_sub_frame_shift (pelts oy) om.data.elts oy.offset
                          (om.y.addr + om.y.ofs) (int32'int sy);
    value_sub_frame_shift (pelts ox) om.data.elts ox.offset
                          (om.x.addr + om.x.ofs) (int32'int sx);
    assert { value xp sx + power radix sx * res = value ox sx + value yp sy };
    res

  let wmpn_add_ry (xp:ptr limb) (sx:int32) (yp:ptr limb) (sy:int32) : limb
    requires { 0 <= sy <= sx }
    requires { valid xp sx }
    requires { valid yp sx }
    requires { writable yp }
    ensures { value xp sx = old value xp sx }
    ensures { value yp sx + power radix sx * result
               = value xp sx + value (old yp) sy }
    ensures { forall j. (0 <= j < offset yp \/ offset yp + sx <= j < plength yp)
              -> (pelts yp)[j] = old (pelts yp)[j] }
    ensures { forall j. 0 <= j < plength xp ->
                 (pelts xp)[j] = old (pelts xp)[j] }
    ensures { 0 <= result <= 1 }
  =
    let ox = pure { xp } in
    let oy = pure { yp } in
    let m = open_ry yp xp in
    assert { separated m.r m.x };
    let om = pure { m } in
    let res = add_raw m sx sy in
    assert { map_eq_sub m.data.elts om.data.elts
               m.x.addr (m.x.addr + m.x.len) };
    let cm = pure { m } in
    label Close in
    close_ry yp xp m;
    assert { forall j. 0 <= j < plength xp ->
                    (pelts xp)[j] = (cm.data.elts)[cm.x.addr + j]
                                  = (om.data.elts)[om.x.addr + j]
                                  = (pelts ox)[j] };
    value_sub_frame (pelts xp) (pelts ox)
                    (offset xp) (offset xp + int32'int sx);
    assert { value xp sx = value ox sx };
    assert { forall j. 0 <= j < offset yp \/ offset yp + sx <= j < plength yp ->
                    (pelts yp)[j] = (cm.data.elts)[cm.r.addr + j]
                                  = (om.data.elts)[om.r.addr + j]
                                  = (pelts oy)[j] };
    map_eq_sub_shift_w (pelts yp) cm.data.elts 0 yp.offset
                          cm.y.addr (cm.y.addr + cm.y.ofs)
                          (plength yp) (int32'int sx);
    map_eq_sub_shift_w (pelts oy) om.data.elts 0 oy.offset
                          om.y.addr (om.y.addr + om.y.ofs)
                          (plength oy) (int32'int sy);
    map_eq_sub_shift_w (pelts ox) om.data.elts 0 ox.offset
                          om.x.addr (om.x.addr + om.x.ofs)
                          (plength ox) (int32'int sx);
    value_sub_frame_shift (pelts yp) cm.data.elts yp.offset
                          (cm.y.addr + cm.y.ofs) (int32'int sx);
    value_sub_frame_shift (pelts oy) om.data.elts oy.offset
                          (om.y.addr + om.y.ofs) (int32'int sy);
    value_sub_frame_shift (pelts ox) om.data.elts ox.offset
                          (om.x.addr + om.x.ofs) (int32'int sx);
    assert { value yp sx + power radix sx * res = value xp sx + value oy sy };
    res

  let wmpn_add_rxy (xp:ptr limb) (sx:int32) : limb
    requires { 0 <= sx }
    requires { valid xp sx }
    requires { writable xp }
    ensures { value xp sx + power radix sx * result
               = old (value xp sx + value xp sx) }
    ensures { forall j. (0 <= j < offset xp \/ offset xp + sx <= j < plength xp)
              -> (pelts xp)[j] = old (pelts xp)[j] }
    ensures { 0 <= result <= 1 }
  = let ox = pure { xp } in
    let m = open_rxy xp in
    let om = pure { m } in
    let res = add_raw_n m sx in
    let cm = pure { m } in
    label Close in
    close_rxy xp m;
    assert { forall j. 0 <= j < offset xp \/ offset xp + sx <= j < plength xp ->
                    (pelts xp)[j] = (cm.data.elts)[cm.r.addr + j]
                                  = (om.data.elts)[om.r.addr + j]
                                  = (pelts ox)[j] };
    map_eq_sub_shift_w (pelts xp) cm.data.elts 0 xp.offset
                          cm.x.addr (cm.x.addr + cm.x.ofs)
                          (plength xp) (int32'int sx);
    map_eq_sub_shift_w (pelts ox) om.data.elts 0 ox.offset
                          om.x.addr (om.x.addr + om.x.ofs)
                          (plength ox) (int32'int sx);
    value_sub_frame_shift (pelts xp) cm.data.elts xp.offset
                          (cm.x.addr + cm.x.ofs) (int32'int sx);
    value_sub_frame_shift (pelts ox) om.data.elts ox.offset
                          (om.x.addr + om.x.ofs) (int32'int sx);
    res

  let wmpn_add_n (rp xp yp:ptr limb) (sz:int32) : limb
    requires { 0 <= sz }
    requires { valid rp sz }
    requires { valid xp sz }
    requires { valid yp sz }
    requires { writable rp }
    ensures { value xp sz = old value xp sz }
    ensures { value yp sz = old value yp sz }
    ensures { value rp sz + power radix sz * result
              = value xp sz + value yp sz }
    ensures { forall j. (0 <= j < offset rp \/ offset rp + sz <= j < plength rp)
              -> (pelts rp)[j] = old (pelts rp)[j] }
    ensures { forall j. (0 <= j < plength xp)
              -> (pelts xp)[j] = old (pelts xp)[j] }
    ensures { forall j. (0 <= j < plength yp)
              -> (pelts yp)[j] = old (pelts yp)[j] }
    ensures { 0 <= result <= 1 }
  =
    let ox = pure { xp } in
    let oy = pure { yp } in
    let or = pure { rp } in
    let m = open_sep rp xp yp in
    let om = pure { m } in
    let res = add_raw_n m sz in
    assert { map_eq_sub m.data.elts om.data.elts
               m.x.addr (m.x.addr + m.x.len) };
    assert { map_eq_sub m.data.elts om.data.elts
               m.y.addr (m.y.addr + m.y.len) };
    let cm = pure { m } in
    label Close in
    close_sep rp xp yp m;
    assert { forall j. 0 <= j < plength xp ->
                    (pelts xp)[j] = (cm.data.elts)[cm.x.addr + j]
                                  = (om.data.elts)[om.x.addr + j]
                                  = (pelts ox)[j]
                     by separated om.x om.r };
    value_sub_frame (pelts xp) (pelts ox)
                    (offset xp) (offset xp + int32'int sz);
    assert { value xp sz = value ox sz };
    assert { forall j. 0 <= j < plength yp ->
                    (pelts yp)[j] = (cm.data.elts)[cm.y.addr + j]
                                  = (om.data.elts)[om.y.addr + j]
                                  = (pelts oy)[j]
                     by separated om.y om.r };
    value_sub_frame (pelts yp) (pelts oy)
                    (offset yp) (offset yp + int32'int sz);
    assert { value yp sz = value oy sz };
    assert { forall j. 0 <= j < offset rp \/ offset rp + sz <= j < plength rp ->
                    (pelts rp)[j] = (cm.data.elts)[cm.r.addr + j]
                                  = (om.data.elts)[om.r.addr + j]
                                  = (pelts or)[j] };
    map_eq_sub_shift_w (pelts ox) om.data.elts 0 xp.offset
                          om.x.addr (om.x.addr + om.x.ofs)
                          (plength ox) (int32'int sz);
    map_eq_sub_shift_w (pelts oy) om.data.elts 0 oy.offset
                          om.y.addr (om.y.addr + om.y.ofs)
                          (plength oy) (int32'int sz);
    map_eq_sub_shift_w (pelts rp) cm.data.elts 0 rp.offset
                          cm.r.addr (cm.r.addr + cm.r.ofs)
                          (plength rp) (int32'int sz);
    value_sub_frame_shift (pelts ox) om.data.elts ox.offset
                          (om.x.addr + om.x.ofs) (int32'int sz);
    value_sub_frame_shift (pelts oy) om.data.elts oy.offset
                          (om.y.addr + om.y.ofs) (int32'int sz);
    value_sub_frame_shift (pelts rp) cm.data.elts rp.offset
                          (cm.r.addr + cm.r.ofs) (int32'int sz);
    assert { value rp sz + power radix sz * res
             = value xp sz + value yp sz };
    res

  let wmpn_add_n_rx (xp yp:ptr limb) (sz:int32) : limb
    requires { 0 <= sz }
    requires { valid xp sz }
    requires { valid yp sz }
    requires { writable xp }
    ensures { value yp sz = old value yp sz }
    ensures { value xp sz + (power radix sz) * result =
              value (old xp) sz + value yp sz }
    ensures { forall j. (0 <= j < offset xp \/ offset xp + sz <= j < plength xp)
              -> (pelts xp)[j] = old (pelts xp)[j] }
    ensures { forall j. (0 <= j < plength yp)
              -> (pelts yp)[j] = old (pelts yp)[j] }
    ensures { 0 <= result <= 1 }
  =
    let ox = pure { xp } in
    let oy = pure { yp } in
    let m = open_rx xp yp in
    assert { separated m.r m.y };
    let om = pure { m } in
    let res = add_raw m sz sz in
    assert { map_eq_sub m.data.elts om.data.elts
               m.y.addr (m.y.addr + m.y.len) };
    let cm = pure { m } in
    label Close in
    close_rx xp yp m;
    assert { forall j. 0 <= j < plength yp ->
                    (pelts yp)[j] = (cm.data.elts)[cm.y.addr + j]
                                  = (om.data.elts)[om.y.addr + j]
                                  = (pelts oy)[j]
                     by separated om.y om.r };
    value_sub_frame (pelts yp) (pelts oy)
                    (offset yp) (offset yp + int32'int sz);
    assert { value yp sz = value oy sz };
    assert { forall j. 0 <= j < offset xp \/ offset xp + sz <= j < plength xp ->
                    (pelts xp)[j] = (cm.data.elts)[cm.r.addr + j]
                                  = (om.data.elts)[om.r.addr + j]
                                  = (pelts ox)[j] };
    map_eq_sub_shift_w (pelts xp) cm.data.elts 0 xp.offset
                          cm.x.addr (cm.x.addr + cm.x.ofs)
                          (plength xp) (int32'int sz);
    map_eq_sub_shift_w (pelts oy) om.data.elts 0 oy.offset
                          om.y.addr (om.y.addr + om.y.ofs)
                          (plength oy) (int32'int sz);
    map_eq_sub_shift_w (pelts ox) om.data.elts 0 ox.offset
                          om.x.addr (om.x.addr + om.x.ofs)
                          (plength ox) (int32'int sz);
    value_sub_frame_shift (pelts xp) cm.data.elts xp.offset
                          (cm.x.addr + cm.x.ofs) (int32'int sz);
    value_sub_frame_shift (pelts oy) om.data.elts oy.offset
                          (om.y.addr + om.y.ofs) (int32'int sz);
    value_sub_frame_shift (pelts ox) om.data.elts ox.offset
                          (om.x.addr + om.x.ofs) (int32'int sz);
    assert { value xp sz + power radix sz * res = value ox sz + value yp sz };
    res

  let wmpn_add_n_ry (xp yp:ptr limb) (sz:int32)  : limb
    requires { 0 <= sz }
    requires { valid xp sz }
    requires { valid yp sz }
    requires { writable yp }
    ensures { value xp sz = old value xp sz }
    ensures { value yp sz + power radix sz * result
               = value xp sz + value (old yp) sz }
    ensures { forall j. (0 <= j < offset yp \/ offset yp + sz <= j < plength yp)
              -> (pelts yp)[j] = old (pelts yp)[j] }
    ensures { forall j. 0 <= j < plength xp ->
                 (pelts xp)[j] = old (pelts xp)[j] }
    ensures { 0 <= result <= 1 }
  =
    let ox = pure { xp } in
    let oy = pure { yp } in
    let m = open_ry yp xp in
    assert { separated m.r m.x };
    let om = pure { m } in
    let res = add_raw m sz sz in
    assert { map_eq_sub m.data.elts om.data.elts
               m.x.addr (m.x.addr + m.x.len) };
    let cm = pure { m } in
    label Close in
    close_ry yp xp m;
    assert { forall j. 0 <= j < plength xp ->
                    (pelts xp)[j] = (cm.data.elts)[cm.x.addr + j]
                                  = (om.data.elts)[om.x.addr + j]
                                  = (pelts ox)[j] };
    value_sub_frame (pelts xp) (pelts ox)
                    (offset xp) (offset xp + int32'int sz);
    assert { value xp sz = value ox sz };
    assert { forall j. 0 <= j < offset yp \/ offset yp + sz <= j < plength yp ->
                    (pelts yp)[j] = (cm.data.elts)[cm.r.addr + j]
                                  = (om.data.elts)[om.r.addr + j]
                                  = (pelts oy)[j] };
    map_eq_sub_shift_w (pelts yp) cm.data.elts 0 yp.offset
                          cm.y.addr (cm.y.addr + cm.y.ofs)
                          (plength yp) (int32'int sz);
    map_eq_sub_shift_w (pelts oy) om.data.elts 0 oy.offset
                          om.y.addr (om.y.addr + om.y.ofs)
                          (plength oy) (int32'int sz);
    map_eq_sub_shift_w (pelts ox) om.data.elts 0 ox.offset
                          om.x.addr (om.x.addr + om.x.ofs)
                          (plength ox) (int32'int sz);
    value_sub_frame_shift (pelts yp) cm.data.elts yp.offset
                          (cm.y.addr + cm.y.ofs) (int32'int sz);
    value_sub_frame_shift (pelts oy) om.data.elts oy.offset
                          (om.y.addr + om.y.ofs) (int32'int sz);
    value_sub_frame_shift (pelts ox) om.data.elts ox.offset
                          (om.x.addr + om.x.ofs) (int32'int sz);
    assert { value yp sz + power radix sz * res = value xp sz + value oy sz };
    res

end