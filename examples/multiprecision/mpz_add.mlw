module Add

use int.Int
use int.Power
use map.Map
use mach.int.Int32
use ref.Ref
use mach.c.C
use lemmas.Lemmas
use util.Util
use compare.Compare
use import mach.int.UInt64GMP as Limb
use add.Add
use sub.Sub
use int.Abs
use mpz.Z

(* TODO eliminate calls to salloc/copy *)

let wmpz_add (w u v: mpz_ptr) : unit
  requires { mpz.alloc[w] >= 1 }
  requires { mpz.readers[w] = 0 /\ mpz.readers[u] = 0 /\ mpz.readers[v] = 0 }
  requires { mpz.abs_size[u] < max_int32 /\ mpz.abs_size[v] < max_int32 }
  ensures  { value_of w mpz = old (value_of u mpz + value_of v mpz) }
  ensures  { forall x. x <> w -> mpz_unchanged x mpz (old mpz) }
  ensures  { mpz.readers[w] = 0 /\ mpz.readers[u] = 0 /\ mpz.readers[v] = 0 }
=
  label Start in
  let ref u = u in
  let ref v = v in
  let ref usize = size_of u in
  let ref vsize = size_of v in
  let ref abs_usize = abs usize in
  let ref abs_vsize = abs vsize in
  begin
    ensures { mpz.abs_size[u] = abs_usize /\ mpz.abs_size[v] = abs_vsize }
    ensures { abs_vsize <= abs_usize < max_int32 }
    ensures { 0 <= abs_vsize <= mpz.alloc[v] }
    ensures { 0 <= abs_usize <= mpz.alloc[u] }
    ensures { mpz.readers[u] = 0 /\ mpz.readers[v] = 0 }
    ensures { abs_usize * mpz.sgn[u] = usize /\
              abs_vsize * mpz.sgn[v] = vsize }
    ensures { value_of u mpz + value_of v mpz
              = old (value_of u mpz + value_of v mpz) }
    ensures { mpz_unchanged u mpz (old mpz) }
    ensures { mpz_unchanged v mpz (old mpz) }
    if Int32.(<) abs_usize abs_vsize
    then begin
      mpz_ptr_swap u v;
      let ref tmp_size = vsize in
      vsize <- usize;
      usize <- tmp_size;
      tmp_size <- abs_vsize;
      abs_vsize <- abs_usize;
      abs_usize <- tmp_size;
    end
  end;
  let ref wsize = Int32.(+) abs_usize 1 in
  let uw = mpz_eq u w in
  let vw = mpz_eq v w in
  label Realloc in
  let ompz = pure { mpz } in
  let wp = mpz_realloc w wsize in
  assert { uw \/ mpz_unchanged u mpz ompz };
  assert { vw \/ mpz_unchanged v mpz ompz };
  assert { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) };
  (* TODO remplacer par usize ^ vsize < 0 *)
  label Op in
  if ((Int32.(>) usize 0 && Int32.(<) vsize 0)
     || (Int32.(>) vsize 0 && Int32.(<) usize 0))
  then begin (*ensures { value wp (abs wsize)
                      = old (abs(mpz.abs_value_of[u] - mpz.abs_value_of[v])) }*)
            ensures { sgn_value wp wsize
                      = (value_of u mpz + value_of v mpz) at Op }
            ensures { uw \/ mpz.readers[u] = 0 }
            ensures { vw \/ mpz.readers[v] = 0 }
            ensures { mpz.readers[w] = -1 }
            ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
            ensures { abs wsize <= plength wp }
            ensures { min wp = old min wp /\ max wp = old max wp
                      /\ plength wp = old plength wp }
    if abs_usize <> abs_vsize
    then begin
      begin ensures { value wp abs_usize
                      = old (mpz.abs_value_of[u] - mpz.abs_value_of[v]) }
            ensures { uw \/ mpz.readers[u] = 0 }
            ensures { vw \/ mpz.readers[v] = 0 }
            ensures { mpz.readers[w] = -1 }
            ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
            ensures { min wp = old min wp /\ max wp = old max wp
                      /\ plength wp = old plength wp }
      if uw
      then begin
        assert { not vw };
        let vp = get_read_ptr v in
        let _b = sub_rx wp abs_usize vp abs_vsize in
        assert { _b = 0 };
        release_reader v vp
      end else if vw
      then begin
        let up = get_read_ptr u in
        let _b = sub_ry up abs_usize wp abs_vsize in
        assert { _b = 0 };
        release_reader u up
      end else begin
        let up = get_read_ptr u in
        let vp = get_read_ptr v in
        let _b = sub wp up abs_usize vp abs_vsize in
        assert { _b = 0 };
        release_reader u up;
        release_reader v vp
      end
      end;
      wsize <- abs_usize;
      normalize wp wsize;
      if usize < 0 then wsize <- -wsize
    end
    else begin
      wsize <- abs_usize;
      if uw
      then begin
        assert { not vw };
        let vp = get_read_ptr v in
        if wmpn_cmp wp vp abs_usize < 0
        then begin
          let _b = sub_n_ry vp wp abs_usize in
          assert { _b = 0 };
          normalize wp wsize;
          if usize >= 0
          then wsize <- -wsize
        end else begin
          let _b = sub_n_rx wp vp abs_usize in
          assert { _b = 0 };
          normalize wp wsize;
          if usize < 0 then wsize <- -wsize
        end;
        release_reader v vp
      end else if vw
      then begin
        let up = get_read_ptr u in
        if wmpn_cmp up wp abs_usize < 0
        then begin
          let _b = sub_n_rx wp up abs_usize in
          assert { _b = 0 };
          normalize wp wsize;
          if usize >= 0 then wsize <- - wsize
        end else begin
          let _b = sub_n_ry up wp abs_usize in
          assert { _b = 0 };
          normalize wp wsize;
          if usize < 0 then wsize <- - wsize
        end;
        release_reader u up
      end else begin
        let up = get_read_ptr u in
        let vp = get_read_ptr v in
        if wmpn_cmp up vp abs_usize < 0
        then begin
          let _b = sub_n wp vp up abs_usize in
          assert { _b = 0 };
          normalize wp wsize;
          if usize >= 0 then wsize <- -wsize
        end else begin
          let _b = sub_n wp up vp abs_usize in
          assert { _b = 0 };
          normalize wp wsize;
          if usize < 0 then wsize <- -wsize
        end;
        release_reader u up;
        release_reader v vp
      end
    end
  end
  else begin
    let ref cy = 0 in
    begin ensures { value wp wsize = old abs (value_of u mpz + value_of v mpz) }
          ensures { uw \/ mpz.readers[u] = 0 }
          ensures { vw \/ mpz.readers[v] = 0 }
          ensures { mpz.readers[w] = -1 }
          ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
          ensures { min wp = old min wp /\ max wp = old max wp
                    /\ plength wp = old plength wp }
          ensures { abs_usize <= wsize <= plength wp }
    assert { abs (value_of u mpz + value_of v mpz)
             = abs (value_of u mpz) + abs (value_of v mpz)
             by if usize >= 0
                then vsize >= 0
                     so abs (value_of u mpz) = value_of u mpz
                     so abs (value_of v mpz) = value_of v mpz
                else vsize <= 0
                     so abs (value_of u mpz) = - value_of u mpz
                     so abs (value_of v mpz) = - value_of v mpz };
    if uw
    then if vw
      then begin
        cy <- add_n_rxy wp abs_vsize;
        assert { value wp abs_usize + power radix abs_usize * cy
                 = abs (value_of u mpz + value_of v mpz) };
      end
      else begin
        let vp = get_read_ptr v in
        cy <- add_rx wp abs_usize vp abs_vsize;
        assert { value wp abs_usize + power radix abs_usize * cy
                 = abs (value_of u mpz + value_of v mpz)
                 by value vp abs_vsize = abs (value_of v mpz)
                 so value wp abs_usize at Op = abs (value_of u mpz)};
        release_reader v vp
      end
    else if vw
      then begin
        let up = get_read_ptr u in
        assert { value wp abs_vsize = abs (value_of v mpz) };
        assert { value up abs_usize = abs (value_of u mpz) };
        cy <- add_ry up abs_usize wp abs_vsize;
        assert { value wp abs_usize + power radix abs_usize * cy
                 = abs (value_of u mpz + value_of v mpz)
                 by value up abs_usize = abs (value_of u mpz) };
        release_reader u up
      end
      else begin
        let up = get_read_ptr u in
        let vp = get_read_ptr v in
        assert { value up abs_usize = abs (value_of u mpz)
                 /\ value vp abs_vsize = abs (value_of v mpz) };
        cy <- add wp up abs_usize vp abs_vsize;
        assert { value wp abs_usize + power radix abs_usize * cy
                 = abs (value_of u mpz + value_of v mpz)
                 by value up abs_usize = abs (value_of u mpz)
                 so value vp abs_vsize = abs (value_of v mpz) };
        release_reader u up;
        release_reader v vp;
      end;
    label Set in
    value_sub_update_no_change (pelts wp) (int32'int abs_usize)
                                    0 (int32'int abs_usize) cy;
    set_ofs wp abs_usize cy;
    value_tail wp abs_usize;
    assert { value wp (abs_usize + 1)
             = value wp abs_usize at Set + power radix abs_usize * cy
             = abs (value_of u mpz + value_of v mpz) };
    begin ensures { if cy = 0 then wsize = abs_usize
                              else wsize = abs_usize + 1 }
      wsize <- abs_usize + Limb.to_int32 cy
    end
    end;
    label Minus in
    if Int32.(<) usize 0
    then begin
      wsize <- Int32.(-_) wsize;
      assert { sgn_value wp wsize = - value wp (wsize at Minus)
               = (value_of u mpz + value_of v mpz) at Op
               by usize < 0 so vsize <= 0 }
    end
    else begin
      assert { sgn_value wp wsize = value wp wsize
               = (value_of u mpz + value_of v mpz) at Op
               by usize >= 0 so vsize >= 0
               so wsize >= abs_usize >= 0 }
    end;
    assert { sgn_value wp wsize = (value_of u mpz + value_of v mpz) at Op }
  end;
  set_size w wsize wp;
  assert { value_of w mpz = sgn_value wp wsize
           = (value_of u mpz + value_of v mpz) at Op };
  release_writer w wp


end