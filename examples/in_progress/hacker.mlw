
module Delight

  use import int.Int
  use import int.Power
  use import bv.BV32
  (* use import mach.int.Int32 *)
  use import int.EuclideanDivision

  type bitVec32 = BV32.t

  constant two : bitVec32 = BV32.of_int 2
  constant n31 : bitVec32 = BV32.of_int 31
  constant n32 : bitVec32 = BV32.of_int 32
  constant twoP31 : bitVec32 = BV32.of_int 0x8000_0000

  function to_int bitVec32 : int
  (* function to_int32 bitVec32 : int32 *)
  function from_int int : bitVec32
  (* function from_int32 int32 : bitVec32 *)

  axiom to_int_1 :
    forall i. to_int( of_int i ) = mod i 0x1_0000_0000
    (* forall i. 0 <= i < 0x1_0000_0000 -> to_int( of_int i ) = i *)

  axiom to_int_2 : 
    forall i. of_int( to_int i ) = i

  (* axiom to_int32_1 :  *)
  (*   forall i. to_int32( of_int32 i ) = i *)

  (* axiom to_int32_2 : *)
  (*   forall i. of_int32( to_int32 i ) = i *)
    

  (* axiom to_int_local :  *)
  (*   forall b. to_int b = BV32.to_int b *)

  axiom of_int_local : 
    forall i. of_int i = BV32.of_int i

  (* axiom conversion : *)
  (*   forall x. to_int x = bitVec32o_int (to_bv x) *)

  (* axiom to_int twoP31 = 0x8000_0000 *)
  (* axiom to_int two = 2 *)
  (* axiom to_int n31 = 31 *)
  (* axiom to_int n32 = 32 *)

  axiom le_to_int :
    forall x y. sle x y <-> (to_int x) <= (to_int y)

  axiom lt_to_int :
    forall x y. slt x y <-> (to_int x) < (to_int y)

  axiom mul_to_int :
    forall x y. mul x y = of_int( (to_int x) * (to_int y) )

  axiom mul_of_int :
    forall i j. mul (of_int i) (of_int j) = of_int( i * j )

  (* lemma mod_pow_2 : *)
  (*   forall x y. slt zero y -> slt y n32 -> *)
  (*   	     	    mod (to_int x) (power 2 (to_int y)) *)
  (*       	  = to_int (bw_and x (sub (lsl_bv one y) one)) *)

  (* axiom lsl_to_int : *) 

(*   val lsl_32 (x : int32 ) ( n : int32 ) : int32 *)
(*   requires{ 0 <= to_int n < 32 } *)
(*   ensures{ to_bv result = BV32.lsl_bv ( to_bv x ) ( to_bv n ) } *)
(*   ensures{ 0 <= to_int x -> to_int x * ( power 2 ( to_int n ) ) < twoP31 *)
(*            -> to_int result = to_int x * ( power 2 ( to_int n ) ) } *)

(*   val lsr_32 (x : int32 ) ( n : int32 ) : int32 *)
(*   requires{ 0 <= to_int n < 32 } *)
(*   ensures{ to_bv result = BV32.lsr_bv ( to_bv x ) ( to_bv n  *)
(* ) } *)
(*   ensures{ 0 <= to_int x -> to_int result = div ( to_int x ) ( power 2 ( to_int n ) ) } *)

  let test1 ( x : bitVec32 ) : bitVec32
  requires{ 0 <= to_int x < 1000 }
  ensures{ to_int result = 4 * to_int x }
  ensures{ bw_and result ( of_int 0b11 ) = zero }
  =
  assert{ power 2 2 = 4 };
  assert{ lsl_bv x two = mul (of_int( 4 )) x };
  assert{ mul (of_int( 4 )) x = of_int( 4 * to_int x ) };
  assert{ lsl_bv x two = of_int( 4 * to_int x ) };
    lsl_bv x two

(*   val bw_and_32 ( x : int32 ) ( y : int32 ) : int32 *)
(*     ensures { to_bv result = BV32.bw_and ( to_bv x ) ( to_bv y ) } *)
(*     (\* ensures { to_int result = bitVec32o_int ( to_bv result ) } *\) *)
    
(*   val sub_32 ( x : int32 ) ( y : int32 ) : int32 *)
(*     ensures { to_bv result = BV32.sub ( to_bv x ) ( to_bv y ) } *)
(*     ensures { - 0x8000_0000 <= to_int x - to_int y < twoP31 *)
(*               -> to_int result = to_int x - to_int y } *)

(*   lemma l : forall y. BV32.slt BV32.zero y -> BV32.slt (BV32.sub y (BV32.of_int 1) ) y *)

(*   let f (x y:int32) (ghost k:int32) : int32 *)
(*     requires { le zero k } *)
(*     requires { lt k n31 } *)
(*     requires { to_bv y = BV32.lsl_bv (BV32.of_int 1) (to_bv k) } *)
(*     requires { to_int y = power 2 (to_int k) } *)
(*     ensures { le zero result } *)
(*     ensures { lt result y } *)
(*     ensures { to_int result = mod (to_int x) (to_int y) }  *)
(*   =  *)
(*     bw_and_32 x ( sub_32 y one ) *)

(*   use import ref.Ref *)
    
(*   (\* Returns the digit index of the most significant (non-zero) digit of Number. (from N622-004) *\) *)
(*   let get_MSD ( number : int32 ) : int *)
(*     requires { not( eq number zero ) } *)
(*     ensures { result <> 0 } *)
(*     ensures { result < 31 } *)
(*     ensures { forall i. result < i < 31 -> BV32.nth ( to_bv number ) i = False } *)
(*   =  *)
(*     let digit_index = ref 0 in *)
(*     for i = 0 to 31 do *)
(*     	invariant { !digit_index <> 0 \/ exists j. i < j /\ j < 31 /\ nth ( to_bv number ) j = True } *)
(* 	invariant { !digit_index < i -> ( forall j. !digit_index < j /\ j < 31 -> nth ( to_bv number ) j = False ) } *)
(*     	if( BV32.nth ( to_bv number ) i = True ) *)
(* 	then 	 *)
(* 	    digit_index := i *)
(*     done; *)
(*     !digit_index *)

end
