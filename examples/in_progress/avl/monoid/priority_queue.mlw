
module Heap

  use import int.Int
  use import avl.SelectionTypes
  use import program_type.TypeParams
  use import option.Option
  use import ref.Ref
  use import list.List
  use import list.Append
  use import list.Mem
  use import list.Length
  
  (* Move remaining parameters here. *)
  constant balancing : int
  axiom balancing_positive : balancing > 0
  
  clone export key_type.ProgramKeyType
  clone preorder.Computable as CO with type T.t = K.t, type T.m = K.m,
    function T.m = K.m, predicate T.c = K.c
  
  clone sorted.Base as S with type K.t = D.m,
    type K.key = K.m,
    function K.key = key,
    predicate O.rel = CO.le,
    goal O.Trans
  
  (* Monoid: ordered keys + infinity. *)
  namespace M
    type m = option K.m
    type t = option K.t
    constant zero : m = None
    function add (x y:m) : m = match x with
      | None -> y
      | Some a -> match y with
        | None -> x
        | Some b -> if CO.lt a b
          then x
          else y
        end
      end
    let lemma assoc_m (x y z:m) : unit
      ensures { add x (add y z) = add (add x y) z }
    = match x , y , z with
      | None , _ , _ -> assert { true }
      | _ , None , _ -> assert { true }
      | _ , _ , None -> assert { true }
      | _ -> ()
      end
    let lemma neutral_m (x:m) : unit
      ensures { add x zero = x = add zero x }
    = match x with None -> () | _ -> assert { true } end
    clone export monoid.Monoid with type t = m,
      constant zero = zero,function add = add,lemma assoc,lemma neutral
    clone export monoid.MonoidListDef with type M.t = m,
      constant M.zero = zero,function M.add = add,goal M.assoc,goal M.neutral
    function m (x:t) : m = match x with None -> None | Some x -> Some x.K.m end
    predicate c (x:t) = match x with None -> true | Some x -> K.c x end
    let zero () : t
      ensures { result = None }
    = None
    let add (x y:t) : t
      requires { c x /\ c y }
      ensures { result.m = add x.m y.m }
      ensures { c result }
    = match x with
      | None -> y
      | Some a -> match y with
        | None -> x
        | Some b -> if CO.compare a b < 0
          then x
          else y
        end
      end
    
  end
  namespace D
    (* ARGHH ! *)
    function measure (d:D.m 'b) : M.m
    axiom measure_def : forall d:D.m 'b. measure d = Some d.key
    let measure (ghost p:type_params 'a 'b) (d:D.t 'a 'b) : M.t
      requires { p.D.mp.inv d }
      ensures { result.M.m = measure (p.D.mp.mdl d) }
      ensures { M.c result }
    = Some (get_key p d)
  end
  
  (* Selector: nothing. *)
  type selector = unit
  
  (* Correction of a selector with respect to an avl:
     the avl list is non-empty. *)
  
  predicate selector_correct 'e (l:list 'g) = l <> Nil
  
  predicate selected 'e (e:position (D.m 'b)) (l:list (D.m 'b)) =
      match e.middle with
      | None -> false
      | Some d -> S.minorate d.key e.left /\ S.minorate d.key e.right
      end /\ rebuild e = l
  
  let rec lemma monoid_sum_is_min (l:list (D.m 'b)) : unit
    ensures { let x = M.sum D.measure l in
      match x with
      | None -> l = Nil
      | Some a -> S.minorate a l /\ (exists d. mem d l /\ CO.eq d.key a)
      end }
    variant { l }
  = match l with Cons _ q -> monoid_sum_is_min q | _ -> () end
  
  let lemma selected_is_min (s:'d) (e:position (D.m 'b))
    (l:list (D.m 'b)) : unit
    requires { selected s e l }
    ensures { match e.middle with
      | None -> false
      | Some d -> S.minorate d.key l && match M.sum D.measure l with
        | None -> false
        | Some k -> CO.eq d.key k
        end
      end }
  = ()
  
  let selected_way (ghost p:type_params 'a 'b)
    (ghost base:list (D.m 'b))
    (ghost llis:list (D.m 'b))
    (ghost rlis:list (D.m 'b))
    (s:unit) (sl:M.t) (d:D.t 'a 'b) (sr:M.t) : way_base unit
    requires { p.D.mp.inv d }
    requires { base = llis ++ Cons (p.D.mp.mdl d) rlis }
    requires { sl.M.m = M.sum D.measure llis /\ sr.M.m = M.sum D.measure rlis }
    requires { M.c sl /\ M.c sr }
    (* A selected position can be found by following the given way. *)
    returns { Here -> let e2 = { left = llis;
        middle = Some (p.D.mp.mdl d);
        right = rlis } in selected s e2 base
      | Left sl -> selector_correct sl llis /\
        forall e. selected sl e llis ->
          selected s (right_extend e (p.D.mp.mdl d) rlis) base
      | Right sr -> selector_correct sr rlis /\
        forall e. selected sr e rlis ->
          selected s (left_extend llis (p.D.mp.mdl d) e) base }
  = let kd = get_key p d in
    match sl , sr with
    | None , None -> Here
    | None , Some a -> if CO.compare kd a <= 0 then Here else Right ()
    | Some a , None -> if CO.compare kd a <= 0 then Here else Left ()
    | Some a , Some b -> if CO.compare kd a <= 0
      then if CO.compare kd b <= 0
        then Here
        else begin
          assert { forall e. selected () e rlis ->
            match e.middle with
            | None -> false
            | Some d -> CO.eq d.key b.K.m && S.minorate d.key llis
            end };
          Right ()
        end
      else if CO.compare a b <= 0
      then begin
        assert { forall e. selected () e llis ->
          match e.middle with
          | None -> false
          | Some d -> CO.eq d.key a.K.m && S.minorate d.key rlis
          end };
        Left ()
      end
      else begin
        assert { forall e. selected () e rlis ->
          match e.middle with
          | None -> false
          | Some d -> CO.eq d.key b.K.m && S.minorate d.key llis
          end };
        Right ()
      end
    end
  
  (* Full clone of the avl module. *)
  clone avl.AVL as Sel with type selector = selector,
    predicate selector_correct = selector_correct,
    predicate selected = selected,
    val selected_way = selected_way,
    goal selector_correct_empty,
    constant balancing = balancing,
    goal balancing_positive,
    type D.t = D.t,
    type D.m = D.m,
    function D.mp = D.mp,
    function D.measure = D.measure,
    val D.measure = D.measure,
    type M.t = M.t,
    type M.m = M.m,
    function M.m = M.m,
    predicate M.c = M.c,
    constant M.zero = M.zero,
    function M.add = M.add,
    goal M.assoc,
    goal M.neutral,
    function M.sum = M.sum,
    goal M.sum_def_nil,
    goal M.sum_def_cons,
    val M.zero = M.zero,
    val M.add = M.add
  
  type t 'a 'b = Sel.t 'a 'b
  
  (* Model: a bag of data. *)
  
  type m 'b = {
    count : D.m 'b -> int;
    card : int;
  }
  
  function prm (t:t 'a 'b) : type_params 'a 'b = t.Sel.prm
  let ghost prm (t:t 'a 'b) : type_params 'a 'b
    ensures { result = t.prm }
  = t.Sel.prm
  function dprm (t:t 'a 'b) : type_params (D.t 'a 'b) (D.m 'b) =
    D.mp t.prm
  let ghost dprm (t:t 'a 'b) : type_params (D.t 'a 'b) (D.m 'b)
    ensures { result = t.dprm }
  = D.mp t.prm
  
  constant empty_bag : 'a -> int = \x:'a. 0
  function add_bag (x:'a) (f:'a -> int) : 'a -> int =
    \y:'a. if y = x then f y + 1 else f y
  
  function as_bag (l:list 'a) : 'a -> int = match l with
    | Nil -> empty_bag
    | Cons x q -> add_bag x (as_bag q)
    end
  
  let rec lemma as_bag_append (l r:list 'a) : unit
    ensures { forall x:'a. as_bag (l++r) x = as_bag l x + as_bag r x }
    variant { l }
  = match l with Nil -> () | Cons _ q -> as_bag_append q r end
  
  let rec lemma as_bag_bounds (l:list 'a) : unit
    ensures { forall x:'a. 0 <= as_bag l x <= length l }
    variant { l }
  = match l with Nil -> () | Cons _ q -> as_bag_bounds q end
  
  let rec lemma as_bag_membership (d:'a) (l:list 'a) : unit
    ensures { as_bag l d > 0 <-> mem d l }
    variant { l }
  = match l with Nil -> () | Cons _ q -> as_bag_membership d q end
  
  function m (t:t 'a 'b) : m 'b =
    { count = as_bag t.Sel.m.Sel.lis;
      card = length t.Sel.m.Sel.lis }
  let ghost m (t:t 'a 'b) : m 'b
    ensures { result = t.m }
  = { count = as_bag t.Sel.m.Sel.lis;
      card = length t.Sel.m.Sel.lis }
  
  let lemma m_def (t:t 'a 'b) : unit
    ensures { t.m.count = as_bag t.Sel.m.Sel.lis }
    ensures { t.m.card = length t.Sel.m.Sel.lis }
  = ()
  
  predicate c (t:t 'a 'b) = Sel.c t
  
  clone export program_type.Type1Prm with type t = t, type m = m,
    function m = m,predicate c = c,function prm = prm
  
  (* Should be the exported part of the invariant. *)
  let lemma correction (t:t 'a 'b) : unit
    requires { c t }
    ensures { forall d:D.m 'b. 0 <= t.m.count d <= t.m.card }
    ensures { t.m.card >= 0 }
  = ()
  
  let empty (ghost p:type_params 'a 'b) : t 'a 'b
    ensures { forall d:D.m 'b. result.m.count d = 0 }
    ensures { result.m.card = 0 }
    ensures { c result /\ result.prm = p }
  = Sel.empty p
  
  let singleton (ghost p:type_params 'a 'b) (d:D.t 'a 'b) : t 'a 'b
    requires { p.D.mp.inv d }
    ensures { let dm = p.D.mp.mdl d in
      result.m.count dm = 1 /\
      forall d2:D.m 'b. d2 <> dm -> result.m.count d2 = 0 }
    ensures { result.m.card = 1 }
    ensures { c result /\ result.prm = p }
  = Sel.singleton p d
  
  let is_empty (ghost rd:ref (D.m 'b)) (t:t 'a 'b) : bool
    requires { c t }
    ensures { result -> forall d:D.m 'b. t.m.count d = 0 }
    ensures { not result -> t.m.count !rd > 0 }
    ensures { result <-> t.m.card = 0 }
  = let res = Sel.is_empty t in
    ghost if not res
    then match t.Sel.m.Sel.lis with
      | Nil -> absurd
      | Cons d _ -> rd := d
      end;
    res
  
  let merge (l r:t 'a 'b) : t 'a 'b
    requires { c l /\ c r /\ l.prm = r.prm }
    ensures { c result /\ result.prm = l.prm }
    ensures { result.m.card = l.m.card + r.m.card }
    ensures { forall d. result.m.count d = l.m.count d + r.m.count d }
  = Sel.concat l r
  
  let lemma remove_count (l:list 'a) (d:'a) (r:list 'a) : unit
    ensures { as_bag (l ++ Cons d r) d = as_bag (l++r) d + 1 }
    ensures { forall d2. d2 <> d -> as_bag (l++Cons d r) d2 = as_bag (l++r) d2 }
  = ()
  
  let extract_min (t:t 'a 'b) : option (D.t 'a 'b,t 'a 'b)
    requires { c t }
    returns { None -> t.m.card = 0 /\ (forall d. t.m.count d = 0)
      | Some (d,e) -> c e /\ e.prm = t.prm /\ t.dprm.inv d /\
        t.m.card = e.m.card + 1 /\ let dm = t.dprm.mdl d in
        t.m.count dm = e.m.count dm + 1 /\
        (forall d2. d2 <> dm -> t.m.count d2 = e.m.count d2) /\
        (forall d2. t.m.count d2 > 0 -> CO.le dm.key d2.key) }
  = if Sel.is_empty t
    then None
    else let (o,e) = Sel.extract (Sel.default_position ()) () t in
      match o with
      | None -> absurd
      | Some d -> Some (d,e)
      end
  
  let min (t:t 'a 'b) : D.t 'a 'b
    requires { c t /\ t.m.card >= 1 }
    ensures { t.dprm.inv result /\ let dm = t.dprm.mdl result in
      t.m.count dm > 0 /\ t.m.card > 0 /\
      (forall d2. t.m.count d2 > 0 -> CO.le dm.key d2.key) }
  = match Sel.get (Sel.default_position ()) () t with
    | None -> absurd
    | Some d -> d
    end
  
  let pop_min (ghost r:ref (D.m 'b)) (t:t 'a 'b) : t 'a 'b
    requires { c t /\ t.m.card >= 1 }
    ensures { c result /\ result.prm = t.prm /\ t.m.card = result.m.card + 1 /\
      t.m.count !r = result.m.count !r + 1 /\
      (forall d2. d2 <> !r -> t.m.count d2 = result.m.count d2) /\
      (forall d2. t.m.count d2 > 0 -> CO.le !r.key d2.key) }
  = let r0 = Sel.default_position () in
    let res = Sel.remove r0 () t in
    r := match !r0.middle with None -> absurd | Some d -> d end;
    res
  
  let add (d:D.t 'a 'b) (t:t 'a 'b) : t 'a 'b
    requires { c t /\ t.dprm.inv d }
    ensures { c result /\ result.prm = t.prm }
    ensures { result.m.card = t.m.card + 1 }
    ensures { let dm = t.dprm.mdl d in
      result.m.count dm = t.m.count dm + 1 /\
      (forall d2. d2 <> dm -> result.m.count d2 = t.m.count d2) }
  = Sel.cons d t
  
end

