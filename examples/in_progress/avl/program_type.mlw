
module TypeParams
  
  use import HighOrd
  
  (* Additional information for parametric programs:
     'a represent the program type (the effective datatype),
     'b represent its logical model (the reasoning datatype).
     inv is the representation invariant of 'a,
     mdl the function mapping the program representation to its logical model.
   *)
  type type_params 'a 'b = {
    inv : 'a -> bool;
    mdl : 'a -> 'b;
  }
  
end

module Type0
  
  use import TypeParams
  
  (* Program version of the type. *)
  type t
  (* Its logical model. *)
  type m
  (* Type invariant (c for correct). *)
  predicate c t
  (* get logical model (m for model). *)
  function m t : m
  (* Parameteric information (for use in polymorphic code). *)
  constant p : type_params t m = { inv = (\t. c t); mdl = (\t. m t) }
  
end

(* Variants with different number of type variables. *)

module Type1
  
  use import TypeParams
  
  (* Need two types variables to represent both the program and logic worlds. *)
  type t 'a 'b
  type m 'b
  predicate c (t 'a 'b)
  function m (t 'a 'b) : m 'b
  function prm (t 'a 'b) : type_params 'a 'b
  function make_params (p:type_params 'a 'b) : type_params (t 'a 'b) (m 'b) =
    { inv = (\t. c t /\ prm t = p);
      mdl = (\t. m t) }
  
end

module Type2
  
  use import TypeParams
  
  type t 'a 'b 'c 'd
  type m 'b 'd
  predicate c (t 'a 'b 'c 'd)
  function m (t 'a 'b 'c 'd) : m 'b 'd
  function prm1 (t 'a 'b 'c 'd) : type_params 'a 'b
  function prm2 (t 'a 'b 'c 'd) : type_params 'c 'd
  function make_params (p1:type_params 'a 'b) (p2:type_params 'c 'd) : 
    type_params (t 'a 'b 'c 'd) (m 'b 'd) =
    { inv = (\t. c t /\ prm1 t = p1 /\ prm2 t = p2);
      mdl = (\t. m t) }
  
end


