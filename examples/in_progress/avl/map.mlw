
module MapBase
  
  use import int.Int
  use import avl.Base as B
  use import avl.SelectionTypes
  use import program_type.TypeParams
  use import option.Option
  use import ref.Ref
  use import list.List
  use import list.Append
  use import list.Mem
  
  (* Move remaining parameters here. *)
  constant balancing : int
  axiom balancing_positive : balancing > 0
  
  clone export key_type.ProgramKeyType
  clone preorder.ComputableParam as CO with namespace T = K
  
  (* Full clone of association_list. *)
  clone association_list.AssocSorted as A with type K.t = D.m,
    type K.key = K.m,
    function K.key = key,
    type O.order = CO.O.m,
    predicate O.correct_for = CO.correct_for,
    predicate O.le = CO.le,
    goal O.refl,
    goal O.trans,
    predicate O.eq = CO.eq,
    goal O.eq_def,
    predicate O.lt = CO.lt,
    goal O.lt_def
  
  (* Selector: key with respect to an order. *)
  type selector 'a 'b 'c 'd = { o : CO.O.t 'a 'b; k : K.t 'a 'b }
  
  (* Correction of a selector with respect to an avl:
     1) the selector key is correct with respect to the ordering,
     2) The avl is sorted with respect to the ordering. *)
  
  predicate selector_correct (p1:type_params 'a 'b) (p2:type_params 'c 'd)
    (s:selector 'a 'b 'c 'd)
    (t:B.t (D.t 'a 'b 'c 'd) (D.m 'b 'd)) =
      let om = (CO.O.make_params p1).mdl s.o in
      let km = (K.make_params p1).mdl s.k in
      CO.correct_for om km /\ A.S.increasing om t.m.lis /\
      (CO.O.make_params p1).inv s.o /\
      (K.make_params p1).inv s.k
  
  predicate selected (p1:type_params 'a 'b) (p2:type_params 'c 'd)
    (s:selector 'a 'b 'c 'd) (e:position (D.m 'b 'd))
    (t:B.t (D.t 'a 'b 'c 'd) (D.m 'b 'd)) =
      let om = (CO.O.make_params p1).mdl s.o in
      let km = (K.make_params p1).mdl s.k in
      A.S.majorate om km e.left /\ A.S.minorate om km e.right /\
      A.S.increasing om e.left /\ A.S.increasing om e.right /\
      match e.middle with
      | None -> true
      | Some d2 -> let k2 = key d2 in
        CO.correct_for om k2 /\ CO.eq om km k2
      end
  
  let selected_way (ghost p1:type_params 'a 'b)
    (ghost p2:type_params 'c 'd)
    (s:selector 'a 'b 'c 'd)
    (ghost base:B.t (D.t 'a 'b 'c 'd) (D.m 'b 'd))
    (l:B.t (D.t 'a 'b 'c 'd) (D.m 'b 'd))
    (d:D.t 'a 'b 'c 'd)
    (r:B.t (D.t 'a 'b 'c 'd) (D.m 'b 'd)) : way_base (selector 'a 'b 'c 'd)
    requires { exists b. c_balancing b l /\ c_balancing b r /\
      c_balancing b base }
    requires { l.prm = r.prm = base.prm /\ l.prm.inv d }
    requires { l.prm = D.make_params p1 p2 }
    requires { let l0 = node_model l.m.lis (l.prm.mdl d) r.m.lis in
      base.m.lis = l0 /\ selector_correct p1 p2 s base }
    returns { Here -> let e2 = { left = l.m.lis;
        middle = Some (l.prm.mdl d);
        right = r.m.lis } in selected p1 p2 s e2 base /\
          rebuild e2 = node_model l.m.lis (l.prm.mdl d) r.m.lis
      | Left sl -> selector_correct p1 p2 sl l /\
        forall e. selected p1 p2 sl e l /\ rebuild e = l.m.lis ->
          let e2 = { e with right = node_model e.right (l.prm.mdl d) r.m.lis }
          in selected p1 p2 s e2 base /\ rebuild e2 = base.m.lis
      | Right sr -> selector_correct p1 p2 sr r /\
        forall e. selected p1 p2 sr e r /\ rebuild e = r.m.lis ->
          let e2 = { e with left = node_model l.m.lis (l.prm.mdl d) e.left } in
          selected p1 p2 s e2 base /\ rebuild e2 = base.m.lis }
  = let kd = get_key p1 p2 d in
    let cmp = CO.compare p1 s.o s.k kd in
    if cmp < 0
    then begin
      assert { let mk = p1.K.make_params.mdl in
        let om = p1.CO.O.make_params.mdl s.o in
        D.make_params p1 p2 = base.prm -> CO.lt om (mk s.k) (mk kd) &&
        A.S.minorate om (mk s.k) r.m.lis &&
        (forall e. rebuild e = l.m.lis -> A.S.majorate om (mk kd) l.m.lis &&
          A.S.majorate om (mk kd) e.right &&
          A.S.increasing om (node_model e.right (l.prm.mdl d) r.m.lis)) };
      Left s
    end else if cmp > 0
    then begin
      assert { let mk = p1.K.make_params.mdl in
        let om = p1.CO.O.make_params.mdl s.o in
        D.make_params p1 p2 = base.prm -> CO.lt om (mk kd) (mk s.k) &&
        A.S.majorate om (mk s.k) l.m.lis &&
        (forall e. rebuild e = r.m.lis /\ A.S.increasing om e.left ->
          A.S.minorate om (mk kd) r.m.lis && A.S.minorate om (mk kd) e.left &&
          A.S.increasing om (node_model l.m.lis (l.prm.mdl d) e.left)) };
      Right s
    end else begin 
      assert { let mk = p1.K.make_params.mdl in
        let om = p1.CO.O.make_params.mdl s.o in
        D.make_params p1 p2 = base.prm -> CO.eq om (mk kd) (mk s.k) &&
        A.S.majorate om (mk s.k) l.B.m.B.lis &&
        A.S.minorate om (mk s.k) r.B.m.B.lis };
      Here
    end
  
  
  (* Full clone of the avl selection module. *)
  clone avl.Selection as Sel with namespace D = D,
    type selector = selector,
    predicate selector_correct = selector_correct,
    predicate selected = selected,
    val selected_way = selected_way,
    goal selector_correct_empty,
    constant balancing = balancing,
    goal balancing_positive
  
  type t 'a 'b 'c 'd = {
    repr : B.t (D.t 'a 'b 'c 'd) (D.m 'b 'd);
    order : CO.O.t 'a 'b;
    ghost prm1 : type_params 'a 'b;
    ghost prm2 : type_params 'c 'd;
  }
  
  type m 'b 'd = {
    func : K.m 'b -> option (D.m 'b 'd);
    ord : CO.O.m 'b;
  }
  
  function prm (t:t 'a 'b 'c 'd) : (type_params 'a 'b,type_params 'c 'd) =
    (t.prm1,t.prm2)
  function oprm (t:t 'a 'b 'c 'd) : type_params (CO.O.t 'a 'b) (CO.O.m 'b) =
    t.prm1.CO.O.make_params
  function kprm (t:t 'a 'b 'c 'd) : type_params (K.t 'a 'b) (K.m 'b) =
    t.prm1.K.make_params
  function dprm (t:t 'a 'b 'c 'd) : type_params (D.t 'a 'b 'c 'd) (D.m 'b 'd) =
    D.make_params t.prm1 t.prm2
  
  function m (t:t 'a 'b 'c 'd) : m 'b 'd =
    { func = A.model (t.oprm.mdl t.order) t.repr.B.m.B.lis;
      ord = t.oprm.mdl t.order }
  
  predicate c (t:t 'a 'b 'c 'd) =
    Sel.c t.repr /\
    t.repr.B.prm = t.dprm /\
    A.S.increasing (t.oprm.mdl t.order) t.repr.B.m.B.lis /\
    t.oprm.inv t.order
  
  clone export program_type.Type2Prm with type t = t, type m = m,
    function m = m,predicate c = c,function prm1 = prm1,function prm2 = prm2
  
  (* Should be the exported part of the invariant. *)
  let lemma correction (t:t 'a 'b 'c 'd) : unit
    requires { c t }
    ensures { forall k1 k2:K.m 'b. CO.correct_for t.m.ord k1 /\
      CO.correct_for t.m.ord k2 /\ CO.eq t.m.ord k1 k2 ->
      t.m.func k1 = t.m.func k2 }
    ensures { forall k:K.m 'b. CO.correct_for t.m.ord k ->
      match t.m.func k with
      | None -> true
      | Some d -> CO.correct_for t.m.ord (key d) /\ CO.eq t.m.ord (key d) k
      end }
  = ()
  
  let empty (ghost p1:type_params 'a 'b)
    (ghost p2:type_params 'c 'd) (o:CO.O.t 'a 'b) : t 'a 'b 'c 'd
    requires { p1.CO.O.make_params.inv o }
    ensures { result.prm1 = p1 /\ result.prm2 = p2 }
    ensures { c result }
    ensures { p1.CO.O.make_params.mdl o = result.m.ord }
    ensures { forall k:K.m 'b. CO.correct_for result.m.ord k ->
      result.m.func k = None }
  = { repr = Sel.empty (D.make_params p1 p2); order = o; prm1 = p1; prm2 = p2 }
  
  let singleton (ghost p1:type_params 'a 'b) (ghost p2:type_params 'c 'd)
    (o:CO.O.t 'a 'b) (d:D.t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { p1.CO.O.make_params.inv o }
    requires { (D.make_params p1 p2).inv d }
    requires { CO.correct_for (p1.CO.O.make_params.mdl o)
      (key ((D.make_params p1 p2).mdl d)) }
    ensures { result.prm1 = p1 /\ result.prm2 = p2 }
    ensures { c result }
    ensures { p1.CO.O.make_params.mdl o = result.m.ord }
    ensures { forall k:K.m 'b. CO.correct_for result.m.ord k ->
      if CO.eq result.m.ord k (key (result.dprm.mdl d))
      then result.m.func k = Some (result.dprm.mdl d)
      else result.m.func k = None }
  = let res = { repr = Sel.singleton (D.make_params p1 p2) d;
      order = o;
      prm1 = p1;
      prm2 = p2 } in
    res
  
  let is_empty (ghost rd:ref (D.m 'b 'd)) (t:t 'a 'b 'c 'd) : bool
    requires { c t }
    ensures { result -> forall k:K.m 'b. CO.correct_for t.m.ord k ->
      t.m.func k = None }
    ensures { not result -> CO.correct_for t.m.ord (key !rd) /\
      t.m.func (key !rd) = Some !rd }
  = let res = Sel.is_empty t.repr in
    ghost if not res
    then match t.repr.B.m.B.lis with
      | Nil -> absurd
      | Cons d _ -> rd := d
      end;
    res
  
  let param_copy (t:t 'a 'b 'c 'd)
    (u:B.t (D.t 'a 'b 'c 'd) (D.m 'b 'd)) : t 'a 'b 'c 'd
    ensures { result.repr = u }
    ensures { result.order = t.order /\ result.m.ord = t.m.ord }
    ensures { result.prm1 = t.prm1 }
    ensures { result.prm2 = t.prm2 }
  = { repr = u; order = t.order; prm1 = t.prm1; prm2 = t.prm2 }
  
  let decompose_min (t:t 'a 'b 'c 'd) : option (D.t 'a 'b 'c 'd,t 'a 'b 'c 'd)
    requires { c t }
    returns { None -> forall k:K.m 'b. CO.correct_for t.m.ord k ->
      t.m.func k = None
      | Some (d,r) -> let dm = r.dprm.mdl d in
        r.prm = t.prm /\ r.m.ord = t.m.ord /\ t.dprm.inv d /\
        CO.correct_for t.m.ord dm.key /\
        forall k:K.m 'b. CO.correct_for t.m.ord k ->
          (CO.lt t.m.ord k dm.key -> t.m.func k = None) /\
          (CO.eq t.m.ord k dm.key -> t.m.func k = Some dm) /\
          (CO.le r.m.ord k dm.key -> r.m.func k = None) /\
          (not CO.eq r.m.ord dm.key k -> r.m.func k = t.m.func k) }
  = match Sel.decompose_front t.repr with
    | None -> None
    | Some (d,r) -> let r = param_copy t r in
      assert { let om = r.m.ord in let dm = r.dprm.mdl d in
        let lt = t.repr.B.m.B.lis in let lr = r.repr.B.m.B.lis in
        CO.correct_for om dm.key && t.m.func = A.model om lt &&
        r.m.func = A.model om lr && om = t.m.ord &&
        lt = (Cons dm Nil) ++ lr && A.S.minorate om dm.key lr &&
        A.S.increasing om lr };
      Some (d,r)
    end
  
  let decompose_max (t:t 'a 'b 'c 'd) : option (t 'a 'b 'c 'd,D.t 'a 'b 'c 'd)
    requires { c t }
    returns { None -> forall k:K.m 'b. CO.correct_for t.m.ord k ->
      t.m.func k = None
      | Some (l,d) -> let dm = l.dprm.mdl d in
        l.prm = t.prm /\ l.m.ord = t.m.ord /\ t.dprm.inv d /\
        CO.correct_for t.m.ord dm.key /\
        forall k:K.m 'b. CO.correct_for t.m.ord k ->
          (CO.lt t.m.ord dm.key k -> t.m.func k = None) /\
          (CO.eq t.m.ord dm.key k -> t.m.func k = Some dm) /\
          (CO.le l.m.ord dm.key k -> l.m.func k = None) /\
          (not CO.eq l.m.ord k dm.key -> l.m.func k = t.m.func k) }
  = match Sel.decompose_back t.repr with
    | None -> None
    | Some (l,d) -> let l = param_copy t l in
      assert { let om = l.m.ord in let dm = l.dprm.mdl d in
        let lt = t.repr.B.m.B.lis in let ll = l.repr.B.m.B.lis in
        CO.correct_for om dm.key && t.m.func = A.model om lt &&
        l.m.func = A.model om ll && om = t.m.ord &&
        lt = ll ++ (Cons dm Nil) && A.S.majorate om dm.key ll &&
        A.S.increasing om ll };
      Some (l,d)
    end
  
  let add_min (d:D.t 'a 'b 'c 'd) (t:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c t /\ t.dprm.inv d }
    requires { CO.correct_for t.m.ord (t.dprm.mdl d).key }
    requires { forall k:K.m 'b. CO.correct_for t.m.ord k /\
      CO.le t.m.ord k (t.dprm.mdl d).key -> t.m.func k = None }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let dm = t.dprm.mdl d in
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
      (CO.lt t.m.ord k dm.key -> result.m.func k = None) /\
      (CO.eq t.m.ord k dm.key -> result.m.func k = Some dm) /\
      (not CO.eq t.m.ord dm.key k -> result.m.func k = t.m.func k) }
  = let res = param_copy t (Sel.cons d t.repr) in
    assert { let lt = t.repr.B.m.B.lis in
      let lr = res.repr.B.m.B.lis in
      let om = t.m.ord in let dm = t.dprm.mdl d in
      res.m.func = A.model om lr && t.m.func = A.model om lt &&
      lr = (Cons dm Nil) ++ lt && (not A.S.minorate om dm.key lt ->
        (forall d. mem d lt ->
        not (CO.correct_for om d.key /\
             CO.lt om dm.key d.key) ->
          A.correct om lt && CO.correct_for om d.key && CO.le om d.key dm.key
          && A.appear om d.key lt && false)
      && false) && A.S.increasing om lr };
    res
  
  let add_max (t:t 'a 'b 'c 'd) (d:D.t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c t /\ t.dprm.inv d }
    requires { CO.correct_for t.m.ord (t.dprm.mdl d).key }
    requires { forall k:K.m 'b. CO.correct_for t.m.ord k /\
      CO.le t.m.ord (t.dprm.mdl d).key k -> t.m.func k = None }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let dm = t.dprm.mdl d in
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
      (CO.lt t.m.ord dm.key k -> result.m.func k = None) /\
      (CO.eq t.m.ord k dm.key -> result.m.func k = Some dm) /\
      (not CO.eq t.m.ord dm.key k -> result.m.func k = t.m.func k) }
  = let res = param_copy t (Sel.snoc t.repr d) in
    assert { let lt = t.repr.B.m.B.lis in
      let lr = res.repr.B.m.B.lis in
      let om = t.m.ord in let dm = t.dprm.mdl d in
      res.m.func = A.model om lr && t.m.func = A.model om lt &&
      lr = lt ++ (Cons dm Nil) && (not A.S.majorate om dm.key lt ->
        (forall d. mem d lt ->
          not (CO.correct_for om d.key /\
            CO.lt om d.key dm.key) ->
          A.correct om lt && CO.correct_for om d.key && CO.le om dm.key d.key
          && A.appear om d.key lt && false)
        && false) && A.S.increasing om lr };
    res
  
  let concat (l r:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c l /\ c r /\ l.prm = r.prm /\ l.m.ord = r.m.ord }
    requires { forall k1 k2. CO.correct_for l.m.ord k1 /\
      CO.correct_for r.m.ord k2 /\ l.m.func k1 <> None /\
      r.m.func k2 <> None -> CO.lt l.m.ord k1 k2 }
    ensures { c result /\ result.prm = l.prm /\ result.m.ord = l.m.ord }
    ensures { forall k. CO.correct_for l.m.ord k ->
      match l.m.func k with None -> result.m.func k = r.m.func k
      | s -> result.m.func k = s end }
    ensures { forall k. CO.correct_for l.m.ord k ->
      match r.m.func k with None -> result.m.func k = l.m.func k
      | s -> result.m.func k = s end }
    ensures { forall k. CO.correct_for l.m.ord k -> (result.m.func k = None <->
      l.m.func k = None /\ r.m.func k = None) }
  = let res = param_copy l (Sel.concat l.repr r.repr) in
    assert { let ll = l.repr.B.m.B.lis in
      let lr = r.repr.B.m.B.lis in
      let om = l.m.ord in
      l.m.func = A.model om ll && r.m.func = A.model om lr &&
      (not A.S.precede om ll lr -> (forall d1 d2. mem d1 ll /\ mem d2 lr ->
        not (CO.correct_for om d1.key /\
             CO.correct_for om d2.key /\
             CO.lt om d1.key d2.key) ->
          A.correct om ll && A.correct om lr &&
          CO.correct_for om d1.key && CO.correct_for om d2.key &&
          A.appear om d1.key ll && A.appear om d2.key lr &&
          l.m.func d1.key <> None && r.m.func d2.key <> None
          && false) && false) &&
      A.S.increasing om (ll++lr) && res.m.func = A.model om (ll++lr) };
    res
  
  let get (k:K.t 'a 'b) (t:t 'a 'b 'c 'd) : option (D.t 'a 'b 'c 'd)
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    returns { None -> let km = t.kprm.mdl k in
      (forall k2. CO.correct_for t.m.ord k2 /\ CO.eq t.m.ord km k2 ->
        t.m.func k2 = None) && t.m.func km = None
      | Some d -> t.dprm.inv d /\ let km = t.kprm.mdl k in
        let dm = t.dprm.mdl d in
        CO.correct_for t.m.ord dm.key /\ CO.eq t.m.ord dm.key km /\
        (forall k2. CO.correct_for t.m.ord k2 /\ CO.eq t.m.ord km k2 ->
          t.m.func k2 = Some dm) && t.m.func km = Some dm = t.m.func dm.key }
  = let r = Sel.default_position () in
    let s = { o = t.order; k = k } in
    let res = Sel.get t.prm1 t.prm2 r s t.repr in
    let om = (CO.O.make_params t.prm1).mdl t.order in
    let km = t.prm1.K.make_params.mdl k in
    ghost match !r.middle with
    | None -> A.model_cut om km !r.left !r.right
    | Some rd -> A.model_split om rd !r.left !r.right
    end;
    res
  
  let add (d:D.t 'a 'b 'c 'd) (t:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c t /\ t.dprm.inv d }
    requires { CO.correct_for t.m.ord (t.dprm.mdl d).key }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let dm = t.dprm.mdl d in
      (forall k:K.m 'b. CO.correct_for t.m.ord k ->
       (CO.eq t.m.ord k dm.key -> result.m.func k = Some dm) /\
       (not CO.eq t.m.ord k dm.key -> result.m.func k = t.m.func k)) &&
      result.m.func dm.key = Some dm }
  = let r = Sel.default_position () in
    let s = { o = t.order; k = get_key t.prm1 t.prm2 d } in
    let res = param_copy t (Sel.add t.prm1 t.prm2 r s d t.repr) in
    let ll = !r.left in let lr = !r.right in
    let om = (CO.O.make_params t.prm1).mdl t.order in
    let dm = t.repr.B.prm.mdl d in
    A.model_split om (t.repr.B.prm.mdl d) ll lr;
    ghost match !r.middle with
    | None -> A.model_cut om dm.key ll lr
    | Some rd -> A.model_split om rd ll lr
    end;
    assert { forall k:K.m 'b. CO.correct_for t.m.ord k /\
      CO.lt t.m.ord k dm.key -> res.m.func k = A.model om ll k = t.m.func k };
    assert { forall k:K.m 'b. CO.correct_for t.m.ord k /\
      CO.lt t.m.ord dm.key k -> res.m.func k = A.model om lr k = t.m.func k };
    res
  
  let remove (k:K.t 'a 'b) (t:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in
      (forall k2:K.m 'b. CO.correct_for t.m.ord k2 ->
       (CO.eq t.m.ord k2 km -> result.m.func k2 = None) /\
       (not CO.eq t.m.ord k2 km -> result.m.func k2 = t.m.func k2)) &&
      result.m.func km = None }
  = let r = Sel.default_position () in
    let s = { o = t.order; k = k } in
    let res = param_copy t (Sel.remove t.prm1 t.prm2 r s t.repr) in
    let ll = !r.left in let lr = !r.right in
    let om = (CO.O.make_params t.prm1).mdl t.order in
    assert { A.S.precede om ll lr };
    let km = t.prm1.K.make_params.mdl k in
    A.model_cut om km ll lr;
    ghost match !r.middle with
    | None -> ()
    | Some rd -> A.model_split om rd ll lr;
      assert { forall k:K.m 'b. CO.correct_for t.m.ord k /\
        CO.lt t.m.ord k km -> res.m.func k = A.model om ll k = t.m.func k };
      assert { forall k:K.m 'b. CO.correct_for t.m.ord k /\
        CO.lt t.m.ord km k -> res.m.func k = A.model om lr k = t.m.func k }
    end;
    res
  
  let split (k:K.t 'a 'b) (t:t 'a 'b 'c 'd) :
    (t 'a 'b 'c 'd,option (D.t 'a 'b 'c 'd),t 'a 'b 'c 'd)
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    returns { (lf,o,rg) ->
      lf.prm = t.prm = rg.prm /\ lf.m.ord = t.m.ord = rg.m.ord /\
      c lf /\ c rg /\
      let om = t.m.ord in
      let km = t.kprm.mdl k in
      match o with
      | None -> (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.eq om km k2 ->
        t.m.func k2 = None) && t.m.func km = None
      | Some d -> t.dprm.inv d /\ let dm = t.dprm.mdl d in
        CO.correct_for om dm.key /\ CO.eq om km dm.key /\
        (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.eq om km k2 ->
          t.m.func k2 = Some dm) && t.m.func km = Some dm = t.m.func dm.key
      end /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.lt om k2 km ->
        lf.m.func k2 = t.m.func k2) /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.le om km k2 ->
        lf.m.func k2 = None) /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.lt om km k2 ->
        rg.m.func k2 = t.m.func k2) /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.le om k2 km ->
        rg.m.func k2 = None) }
  = let r = Sel.default_position () in
    let s = { o = t.order; k = k } in
    let (lf0,o,rg0) = Sel.split t.prm1 t.prm2 r s t.repr in
    let lf = param_copy t lf0 in let rg = param_copy t rg0 in
    let om = (CO.O.make_params t.prm1).mdl t.order in
    let km = t.prm1.K.make_params.mdl k in
    ghost match !r.middle with
    | None -> A.model_cut om km !r.left !r.right
    | Some rd -> A.model_split om rd !r.left !r.right;
    end;
    (lf,o,rg)
    
  
end

module Map
  
  use import int.Int
  use import program_type.TypeParams
  use import option.Option
  use import ref.Ref
  
  (* Parameters. *)
  constant balancing : int
  axiom balancing_positive : balancing > 0
  
  (* Comparable key type. *)
  clone program_type.Type1 as K
  clone preorder.ComputableParam as CO with namespace T = K
  
  (* stored type is a pair. *)
  namespace D
    
    type t 'a 'b 'c 'd = (K.t 'a 'b,'c)
    type m 'b 'd = (K.m 'b,'d)
    function make_params (p1:type_params 'a 'b) (p2:type_params 'c 'd) :
      type_params (t 'a 'b 'c 'd) (m 'b 'd) =
      { inv = \p. let (a,b) = p in p1.K.make_params.inv a /\ p2.inv b;
        mdl = \p. let (a,b) = p in (p1.K.make_params.mdl a,p2.mdl b) }
    function key (t:m 'b 'd) : K.m 'b = let (a,_) = t in a
    let get_key (ghost p1:type_params 'a 'b) (ghost p2:type_params 'c 'd)
      (t:t 'a 'b 'c 'd) : K.t 'a 'b
      requires { (make_params p1 p2).inv t }
      ensures { (K.make_params p1).inv result }
      ensures { key ((make_params p1 p2).mdl t) =
        (K.make_params p1).mdl result }
    = let (a,_) = t in a
    
  end
  
  clone MapBase as MB with constant balancing = balancing,
    goal balancing_positive,
    namespace K = K,
    namespace D = D,
    function key = D.key,
    val get_key = D.get_key,
    namespace CO = CO,
    goal CO.lt_def,
    goal CO.eq_def,
    goal CO.refl,
    goal CO.trans,
    goal CO.total
  
  type t 'a 'b 'c 'd = MB.t 'a 'b 'c 'd
  type m 'b 'd = {
    func : K.m 'b -> option 'd;
    ord : CO.O.m 'b;
  }
  predicate c (t:t 'a 'b 'c 'd) = MB.c t
  function prm1 (t:t 'a 'b 'c 'd) : type_params 'a 'b = t.MB.prm1
  function prm2 (t:t 'a 'b 'c 'd) : type_params 'c 'd = t.MB.prm2
  function prm (t:t 'a 'b 'c 'd) : (type_params 'a 'b,type_params 'c 'd) =
    (t.prm1,t.prm2)
  function kprm (t:t 'a 'b 'c 'd) : type_params (K.t 'a 'b) (K.m 'b) =
    t.prm1.K.make_params
  function oprm (t:t 'a 'b 'c 'd) : type_params (CO.O.t 'a 'b) (CO.O.m 'b) =
    t.prm1.CO.O.make_params
  function oproj (o:option ('a,'b)) : option 'b = match o with
  | None -> None
  | Some (_,v) -> Some v
  end
  function m (t:t 'a 'b 'c 'd) : m 'b 'd =
    { func = \k. oproj (t.MB.m.MB.func k);
      ord = t.MB.m.MB.ord }
  
  let lemma m_def (t:t 'a 'b 'c 'd) : unit
    ensures { forall k. t.m.func k = None <-> t.MB.m.MB.func k = None }
    ensures { forall k k2 v. t.MB.m.MB.func k = Some (k2,v) ->
      t.m.func k = Some v }
    ensures { t.m.ord = t.MB.m.MB.ord }
  = ()
  
  let empty (ghost p1:type_params 'a 'b)
    (ghost p2:type_params 'c 'd) (o:CO.O.t 'a 'b) : t 'a 'b 'c 'd
    requires { p1.CO.O.make_params.inv o }
    ensures { result.prm1 = p1 /\ result.prm2 = p2 }
    ensures { c result }
    ensures { p1.CO.O.make_params.mdl o = result.m.ord }
    ensures { forall k:K.m 'b. CO.correct_for result.m.ord k ->
      result.m.func k = None }
  = MB.empty p1 p2 o
  
  let singleton (ghost p1:type_params 'a 'b) (ghost p2:type_params 'c 'd)
    (o:CO.O.t 'a 'b) (k:K.t 'a 'b) (v:'c) : t 'a 'b 'c 'd
    requires { p1.CO.O.make_params.inv o }
    requires { p1.K.make_params.inv k /\ p2.inv v }
    requires { CO.correct_for (p1.CO.O.make_params.mdl o)
      (p1.K.make_params.mdl k) }
    ensures { result.prm1 = p1 /\ result.prm2 = p2 }
    ensures { c result }
    ensures { p1.CO.O.make_params.mdl o = result.m.ord }
    ensures { forall k2:K.m 'b. CO.correct_for result.m.ord k2 ->
      if CO.eq result.m.ord k2 (result.kprm.mdl k)
      then result.m.func k2 = Some (result.prm2.mdl v)
      else result.m.func k2 = None }
  = let d = (k,v) in
    let km = p1.K.make_params.mdl k in
    let dm = (D.make_params p1 p2).mdl d in
    let res = MB.singleton p1 p2 o d in
    assert { forall k2:K.m 'b. CO.correct_for res.m.ord k2 ->
      if CO.eq res.m.ord k2 km
      then res.MB.m.MB.func k2 = Some dm
      else res.MB.m.MB.func k2 = None };
    res
  
  let is_empty (ghost rk:ref (K.m 'b)) (ghost rv:ref 'd)
    (t:t 'a 'b 'c 'd) : bool
    requires { c t }
    ensures { result -> forall k:K.m 'b. CO.correct_for t.m.ord k ->
      t.m.func k = None }
    ensures { not result -> CO.correct_for t.m.ord !rk /\
      t.m.func !rk = Some !rv }
  = let r = ref (!rk,!rv) in
    let res = MB.is_empty r t in
    let (a,b) = !r in rk := a;rv := b;res
  
  let decompose_min (t:t 'a 'b 'c 'd) : option ((K.t 'a 'b,'c),t 'a 'b 'c 'd)
    requires { c t }
    returns { None -> forall k:K.m 'b. CO.correct_for t.m.ord k ->
      t.m.func k = None
      | Some ((k,v),r) -> let vm = t.prm2.mdl v in
        let km = r.kprm.mdl k in
        r.prm = t.prm /\ r.m.ord = t.m.ord /\ t.kprm.inv k /\ t.prm2.inv v /\
        CO.correct_for t.m.ord km /\
        forall k:K.m 'b. CO.correct_for t.m.ord k ->
          (CO.lt t.m.ord k km -> t.m.func k = None) /\
          (CO.eq t.m.ord k km -> t.m.func k = Some vm) /\
          (CO.le r.m.ord k km -> r.m.func k = None) /\
          (not CO.eq r.m.ord km k -> r.m.func k = t.m.func k) }
  = let res = MB.decompose_min t in
    ghost match res with None -> ()
    | Some (d,r) -> let (k,v) = d in
      assert { let km = t.kprm.mdl k in let vm = t.prm2.mdl v in
        let dm = (D.make_params t.prm1 t.prm2).mdl d in dm = (km,vm) &&
        t.kprm.inv k && t.prm2.inv v && CO.correct_for t.m.ord km &&
        (forall k:K.m 'b. CO.correct_for t.m.ord k ->
          (CO.lt t.m.ord k km -> t.MB.m.MB.func k = None) /\
          (CO.eq t.m.ord k km -> t.MB.m.MB.func k = Some dm) /\
          (CO.le r.m.ord k km -> r.MB.m.MB.func k = None) /\
          (not CO.eq r.m.ord km k -> r.MB.m.MB.func k = t.MB.m.MB.func k &&
            r.m.func k = t.m.func k)) }
    end; res
  
  let decompose_max (t:t 'a 'b 'c 'd) : option (t 'a 'b 'c 'd,(K.t 'a 'b,'c))
    requires { c t }
    returns { None -> forall k:K.m 'b. CO.correct_for t.m.ord k ->
      t.m.func k = None
      | Some (l,(k,v)) -> let vm = t.prm2.mdl v in
        let km = l.kprm.mdl k in
        l.prm = t.prm /\ l.m.ord = t.m.ord /\ t.kprm.inv k /\ t.prm2.inv v /\
        CO.correct_for t.m.ord km /\
        forall k:K.m 'b. CO.correct_for t.m.ord k ->
          (CO.lt t.m.ord km k -> t.m.func k = None) /\
          (CO.eq t.m.ord km k -> t.m.func k = Some vm) /\
          (CO.le l.m.ord km k -> l.m.func k = None) /\
          (not CO.eq l.m.ord k km -> l.m.func k = t.m.func k) }
  = let res = MB.decompose_max t in
  ghost match res with None -> ()
  | Some (l,d) -> let (k,v) = d in
    assert { let km = t.kprm.mdl k in let vm = t.prm2.mdl v in
      let dm = (D.make_params t.prm1 t.prm2).mdl d in dm = (km,vm) &&
      t.kprm.inv k && t.prm2.inv v && CO.correct_for t.m.ord km &&
      (forall k:K.m 'b. CO.correct_for t.m.ord k ->
        (CO.lt t.m.ord km k -> t.MB.m.MB.func k = None) /\
        (CO.eq t.m.ord km k -> t.MB.m.MB.func k = Some dm) /\
        (CO.le l.m.ord km k -> l.MB.m.MB.func k = None) /\
        (not CO.eq l.m.ord k km -> l.MB.m.MB.func k = t.MB.m.MB.func k)) }
  end; res
  
  let add_min (k:K.t 'a 'b) (v:'c) (t:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c t /\ t.kprm.inv k /\ t.prm2.inv v }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    requires { forall k2:K.m 'b. CO.correct_for t.m.ord k2 /\
      CO.le t.m.ord k2 (t.kprm.mdl k) -> t.m.func k2 = None }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in let vm = t.prm2.mdl v in
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
      (CO.lt t.m.ord k km -> result.m.func k = None) /\
      (CO.eq t.m.ord k km -> result.m.func k = Some vm) /\
      (not CO.eq t.m.ord km k -> result.m.func k = t.m.func k) }
  = let d = (k,v) in
    let res = MB.add_min d t in
    assert { let km = t.kprm.mdl k in let vm = t.prm2.mdl v in
      let dm = (D.make_params t.prm1 t.prm2).mdl d in dm = (km,vm) &&
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
        (CO.lt t.m.ord k km -> res.MB.m.MB.func k = None) /\
        (CO.eq t.m.ord k km -> res.MB.m.MB.func k = Some dm) /\
        (not CO.eq t.m.ord km k -> res.MB.m.MB.func k = t.MB.m.MB.func k) };
    res
  
  let add_max (t:t 'a 'b 'c 'd) (k:K.t 'a 'b) (v:'c) : t 'a 'b 'c 'd
    requires { c t /\ t.kprm.inv k /\ t.prm2.inv v }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    requires { forall k2:K.m 'b. CO.correct_for t.m.ord k2 /\
      CO.le t.m.ord (t.kprm.mdl k) k2 -> t.m.func k2 = None }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in let vm = t.prm2.mdl v in
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
      (CO.lt t.m.ord km k -> result.m.func k = None) /\
      (CO.eq t.m.ord km k -> result.m.func k = Some vm) /\
      (not CO.eq t.m.ord k km -> result.m.func k = t.m.func k) }
  = let d = (k,v) in
    let res = MB.add_max t d in
    assert { let km = t.kprm.mdl k in let vm = t.prm2.mdl v in
      let dm = (D.make_params t.prm1 t.prm2).mdl d in dm = (km,vm) &&
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
        (CO.lt t.m.ord km k -> res.MB.m.MB.func k = None) /\
        (CO.eq t.m.ord km k -> res.MB.m.MB.func k = Some dm) /\
        (not CO.eq t.m.ord k km -> res.MB.m.MB.func k = t.MB.m.MB.func k) };
    res
  
  let concat (l r:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c l /\ c r /\ l.prm = r.prm /\ l.m.ord = r.m.ord }
    requires { forall k1 k2. CO.correct_for l.m.ord k1 /\
      CO.correct_for r.m.ord k2 /\ l.m.func k1 <> None /\
      r.m.func k2 <> None -> CO.lt l.m.ord k1 k2 }
    ensures { c result /\ result.prm = l.prm /\ result.m.ord = l.m.ord }
    ensures { forall k. CO.correct_for l.m.ord k ->
      match l.m.func k with None -> result.m.func k = r.m.func k
      | s -> result.m.func k = s end }
    ensures { forall k. CO.correct_for l.m.ord k ->
      match r.m.func k with None -> result.m.func k = l.m.func k
      | s -> result.m.func k = s end }
    ensures { forall k. CO.correct_for l.m.ord k -> (result.m.func k = None <->
      l.m.func k = None /\ r.m.func k = None) }
  = MB.concat l r
  
  let get (k:K.t 'a 'b) (t:t 'a 'b 'c 'd) : option 'c
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    returns { None -> let km = t.kprm.mdl k in
        (forall k2. CO.correct_for t.m.ord k2 /\ CO.eq t.m.ord km k2 ->
          t.m.func k2 = None) && t.m.func km = None
      | Some v -> t.prm2.inv v /\ let km = t.kprm.mdl k in
        let vm = t.prm2.mdl v in
        (forall k2. CO.correct_for t.m.ord k2 /\ CO.eq t.m.ord km k2 ->
          t.m.func k2 = Some vm) && t.m.func km = Some vm }
  = match MB.get k t with
    | None -> None
    | Some (_,v) -> Some v
    end
  
  let add (k:K.t 'a 'b) (v:'c) (t:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c t /\ t.kprm.inv k /\ t.prm2.inv v }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let vm = t.prm2.mdl v in let km = t.kprm.mdl k in
      (forall k:K.m 'b. CO.correct_for t.m.ord k ->
       (CO.eq t.m.ord k km -> result.m.func k = Some vm) /\
       (not CO.eq t.m.ord k km -> result.m.func k = t.m.func k)) &&
      result.m.func km = Some vm }
  = let d = (k,v) in let res = MB.add d t in
    assert { let km = t.kprm.mdl k in let vm = t.prm2.mdl v in
      let dm = (D.make_params t.prm1 t.prm2).mdl d in dm = (km,vm) &&
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
        (not CO.eq t.m.ord k km -> res.MB.m.MB.func k = t.MB.m.MB.func k) };
    res
  
  let remove (k:K.t 'a 'b) (t:t 'a 'b 'c 'd) : t 'a 'b 'c 'd
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in
      (forall k2:K.m 'b. CO.correct_for t.m.ord k2 ->
       (CO.eq t.m.ord k2 km -> result.m.func k2 = None) /\
       (not CO.eq t.m.ord k2 km -> result.m.func k2 = t.m.func k2)) &&
      result.m.func km = None }
  = MB.remove k t
  
  let split (k:K.t 'a 'b) (t:t 'a 'b 'c 'd) :
    (t 'a 'b 'c 'd,option 'c,t 'a 'b 'c 'd)
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    returns { (lf,o,rg) ->
      lf.prm = t.prm = rg.prm /\ lf.m.ord = t.m.ord = rg.m.ord /\
      c lf /\ c rg /\
      let om = t.m.ord in
      let km = t.kprm.mdl k in
      match o with
      | None -> (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.eq om km k2 ->
        t.m.func k2 = None) && t.m.func km = None
      | Some v -> t.prm2.inv v /\ let vm = t.prm2.mdl v in
        (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.eq om km k2 ->
          t.m.func k2 = Some vm) && t.m.func km = Some vm
      end /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.lt om k2 km ->
        lf.m.func k2 = t.m.func k2) /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.le om km k2 ->
        lf.m.func k2 = None) /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.lt om km k2 ->
        rg.m.func k2 = t.m.func k2) /\
      (forall k2:K.m 'b. CO.correct_for om k2 /\ CO.le om k2 km ->
        rg.m.func k2 = None) }
  = let (lf,o,rg) = MB.split k t in
    let o = abstract ensures { match o with None -> result = None
        | Some (_,v) -> result = Some v end }
        match o with None -> None | Some (_,v) -> Some v end end in
    (lf,o,rg)
  
end

module Set
  
  use import int.Int
  use import program_type.TypeParams
  use import option.Option
  use import ref.Ref
  
  (* Parameters. *)
  constant balancing : int
  axiom balancing_positive : balancing > 0
  
  (* Comparable key type. *)
  clone program_type.Type1 as K
  clone preorder.ComputableParam as CO with namespace T = K
  
  (* stored type is only the key. *)
  namespace D
    
    type t 'a 'b 'c 'd = K.t 'a 'b
    type m 'b 'd = K.m 'b
    function make_params (p1:type_params 'a 'b) (p2:type_params 'c 'd) :
      type_params (t 'a 'b 'c 'd) (m 'b 'd) = p1.K.make_params
    function key (t:m 'b 'd) : K.m 'b = t
    let get_key (ghost p1:type_params 'a 'b) (ghost p2:type_params 'c 'd)
      (t:t 'a 'b 'c 'd) : K.t 'a 'b
      requires { (make_params p1 p2).inv t }
      ensures { (K.make_params p1).inv result }
      ensures { key ((make_params p1 p2).mdl t) =
        (K.make_params p1).mdl result }
    = t
    
  end
  
  clone MapBase as MB with constant balancing = balancing,
    goal balancing_positive,
    namespace K = K,
    namespace D = D,
    function key = D.key,
    val get_key = D.get_key,
    namespace CO = CO,
    goal CO.lt_def,
    goal CO.eq_def,
    goal CO.refl,
    goal CO.trans,
    goal CO.total
  
  type t 'a 'b = MB.t 'a 'b 'a 'b
  type m 'b = {
    set : K.m 'b -> bool;
    ord : CO.O.m 'b;
  }
  predicate c (t:t 'a 'b) = MB.c t /\ t.MB.prm1 = t.MB.prm2
  function prm (t:t 'a 'b) : type_params 'a 'b = t.MB.prm1
  function kprm (t:t 'a 'b) : type_params (K.t 'a 'b) (K.m 'b) =
    t.prm.K.make_params
  function oprm (t:t 'a 'b) : type_params (CO.O.t 'a 'b) (CO.O.m 'b) =
    t.prm.CO.O.make_params
  function oproj (o:option 'a) : bool = match o with
  | None -> false
  | Some _ -> true
  end
  function m (t:t 'a 'b) : m 'b =
    { set = \k. oproj (t.MB.m.MB.func k);
      ord = t.MB.m.MB.ord }
  
  let lemma m_def (t:t 'a 'b) : unit
    ensures { forall k. not t.m.set k <-> t.MB.m.MB.func k = None }
    ensures { forall k v. t.MB.m.MB.func k = Some v ->
      t.m.set k }
    ensures { t.m.ord = t.MB.m.MB.ord }
  = ()
  
  let empty (ghost p:type_params 'a 'b) (o:CO.O.t 'a 'b) : t 'a 'b
    requires { p.CO.O.make_params.inv o }
    ensures { result.prm = p }
    ensures { c result }
    ensures { p.CO.O.make_params.mdl o = result.m.ord }
    ensures { forall k:K.m 'b. CO.correct_for result.m.ord k ->
      not result.m.set k }
  = MB.empty p p o
  
  let singleton (ghost p:type_params 'a 'b) (o:CO.O.t 'a 'b)
    (k:K.t 'a 'b) : t 'a 'b
    requires { p.CO.O.make_params.inv o }
    requires { p.K.make_params.inv k }
    requires { CO.correct_for (p.CO.O.make_params.mdl o)
      (p.K.make_params.mdl k) }
    ensures { result.prm = p }
    ensures { c result }
    ensures { p.CO.O.make_params.mdl o = result.m.ord }
    ensures { forall k2:K.m 'b. CO.correct_for result.m.ord k2 ->
      result.m.set k2 <-> CO.eq result.m.ord k2 (result.kprm.mdl k) }
  = MB.singleton p p o k
  
  let is_empty (ghost rk:ref (K.m 'b)) (t:t 'a 'b) : bool
    requires { c t }
    ensures { result -> forall k:K.m 'b. CO.correct_for t.m.ord k ->
      not t.m.set k }
    ensures { not result -> CO.correct_for t.m.ord !rk /\
      t.m.set !rk }
  = MB.is_empty rk t
  
  let decompose_min (t:t 'a 'b) : option (K.t 'a 'b,t 'a 'b)
    requires { c t }
    returns { None -> forall k:K.m 'b. CO.correct_for t.m.ord k -> not t.m.set k
      | Some (k,r) -> let km = r.kprm.mdl k in
        r.prm = t.prm /\ r.m.ord = t.m.ord /\ t.kprm.inv k /\
        CO.correct_for t.m.ord km /\
        forall k:K.m 'b. CO.correct_for t.m.ord k ->
          (CO.lt t.m.ord k km -> not t.m.set k) /\
          (CO.eq t.m.ord k km -> t.m.set k) /\
          (CO.le r.m.ord k km -> not r.m.set k) /\
          (not CO.eq r.m.ord km k -> r.m.set k <-> t.m.set k) }
  = MB.decompose_min t
  
  let decompose_max (t:t 'a 'b) : option (t 'a 'b,K.t 'a 'b)
    requires { c t }
    returns { None -> forall k:K.m 'b. CO.correct_for t.m.ord k -> not t.m.set k
      | Some (l,k) -> let km = l.kprm.mdl k in
        l.prm = t.prm /\ l.m.ord = t.m.ord /\ t.kprm.inv k /\
        CO.correct_for t.m.ord km /\
        forall k:K.m 'b. CO.correct_for t.m.ord k ->
          (CO.lt t.m.ord km k -> not t.m.set k) /\
          (CO.eq t.m.ord km k -> t.m.set k) /\
          (CO.le l.m.ord km k -> not l.m.set k) /\
          (not CO.eq l.m.ord k km -> l.m.set k <-> t.m.set k) }
  = MB.decompose_max t
  
  let add_min (k:K.t 'a 'b) (t:t 'a 'b) : t 'a 'b
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    requires { forall k2:K.m 'b. CO.correct_for t.m.ord k2 /\
      CO.le t.m.ord k2 (t.kprm.mdl k) -> not t.m.set k2 }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
      (CO.lt t.m.ord k km -> not result.m.set k) /\
      (CO.eq t.m.ord k km -> result.m.set k) /\
      (not CO.eq t.m.ord km k -> result.m.set k <-> t.m.set k) }
  = MB.add_min k t
  
  let add_max (t:t 'a 'b) (k:K.t 'a 'b) : t 'a 'b
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    requires { forall k2:K.m 'b. CO.correct_for t.m.ord k2 /\
      CO.le t.m.ord (t.kprm.mdl k) k2 -> not t.m.set k2 }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in
      forall k:K.m 'b. CO.correct_for t.m.ord k ->
      (CO.lt t.m.ord km k -> not result.m.set k) /\
      (CO.eq t.m.ord km k -> result.m.set k) /\
      (not CO.eq t.m.ord k km -> result.m.set k <-> t.m.set k) }
  = MB.add_max t k
  
  let concat (l r:t 'a 'b) : t 'a 'b
    requires { c l /\ c r /\ l.prm = r.prm /\ l.m.ord = r.m.ord }
    requires { forall k1 k2. CO.correct_for l.m.ord k1 /\
      CO.correct_for r.m.ord k2 /\ l.m.set k1 /\ r.m.set k2 ->
        CO.lt l.m.ord k1 k2 }
    ensures { c result /\ result.prm = l.prm /\ result.m.ord = l.m.ord }
    ensures { forall k. CO.correct_for l.m.ord k -> result.m.set k <->
      (r.m.set k \/ l.m.set k) }
  = MB.concat l r
  
  let mem (k:K.t 'a 'b) (t:t 'a 'b) : bool
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    ensures { result <-> t.m.set (t.kprm.mdl k) }
    ensures { result <-> (forall k2. CO.correct_for t.m.ord k2 /\
      CO.eq t.m.ord k2 (t.kprm.mdl k) -> t.m.set k2) }
  = match MB.get k t with None -> false | _ -> true end
  
  let add (k:K.t 'a 'b) (t:t 'a 'b) : t 'a 'b
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in
      (forall k:K.m 'b. CO.correct_for t.m.ord k ->
        (CO.eq t.m.ord k km -> result.m.set k) /\
        (t.m.set k -> result.m.set k) /\
        (not CO.eq t.m.ord k km -> result.m.set k -> t.m.set k)) &&
        result.m.set km }
  = MB.add k t
  
  let remove (k:K.t 'a 'b) (t:t 'a 'b) : t 'a 'b
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    ensures { c result /\ result.prm = t.prm /\ result.m.ord = t.m.ord }
    ensures { let km = t.kprm.mdl k in
      (forall k:K.m 'b. CO.correct_for t.m.ord k ->
        (CO.eq t.m.ord k km -> not result.m.set k) /\
        (result.m.set k -> t.m.set k) /\
        (not CO.eq t.m.ord k km -> t.m.set k -> result.m.set k)) &&
        not result.m.set km }
  = MB.remove k t
  
  let split (k:K.t 'a 'b) (t:t 'a 'b) : (t 'a 'b,bool,t 'a 'b)
    requires { c t /\ t.kprm.inv k }
    requires { CO.correct_for t.m.ord (t.kprm.mdl k) }
    returns { (lf,b,rg) ->
      lf.prm = t.prm = rg.prm /\ lf.m.ord = t.m.ord = rg.m.ord /\
      c lf /\ c rg /\
      let om = t.m.ord in let km = t.kprm.mdl k in
      (b <-> t.m.set km) /\
      (b <-> (forall k. CO.correct_for om k /\ CO.eq om k km ->
        t.m.set km)) /\
      (forall k. CO.correct_for om k /\ lf.m.set k -> t.m.set k) /\
      (forall k. CO.correct_for om k /\ rg.m.set k -> t.m.set k) /\
      (forall k. CO.correct_for om k /\ CO.lt om k km ->
        t.m.set k -> lf.m.set k) /\
      (forall k. CO.correct_for om k /\ CO.lt om km k ->
        t.m.set k -> rg.m.set k) /\
      (forall k. CO.correct_for om k /\ CO.le om km k ->
        not lf.m.set k) /\
      (forall k. CO.correct_for om k /\ CO.le om k km ->
        not rg.m.set k) }
  = let (lf,o,rg) = MB.split k t in
    let o = abstract ensures { result <-> o <> None }
      match o with None -> false | _ -> true end end in
    (lf,o,rg)
  
end

(* Example with integer keys and fixed ordering. *)
module IMapAndSet
  
  use import int.Int
  use import program_type.TypeParams
  
  namespace K
    type t 'a 'b = int
    type m 'b = int
    function make_params (p:type_params 'a 'b) : type_params int int =
      default_params
  end
  
  namespace O
    type t 'a 'b = unit
    type m 'b = unit
    function make_params (p:type_params 'a 'b) : type_params unit unit =
      default_params
  end
  
  constant balancing : int = 1
  
  predicate le unit (x y:int) = x <= y
  predicate eq unit (x y:int) = x = y
  predicate lt unit (x y:int) = x < y
  predicate correct_for unit int = true
  
  let compare (ghost p:type_params 'a 'b) (o:unit) (x y:int) : int
    ensures { result = x - y }
  = x - y
  
  clone Map as M with constant balancing = balancing,
    goal balancing_positive,
    namespace K = K,
    namespace CO.O = O,
    predicate CO.le = le,
    predicate CO.lt = lt,
    predicate CO.eq = eq,
    predicate CO.correct_for = correct_for,
    goal CO.lt_def,
    goal CO.eq_def,
    goal CO.refl,
    goal CO.trans,
    goal CO.total,
    val CO.compare = compare
  
  clone Set as S with constant balancing = balancing,
    goal balancing_positive,
    namespace K = K,
    namespace CO.O = O,
    predicate CO.le = le,
    predicate CO.lt = lt,
    predicate CO.eq = eq,
    predicate CO.correct_for = correct_for,
    goal CO.lt_def,
    goal CO.eq_def,
    goal CO.refl,
    goal CO.trans,
    goal CO.total,
    val CO.compare = compare
  
end

