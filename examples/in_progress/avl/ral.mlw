
(* Random-access list implementation. *)

module RAL
  
  use import int.Int
  use import list.NthLengthAppend
  use import avl.Base as B
  use import avl.SelectionTypes
  use import program_type.TypeParams
  use import ref.Ref
  
  (* Move remaining parameters here. *)
  constant balancing : int
  axiom balancing_positive : balancing > 0
  
  type selector 'a 'b = { index : int; hole : bool }
  (* Select an element or the hole before him (e.g holes starts at 0) *)
  
  (* To discuss: do we want to ensures that index fall in bounds ?
     Answer: yes, we do ! *)
  predicate selector_correct (s:selector 'a 'b) (t:B.t 'a 'b) =
    0 <= s.index && (if s.hole then s.index <= length t.m.lis
      else s.index < length t.m.lis)
  
  predicate selected (s:selector 'a 'b) (e:position 'b) (t:B.t 'a 'b) =
    s.index = length e.left /\ (s.hole <-> e.middle = None)
  
  let selected_way_impl (s:selector 'a 'b) (ghost base:t 'a 'b)
    (l:t 'a 'b) (d:'a) (r:t 'a 'b) : way_base (selector 'a 'b)
    requires { l.prm = r.prm = base.prm /\ l.prm.inv d }
    requires { exists b. c_balancing b l /\ c_balancing b r }
    requires { let l0 = node_model l.m.lis (l.prm.mdl d) r.m.lis in
      base.m.lis = l0 /\ selector_correct s base }
    (* A selected position can be found by following the given way. *)
    returns { Here -> let e2 = { left = l.m.lis;
        middle = Some (l.prm.mdl d);
        right = r.m.lis } in selected s e2 base /\
          rebuild e2 = node_model l.m.lis (l.prm.mdl d) r.m.lis
      | Left sl -> selector_correct sl l /\ forall e. selected sl e l /\
          rebuild e = l.m.lis ->
          let e2 = { e with right = node_model e.right (l.prm.mdl d) r.m.lis }
          in selected s e2 base /\ rebuild e2 = base.m.lis
      | Right sr -> selector_correct sr r /\ forall e. selected sr e r /\
          rebuild e = r.m.lis ->
          let e2 = { e with left = node_model l.m.lis (l.prm.mdl d) e.left } in
          selected s e2 base /\ rebuild e2 = base.m.lis }
  = let sl = B.size l in
    let ind = s.index in
    if ind > sl
    then Right { s with index = ind - sl - 1 }
    else if ind < sl
    then Left s
    else if s.hole
    then Left s
    else Here
  
  clone avl.Selection as Sel with type selector = selector,
    predicate selector_correct = selector_correct,
    predicate selected = selected,
    val selected_way = selected_way_impl,
    goal selector_correct_empty,
    constant balancing = balancing,
    goal balancing_positive
  
  type t 'a 'b = B.t 'a 'b
  type m 'b = list 'b
  predicate c (r:t 'a 'b) = Sel.c r
  function m (r:t 'a 'b) : m 'b = r.B.m.B.lis
  function prm (r:t 'a 'b) : type_params 'a 'b = r.B.prm
  clone export program_type.Type1 with type t = t, type m = m,
    predicate c = c, function m = m, function prm = prm
  
  (* Create an empty random-access list. *)
  let empty (ghost p:type_params 'a 'b) : t 'a 'b
    ensures { result.prm = p }
    ensures { result.m = Nil }
    ensures { c result }
  = Sel.empty p
  
  (* Create a list with a single element. *)
  let singleton (ghost p:type_params 'a 'b) (d:'a) : t 'a 'b
    requires { p.inv d }
    ensures { result.prm = p }
    ensures { result.m = Cons (p.mdl d) Nil }
    ensures { c result }
  = Sel.singleton p d
  
  (* Emptyness test. *)
  let is_empty (r:t 'a 'b) : bool
    requires { c r }
    ensures { result <-> match r.m with Nil -> true | _ -> false end }
  = Sel.is_empty r
  
  (* Pattern-matching over the list front. *)
  let decompose_front (r:t 'a 'b) : option ('a,t 'a 'b)
    requires { c r }
    returns { None -> r.m = Nil
      | Some (hd,tl) -> let p = r.prm in
        r.m = Cons (p.mdl hd) tl.m /\ c tl /\ tl.prm = p /\ p.inv hd }
  = Sel.decompose_front r
  
  (* Pattern-matching over the list back. *)
  let decompose_back (r:t 'a 'b) : option (t 'a 'b,'a)
    requires { c r }
    returns { None -> r.m = Nil
      | Some (cotl,cohd) -> let p = r.prm in
        r.m = cotl.m ++ Cons (p.mdl cohd) Nil /\ c cotl /\
        cotl.prm = p /\ p.inv cohd }
  = Sel.decompose_back r
  
  (* Get the first element of a non-empty list. *)
  let front (ghost li:ref (list 'b)) (r:t 'a 'b) : 'a
    requires { c r /\ r.m <> Nil }
    ensures { r.prm.inv result }
    ensures { Cons (r.prm.mdl result) !li = r.m }
  = Sel.front li r
  
  (* Get the last element of a non-empty list. *)
  let back (ghost li:ref (list 'b)) (r:t 'a 'b) : 'a
    requires { c r /\ r.m <> Nil }
    ensures { r.prm.inv result }
    ensures { !li ++ Cons (r.prm.mdl result) Nil = r.m }
  = Sel.back li r
  
  (* Add an element at the list front. *)
  let cons (d:'a) (r:t 'a 'b) : t 'a 'b
    requires { c r /\ r.prm.inv d }
    ensures { result.m = Cons (r.prm.mdl d) r.m }
    ensures { result.prm = r.prm }
  = Sel.cons d r
  
  (* Add an element at the list back. *)
  let snoc (r:t 'a 'b) (d:'a) : t 'a 'b
    requires { c r /\ r.prm.inv d }
    ensures { result.m = r.m ++ Cons (r.prm.mdl d) Nil }
    ensures { result.prm = r.prm }
  = Sel.snoc r d
  
  (* Append two lists. *)
  let concat (l:t 'a 'b) (r:t 'a 'b) : t 'a 'b
    requires { c l /\ c r /\ l.prm = r.prm }
    ensures { result.prm = l.prm /\ result.m = l.m ++ r.m }
  = Sel.concat l r
  
  (* Get the length of a list. *)
  let length (l:t 'a 'b) : int
    requires { c l }
    ensures { result = length l.m }
  = size l
  
  (* Set the n-th element. *)
  let set (n:int) (d:'a) (l:t 'a 'b) : t 'a 'b
    requires { 0 <= n < length l.m }
    requires { l.prm.inv d /\ c l }
    ensures { result.prm = l.prm }
    ensures { length result.m = length l.m }
    ensures { forall i:int. i <> n -> nth i result.m = nth i l.m }
    ensures { nth n result.m = Some (l.prm.mdl d) }
  = let ghost r = ref (Sel.default_position ()) in
    Sel.add r { index = n; hole = false } d l
  
  (* Get the n-th element. *)
  let get (n:int) (l:t 'a 'b) : 'a
    requires { 0 <= n < length l.m /\ c l }
    ensures { match nth n l.m with None -> false
      | Some d -> d = l.prm.mdl result end }
    ensures { l.prm.inv result }
  = let ghost r = ref (Sel.default_position ()) in
    match Sel.get r { index = n; hole = false } l with
    | None -> absurd
    | Some d -> d
    end
  
  (* Insert an element in the n-th position of the list,
     i.e between the (n-1)-th and n-th elements of the initial list. *)
  let insert (n:int) (d:'a) (l:t 'a 'b) : t 'a 'b
    requires { 0 <= n <= length l.m }
    requires { l.prm.inv d /\ c l }
    ensures { result.prm = l.prm }
    ensures { length result.m = length l.m + 1 }
    ensures { forall i:int. i < n -> nth i result.m = nth i l.m }
    ensures { forall i:int. i > n -> nth i result.m = nth (i-1) l.m }
    ensures { nth n result.m = Some (l.prm.mdl d) }
  = let ghost r = ref (Sel.default_position ()) in
    Sel.add r { index = n; hole = true } d l
  
  (* Cut the list between the (n-1)-th and n-th elements. *)
  let cut (n:int) (l:t 'a 'b) : (t 'a 'b,t 'a 'b)
    requires { 0 <= n <= length l.m /\ c l }
    returns { (lf,rg) -> l.m = lf.m ++ rg.m /\
      c lf /\ c rg /\ lf.prm = l.prm = rg.prm }
  = let ghost r = ref (Sel.default_position ()) in
    let (lf,_,rg) = Sel.split r { index = n; hole = true } l in
    (lf,rg)
  
end

