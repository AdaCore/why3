module BitInterval
  use import int.Int
  use import bv.BV32

  predicate interval_eq_bv (a b:t) (i n:t) =
  let mask = lsl_bv (sub (lsl_bv (of_int 1) n) (of_int 1)) i in
    bw_and b mask = bw_and a mask

  predicate interval_eq (a b:t) (i n:int) =
    forall j. i <= j < i + n -> nth a j = nth b j

  let lemma interval_eq_is_equ (a b i n : t)
    requires {ult i size /\ ule n size /\ ule (add i n) size}
    ensures { interval_eq    a b (to_uint i) (to_uint n)
          <-> interval_eq_bv a b i n }
  =
  (*   let tmp = lsl_bv (of_int 1) n in *)
  (* assert { ult n size -> nth_bv tmp n }; *)
  (* assert { n = size -> tmp = zero }; *)
  (* assert { forall i. i <> n -> not (nth_bv tmp i) }; *)
  (*   let tmp2 = sub tmp (of_int 1) in *)
  (* assert { forall i. ult i n -> nth_bv tmp2 i }; *)
  (* assert { forall i. uge i n /\ ult i size -> not (nth_bv tmp2 i) }; *)
  (*   let mask = lsl_bv tmp2 i in *)
  let mask =
  abstract
  ensures { forall j. ule i j /\ ult j (add i n) -> nth_bv result j }
  ensures { forall j. ult j i -> not (nth_bv result j) }
  ensures { forall j. ule (add i n) j -> not (nth_bv result j) }
    lsl_bv (sub (lsl_bv (of_int 1) n) (of_int 1)) i
  end
    in
  assert { to_uint i + to_uint n = to_uint (add i n) };
  assert { forall j. to_uint i <= j /\ j < (to_uint i + to_uint n) -> j = to_uint (of_int j) && nth mask j };
  assert { forall j. 0 <= j < to_uint i -> j = to_uint (of_int j) && not (nth mask j) };
  assert { forall j. (to_uint i + to_uint n) <= j < size_int -> j = to_uint (of_int j) && not (nth mask j) };
  assert { interval_eq    a b (to_uint i) (to_uint n)
       <->  bw_and b mask = bw_and a mask };
    ()

  use bv.BV64
  use bv.BVConverter_32_64 as C32_64

  predicate interval_eq_bv_64 (a b:BV64.t) (i n:BV64.t) =
  let mask = BV64.lsr_bv (BV64.sub (BV64.lsl_bv (BV64.of_int 1) n) (BV64.of_int 1)) i in
    BV64.bw_and b mask = BV64.bw_and a mask

  predicate interval_eq_64 (a b:BV64.t) (i n:int) =
    forall j. i <= j < i + n -> BV64.nth a j = BV64.nth b j

  lemma interval_eq_is_equ_64 : forall a b i n.
    BV64.ule i BV64.size -> BV64.ule (BV64.add i n) BV64.size ->
      interval_eq_64    a b (BV64.to_uint i) (BV64.to_uint n)
  <-> interval_eq_bv_64 a b i n

  function maxvalue (len : BV32.t) : BV64.t = BV64.lsl_bv (BV64.of_int 1) (C32_64.toBig len)

  lemma nth_ult:
    forall x:BV64.t, len:BV32.t. BV32.to_uint len < 64 ->
      (BV64.to_uint x < BV64.to_uint (maxvalue len)
  (* <-> (forall j:int. BV32.to_uint len <= j < 64 -> BV64.nth x j = False)) *)
  <-> interval_eq_bv_64 BV64.zero x (C32_64.toBig len) (BV64.sub (BV64.of_int 64) (C32_64.toBig len)))


  (* predicate bits_interval_is_zero_bv (a:BV32.t) (i:BV32.t) (n:BV32.t) = interval_eq_bv a zero i n *)

  (* predicate bits_interval_is_one_bv (a:BV32.t) (i:BV32.t) (n:BV32.t) = interval_eq_bv a ones i n *)

  (* predicate bits_interval_is_zero (a:BV32.t) (i : int) (n : int) = interval_eq a zero i n *)

  (* predicate bits_interval_is_one (a:BV32.t) (i : int) (n : int) = interval_eq a ones i n *)

  (* lemma bits_interval_is_zero_equ : forall a i n. *)
  (*   ule i (of_int 32) -> ule (add i n) (of_int 32) -> *)
  (*     bits_interval_is_zero a (to_uint i) (to_uint n) <-> bits_interval_is_zero_bv a i n *)

  (* lemma bits_interval_is_one_equ : forall a i n. *)
  (*   ule i (of_int 32) /\ ule n (sub (of_int 32) i) -> *)
  (*     bits_interval_is_one a (to_uint i) (to_uint n) <-> bits_interval_is_one_bv a i n *)

end