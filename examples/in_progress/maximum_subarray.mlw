
(* Maximum subarray problem

   Given an array of integers, find the contiguous subarray with the
   largest sum.
 *)

module Spec
  use import int.Int
  use export array.Array
  use export array.ArraySum

  predicate maxsublo (a: array int) (maxlo: int) (s: int) =
    forall l h: int. 0 <= l < maxlo -> l <= h <= length a -> sum a l h <= s

  predicate maxsub (a: array int) (s: int) =
    forall l h: int. 0 <= l <= h <= length a -> sum a l h <= s

end

(* Naive solution, in O(N^3) *)
module Algo1

  use import ref.Refint
  use import Spec

  let maximum_subarray (a: array int) (ghost lo hi: ref int): int
    ensures { 0 <= !lo <= !hi <= length a && result = sum a !lo !hi }
    ensures { maxsub a result }
  = lo := 0;
    hi := 0;
    let n = length a in
    let ms = ref 0 in
    for l = 0 to n-1 do
      invariant { 0 <= !lo <= l && !lo <= !hi <= n && !ms = sum a !lo !hi }
      invariant { maxsublo a l !ms }
      for h = l to n do
        invariant { 0 <= !lo <= l && !lo <= !hi <= n && !ms = sum a !lo !hi }
        invariant { maxsublo a l !ms }
        invariant { forall h': int. l <= h' < h -> sum a l h' <= !ms }
        (* consider the sum of a[l..h[ *)
        let s = ref 0 in
        for i = l to h-1 do
          invariant { !s = sum a l i }
          invariant { 0 <= !lo <= l && !lo <= !hi <= n && !ms = sum a !lo !hi }
          s += a[i]
        done;
        assert { !s = sum a l h };
        if !s > !ms then begin ms := !s; lo := l; hi := h end
      done
    done;
    !ms

end

(* Slightly less naive solution, in O(N^2) *)

module Algo2

  use import ref.Refint
  use import Spec

  let maximum_subarray (a: array int) (ghost lo hi: ref int): int
    ensures { 0 <= !lo <= !hi <= length a && result = sum a !lo !hi }
    ensures { maxsub a result }
  = lo := 0;
    hi := 0;
    let n = length a in
    let ms = ref 0 in
    for l = 0 to n-1 do
      invariant { 0 <= !lo <= l && !lo <= !hi <= n && 0 <= !ms = sum a !lo !hi }
      invariant { maxsublo a l !ms }
      let s = ref 0 in
      for h = l+1 to n do
        invariant
                { 0 <= !lo <= l && !lo <= !hi <= n && 0 <= !ms = sum a !lo !hi }
        invariant { maxsublo a l !ms }
        invariant { forall h': int. l <= h' < h -> sum a l h' <= !ms }
        invariant { !s = sum a l (h-1) }
        s += a[h-1];
        assert { !s = sum a l h };
        if !s > !ms then begin ms := !s; lo := l; hi := h end
      done
    done;
    !ms

end


