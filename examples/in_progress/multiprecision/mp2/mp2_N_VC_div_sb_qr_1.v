(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.EuclideanDivision.
Require int.ComputerDivision.
Require int.Power.
Require map.Map.
Require map.Const.
Require bv.Pow2int.
Require bv.BV_Gen.
Require bool.Bool.

(* Why3 assumption *)
Definition unit := unit.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType : forall (a:Type) {a_WT:WhyType a},
  WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, (array a) -> (Z -> a).

Parameter length: forall {a:Type} {a_WT:WhyType a}, (array a) -> Z.

Axiom inv_array : forall {a:Type} {a_WT:WhyType a}, forall (self:(array a)),
  (0%Z <= (length self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z): a :=
  ((elts a1) i).

Parameter mixfix_lblsmnrb: forall {a:Type} {a_WT:WhyType a}, (array a) ->
  Z -> a -> (array a).

Axiom mixfix_lblsmnrb_spec : forall {a:Type} {a_WT:WhyType a},
  forall (a1:(array a)) (i:Z) (v:a), ((length (mixfix_lblsmnrb a1 i
  v)) = (length a1)) /\ ((elts (mixfix_lblsmnrb a1 i
  v)) = (map.Map.set (elts a1) i v)).

Axiom int32 : Type.
Parameter int32_WhyType : WhyType int32.
Existing Instance int32_WhyType.

Parameter to_int: int32 -> Z.

(* Why3 assumption *)
Definition in_bounds (n:Z): Prop := ((-2147483648%Z)%Z <= n)%Z /\
  (n <= 2147483647%Z)%Z.

Axiom to_int_in_bounds : forall (n:int32), (in_bounds (to_int n)).

Axiom extensionality : forall (x:int32) (y:int32),
  ((to_int x) = (to_int y)) -> (x = y).

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter nth: t -> Z -> bool.

Axiom nth_out_of_bound : forall (x:t) (n:Z), ((n < 0%Z)%Z \/
  (32%Z <= n)%Z) -> ((nth x n) = false).

Parameter zeros: t.

Axiom Nth_zeros : forall (n:Z), ((nth zeros n) = false).

Parameter ones: t.

Axiom Nth_ones : forall (n:Z), ((0%Z <= n)%Z /\ (n < 32%Z)%Z) -> ((nth ones
  n) = true).

Parameter bw_and: t -> t -> t.

Axiom Nth_bw_and : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < 32%Z)%Z) -> ((nth (bw_and v1 v2) n) = (Init.Datatypes.andb (nth v1
  n) (nth v2 n))).

Parameter bw_or: t -> t -> t.

Axiom Nth_bw_or : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < 32%Z)%Z) -> ((nth (bw_or v1 v2) n) = (Init.Datatypes.orb (nth v1
  n) (nth v2 n))).

Parameter bw_xor: t -> t -> t.

Axiom Nth_bw_xor : forall (v1:t) (v2:t) (n:Z), ((0%Z <= n)%Z /\
  (n < 32%Z)%Z) -> ((nth (bw_xor v1 v2) n) = (Init.Datatypes.xorb (nth v1
  n) (nth v2 n))).

Parameter bw_not: t -> t.

Axiom Nth_bw_not : forall (v:t) (n:Z), ((0%Z <= n)%Z /\ (n < 32%Z)%Z) ->
  ((nth (bw_not v) n) = (Init.Datatypes.negb (nth v n))).

Parameter lsr: t -> Z -> t.

Axiom Lsr_nth_low : forall (b:t) (n:Z) (s:Z), (0%Z <= s)%Z ->
  ((0%Z <= n)%Z -> (((n + s)%Z < 32%Z)%Z -> ((nth (lsr b s) n) = (nth b
  (n + s)%Z)))).

Axiom Lsr_nth_high : forall (b:t) (n:Z) (s:Z), (0%Z <= s)%Z ->
  ((0%Z <= n)%Z -> ((32%Z <= (n + s)%Z)%Z -> ((nth (lsr b s) n) = false))).

Axiom lsr_zeros : forall (x:t), ((lsr x 0%Z) = x).

Parameter asr: t -> Z -> t.

Axiom Asr_nth_low : forall (b:t) (n:Z) (s:Z), (0%Z <= s)%Z ->
  (((0%Z <= n)%Z /\ (n < 32%Z)%Z) -> (((n + s)%Z < 32%Z)%Z -> ((nth (asr b s)
  n) = (nth b (n + s)%Z)))).

Axiom Asr_nth_high : forall (b:t) (n:Z) (s:Z), (0%Z <= s)%Z ->
  (((0%Z <= n)%Z /\ (n < 32%Z)%Z) -> ((32%Z <= (n + s)%Z)%Z -> ((nth (asr b
  s) n) = (nth b (32%Z - 1%Z)%Z)))).

Axiom asr_zeros : forall (x:t), ((asr x 0%Z) = x).

Parameter lsl: t -> Z -> t.

Axiom Lsl_nth_high : forall (b:t) (n:Z) (s:Z), ((0%Z <= s)%Z /\
  ((s <= n)%Z /\ (n < 32%Z)%Z)) -> ((nth (lsl b s) n) = (nth b (n - s)%Z)).

Axiom Lsl_nth_low : forall (b:t) (n:Z) (s:Z), ((0%Z <= n)%Z /\ (n < s)%Z) ->
  ((nth (lsl b s) n) = false).

Axiom lsl_zeros : forall (x:t), ((lsl x 0%Z) = x).

Parameter rotate_right: t -> Z -> t.

Axiom Nth_rotate_right : forall (v:t) (n:Z) (i:Z), ((0%Z <= i)%Z /\
  (i < 32%Z)%Z) -> ((0%Z <= n)%Z -> ((nth (rotate_right v n) i) = (nth v
  (int.EuclideanDivision.mod1 (i + n)%Z 32%Z)))).

Parameter rotate_left: t -> Z -> t.

Axiom Nth_rotate_left : forall (v:t) (n:Z) (i:Z), ((0%Z <= i)%Z /\
  (i < 32%Z)%Z) -> ((0%Z <= n)%Z -> ((nth (rotate_left v n) i) = (nth v
  (int.EuclideanDivision.mod1 (i - n)%Z 32%Z)))).

Parameter to_int1: t -> Z.

Parameter to_uint: t -> Z.

Parameter of_int: Z -> t.

Axiom to_uint_extensionality : forall (v:t) (v':t),
  ((to_uint v) = (to_uint v')) -> (v = v').

Axiom to_int_extensionality : forall (v:t) (v':t),
  ((to_int1 v) = (to_int1 v')) -> (v = v').

(* Why3 assumption *)
Definition uint_in_range (i:Z): Prop := (0%Z <= i)%Z /\
  (i <= 4294967295%Z)%Z.

Axiom to_uint_bounds : forall (v:t), (0%Z <= (to_uint v))%Z /\
  ((to_uint v) < 4294967296%Z)%Z.

Axiom to_uint_of_int : forall (i:Z), ((0%Z <= i)%Z /\
  (i < 4294967296%Z)%Z) -> ((to_uint (of_int i)) = i).

Axiom Of_int_zeros : (zeros = (of_int 0%Z)).

Axiom Of_int_ones : (ones = (of_int 4294967295%Z)).

(* Why3 assumption *)
Definition ult (x:t) (y:t): Prop := ((to_uint x) < (to_uint y))%Z.

(* Why3 assumption *)
Definition ule (x:t) (y:t): Prop := ((to_uint x) <= (to_uint y))%Z.

(* Why3 assumption *)
Definition ugt (x:t) (y:t): Prop := ((to_uint y) < (to_uint x))%Z.

(* Why3 assumption *)
Definition uge (x:t) (y:t): Prop := ((to_uint y) <= (to_uint x))%Z.

(* Why3 assumption *)
Definition slt (v1:t) (v2:t): Prop := ((to_int1 v1) < (to_int1 v2))%Z.

(* Why3 assumption *)
Definition sle (v1:t) (v2:t): Prop := ((to_int1 v1) <= (to_int1 v2))%Z.

(* Why3 assumption *)
Definition sgt (v1:t) (v2:t): Prop := ((to_int1 v2) < (to_int1 v1))%Z.

(* Why3 assumption *)
Definition sge (v1:t) (v2:t): Prop := ((to_int1 v2) <= (to_int1 v1))%Z.

Parameter add: t -> t -> t.

Axiom to_uint_add : forall (v1:t) (v2:t), ((to_uint (add v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) + (to_uint v2))%Z
  4294967296%Z)).

Axiom to_uint_add_bounded : forall (v1:t) (v2:t),
  (((to_uint v1) + (to_uint v2))%Z < 4294967296%Z)%Z -> ((to_uint (add v1
  v2)) = ((to_uint v1) + (to_uint v2))%Z).

Parameter sub: t -> t -> t.

Axiom to_uint_sub : forall (v1:t) (v2:t), ((to_uint (sub v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) - (to_uint v2))%Z
  4294967296%Z)).

Axiom to_uint_sub_bounded : forall (v1:t) (v2:t),
  ((0%Z <= ((to_uint v1) - (to_uint v2))%Z)%Z /\
  (((to_uint v1) - (to_uint v2))%Z < 4294967296%Z)%Z) -> ((to_uint (sub v1
  v2)) = ((to_uint v1) - (to_uint v2))%Z).

Parameter neg: t -> t.

Axiom to_uint_neg : forall (v:t),
  ((to_uint (neg v)) = (int.EuclideanDivision.mod1 (-(to_uint v))%Z
  4294967296%Z)).

Parameter mul: t -> t -> t.

Axiom to_uint_mul : forall (v1:t) (v2:t), ((to_uint (mul v1
  v2)) = (int.EuclideanDivision.mod1 ((to_uint v1) * (to_uint v2))%Z
  4294967296%Z)).

Axiom to_uint_mul_bounded : forall (v1:t) (v2:t),
  (((to_uint v1) * (to_uint v2))%Z < 4294967296%Z)%Z -> ((to_uint (mul v1
  v2)) = ((to_uint v1) * (to_uint v2))%Z).

Parameter udiv: t -> t -> t.

Axiom to_uint_udiv : forall (v1:t) (v2:t), ((to_uint (udiv v1
  v2)) = (int.EuclideanDivision.div (to_uint v1) (to_uint v2))).

Parameter urem: t -> t -> t.

Axiom to_uint_urem : forall (v1:t) (v2:t), ((to_uint (urem v1
  v2)) = (int.EuclideanDivision.mod1 (to_uint v1) (to_uint v2))).

Parameter lsr_bv: t -> t -> t.

Axiom lsr_bv_is_lsr : forall (x:t) (n:t), ((lsr_bv x n) = (lsr x
  (to_uint n))).

Axiom to_uint_lsr : forall (v:t) (n:t), ((to_uint (lsr_bv v
  n)) = (int.EuclideanDivision.div (to_uint v)
  (bv.Pow2int.pow2 (to_uint n)))).

Parameter asr_bv: t -> t -> t.

Axiom asr_bv_is_asr : forall (x:t) (n:t), ((asr_bv x n) = (asr x
  (to_uint n))).

Parameter lsl_bv: t -> t -> t.

Axiom lsl_bv_is_lsl : forall (x:t) (n:t), ((lsl_bv x n) = (lsl x
  (to_uint n))).

Axiom to_uint_lsl : forall (v:t) (n:t), ((to_uint (lsl_bv v
  n)) = (int.EuclideanDivision.mod1 ((to_uint v) * (bv.Pow2int.pow2 (to_uint n)))%Z
  4294967296%Z)).

Parameter rotate_right_bv: t -> t -> t.

Parameter rotate_left_bv: t -> t -> t.

Axiom rotate_left_bv_is_rotate_left : forall (v:t) (n:t), ((rotate_left_bv v
  n) = (rotate_left v (to_uint n))).

Axiom rotate_right_bv_is_rotate_right : forall (v:t) (n:t),
  ((rotate_right_bv v n) = (rotate_right v (to_uint n))).

Parameter nth_bv: t -> t -> bool.

Axiom nth_bv_def : forall (x:t) (i:t), ((nth_bv x i) = true) <->
  ~ ((bw_and (lsr_bv x i) (of_int 1%Z)) = zeros).

Axiom Nth_bv_is_nth : forall (x:t) (i:t), ((nth x (to_uint i)) = (nth_bv x
  i)).

Axiom Nth_bv_is_nth2 : forall (x:t) (i:Z), ((0%Z <= i)%Z /\
  (i < 4294967296%Z)%Z) -> ((nth_bv x (of_int i)) = (nth x i)).

Parameter eq_sub_bv: t -> t -> t -> t -> Prop.

Axiom eq_sub_bv_def : forall (a:t) (b:t) (i:t) (n:t), let mask :=
  (lsl_bv (sub (lsl_bv (of_int 1%Z) n) (of_int 1%Z)) i) in ((eq_sub_bv a b i
  n) <-> ((bw_and b mask) = (bw_and a mask))).

(* Why3 assumption *)
Definition eq_sub (a:t) (b:t) (i:Z) (n:Z): Prop := forall (j:Z),
  ((i <= j)%Z /\ (j < (i + n)%Z)%Z) -> ((nth a j) = (nth b j)).

Axiom eq_sub_equiv : forall (a:t) (b:t) (i:t) (n:t), (eq_sub a b (to_uint i)
  (to_uint n)) <-> (eq_sub_bv a b i n).

Axiom Extensionality : forall (x:t) (y:t), (eq_sub x y 0%Z 32%Z) -> (x = y).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Implicit Arguments mk_ref [[a]].

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:(ref a)): a :=
  match v with
  | (mk_ref x) => x
  end.

(* Why3 assumption *)
Definition map_eq_sub {a:Type} {a_WT:WhyType a} (a1:(Z -> a)) (a2:(Z -> a))
  (l:Z) (u:Z): Prop := forall (i:Z), ((l <= i)%Z /\ (i < u)%Z) -> ((a1
  i) = (a2 i)).

(* Why3 assumption *)
Definition map_eq_sub_shift {a:Type} {a_WT:WhyType a} (x:(Z -> a)) (y:(Z ->
  a)) (xi:Z) (yi:Z) (sz:Z): Prop := forall (i:Z), ((0%Z <= i)%Z /\
  (i < sz)%Z) -> ((x (xi + i)%Z) = (y (yi + i)%Z)).

Axiom map_eq_shift : forall {a:Type} {a_WT:WhyType a}, forall (x:(Z -> a))
  (y:(Z -> a)) (xi:Z) (yi:Z) (sz:Z) (k:Z), (map_eq_sub_shift x y xi yi sz) ->
  (((0%Z <= k)%Z /\ (k < sz)%Z) -> ((x (xi + k)%Z) = (y (yi + k)%Z))).

Axiom map_eq_shift_zero : forall {a:Type} {a_WT:WhyType a}, forall (x:(Z ->
  a)) (y:(Z -> a)) (n:Z) (m:Z), (map_eq_sub_shift x y n n (m - n)%Z) ->
  (map_eq_sub x y n m).

Axiom uint64 : Type.
Parameter uint64_WhyType : WhyType uint64.
Existing Instance uint64_WhyType.

Parameter to_int2: uint64 -> Z.

(* Why3 assumption *)
Definition in_bounds1 (n:Z): Prop := (0%Z <= n)%Z /\
  (n <= 18446744073709551615%Z)%Z.

Axiom to_int_in_bounds1 : forall (n:uint64), (in_bounds1 (to_int2 n)).

Axiom extensionality1 : forall (x:uint64) (y:uint64),
  ((to_int2 x) = (to_int2 y)) -> (x = y).

Parameter zero_unsigned: uint64.

Axiom zero_unsigned_is_zero : ((to_int2 zero_unsigned) = 0%Z).

Parameter is_msb_set: uint64 -> Prop.

Axiom is_msb_set_spec : forall (x:uint64), (is_msb_set x) <->
  (18446744073709551615%Z < (2%Z * (to_int2 x))%Z)%Z.

(* Why3 assumption *)
Definition limb := uint64.

Axiom limb_max_bound : (1%Z <= 18446744073709551615%Z)%Z.

Axiom prod_compat_strict_r : forall (a:Z) (b:Z) (c:Z), ((0%Z <= a)%Z /\
  (a < b)%Z) -> ((0%Z < c)%Z -> ((c * a)%Z < (c * b)%Z)%Z).

Parameter value_sub: (Z -> uint64) -> Z -> Z -> Z.

Axiom value_sub_def : forall (x:(Z -> uint64)) (n:Z) (m:Z), ((n < m)%Z ->
  ((value_sub x n m) = ((to_int2 (x
  n)) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub x (n + 1%Z)%Z
  m))%Z)%Z)) /\ ((~ (n < m)%Z) -> ((value_sub x n m) = 0%Z)).

Axiom value_sub_frame : forall (x:(Z -> uint64)) (y:(Z -> uint64)) (n:Z)
  (m:Z), (map_eq_sub x y n m) -> ((value_sub x n m) = (value_sub y n m)).

Axiom value_sub_frame_shift : forall (x:(Z -> uint64)) (y:(Z -> uint64))
  (xi:Z) (yi:Z) (sz:Z), (map_eq_sub_shift x y xi yi sz) -> ((value_sub x xi
  (xi + sz)%Z) = (value_sub y yi (yi + sz)%Z)).

Axiom value_sub_tail : forall (x:(Z -> uint64)) (n:Z) (m:Z), (n <= m)%Z ->
  ((value_sub x n (m + 1%Z)%Z) = ((value_sub x n m) + ((to_int2 (x
  m)) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z (m - n)%Z))%Z)%Z).

Axiom value_sub_concat : forall (x:(Z -> uint64)) (n:Z) (m:Z) (l:Z),
  ((n <= m)%Z /\ (m <= l)%Z) -> ((value_sub x n l) = ((value_sub x n
  m) + ((value_sub x m l) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (m - n)%Z))%Z)%Z).

Axiom value_sub_head : forall (x:(Z -> uint64)) (n:Z) (m:Z), (n < m)%Z ->
  ((value_sub x n m) = ((to_int2 (x
  n)) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub x (n + 1%Z)%Z
  m))%Z)%Z).

Axiom value_sub_update : forall (x:(Z -> uint64)) (i:Z) (n:Z) (m:Z)
  (v:uint64), ((n <= i)%Z /\ (i < m)%Z) -> ((value_sub (map.Map.set x i v) n
  m) = ((value_sub x n
  m) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (i - n)%Z) * ((to_int2 v) - (to_int2 (x i)))%Z)%Z)%Z).

Axiom value_zero : forall (x:(Z -> uint64)) (n:Z) (m:Z), (map_eq_sub x
  (map.Const.const zero_unsigned: (Z -> uint64)) n m) -> ((value_sub x n
  m) = 0%Z).

Axiom value_sub_update_no_change : forall (x:(Z -> uint64)) (i:Z) (n:Z) (m:Z)
  (v:uint64), (n <= m)%Z -> (((i < n)%Z \/ (m <= i)%Z) -> ((value_sub x n
  m) = (value_sub (map.Map.set x i v) n m))).

Axiom value_sub_shift_no_change : forall (x:(Z -> uint64)) (ofs:Z) (i:Z)
  (sz:Z) (v:uint64), ((i < 0%Z)%Z \/ (sz <= i)%Z) -> ((0%Z <= sz)%Z ->
  ((value_sub x ofs (ofs + sz)%Z) = (value_sub (map.Map.set x (ofs + i)%Z v)
  ofs (ofs + sz)%Z))).

Axiom value_sub_lower_bound : forall (x:(Z -> uint64)) (x1:Z) (x2:Z),
  (0%Z <= (value_sub x x1 x2))%Z.

Axiom value_sub_upper_bound : forall (x:(Z -> uint64)) (x1:Z) (x2:Z),
  (x1 <= x2)%Z -> ((value_sub x x1
  x2) < (int.Power.power (18446744073709551615%Z + 1%Z)%Z (x2 - x1)%Z))%Z.

Axiom value_sub_lower_bound_tight : forall (x:(Z -> uint64)) (x1:Z) (x2:Z),
  (x1 < x2)%Z -> (((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((x2 - x1)%Z - 1%Z)%Z) * (to_int2 (x (x2 - 1%Z)%Z)))%Z <= (value_sub x x1
  x2))%Z.

Axiom value_sub_upper_bound_tight : forall (x:(Z -> uint64)) (x1:Z) (x2:Z),
  (x1 < x2)%Z -> ((value_sub x x1
  x2) < ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((x2 - x1)%Z - 1%Z)%Z) * ((to_int2 (x (x2 - 1%Z)%Z)) + 1%Z)%Z)%Z)%Z.

Axiom t1 : Type.
Parameter t1_WhyType : WhyType t1.
Existing Instance t1_WhyType.

Parameter max: Z.

Parameter to_int3: t1 -> Z.

(* Why3 assumption *)
Definition in_bounds2 (n:Z): Prop := (0%Z <= n)%Z /\ (n <= max)%Z.

Axiom to_int_in_bounds2 : forall (n:t1), (in_bounds2 (to_int3 n)).

Axiom extensionality2 : forall (x:t1) (y:t1), ((to_int3 x) = (to_int3 y)) ->
  (x = y).

Parameter zero_unsigned1: t1.

Axiom zero_unsigned_is_zero1 : ((to_int3 zero_unsigned1) = 0%Z).

Axiom uint32 : Type.
Parameter uint32_WhyType : WhyType uint32.
Existing Instance uint32_WhyType.

Parameter to_int4: uint32 -> Z.

(* Why3 assumption *)
Definition in_bounds3 (n:Z): Prop := (0%Z <= n)%Z /\ (n <= 4294967295%Z)%Z.

Axiom to_int_in_bounds3 : forall (n:uint32), (in_bounds3 (to_int4 n)).

Axiom extensionality3 : forall (x:uint32) (y:uint32),
  ((to_int4 x) = (to_int4 y)) -> (x = y).

Parameter zero_unsigned2: uint32.

Axiom zero_unsigned_is_zero2 : ((to_int4 zero_unsigned2) = 0%Z).

Parameter is_msb_set1: uint32 -> Prop.

Axiom is_msb_set_spec1 : forall (x:uint32), (is_msb_set1 x) <->
  (4294967295%Z < (2%Z * (to_int4 x))%Z)%Z.

(* Why3 assumption *)
Definition in_us_bounds (n:Z): Prop := (0%Z <= n)%Z /\ (n <= 4294967295%Z)%Z.

(* Why3 assumption *)
Definition in_bounds4 (n:Z): Prop := ((-2147483648%Z)%Z <= n)%Z /\
  (n <= 2147483647%Z)%Z.

(* Why3 assumption *)
Inductive ptr (a:Type) :=
  | mk_ptr : (ref (array a)) -> Z -> ptr a.
Axiom ptr_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ptr a).
Existing Instance ptr_WhyType.
Implicit Arguments mk_ptr [[a]].

(* Why3 assumption *)
Definition offset {a:Type} {a_WT:WhyType a} (v:(ptr a)): Z :=
  match v with
  | (mk_ptr x x1) => x1
  end.

(* Why3 assumption *)
Definition data {a:Type} {a_WT:WhyType a} (v:(ptr a)): (ref (array a)) :=
  match v with
  | (mk_ptr x x1) => x
  end.

(* Why3 assumption *)
Definition plength {a:Type} {a_WT:WhyType a} (p:(ptr a)): Z :=
  (length (contents (data p))).

(* Why3 assumption *)
Definition pelts {a:Type} {a_WT:WhyType a} (p:(ptr a)): (Z -> a) :=
  (elts (contents (data p))).

Parameter is_null: forall {a:Type} {a_WT:WhyType a}, (ptr a) -> Prop.

Axiom is_null_spec : forall {a:Type} {a_WT:WhyType a}, forall (p:(ptr a)),
  (is_null p) <-> ((plength p) = 0%Z).

(* Why3 assumption *)
Definition valid_ptr_shift {a:Type} {a_WT:WhyType a} (p:(ptr a))
  (i:Z): Prop := (0%Z <= ((offset p) + i)%Z)%Z /\
  (((offset p) + i)%Z < (plength p))%Z.

(* Why3 assumption *)
Definition valid_ptr_itv {a:Type} {a_WT:WhyType a} (p:(ptr a))
  (sz:Z): Prop := (in_bounds4 sz) /\ ((0%Z <= sz)%Z /\
  ((0%Z <= (offset p))%Z /\ (((offset p) + sz)%Z <= (plength p))%Z)).

Axiom valid_itv_to_shift : forall {a:Type} {a_WT:WhyType a}, forall (p:(ptr
  a)) (sz:Z), (valid_ptr_itv p sz) -> forall (i:Z), ((0%Z <= i)%Z /\
  (i < sz)%Z) -> (valid_ptr_shift p i).

(* Why3 assumption *)
Definition t2 := (ptr uint64).

(* Why3 assumption *)
Definition value (x:(ptr uint64)): Z := (value_sub (pelts x) 0%Z
  (plength x)).

(* Why3 assumption *)
Definition value_sub_shift (x:(ptr uint64)) (sz:Z): Z := (value_sub (pelts x)
  (offset x) ((offset x) + sz)%Z).

Parameter compare_int: Z -> Z -> Z.

Axiom compare_int_def : forall (x:Z) (y:Z), ((x < y)%Z -> ((compare_int x
  y) = (-1%Z)%Z)) /\ ((~ (x < y)%Z) -> (((x = y) -> ((compare_int x
  y) = 0%Z)) /\ ((~ (x = y)) -> ((compare_int x y) = 1%Z)))).

Axiom pow2_64 : ((int.Power.power 2%Z
  64%Z) = (18446744073709551615%Z + 1%Z)%Z).

Axiom mod_mult : forall (x:Z) (y:Z) (z:Z), (0%Z < x)%Z ->
  ((int.EuclideanDivision.mod1 ((x * y)%Z + z)%Z
  x) = (int.EuclideanDivision.mod1 z x)).

(* Why3 assumption *)
Definition reciprocal (v:uint64) (d:uint64): Prop :=
  ((to_int2 v) = ((int.EuclideanDivision.div (((18446744073709551615%Z + 1%Z)%Z * (18446744073709551615%Z + 1%Z)%Z)%Z - 1%Z)%Z
  (to_int2 d)) - (18446744073709551615%Z + 1%Z)%Z)%Z).

Axiom fact_div : forall (x:Z) (y:Z) (z:Z), (0%Z < y)%Z ->
  ((int.EuclideanDivision.div (x + (y * z)%Z)%Z
  y) = ((int.EuclideanDivision.div x y) + z)%Z).

(* Why3 assumption *)
Definition reciprocal_3by2 (v:uint64) (dh:uint64) (dl:uint64): Prop :=
  ((to_int2 v) = ((int.EuclideanDivision.div ((((18446744073709551615%Z + 1%Z)%Z * (18446744073709551615%Z + 1%Z)%Z)%Z * (18446744073709551615%Z + 1%Z)%Z)%Z - 1%Z)%Z
  ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z) - (18446744073709551615%Z + 1%Z)%Z)%Z).

Axiom bounds_imply_rec3by2 : forall (v:uint64) (dh:uint64) (dl:uint64),
  ((((((18446744073709551615%Z + 1%Z)%Z * (18446744073709551615%Z + 1%Z)%Z)%Z * (18446744073709551615%Z + 1%Z)%Z)%Z - ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z <= (((18446744073709551615%Z + 1%Z)%Z + (to_int2 v))%Z * ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z)%Z /\
  ((((18446744073709551615%Z + 1%Z)%Z + (to_int2 v))%Z * ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z < (((18446744073709551615%Z + 1%Z)%Z * (18446744073709551615%Z + 1%Z)%Z)%Z * (18446744073709551615%Z + 1%Z)%Z)%Z)%Z) ->
  (reciprocal_3by2 v dh dl).

(* Why3 assumption *)
Definition normalized (x:(ptr uint64)) (sz:int32): Prop := (valid_ptr_itv x
  (to_int sz)) /\
  ((int.EuclideanDivision.div (18446744073709551615%Z + 1%Z)%Z
  2%Z) <= (to_int2 ((pelts x) (((offset x) + (to_int sz))%Z - 1%Z)%Z)))%Z.

(* Why3 goal *)
Theorem VC_div_sb_qr : forall (q:(ptr uint64)) (x:(ptr uint64)) (y:(ptr
  uint64)) (sx:int32) (sy:int32), (((3%Z <= (to_int sy))%Z /\
  ((to_int sy) <= (to_int sx))%Z) /\ ((valid_ptr_itv x (to_int sx)) /\
  ((valid_ptr_itv y (to_int sy)) /\ ((valid_ptr_itv q
  ((to_int sx) - (to_int sy))%Z) /\ (normalized y sy))))) ->
  forall (one:int32), ((to_int one) = 1%Z) -> forall (two:int32),
  ((to_int two) = 2%Z) -> forall (limb_zero:uint64),
  ((to_int2 limb_zero) = 0%Z) -> forall (zero:int32),
  ((to_int zero) = 0%Z) -> forall (o:int32), ((to_int o) = 1%Z) ->
  forall (minus_one:int32), ((to_int minus_one) = (-(to_int o))%Z) ->
  forall (uone:uint64), ((to_int2 uone) = 1%Z) -> forall (o1:int32),
  ((to_int o1) = ((to_int sx) - (to_int two))%Z) -> forall (o2:(ptr uint64)),
  (((offset o2) = ((offset x) + (to_int o1))%Z) /\ ((data o2) = (data x))) ->
  forall (o3:int32), ((to_int o3) = ((to_int sx) - (to_int sy))%Z) ->
  forall (o4:(ptr uint64)), (((offset o4) = ((offset q) + (to_int o3))%Z) /\
  ((data o4) = (data q))) -> forall (o5:int32),
  ((to_int o5) = ((to_int sy) - (to_int one))%Z) -> let dh :=
  (mixfix_lbrb (contents (data y)) ((offset y) + (to_int o5))%Z) in
  (((int.EuclideanDivision.div (18446744073709551615%Z + 1%Z)%Z
  2%Z) <= (to_int2 dh))%Z -> forall (o6:int32),
  ((to_int o6) = ((to_int sy) - (to_int two))%Z) -> let dl :=
  (mixfix_lbrb (contents (data y)) ((offset y) + (to_int o6))%Z) in
  forall (v:uint64), (reciprocal_3by2 v dh dl) -> forall (o7:int32),
  ((to_int o7) = ((to_int sx) - (to_int sy))%Z) -> forall (mdn:int32),
  ((to_int mdn) = ((to_int two) - (to_int sy))%Z) -> forall (xd:(ptr
  uint64)), (((offset xd) = ((offset o2) + (to_int mdn))%Z) /\
  ((data xd) = (data o2))) -> let vy := (value_sub_shift y (to_int sy)) in
  forall (r:int32), ((to_int r) = (compare_int (value_sub_shift xd
  (to_int sy)) (value_sub_shift y (to_int sy)))) ->
  ((((to_int zero) <= (to_int r))%Z -> forall (x1:uint64) (xp:(ptr uint64))
  (x2:(ptr uint64)), ((xp = (mk_ptr (data x2) (offset o2))) /\
  ((length (contents (data x2))) = (length (contents (data o2))))) ->
  (((x2 = (mk_ptr (data x2) (offset x))) /\
  ((length (contents (data x2))) = (length (contents (data x))))) ->
  ((((value_sub_shift x (to_int sx)) = ((((((value_sub_shift o4
  (((to_int sx) - (to_int sy))%Z - (to_int o7))%Z) + ((to_int2 uone) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sx) - (to_int sy))%Z - (to_int o7))%Z))%Z)%Z * vy)%Z * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int o7)))%Z + (value_sub_shift x2
  (((to_int sy) + (to_int o7))%Z - 1%Z)%Z))%Z + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sy) + (to_int o7))%Z - 1%Z)%Z) * (to_int2 x1))%Z)%Z) /\
  ((((value_sub (pelts x2) ((offset xp) + (to_int mdn))%Z
  ((((offset xp) + (to_int mdn))%Z + (to_int sy))%Z - 1%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 1%Z)%Z) * (to_int2 x1))%Z)%Z < vy)%Z /\
  (((to_int2 ((pelts x2)
  (offset xp))) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x1))%Z)%Z <= ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z)) ->
  forall (x11:uint64) (i:int32) (qp:(ptr uint64)) (xp1:(ptr uint64)) (x3:(ptr
  uint64)) (q1:(ptr uint64)), ((x3 = (mk_ptr (data x3) (offset x2))) /\
  ((length (contents (data x3))) = (length (contents (data x2))))) ->
  (((q1 = (mk_ptr (data q1) (offset q))) /\
  ((length (contents (data q1))) = (length (contents (data q))))) ->
  ((((0%Z <= (to_int i))%Z /\
  ((to_int i) <= ((to_int sx) - (to_int sy))%Z)%Z) /\
  (((offset qp) = ((offset q1) + (to_int i))%Z) /\
  (((offset xp1) = ((((offset x3) + (to_int sy))%Z + (to_int i))%Z - 2%Z)%Z) /\
  (((plength qp) = (plength q1)) /\ (((plength xp1) = (plength x3)) /\
  (((pelts qp) = (pelts q1)) /\ (((pelts xp1) = (pelts x3)) /\
  (((value_sub_shift x (to_int sx)) = ((((((value_sub_shift qp
  (((to_int sx) - (to_int sy))%Z - (to_int i))%Z) + ((to_int2 uone) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sx) - (to_int sy))%Z - (to_int i))%Z))%Z)%Z * vy)%Z * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int i)))%Z + (value_sub_shift x3
  (((to_int sy) + (to_int i))%Z - 1%Z)%Z))%Z + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sy) + (to_int i))%Z - 1%Z)%Z) * (to_int2 x11))%Z)%Z) /\
  ((((value_sub (pelts x3) ((offset xp1) + (to_int mdn))%Z
  ((((offset xp1) + (to_int mdn))%Z + (to_int sy))%Z - 1%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 1%Z)%Z) * (to_int2 x11))%Z)%Z < vy)%Z /\
  (((to_int2 ((pelts x3)
  (offset xp1))) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x11))%Z)%Z <= ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z))))))))) ->
  (((to_int zero) < (to_int i))%Z -> let k := (to_int i) in
  forall (o8:int32), ((to_int o8) = ((to_int i) - (to_int one))%Z) ->
  forall (i1:int32), (i1 = o8) -> let s :=
  (((to_int sy) + (to_int i1))%Z - 1%Z)%Z in forall (o9:(ptr uint64)),
  (((offset o9) = ((offset xp1) + (to_int minus_one))%Z) /\
  ((data o9) = (data xp1))) -> forall (xp2:(ptr uint64)), (xp2 = o9) ->
  forall (xd1:(ptr uint64)),
  (((offset xd1) = ((offset xp2) + (to_int mdn))%Z) /\
  ((data xd1) = (data xp2))) -> ((~ (((to_int2 x11) = (to_int2 dh)) /\
  ((to_int2 (mixfix_lbrb (contents (data xp2))
  ((offset xp2) + (to_int one))%Z)) = (to_int2 dl)))) ->
  ((((to_int2 ((pelts x3)
  ((offset xp2) + 1%Z)%Z)) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x11))%Z)%Z < ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z ->
  let xp0 := (mixfix_lbrb (contents (data xp2)) (offset xp2)) in let xp11 :=
  (mixfix_lbrb (contents (data xp2)) ((offset xp2) + (to_int one))%Z) in
  (((value_sub_shift xd1 (to_int sy)) = ((value_sub_shift xd1
  ((to_int sy) - 2%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 2%Z)%Z) * ((to_int2 xp0) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 xp11))%Z)%Z)%Z)%Z) ->
  forall (o10:uint64) (o11:uint64) (o12:uint64),
  ((((((to_int2 o10) * ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z + (to_int2 o11))%Z + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 o12))%Z)%Z = ((to_int2 xp0) + ((18446744073709551615%Z + 1%Z)%Z * ((to_int2 xp11) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x11))%Z)%Z)%Z)%Z) /\
  ((0%Z <= ((to_int2 o11) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 o12))%Z)%Z)%Z /\
  (((to_int2 o11) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 o12))%Z)%Z < ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z)) ->
  forall (ql:uint64), (ql = o10) -> forall (x12:uint64), (x12 = o12) ->
  forall (x0:uint64), (x0 = o11) -> let o13 :=
  ((((offset x3) + (to_int sy))%Z + k)%Z - 1%Z)%Z in let o14 :=
  (offset xd1) in let o15 := (offset x3) in let o16 := (pelts x3) in
  (((value_sub o16 o15 o13) = ((value_sub o16 o15 o14) + ((value_sub o16 o14
  o13) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o14 - o15)%Z))%Z)%Z) -> let o17 := (contents (data x3)) in
  forall (xc:(array uint64)), (((length xc) = (length o17)) /\ forall (i2:Z),
  ((0%Z <= i2)%Z /\ (i2 < (length xc))%Z) -> ((mixfix_lbrb xc
  i2) = (mixfix_lbrb o17 i2))) -> let o18 := ((offset x3) + (to_int i1))%Z in
  let o19 := (offset x3) in (((value_sub (pelts x3) o19
  o18) = (value_sub (elts xc) o19 o18)) -> forall (o20:int32),
  ((to_int o20) = ((to_int sy) - (to_int two))%Z) -> forall (xp3:(ptr
  uint64)) (x4:(ptr uint64)), let xd2 := (mk_ptr (data x4) (offset xd1)) in
  (((length (contents (data x4))) = (length (contents (data xd1)))) ->
  (((xp3 = (mk_ptr (data x4) (offset xp2))) /\
  ((length (contents (data x4))) = (length (contents (data xp2))))) ->
  (((x4 = (mk_ptr (data x4) (offset x3))) /\
  ((length (contents (data x4))) = (length (contents (data x3))))) ->
  forall (cy:uint64), ((((value_sub_shift xd2
  (to_int o20)) - ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int o20)) * (to_int2 cy))%Z)%Z = ((value_sub_shift xd1
  (to_int o20)) - ((value_sub_shift y (to_int o20)) * (to_int2 ql))%Z)%Z) /\
  forall (j:Z), ((j < (offset xd1))%Z \/
  (((offset xd1) + (to_int o20))%Z <= j)%Z) -> (((pelts xd2)
  j) = ((pelts xd1) j))) -> (((value_sub_shift x4
  (to_int i1)) = (value_sub_shift x3 (to_int i1))) -> forall (cy1:uint64),
  ((((to_int2 x0) < (to_int2 cy))%Z /\ (cy1 = uone)) \/
  ((~ ((to_int2 x0) < (to_int2 cy))%Z) /\ (cy1 = limb_zero))) ->
  forall (o21:uint64),
  ((to_int2 o21) = (int.EuclideanDivision.mod1 ((to_int2 x0) - (to_int2 cy))%Z
  (18446744073709551615%Z + 1%Z)%Z)) -> forall (x01:uint64), (x01 = o21) ->
  forall (cy2:uint64), ((((to_int2 x12) < (to_int2 cy1))%Z /\
  (cy2 = uone)) \/ ((~ ((to_int2 x12) < (to_int2 cy1))%Z) /\
  (cy2 = limb_zero))) -> forall (o22:uint64),
  ((to_int2 o22) = (int.EuclideanDivision.mod1 ((to_int2 x12) - (to_int2 cy1))%Z
  (18446744073709551615%Z + 1%Z)%Z)) -> forall (x13:uint64), (x13 = o22) ->
  (((0%Z <= (to_int2 cy2))%Z /\ ((to_int2 cy2) <= 1%Z)%Z) -> let o23 :=
  (((offset xd1) + (to_int sy))%Z - 1%Z)%Z in let o24 := (offset xd1) in
  let o25 := (offset xp3) in let o26 := (pelts x4) in
  (((value_sub (map.Map.set o26 o25 x01) o24 o23) = ((value_sub o26 o24
  o23) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o25 - o24)%Z) * ((to_int2 x01) - (to_int2 (o26 o25)))%Z)%Z)%Z) ->
  let o27 := ((offset x4) + (to_int i1))%Z in let o28 := (offset x4) in
  let o29 := (pelts x4) in (((value_sub o29 o28
  o27) = (value_sub (map.Map.set o29 (offset xp3) x01) o28 o27)) ->
  let o30 := (((offset xd1) + (to_int sy))%Z - 2%Z)%Z in let o31 :=
  (offset xd1) in let o32 := (pelts x4) in (((value_sub o32 o31
  o30) = (value_sub (map.Map.set o32 (offset xp3) x01) o31 o30)) ->
  forall (xp4:(ptr uint64)) (x5:(ptr uint64)),
  ((length (contents (data x5))) = (length (contents (data xp3)))) ->
  let xd3 := (mk_ptr (data x5) (offset xd1)) in
  (((length (contents (data x5))) = (length (contents (data x4)))) ->
  (((xp4 = (mk_ptr (data x5) (offset xp3))) /\
  ((length (contents (data x5))) = (length (contents (data xp3))))) ->
  (((x5 = (mk_ptr (data x5) (offset x4))) /\
  ((length (contents (data x5))) = (length (contents (data x4))))) ->
  (((pelts (mk_ptr (data x5) (offset xp3))) = (map.Map.set (pelts xp3)
  (offset xp3) x01)) -> (((value_sub_shift x5
  (to_int i1)) = (value_sub_shift x3 (to_int i1))) -> let o33 :=
  (((offset xd1) + (to_int sy))%Z - 1%Z)%Z in let o34 := (offset xd1) in
  let o35 := (pelts x5) in (((value_sub o35 o34
  (o33 + 1%Z)%Z) = ((value_sub o35 o34 o33) + ((to_int2 (o35
  o33)) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o33 - o34)%Z))%Z)%Z) -> (((((value_sub_shift xd3
  ((to_int sy) - 1%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 1%Z)%Z) * (to_int2 x13))%Z)%Z - ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int sy)) * (to_int2 cy2))%Z)%Z = (((value_sub_shift xd1
  (to_int sy)) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int sy)) * (to_int2 x11))%Z)%Z - ((to_int2 ql) * vy)%Z)%Z) ->
  forall (o36:bool), (((~ (cy2 = limb_zero)) -> (o36 = true)) /\
  ((o36 = true) -> ~ ((to_int2 cy2) = (to_int2 limb_zero)))) ->
  ((~ (o36 = true)) -> forall (o37:(ptr uint64)),
  (((offset o37) = ((offset qp) + (to_int minus_one))%Z) /\
  ((data o37) = (data qp))) -> forall (qp1:(ptr uint64)), (qp1 = o37) ->
  let o38 :=
  ((((offset qp1) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z in
  let o39 := ((offset qp1) + 1%Z)%Z in let o40 := (pelts q1) in
  (((value_sub o40 o39 o38) = (value_sub (map.Map.set o40 (offset qp1) ql)
  o39 o38)) -> forall (qp2:(ptr uint64)) (q2:(ptr uint64)),
  ((length (contents (data q2))) = (length (contents (data qp1)))) ->
  (((qp2 = (mk_ptr (data q2) (offset qp1))) /\
  ((length (contents (data q2))) = (length (contents (data qp1))))) ->
  (((q2 = (mk_ptr (data q2) (offset q1))) /\
  ((length (contents (data q2))) = (length (contents (data q1))))) ->
  (((pelts (mk_ptr (data q2) (offset qp1))) = (map.Map.set (pelts qp1)
  (offset qp1) ql)) -> let o41 :=
  ((((offset qp2) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z in
  let o42 := (offset qp2) in let o43 := (pelts q2) in (((value_sub o43 o42
  o41) = ((to_int2 (o43
  o42)) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub o43 (o42 + 1%Z)%Z
  o41))%Z)%Z) -> let o44 :=
  ((((offset x5) + (to_int sy))%Z + (to_int i1))%Z - 1%Z)%Z in let o45 :=
  (offset x5) in let o46 := (pelts x5) in (((value_sub o46 o45
  (o44 + 1%Z)%Z) = ((value_sub o46 o45 o44) + ((to_int2 (o46
  o44)) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o44 - o45)%Z))%Z)%Z) -> let o47 := ((offset x5) + s)%Z in let o48 :=
  (offset xd1) in let o49 := (offset x5) in let o50 := (pelts x5) in
  (((value_sub o50 o49 o47) = ((value_sub o50 o49 o48) + ((value_sub o50 o48
  o47) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o48 - o49)%Z))%Z)%Z) -> (((value_sub_shift qp2
  (((to_int sx) - (to_int sy))%Z - (to_int i1))%Z) = ((to_int2 ql) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub (pelts q2)
  ((offset qp2) + 1%Z)%Z
  ((((offset qp2) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z))%Z)%Z) ->
  (((value_sub (pelts q2) ((offset qp2) + 1%Z)%Z
  ((((offset qp2) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z) = (value_sub_shift qp
  (((to_int sx) - (to_int sy))%Z - k)%Z)) -> (((value_sub_shift qp2
  (((to_int sx) - (to_int sy))%Z - (to_int i1))%Z) = ((to_int2 ql) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub_shift qp
  (((to_int sx) - (to_int sy))%Z - k)%Z))%Z)%Z) -> (((value_sub_shift x5
  s) = ((value_sub_shift x5
  (to_int i1)) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int i1)) * (value_sub_shift xd3 ((to_int sy) - 1%Z)%Z))%Z)%Z) ->
  let m := ((to_int sy) - 1%Z)%Z in let x6 :=
  (18446744073709551615%Z + 1%Z)%Z in (((int.Power.power x6
  s) = (int.Power.power x6 ((to_int i1) + m)%Z)) ->
  (((0%Z <= (to_int i1))%Z /\ ((0%Z <= m)%Z /\ forall (x7:Z) (n:Z) (m1:Z),
  (0%Z <= n)%Z -> ((0%Z <= m1)%Z -> ((int.Power.power x7
  (n + m1)%Z) = ((int.Power.power x7 n) * (int.Power.power x7 m1))%Z)))) ->
  ((int.Power.power x6 ((to_int i1) + m)%Z) = ((int.Power.power x6
  (to_int i1)) * (int.Power.power x6
  m))%Z))))))))))))))))))))))))))))))))))))))))) /\
  ((~ ((to_int zero) <= (to_int r))%Z) -> forall (x1:uint64) (xp:(ptr
  uint64)) (x2:(ptr uint64)), ((xp = (mk_ptr (data x2) (offset o2))) /\
  ((length (contents (data x2))) = (length (contents (data o2))))) ->
  (((x2 = (mk_ptr (data x2) (offset x))) /\
  ((length (contents (data x2))) = (length (contents (data x))))) ->
  ((((value_sub_shift x (to_int sx)) = ((((((value_sub_shift o4
  (((to_int sx) - (to_int sy))%Z - (to_int o7))%Z) + ((to_int2 limb_zero) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sx) - (to_int sy))%Z - (to_int o7))%Z))%Z)%Z * vy)%Z * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int o7)))%Z + (value_sub_shift x2
  (((to_int sy) + (to_int o7))%Z - 1%Z)%Z))%Z + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sy) + (to_int o7))%Z - 1%Z)%Z) * (to_int2 x1))%Z)%Z) /\
  ((((value_sub (pelts x2) ((offset xp) + (to_int mdn))%Z
  ((((offset xp) + (to_int mdn))%Z + (to_int sy))%Z - 1%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 1%Z)%Z) * (to_int2 x1))%Z)%Z < vy)%Z /\
  (((to_int2 ((pelts x2)
  (offset xp))) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x1))%Z)%Z <= ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z)) ->
  forall (x11:uint64) (i:int32) (qp:(ptr uint64)) (xp1:(ptr uint64)) (x3:(ptr
  uint64)) (q1:(ptr uint64)), ((x3 = (mk_ptr (data x3) (offset x2))) /\
  ((length (contents (data x3))) = (length (contents (data x2))))) ->
  (((q1 = (mk_ptr (data q1) (offset q))) /\
  ((length (contents (data q1))) = (length (contents (data q))))) ->
  ((((0%Z <= (to_int i))%Z /\
  ((to_int i) <= ((to_int sx) - (to_int sy))%Z)%Z) /\
  (((offset qp) = ((offset q1) + (to_int i))%Z) /\
  (((offset xp1) = ((((offset x3) + (to_int sy))%Z + (to_int i))%Z - 2%Z)%Z) /\
  (((plength qp) = (plength q1)) /\ (((plength xp1) = (plength x3)) /\
  (((pelts qp) = (pelts q1)) /\ (((pelts xp1) = (pelts x3)) /\
  (((value_sub_shift x (to_int sx)) = ((((((value_sub_shift qp
  (((to_int sx) - (to_int sy))%Z - (to_int i))%Z) + ((to_int2 limb_zero) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sx) - (to_int sy))%Z - (to_int i))%Z))%Z)%Z * vy)%Z * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int i)))%Z + (value_sub_shift x3
  (((to_int sy) + (to_int i))%Z - 1%Z)%Z))%Z + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (((to_int sy) + (to_int i))%Z - 1%Z)%Z) * (to_int2 x11))%Z)%Z) /\
  ((((value_sub (pelts x3) ((offset xp1) + (to_int mdn))%Z
  ((((offset xp1) + (to_int mdn))%Z + (to_int sy))%Z - 1%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 1%Z)%Z) * (to_int2 x11))%Z)%Z < vy)%Z /\
  (((to_int2 ((pelts x3)
  (offset xp1))) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x11))%Z)%Z <= ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z))))))))) ->
  (((to_int zero) < (to_int i))%Z -> let k := (to_int i) in
  forall (o8:int32), ((to_int o8) = ((to_int i) - (to_int one))%Z) ->
  forall (i1:int32), (i1 = o8) -> let s :=
  (((to_int sy) + (to_int i1))%Z - 1%Z)%Z in forall (o9:(ptr uint64)),
  (((offset o9) = ((offset xp1) + (to_int minus_one))%Z) /\
  ((data o9) = (data xp1))) -> forall (xp2:(ptr uint64)), (xp2 = o9) ->
  forall (xd1:(ptr uint64)),
  (((offset xd1) = ((offset xp2) + (to_int mdn))%Z) /\
  ((data xd1) = (data xp2))) -> ((~ (((to_int2 x11) = (to_int2 dh)) /\
  ((to_int2 (mixfix_lbrb (contents (data xp2))
  ((offset xp2) + (to_int one))%Z)) = (to_int2 dl)))) ->
  ((((to_int2 ((pelts x3)
  ((offset xp2) + 1%Z)%Z)) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x11))%Z)%Z < ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z ->
  let xp0 := (mixfix_lbrb (contents (data xp2)) (offset xp2)) in let xp11 :=
  (mixfix_lbrb (contents (data xp2)) ((offset xp2) + (to_int one))%Z) in
  (((value_sub_shift xd1 (to_int sy)) = ((value_sub_shift xd1
  ((to_int sy) - 2%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 2%Z)%Z) * ((to_int2 xp0) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 xp11))%Z)%Z)%Z)%Z) ->
  forall (o10:uint64) (o11:uint64) (o12:uint64),
  ((((((to_int2 o10) * ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z + (to_int2 o11))%Z + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 o12))%Z)%Z = ((to_int2 xp0) + ((18446744073709551615%Z + 1%Z)%Z * ((to_int2 xp11) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 x11))%Z)%Z)%Z)%Z) /\
  ((0%Z <= ((to_int2 o11) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 o12))%Z)%Z)%Z /\
  (((to_int2 o11) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 o12))%Z)%Z < ((to_int2 dl) + ((18446744073709551615%Z + 1%Z)%Z * (to_int2 dh))%Z)%Z)%Z)) ->
  forall (ql:uint64), (ql = o10) -> forall (x12:uint64), (x12 = o12) ->
  forall (x0:uint64), (x0 = o11) -> let o13 :=
  ((((offset x3) + (to_int sy))%Z + k)%Z - 1%Z)%Z in let o14 :=
  (offset xd1) in let o15 := (offset x3) in let o16 := (pelts x3) in
  (((value_sub o16 o15 o13) = ((value_sub o16 o15 o14) + ((value_sub o16 o14
  o13) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o14 - o15)%Z))%Z)%Z) -> let o17 := (contents (data x3)) in
  forall (xc:(array uint64)), (((length xc) = (length o17)) /\ forall (i2:Z),
  ((0%Z <= i2)%Z /\ (i2 < (length xc))%Z) -> ((mixfix_lbrb xc
  i2) = (mixfix_lbrb o17 i2))) -> let o18 := ((offset x3) + (to_int i1))%Z in
  let o19 := (offset x3) in (((value_sub (pelts x3) o19
  o18) = (value_sub (elts xc) o19 o18)) -> forall (o20:int32),
  ((to_int o20) = ((to_int sy) - (to_int two))%Z) -> forall (xp3:(ptr
  uint64)) (x4:(ptr uint64)), let xd2 := (mk_ptr (data x4) (offset xd1)) in
  (((length (contents (data x4))) = (length (contents (data xd1)))) ->
  (((xp3 = (mk_ptr (data x4) (offset xp2))) /\
  ((length (contents (data x4))) = (length (contents (data xp2))))) ->
  (((x4 = (mk_ptr (data x4) (offset x3))) /\
  ((length (contents (data x4))) = (length (contents (data x3))))) ->
  forall (cy:uint64), ((((value_sub_shift xd2
  (to_int o20)) - ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int o20)) * (to_int2 cy))%Z)%Z = ((value_sub_shift xd1
  (to_int o20)) - ((value_sub_shift y (to_int o20)) * (to_int2 ql))%Z)%Z) /\
  forall (j:Z), ((j < (offset xd1))%Z \/
  (((offset xd1) + (to_int o20))%Z <= j)%Z) -> (((pelts xd2)
  j) = ((pelts xd1) j))) -> (((value_sub_shift x4
  (to_int i1)) = (value_sub_shift x3 (to_int i1))) -> forall (cy1:uint64),
  ((((to_int2 x0) < (to_int2 cy))%Z /\ (cy1 = uone)) \/
  ((~ ((to_int2 x0) < (to_int2 cy))%Z) /\ (cy1 = limb_zero))) ->
  forall (o21:uint64),
  ((to_int2 o21) = (int.EuclideanDivision.mod1 ((to_int2 x0) - (to_int2 cy))%Z
  (18446744073709551615%Z + 1%Z)%Z)) -> forall (x01:uint64), (x01 = o21) ->
  forall (cy2:uint64), ((((to_int2 x12) < (to_int2 cy1))%Z /\
  (cy2 = uone)) \/ ((~ ((to_int2 x12) < (to_int2 cy1))%Z) /\
  (cy2 = limb_zero))) -> forall (o22:uint64),
  ((to_int2 o22) = (int.EuclideanDivision.mod1 ((to_int2 x12) - (to_int2 cy1))%Z
  (18446744073709551615%Z + 1%Z)%Z)) -> forall (x13:uint64), (x13 = o22) ->
  (((0%Z <= (to_int2 cy2))%Z /\ ((to_int2 cy2) <= 1%Z)%Z) -> let o23 :=
  (((offset xd1) + (to_int sy))%Z - 1%Z)%Z in let o24 := (offset xd1) in
  let o25 := (offset xp3) in let o26 := (pelts x4) in
  (((value_sub (map.Map.set o26 o25 x01) o24 o23) = ((value_sub o26 o24
  o23) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o25 - o24)%Z) * ((to_int2 x01) - (to_int2 (o26 o25)))%Z)%Z)%Z) ->
  let o27 := ((offset x4) + (to_int i1))%Z in let o28 := (offset x4) in
  let o29 := (pelts x4) in (((value_sub o29 o28
  o27) = (value_sub (map.Map.set o29 (offset xp3) x01) o28 o27)) ->
  let o30 := (((offset xd1) + (to_int sy))%Z - 2%Z)%Z in let o31 :=
  (offset xd1) in let o32 := (pelts x4) in (((value_sub o32 o31
  o30) = (value_sub (map.Map.set o32 (offset xp3) x01) o31 o30)) ->
  forall (xp4:(ptr uint64)) (x5:(ptr uint64)),
  ((length (contents (data x5))) = (length (contents (data xp3)))) ->
  let xd3 := (mk_ptr (data x5) (offset xd1)) in
  (((length (contents (data x5))) = (length (contents (data x4)))) ->
  (((xp4 = (mk_ptr (data x5) (offset xp3))) /\
  ((length (contents (data x5))) = (length (contents (data xp3))))) ->
  (((x5 = (mk_ptr (data x5) (offset x4))) /\
  ((length (contents (data x5))) = (length (contents (data x4))))) ->
  (((pelts (mk_ptr (data x5) (offset xp3))) = (map.Map.set (pelts xp3)
  (offset xp3) x01)) -> (((value_sub_shift x5
  (to_int i1)) = (value_sub_shift x3 (to_int i1))) -> let o33 :=
  (((offset xd1) + (to_int sy))%Z - 1%Z)%Z in let o34 := (offset xd1) in
  let o35 := (pelts x5) in (((value_sub o35 o34
  (o33 + 1%Z)%Z) = ((value_sub o35 o34 o33) + ((to_int2 (o35
  o33)) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o33 - o34)%Z))%Z)%Z) -> (((((value_sub_shift xd3
  ((to_int sy) - 1%Z)%Z) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  ((to_int sy) - 1%Z)%Z) * (to_int2 x13))%Z)%Z - ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int sy)) * (to_int2 cy2))%Z)%Z = (((value_sub_shift xd1
  (to_int sy)) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int sy)) * (to_int2 x11))%Z)%Z - ((to_int2 ql) * vy)%Z)%Z) ->
  forall (o36:bool), (((~ (cy2 = limb_zero)) -> (o36 = true)) /\
  ((o36 = true) -> ~ ((to_int2 cy2) = (to_int2 limb_zero)))) ->
  ((~ (o36 = true)) -> forall (o37:(ptr uint64)),
  (((offset o37) = ((offset qp) + (to_int minus_one))%Z) /\
  ((data o37) = (data qp))) -> forall (qp1:(ptr uint64)), (qp1 = o37) ->
  let o38 :=
  ((((offset qp1) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z in
  let o39 := ((offset qp1) + 1%Z)%Z in let o40 := (pelts q1) in
  (((value_sub o40 o39 o38) = (value_sub (map.Map.set o40 (offset qp1) ql)
  o39 o38)) -> forall (qp2:(ptr uint64)) (q2:(ptr uint64)),
  ((length (contents (data q2))) = (length (contents (data qp1)))) ->
  (((qp2 = (mk_ptr (data q2) (offset qp1))) /\
  ((length (contents (data q2))) = (length (contents (data qp1))))) ->
  (((q2 = (mk_ptr (data q2) (offset q1))) /\
  ((length (contents (data q2))) = (length (contents (data q1))))) ->
  (((pelts (mk_ptr (data q2) (offset qp1))) = (map.Map.set (pelts qp1)
  (offset qp1) ql)) -> let o41 :=
  ((((offset qp2) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z in
  let o42 := (offset qp2) in let o43 := (pelts q2) in (((value_sub o43 o42
  o41) = ((to_int2 (o43
  o42)) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub o43 (o42 + 1%Z)%Z
  o41))%Z)%Z) -> let o44 :=
  ((((offset x5) + (to_int sy))%Z + (to_int i1))%Z - 1%Z)%Z in let o45 :=
  (offset x5) in let o46 := (pelts x5) in (((value_sub o46 o45
  (o44 + 1%Z)%Z) = ((value_sub o46 o45 o44) + ((to_int2 (o46
  o44)) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o44 - o45)%Z))%Z)%Z) -> let o47 := ((offset x5) + s)%Z in let o48 :=
  (offset xd1) in let o49 := (offset x5) in let o50 := (pelts x5) in
  (((value_sub o50 o49 o47) = ((value_sub o50 o49 o48) + ((value_sub o50 o48
  o47) * (int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (o48 - o49)%Z))%Z)%Z) -> (((value_sub_shift qp2
  (((to_int sx) - (to_int sy))%Z - (to_int i1))%Z) = ((to_int2 ql) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub (pelts q2)
  ((offset qp2) + 1%Z)%Z
  ((((offset qp2) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z))%Z)%Z) ->
  (((value_sub (pelts q2) ((offset qp2) + 1%Z)%Z
  ((((offset qp2) + (to_int sx))%Z - (to_int sy))%Z - (to_int i1))%Z) = (value_sub_shift qp
  (((to_int sx) - (to_int sy))%Z - k)%Z)) -> (((value_sub_shift qp2
  (((to_int sx) - (to_int sy))%Z - (to_int i1))%Z) = ((to_int2 ql) + ((18446744073709551615%Z + 1%Z)%Z * (value_sub_shift qp
  (((to_int sx) - (to_int sy))%Z - k)%Z))%Z)%Z) -> (((value_sub_shift x5
  s) = ((value_sub_shift x5
  (to_int i1)) + ((int.Power.power (18446744073709551615%Z + 1%Z)%Z
  (to_int i1)) * (value_sub_shift xd3 ((to_int sy) - 1%Z)%Z))%Z)%Z) ->
  let m := ((to_int sy) - 1%Z)%Z in let x6 :=
  (18446744073709551615%Z + 1%Z)%Z in (((int.Power.power x6
  s) = (int.Power.power x6 ((to_int i1) + m)%Z)) ->
  (((0%Z <= (to_int i1))%Z /\ ((0%Z <= m)%Z /\ forall (x7:Z) (n:Z) (m1:Z),
  (0%Z <= n)%Z -> ((0%Z <= m1)%Z -> ((int.Power.power x7
  (n + m1)%Z) = ((int.Power.power x7 n) * (int.Power.power x7 m1))%Z)))) ->
  ((int.Power.power x6 ((to_int i1) + m)%Z) = ((int.Power.power x6
  (to_int i1)) * (int.Power.power x6
  m))%Z))))))))))))))))))))))))))))))))))))))))))).
intros q x y sx sy ((h1,h2),(h3,(h4,(h5,h6)))) one h7 two h8 limb_zero h9
zero h10 o h11 minus_one h12 uone h13 o1 h14 o2 (h15,h16) o3 h17 o4 (h18,h19)
o5 h20 dh h21 o6 h22 dl v h23 o7 h24 mdn h25 xd (h26,h27) vy r h28.
split. intros.
apply H63.
omega.
omega.
intros.
apply H63.
omega.
omega.
Qed.

