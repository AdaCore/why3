module UnitaryCommutativeRingDecision

clone algebra.UnitaryCommutativeRing as C

clone algebra.UnitaryCommutativeRing as Z

function morph Z.t : C.t

axiom morph_zero: morph Z.zero = C.zero
axiom morph_one: morph Z.one = C.one
axiom morph_add: forall z1 z2:Z.t. morph (Z.(+) z1 z2) = C.(+) (morph z1) (morph z2)
axiom morph_mul: forall z1 z2:Z.t. morph (Z.( *) z1 z2)
                                   = C.( *) (morph z1) (morph z2)
axiom morph_inv: forall z:Z.t. morph (Z.(-_) z) = C.(-_) (morph z)

val predicate eq0 (x:Z.t) ensures { result <-> x = Z.zero }

use import int.Int
use import list.List

type t = Var int | Add t t | Mul t t | Cst Z.t

type vars = int -> C.t

function interp (x:t) (y:vars) : C.t =
  match x with
  | Var n -> y n
  | Add x1 x2 -> C.(+) (interp x1 y) (interp x2 y)
  | Mul x1 x2 -> C.( *) (interp x1 y) (interp x2 y)
  | Cst c -> morph c end

predicate eq (x1 x2:t) = forall y: vars. interp x1 y = interp x2 y

(** Conversion *)

type m = M Z.t (list int)
type t' = list m (* sum of monomials *)

function mon (x:list int) (y:vars) : C.t =
  match x with
  | Nil -> C.one
  | Cons x r -> C.( *) (y x) (mon r y) end

function interp' (x:t') (y:vars) : C.t =
  match x with
  | Nil -> C.zero
  | Cons (M a m) r -> C.(+) (C.( *) (morph a) (mon m y)) (interp' r y) end

predicate eq_mon (m1 m2: list int) = forall y: vars. mon m1 y = mon m2 y
predicate eq' (x1 x2: t') = forall y: vars. interp' x1 y = interp' x2 y

use import list.Append
use import list.Length

let rec lemma mon_append (x1 x2: list int) (y:vars)
  ensures { mon (x1 ++ x2) y = C.( *) (mon x1 y) (mon x2 y) }
  variant { x1 }
=
  match x1 with Nil -> () | Cons _ x -> mon_append x x2 y end

lemma interp_nil : forall y:vars. interp' Nil y = C.zero
lemma interp_cons : forall m:m, x:t', y:vars.
      interp' (Cons m x) y = C.(+) (interp' (Cons m Nil) y) (interp' x y)
let rec lemma interp_sum (x1 x2:t') (y:vars)
    ensures { interp' (x1 ++ x2) y = C.(+) (interp' x1 y) (interp' x2 y) }
    variant { x1 }
=
  match x1 with
    | Nil -> ()
    | Cons _ x -> interp_sum x x2 y
  end

let ghost function append_mon (m1 m2:m)
  ensures { forall y. interp' (Cons result Nil) y
              = C.( *) (interp' (Cons m1 Nil) y) (interp' (Cons m2 Nil) y) }
= match m1,m2 with M a1 l1, M a2 l2 -> M (Z.( *) a1 a2) (l1 ++ l2) end

let rec ghost function mul_mon (x:t') (mon:m) : t'
  ensures { forall y.
            interp' result y = C.( *) (interp' x y) (interp' (Cons mon Nil) y) }
= match x with
  | Nil -> Nil
  | Cons m r ->
    let mr = append_mon m mon in
    let lr = mul_mon r mon in
    Cons mr lr
end

let rec ghost function mul_devel (x1 x2:t') : t'
  ensures { forall y. interp' result y = C.( *) (interp' x1 y) (interp' x2 y) } =
  match x1 with
  | Nil -> Nil
  | Cons (M a m) r -> (mul_mon x2 (M a m)) ++ (mul_devel r x2)
  end

let rec ghost function conv (x:t) : t'
  ensures { forall y. interp x y = interp' result y } =
  match x with
  | Var v -> Cons (M Z.one (Cons v Nil)) Nil
  | Add x1 x2 -> (conv x1) ++ (conv x2)
  | Mul x1 x2 -> mul_devel (conv x1) (conv x2)
  | Cst n -> Cons (M n Nil) Nil
  end


(** Normalisation *)

let rec function insert (x: int) (l: list int) : list int
  ensures  { eq_mon (Cons x l) result }
  variant  { l }
= match l with
  | Nil -> Cons x Nil
  | Cons y r -> if x <= y then Cons x l else Cons y (insert x r)
  end

(*no need to prove that this actually sorts the list*)
let rec function insertion_sort (l: list int) : list int
  ensures { eq_mon l result }
  variant { l }
= match l with
  | Nil -> Nil
  | Cons x r -> insert x (insertion_sort r)
  end

let function sort_mon (x:m) : m
  ensures { eq' (Cons x Nil) (Cons result Nil) }
= match x with M a m -> M a (insertion_sort m) end

let rec function sort_mons (x:t') : t'
  ensures { eq' result x }
  variant { x }
= match x with Nil -> Nil | Cons m r -> Cons (sort_mon m) (sort_mons r) end

(*lexicographic order on monomials with variables sorted using sort_mons*)
let rec function le_mon (x1 x2: list int) : bool
= (length x1 < length x2) ||
  ((length x1 = length x2) &&
  match x1, x2 with
  | Nil, _ -> true
  | _, Nil -> false
  | Cons v1 r1, Cons v2 r2 ->  v1 <= v2 && le_mon r1 r2
  end)

let rec function same (l1 l2: list int) : bool
  ensures { result -> eq_mon l1 l2 }
= match l1, l2 with
  | Nil, Nil -> true
  | Nil, _ | _, Nil -> false
  | Cons x1 l1, Cons x2 l2 -> x1 = x2 && same l1 l2
  end


lemma squash_sum: forall a1 a2:Z.t, l1 l2: list int. same l1 l2 ->
      eq' (Cons (M a1 l1) (Cons (M a2 l2) Nil)) (Cons (M (Z.(+) a1 a2) l1) Nil)

let lemma squash_append (a1 a2:Z.t) (l1 l2: list int) (r:t')
      requires { same l1 l2 }
      ensures { eq' (Cons (M a1 l1) (Cons (M a2 l2) r))
                    (Cons (M (Z.(+) a1 a2) l1) r) }
= ()

let rec ghost function insert_mon (m: m) (x: t') : t'
  ensures { eq' result (Cons m x) }
  variant { length x }
= match m,x with
  | _,Nil -> Cons m Nil
  | M a1 l1, Cons (M a2 l2) r ->
      if same l1 l2
      then
        let s = Z.(+) a1 a2 in
        if eq0 s
        then (assert { eq' r (Cons m x)
                       by eq' r (Cons (M s l1) r)
                       so eq' (Cons (M s l1) r) (Cons m x)};
              r)
        else Cons (M s l1) r
      else if le_mon l1 l2 then Cons m x else Cons (M a2 l2) (insert_mon m r)
  end

let rec ghost function insertion_sort_mon (x: t') : t'
  ensures { eq' result x }
  variant { x }
= match x with
  | Nil -> Nil
  | Cons m r -> insert_mon m (insertion_sort_mon r)
  end

let ghost function normalize (x: t') : t'
  ensures { eq' result x }
=
  (* sort inside each monomial *)
  let x = sort_mons x in
  (* sort monomials lexicographically *)
  insertion_sort_mon x

lemma norm: forall x1 x2:t', y:vars.
      normalize x1 = normalize x2 -> interp' x1 y = interp' x2 y

end



(** Tests *)
module Tests

use import int.Int

function id (x:int) : int = x
let predicate eq0_int (x:int) = x = 0


clone export UnitaryCommutativeRingDecision with type C.t = int, constant C.zero = zero, constant C.one = one, function C.(-_) = (-_), function C.(+) = (+), function C.(*) = (*), type Z.t = int, constant Z.zero = zero, constant Z.one = one, function Z.(-_) = (-_), function Z.(+) = (+), function Z.(*) = (*), function morph = id, goal morph_zero, goal morph_one, goal morph_add, goal morph_mul, goal morph_inv, val eq0 = eq0_int



constant radix : int = 1
constant d : int = 0
constant z : int = 2

constant x1 : t = Add (Add (Var radix) (Cst (-1)))
                      (Mul (Var radix)
                        (Add (Var radix) (Mul (Cst (-1)) (Add (Cst 1) (Var d)))))

constant x2 : t = Add (Mul (Var radix) (Var radix))
                      (Add (Cst (-1)) (Mul (Cst (-1)) (Mul (Var radix) (Var d))))

constant z1 : t = Add (Add (Var radix) (Var z))
                      (Mul (Var radix)
                        (Add (Var radix) (Mul (Var z) (Add (Cst 1) (Var d)))))

constant z2 : t = Add (Mul (Var radix) (Var radix))
                      (Add (Var radix)
                           (Mul (Var z)
                                (Add (Cst 1)
                                     (Add (Var radix) (Mul (Var radix) (Var d))))))

constant x3 : t = Mul x1 x1
constant x4 : t = Mul x2 x2
constant x5 : t = Mul z1 z1
constant x6 : t = Mul z2 z2

constant x7 : t = Mul x3 x5
constant x8 : t = Mul x4 x6
constant x9 : t = Mul x3 x3
constant x10 : t = Mul x4 x4

meta "compute_max_steps" 0x10000000
(*
goal d: eq' (conv z1) (conv z2)
goal d': eq' (conv z1) (conv z2) by normalize (conv z1) = normalize (conv z2)

goal devel_1: eq x1 x2
goal devel_2: eq x3 x4
goal devel_3: eq x5 x6
goal devel_4: eq x7 x8
goal devel_5: eq x9 x10

goal devel_conv_1: forall y. interp' (conv x1) y = interp' (conv x2) y
goal devel_conv_2: forall y. interp' (conv x3) y = interp' (conv x4) y
goal devel_conv_3: forall y. interp' (conv x5) y = interp' (conv x6) y
goal devel_conv_4: forall y. interp' (conv x7) y = interp' (conv x8) y
goal devel_conv_5: forall y. interp' (conv x9) y = interp' (conv x10) y

goal devel_conv_1_norm: eq' (conv x1) (conv x2) by normalize (conv x1) = normalize (conv x2)
goal devel_conv_2_norm: eq' (conv x3) (conv x4) by normalize (conv x3) = normalize (conv x4)
goal devel_conv_3_norm: eq' (conv x5) (conv x6) by normalize (conv x5) = normalize (conv x6)
goal devel_conv_4_norm: eq' (conv x7) (conv x8) by normalize (conv x7) = normalize (conv x8)
goal devel_conv_5_norm: eq' (conv x9) (conv x10) by normalize (conv x9) = normalize (conv x10)

constant g1 : t = Mul x9 x9
constant g2 : t = Mul x10 x10
constant g3 : t = Mul x5 x5
constant g4 : t = Mul x6 x6
constant g5 : t = Mul g3 x6
constant g6 : t = Mul g4 x5

goal devel_6 : eq g3 g4
goal devel_conv_6: eq' (conv g3) (conv g4)
goal devel_conv_6_norm: eq' (conv g3) (conv g4) by normalize (conv g3) = normalize (conv g4)
*)

(*
goal devel_7 : eq g5 g6
goal devel_conv_7: eq' (conv g5) (conv g6)
goal devel_conv_7_norm: eq' (conv g5) (conv g6) by normalize (conv g5) = normalize (conv g6)
*)


end

module AssocAlgebra

type r
type a

function (+) a a : a
function ( *) a a : a

clone algebra.UnitaryCommutativeRing as R with type t = r
clone algebra.Ring as A with type t = a, function (+) = (+), function (*) = (*)
constant one : a
constant zero : a = A.zero
axiom AUnitary : forall x:a. one * x = x * one = x
axiom ANonTrivial : A.zero <> one

(* A is an associative algebra over R *)

function (@) r a : a


axiom ExtDistSumA : forall r: r, x y: a. r @ (x + y) = r @ x + r @ y
axiom ExtDistSumR : forall r s: r, x: a. (R.(+) r s)@x = r@x + s@x
axiom AssocMulExt : forall r s: r, x: a. (R.( *) r s)@x = r@(s@x)
axiom UnitExt     : forall x: a.         R.one @ x = x
axiom CommMulExt  : forall r: r, x y: a. r@(x*y) = (r@x)*y = x*(r@y)

val predicate eq0 (r: r) ensures { result <-> r = R.zero }

end

module AssocAlgebraDecision

use import int.Int
use import list.List
use import AssocAlgebra as AA

type t = Var int | Add t t | Mul t t | Ext r t
type vars = int -> a

function interp (x: t) (y: vars) : a =
  match x with
  | Var n -> y n
  | Add x1 x2 -> interp x1 y + interp x2 y
  | Mul x1 x2 -> interp x1 y * interp x2 y
  | Ext r x -> AA.(@) r (interp x y)
  end

predicate eq (x1 x2:t) = forall y: vars. interp x1 y = interp x2 y

(** Conversion to sum of monomials *)

type m = M r (list int)
type t' = list m

function mon (x: list int) (y: vars) : a =
  match x with
  | Nil -> AA.one
  | Cons x l -> y x * mon l y
  end

function interp' (x: t') (y: vars) : a =
  match x with
  | Nil -> AA.zero
  | Cons (M r m) l -> (AA.(@) r (mon m y)) + interp' l y end

predicate eq_mon (m1 m2: list int) = forall y: vars. mon m1 y = mon m2 y
predicate eq' (x1 x2: t') = forall y: vars. interp' x1 y = interp' x2 y

use import list.Append
use import list.Length

let rec lemma mon_append (x1 x2: list int) (y: vars)
  ensures { mon (x1 ++ x2) y = mon x1 y * mon x2 y }
  variant { x1 }
= match x1 with Nil -> () | Cons _ x -> mon_append x x2 y end

lemma interp_cons : forall m:m, x:t', y:vars.
      interp' (Cons m x) y = interp' x y + interp' (Cons m Nil) y

let rec lemma interp_sum (x1 x2: t') (y: vars)
    ensures { interp' (x1++x2) y = interp' x1 y + interp' x2 y }
    variant { x1 }
= match x1 with
  | Nil -> ()
  | Cons _ x -> interp_sum x x2 y end

let ghost function append_mon (m1 m2:m)
  ensures { forall y. interp' (Cons result Nil) y
              = interp' (Cons m1 Nil) y * interp' (Cons m2 Nil) y }
= match m1,m2 with M r1 l1, M r2 l2 -> M (R.( *) r1 r2) (l1 ++ l2) end

let rec ghost function mul_mon (mon: m) (x:t'): t'  (* mon*x *)
  ensures { forall y. interp' result y = interp' (Cons mon Nil) y * interp' x y }
= match x with
  | Nil -> Nil
  | Cons m l ->
    let mr = append_mon mon m in
    let lr = mul_mon mon l in
    Cons mr lr
  end

let rec ghost function mul_devel (x1 x2:t') : t'
  ensures { forall y. interp' result y = (interp' x1 y) * (interp' x2 y) }
= match x1 with
  | Nil -> Nil
  | Cons (M r m) l -> mul_mon (M r m) x2 ++ mul_devel l x2
  end

let rec ghost function ext (c:r) (x:t') : t'
  ensures { forall y. interp' result y = AA.(@) c (interp' x y) }
= match x with
  | Nil -> Nil
  | Cons (M r m) l -> Cons (M (R.( *) c r) m) (ext c l) end

let rec ghost function conv (x:t) : t'
  ensures { forall y. interp x y = interp' result y }
= match x with
  | Var v -> Cons (M R.one (Cons v Nil)) Nil
  | Add x1 x2 -> (conv x1) ++ (conv x2)
  | Mul x1 x2 -> mul_devel (conv x1) (conv x2)
  | Ext r x -> ext r (conv x)
  end


(** Normalisation *)

(*lexicographic order on monomials with variables sorted using sort_mons*)
let rec function le_mon (x1 x2: list int) : bool
= (length x1 < length x2) ||
  ((length x1 = length x2) &&
  match x1, x2 with
  | Nil, _ -> true
  | _, Nil -> false
  | Cons v1 r1, Cons v2 r2 ->  v1 <= v2 && le_mon r1 r2
  end)

let rec function same (l1 l2: list int) : bool
  ensures { result -> eq_mon l1 l2 }
= match l1, l2 with
  | Nil, Nil -> true
  | Nil, _ | _, Nil -> false
  | Cons x1 l1, Cons x2 l2 -> x1 = x2 && same l1 l2
  end

lemma squash_append: forall r1 r2: r, l1 l2: list int, l: t'. same l1 l2 ->
      eq' (Cons (M r1 l1) (Cons (M r2 l2) l)) (Cons (M (R.(+) r1 r2) l1) l)

let rec ghost function insert_mon (m: m) (x: t') : t'
  ensures { eq' result (Cons m x) }
  variant { length x }
= match m,x with
  | _,Nil -> Cons m Nil
  | M r1 l1, Cons (M r2 l2) l ->
      if same l1 l2
      then
        let s = R.(+) r1 r2 in
        if eq0 s
        then (assert { eq' l (Cons m x)
                       by eq' l (Cons (M s l1) l)
                       so eq' (Cons (M s l1) l) (Cons m x)};
              l)
        else Cons (M s l1) l
      else if le_mon l1 l2 then Cons m x else Cons (M r2 l2) (insert_mon m l)
  end

let rec ghost function insertion_sort_mon (x:t') : t'
  ensures { eq' result x }
  variant { x }
= match x with
  | Nil -> Nil
  | Cons m l -> insert_mon m (insertion_sort_mon l)
  end

let ghost function normalize (x:t') : t'
  ensures { eq' result x }
= insertion_sort_mon x

lemma norm: forall x1 x2: t, y:vars.
      normalize (conv x1) = normalize (conv x2) -> interp x1 y = interp x2 y

lemma norm': forall x1 x2: t'. normalize x1 = normalize x2 -> eq' x1 x2

end

module Matrix

use import int.Int

use import matrices.Matrix
use import matrices.MatrixArithmetic
use import matrices.BlockMul

function extf (c: int) (a:mat int) : int -> int -> int =
  fun x y -> c * (get a x y)

function ext (c: int) (a:mat int) : mat int =
  create (rows a) (cols a) (extf c a)


constant d : int
axiom DimNonNeg : d >= 0

constant zero11 : mat int = zero d d
constant one11 : mat int = create d d (fun _ _ -> 1)

let predicate eq0_int (x:int) = x=0

clone export AssocAlgebra with type r = int, type a = mat int, constant R.zero = Int.zero, constant R.one = Int.one, function R.(+) = (+), function R.(-_) = (-_), function R.(*) = (*),constant A.zero = zero11, constant one = one11, function (+) = add, function A.(-_) = opp, function ( *) = mul, function (@) = ext, goal AUnitary, goal ANonTrivial, goal ExtDistSumA, goal ExtDistSumR, goal AssocMulExt, goal UnitExt, goal CommMulExt, val eq0 = eq0_int

use import AssocAlgebraDecision

end