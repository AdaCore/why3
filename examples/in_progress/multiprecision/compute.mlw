module UnitaryCommutativeRingDecision

clone algebra.UnitaryCommutativeRing as C

clone algebra.UnitaryCommutativeRing as Z

function morph Z.t : C.t

axiom morph_zero: morph Z.zero = C.zero
axiom morph_one: morph Z.one = C.one
axiom morph_add: forall z1 z2:Z.t. morph (Z.(+) z1 z2) = C.(+) (morph z1) (morph z2)
axiom morph_mul: forall z1 z2:Z.t. morph (Z.( *) z1 z2)
                                   = C.( *) (morph z1) (morph z2)
axiom morph_inv: forall z:Z.t. morph (Z.(-_) z) = C.(-_) (morph z)

val predicate eq0 (x:Z.t) ensures { result <-> x = Z.zero }

use import int.Int
use import list.List

type t = Var int | Add t t | Mul t t | Cst Z.t

type vars = int -> C.t

function interp (x:t) (y:vars) : C.t =
  match x with
  | Var n -> y n
  | Add x1 x2 -> C.(+) (interp x1 y) (interp x2 y)
  | Mul x1 x2 -> C.( *) (interp x1 y) (interp x2 y)
  | Cst c -> morph c end

predicate eq (x1 x2:t) = forall y: vars. interp x1 y = interp x2 y

(** Conversion *)

type m = M Z.t (list int)
type t' = list m (* sum of monomials *)

function mon (x:list int) (y:vars) : C.t =
  match x with
  | Nil -> C.one
  | Cons x r -> C.( *) (y x) (mon r y) end

function interp' (x:t') (y:vars) : C.t =
  match x with
  | Nil -> C.zero
  | Cons (M a m) r -> C.(+) (C.( *) (morph a) (mon m y)) (interp' r y) end

predicate eq_mon (m1 m2: list int) = forall y: vars. mon m1 y = mon m2 y
predicate eq' (x1 x2: t') = forall y: vars. interp' x1 y = interp' x2 y

use import list.Append
use import list.Length

let rec lemma mon_append (x1 x2: list int) (y:vars)
  ensures { mon (x1 ++ x2) y = C.( *) (mon x1 y) (mon x2 y) }
  variant { x1 }
=
  match x1 with Nil -> () | Cons _ x -> mon_append x x2 y end

lemma interp_nil : forall y:vars. interp' Nil y = C.zero
lemma interp_cons : forall m:m, x:t', y:vars.
      interp' (Cons m x) y = C.(+) (interp' (Cons m Nil) y) (interp' x y)
let rec lemma interp_sum (x1 x2:t') (y:vars)
    ensures { interp' (x1 ++ x2) y = C.(+) (interp' x1 y) (interp' x2 y) }
    variant { x1 }
=
  match x1 with
    | Nil -> ()
    | Cons _ x -> interp_sum x x2 y
  end

let ghost function append_mon (m1 m2:m)
  ensures { forall y. interp' (Cons result Nil) y
              = C.( *) (interp' (Cons m1 Nil) y) (interp' (Cons m2 Nil) y) }
= match m1,m2 with M a1 l1, M a2 l2 -> M (Z.( *) a1 a2) (l1 ++ l2) end

let rec ghost function mul_mon (x:t') (mon:m) : t'
  ensures { forall y.
            interp' result y = C.( *) (interp' x y) (interp' (Cons mon Nil) y) } =
  match x with
  | Nil -> Nil
  | Cons m r ->
    let mr = append_mon m mon in
    let lr = mul_mon r mon in
    let res = Cons mr lr in
    assert { forall y. interp' res y
             = C.(+) (interp' (Cons mr Nil) y) (interp' lr y)
             = C.(+) (C.( *) (interp' (Cons m Nil) y) (interp' (Cons mon Nil) y))
                     (C.( *) (interp' r y) (interp' (Cons mon Nil) y))
             = C.( *) (C.(+) (interp' (Cons m Nil) y) (interp' r y))
                      (interp' (Cons mon Nil) y)
             = C.( *) (interp' x y) (interp' (Cons mon Nil) y) };
    res
end

let rec ghost function mul_devel (x1 x2:t') : t'
  ensures { forall y. interp' result y = C.( *) (interp' x1 y) (interp' x2 y) } =
  match x1 with
  | Nil -> Nil
  | Cons (M a m) r -> (mul_mon x2 (M a m)) ++ (mul_devel r x2)
  end

let rec ghost function conv (x:t) : t'
  ensures { forall y. interp x y = interp' result y } =
  match x with
  | Var v -> Cons (M Z.one (Cons v Nil)) Nil
  | Add x1 x2 -> (conv x1) ++ (conv x2)
  | Mul x1 x2 -> mul_devel (conv x1) (conv x2)
  | Cst n -> Cons (M n Nil) Nil
  end


(** Normalisation *)

let rec function insert (x: int) (l: list int) : list int
  ensures  { eq_mon (Cons x l) result }
  variant  { l }
= match l with
  | Nil -> Cons x Nil
  | Cons y r -> if x <= y then Cons x l else Cons y (insert x r)
  end

(*no need to prove that this actually sorts the list*)
let rec function insertion_sort (l: list int) : list int
  ensures { eq_mon l result }
  variant { l }
= match l with
  | Nil -> Nil
  | Cons x r -> insert x (insertion_sort r)
  end

let function sort_mon (x:m) : m
  ensures { eq' (Cons x Nil) (Cons result Nil) }
= match x with M a m -> M a (insertion_sort m) end

let rec function sort_mons (x:t') : t'
  ensures { eq' result x }
  variant { x }
= match x with Nil -> Nil | Cons m r -> Cons (sort_mon m) (sort_mons r) end

(*lexicographic order on monomials with variables sorted using sort_mons*)
let rec function le_mon (x1 x2: list int) : bool
= (length x1 < length x2) ||
  ((length x1 = length x2) &&
  match x1, x2 with
  | Nil, _ -> true
  | _, Nil -> false
  | Cons v1 r1, Cons v2 r2 ->  v1 <= v2 && le_mon r1 r2
  end)

let rec function same (l1 l2: list int) : bool
  ensures { result -> eq_mon l1 l2 }
= match l1, l2 with
  | Nil, Nil -> true
  | Nil, _ | _, Nil -> false
  | Cons x1 l1, Cons x2 l2 -> x1 = x2 && same l1 l2
  end


lemma squash_sum: forall a1 a2:Z.t, l1 l2: list int. same l1 l2 ->
      eq' (Cons (M a1 l1) (Cons (M a2 l2) Nil)) (Cons (M (Z.(+) a1 a2) l1) Nil)

let lemma squash_append (a1 a2:Z.t) (l1 l2: list int) (r:t')
      requires { same l1 l2 }
      ensures { eq' (Cons (M a1 l1) (Cons (M a2 l2) r))
                    (Cons (M (Z.(+) a1 a2) l1) r) }
= ()

let rec ghost function insert_mon (m: m) (x: t') : t'
  ensures { eq' result (Cons m x) }
  variant { length x }
= match m,x with
  | _,Nil -> Cons m Nil
  | M a1 l1, Cons (M a2 l2) r ->
      if same l1 l2
      then
        let s = Z.(+) a1 a2 in
        if eq0 s
        then (assert { eq' r (Cons m x)
                       by eq' r (Cons (M s l1) r)
                       so eq' (Cons (M s l1) r) (Cons m x)};
              r)
        else Cons (M s l1) r
      else if le_mon l1 l2 then Cons m x else Cons (M a2 l2) (insert_mon m r)
  end

let rec ghost function insertion_sort_mon (x: t') : t'
  ensures { eq' result x }
  variant { x }
= match x with
  | Nil -> Nil
  | Cons m r -> insert_mon m (insertion_sort_mon r)
  end

let ghost function normalize (x: t') : t'
  ensures { eq' result x }
=
  (* sort inside each monomial *)
  let x = sort_mons x in
  (* sort monomials lexicographically *)
  insertion_sort_mon x

lemma norm: forall x1 x2:t', y:vars.
      normalize x1 = normalize x2 -> interp' x1 y = interp' x2 y

end



(** Tests *)
module Tests

use import int.Int

function id (x:int) : int = x
let predicate eq0_int (x:int) = x = 0


clone export UnitaryCommutativeRingDecision with type C.t = int, constant C.zero = zero, constant C.one = one, function C.(-_) = (-_), function C.(+) = (+), function C.(*) = (*), type Z.t = int, constant Z.zero = zero, constant Z.one = one, function Z.(-_) = (-_), function Z.(+) = (+), function Z.(*) = (*), function morph = id, goal morph_zero, goal morph_one, goal morph_add, goal morph_mul, goal morph_inv, val eq0 = eq0_int



constant radix : int = 1
constant d : int = 0
constant z : int = 2

constant x1 : t = Add (Add (Var radix) (Cst (-1)))
                      (Mul (Var radix)
                        (Add (Var radix) (Mul (Cst (-1)) (Add (Cst 1) (Var d)))))

constant x2 : t = Add (Mul (Var radix) (Var radix))
                      (Add (Cst (-1)) (Mul (Cst (-1)) (Mul (Var radix) (Var d))))

constant z1 : t = Add (Add (Var radix) (Var z))
                      (Mul (Var radix)
                        (Add (Var radix) (Mul (Var z) (Add (Cst 1) (Var d)))))

constant z2 : t = Add (Mul (Var radix) (Var radix))
                      (Add (Var radix)
                           (Mul (Var z)
                                (Add (Cst 1)
                                     (Add (Var radix) (Mul (Var radix) (Var d))))))

constant x3 : t = Mul x1 x1
constant x4 : t = Mul x2 x2
constant x5 : t = Mul z1 z1
constant x6 : t = Mul z2 z2

constant x7 : t = Mul x3 x5
constant x8 : t = Mul x4 x6
constant x9 : t = Mul x3 x3
constant x10 : t = Mul x4 x4

meta "compute_max_steps" 0x10000000

goal d: eq' (conv z1) (conv z2)
goal d': eq' (conv z1) (conv z2) by normalize (conv z1) = normalize (conv z2)

goal devel_1: eq x1 x2
goal devel_2: eq x3 x4
goal devel_3: eq x5 x6
goal devel_4: eq x7 x8
goal devel_5: eq x9 x10

goal devel_conv_1: forall y. interp' (conv x1) y = interp' (conv x2) y
goal devel_conv_2: forall y. interp' (conv x3) y = interp' (conv x4) y
goal devel_conv_3: forall y. interp' (conv x5) y = interp' (conv x6) y
goal devel_conv_4: forall y. interp' (conv x7) y = interp' (conv x8) y
goal devel_conv_5: forall y. interp' (conv x9) y = interp' (conv x10) y

goal devel_conv_1_norm: eq' (conv x1) (conv x2) by normalize (conv x1) = normalize (conv x2)
goal devel_conv_2_norm: eq' (conv x3) (conv x4) by normalize (conv x3) = normalize (conv x4)
goal devel_conv_3_norm: eq' (conv x5) (conv x6) by normalize (conv x5) = normalize (conv x6)
goal devel_conv_4_norm: eq' (conv x7) (conv x8) by normalize (conv x7) = normalize (conv x8)
goal devel_conv_5_norm: eq' (conv x9) (conv x10) by normalize (conv x9) = normalize (conv x10)

constant g1 : t = Mul x9 x9
constant g2 : t = Mul x10 x10
constant g3 : t = Mul x5 x5
constant g4 : t = Mul x6 x6
constant g5 : t = Mul g3 x6
constant g6 : t = Mul g4 x5

goal devel_6 : eq g3 g4
goal devel_conv_6: eq' (conv g3) (conv g4)
goal devel_conv_6_norm: eq' (conv g3) (conv g4) by normalize (conv g3) = normalize (conv g4)
(*
goal devel_7 : eq g5 g6
goal devel_conv_7: eq' (conv g5) (conv g6)
goal devel_conv_7_norm: eq' (conv g5) (conv g6) by normalize (conv g5) = normalize (conv g6)
*)


end