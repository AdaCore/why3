module Test_proofinuse

  use import int.Int
  use import int.Power
  use import int.EuclideanDivision
  use import bitvec.BitVector_32

  (* Shift is div example -------------------  *)

  let shift_is_div ( x : bitvec32 ) ( y : bitvec32 ) : bitvec32 =
    requires{ 0 <= to_uint y < 32 }
    let res = lsr x ( of_int_const 1 ) in
    assert{ res = ( udiv x (of_int_const 2) ) };
    assert{ to_uint res = div (to_uint x) 2 };
    let res = lsr res ( of_int_const 2 ) in
    assert{ res = ( udiv x (of_int_const 8) ) };
    assert{ to_uint res = div (to_uint x) 8 };
    res

 (* Mask example --------------------- *)

  use bv.BV8
  use bv.BV64

  use bv.BVConverter_32_64 as C32_46
  use bv.BVConverter_8_32 as C8_32

  type bitvec8 = BV8.t
  type bitvec64 = BV64.t

  let mask ( x : bitvec32 ) =
    ensures{ BV8.eq result (BV8.of_int_const 1) }
    let res = C8_32.toSmall(
                bw_and
                  ( bw_or
                    ( bw_and x (of_int_const 0xFFFF_FF00) )
                    (of_int_const 1) )
                  ( of_int_const 0x0000_00FF ) )
    in res

  (* test invariant from frama-c ---------------- *)

  use import ref.Ref

  let testVariant( n : bitvec32 ) =
    let i = ref n in
    let two = of_int_const 2 in

    while uge !i two do
    variant{ !i with ult }
      i := lsr !i two
    done

end

theory Hackers_delight
  use import int.Int
  use import bitvec.BitVector_32
  
  (* de morgan's laws *)

  goal DM1: forall x y.
    bw_not( bw_and x y ) = bw_or (bw_not x) (bw_not y)

  goal DM2: forall x y.
    bw_not( bw_or x y ) = bw_and (bw_not x) (bw_not y)

  goal DM3: forall x.
    bw_not( add x (of_int_const 1) ) = sub (bw_not x) (of_int_const 1)

  goal DM4: forall x.
    bw_not( sub x (of_int_const 1) ) = add (bw_not x) (of_int_const 1)

  goal DM5: forall x.
    bw_not( neg x ) = sub x (of_int_const 1)

  goal DM6: forall x y.
    bw_not( bw_xor x y ) = bw_xor (bw_not x) y (* = eq x y *)
  
  goal DM7: forall x y.
    bw_not( add x y ) = sub (bw_not x) y
    
  goal DM8: forall x y.
    bw_not( sub x y ) = add (bw_not x) y

  goal DMtest: forall x.
    zero = bw_not( bw_or x (neg( add x (of_int_const 1))))

  (* inequality  *)

  goal IE1: forall x y.
    ule (bw_xor x y) (bw_or x y)

  goal IE2: forall x y.
    ule (bw_and x y) (bw_not( bw_xor x y ))

  goal IE3: forall x y.
    ( ule x (add x y) /\ ule y (add x y) ) -> ule (bw_or x y) (add x y)

  goal IE4: forall x y.
    not ( ule x (add x y) /\ ule y (add x y) ) -> ugt (bw_or x y) (add x y)

  (* shift right and arithmetic shift right *)

  goal SR1: forall x n. ( ule zero n /\ ule n (of_int_const 31)) ->
    bw_or (lsr_bv x n) (lsl_bv (neg( lsr_bv x (of_int_const 31) )) (sub (of_int_const 31) n))
  = asr_bv x n

  (* rotate en shift *)

  goal RS_left: forall x.
    bw_or (lsl_bv x (of_int_const 1)) (lsr_bv x (of_int_const 31)) = rotate_left x

  goal RS_right: forall x.
    bw_or (lsr_bv x (of_int_const 1)) (lsl_bv x (of_int_const 31)) = rotate_right x

  (* bound propagation *)

  goal BP1: forall a b c d x y.
    ( ule a x /\ ule x b /\ ule c y /\ ule y d ) ->
    ( ule b (add b d) /\ ule d (add b d) ) -> (* no overflow in addition *)
      ule (bw_or x y) (add b d) /\ ule zero (bw_and x y)

  goal BP2: forall a b c d x y.
    ( ule a x /\ ule x b /\ ule c y /\ ule y d ) ->
    ( ule b (add b d) /\ ule d (add b d) ) -> (* no overflow in addition *)
      ule zero (bw_xor x y) /\ ule (bw_xor x y) (add b d)

  goal BP3: forall a b c d x y.
    ( ule a x /\ ule x b /\ ule c y /\ ule y d ) ->
      ule (bw_not b) (bw_not x) /\ ule (bw_not x) (bw_not a)

end

module Hackers_delight_mod
  use import int.Int
  use import bitvec.BitVector_32

  (* de morgan's laws *)

  let dm1 (x : bitvec32) (y : bitvec32) = 
    ensures{ result = bw_or (bw_not x) (bw_not y) }
    bw_not( bw_and x y )
  
  let dm2 (x : bitvec32) (y : bitvec32) = 
    ensures{ result = bw_and (bw_not x) (bw_not y) }
    bw_not( bw_or x y )

  let dm3 (x : bitvec32) =
    ensures{ result = sub (bw_not x) (of_int_const 1) }
    bw_not( add x (of_int_const 1) )

  let dm4 (x : bitvec32) =
    ensures{ result = add (bw_not x) (of_int_const 1) }
    bw_not( sub x (of_int_const 1) )

  let dm5 (x : bitvec32) =
    ensures{ result = sub x (of_int_const 1) }
    bw_not( neg x )

  let dm6 (x : bitvec32) (y : bitvec32) =
    ensures{ result = bw_xor (bw_not x) y } 
    bw_not( bw_xor x y )
  
  let dm7 (x : bitvec32) (y : bitvec32) =
    ensures{ result = sub (bw_not x) y }
    bw_not( add x y )
    
  let dm8 (x : bitvec32) (y : bitvec32) =
    ensures{ result = add (bw_not x) y }
    bw_not( sub x y )

  let dmtest (x : bitvec32) =
    ensures{ result = zero }
    bw_not( bw_or x (neg( add x (of_int_const 1))))

  (* inequality  *)

  let ie1 (x : bitvec32) (y : bitvec32) =
    ensures{ ule result (bw_or x y) }
    bw_xor x y

  let ie2 (x : bitvec32) (y : bitvec32) =
    ensures{ ule result (bw_not( bw_xor x y ))}
    bw_and x y

  let ie3 (x : bitvec32) (y : bitvec32) =
    requires{ ule x (add x y) /\ ule y (add x y) }
    ensures{ ule result (add x y) }
    bw_or x y

  let ie4 (x : bitvec32) (y : bitvec32) = 
    requires{ not ( ule x (add x y) /\ ule y (add x y) ) }
    ensures{ ugt result (add x y) }
    bw_or x y

  (* shift right and arithmetic shift right *)

  let sr1 (x : bitvec32) (n : bitvec32) = 
    requires{ ule zero n /\ ule n (of_int_const 31) }
    ensures{ result = asr_bv x n }
    bw_or (lsr x n) (lsl (neg( lsr x (of_int_const 31) )) (sub (of_int_const 31) n))

  (* rotate en shift *)

  let rs_left (x : bitvec32) =
  ensures{ result = rotate_left x }
    bw_or (lsl x (of_int_const 1)) (lsr x (of_int_const 31))

  let rs_right (x : bitvec32) =
  ensures{ result = rotate_right x }
    bw_or (lsr x (of_int_const 1)) (lsl x (of_int_const 31))

  (* bound propagation *)

  let bp1 (a b c d x y : bitvec32) = 
  requires{ ule a x /\ ule x b }
  requires{ ule c y /\ ule y d }
  requires{ ule b (add b d) /\ ule d (add b d) } (* no overflow in addition *)
  ensures{ ule result (add b d) }
    bw_or x y

  let bp1' (a b c d x y : bitvec32) = 
  requires{ ule a x /\ ule x b }
  requires{ ule c y /\ ule y d }
  requires{ ule b (add b d) /\ ule d (add b d) } (* no overflow in addition *)
  ensures{ ule zero result }
    bw_and x y

  let bp2 (a b c d x y : bitvec32) =         
  requires{ ule a x /\ ule x b }
  requires{ ule c y /\ ule y d }
  requires{ ule b (add b d) /\ ule d (add b d) } (* no overflow in addition *)
  ensures{ ule zero result }
  ensures{ ule result (add b d) }
    bw_xor x y

  let bp3 (a b c d x y : bitvec32) = 
  requires{ ule a x /\ ule x b }
  requires{ ule c y /\ ule y d }
  ensures{ ule (bw_not b) result }
  ensures{ ule result (bw_not a) }
    bw_not x

end

module Test_imperial_violet
       
  use import int.Int
  use import int.EuclideanDivision
  use import bitvec.BitVector_32
  use import array.Array

  (* to_uint and bounds *)

  lemma bv32_bounds_bv:
    forall b. ule zero b /\ ule b ones

  lemma to_uint_ule:
    forall b c. ule b c -> to_uint b <= to_uint c

  lemma to_uint_ult:
    forall b c. ult b c -> to_uint b < to_uint c
  
  lemma bv32_bounds_0:
    forall b. 0 <= to_uint b

  lemma bv32_bounds:
    forall b. 0 <= to_uint b < 0x1_0000_0000

  (* bounded add of array of bitvec32 *)

  let add (a : array bitvec32 ) (b : array bitvec32) =
    requires{ length a = length b }
    requires{ forall i. 0 <= i < length a ->
                ult a[i] (of_int_const 0x8000_0000) }
    requires{ forall i. 0 <= i < length b -> 
                ult b[i] (of_int_const 0x8000_0000) }
    ensures{ forall i. 0 <= i < length result -> 
               to_uint result[i] = to_uint a[i] + to_uint b[i] }
    let sum = make (length a) zero in
    for i = 0 to length a - 1 do
      (* invariant{ forall j. 0 <= j < i -> sum[j] = add a[j] b[j] }  *)
      invariant{ forall j. 0 <= j < i -> to_uint sum[j] = to_uint a[j] + to_uint b[j] }
      sum[i] <- add a[i] b[i]
    done;
    sum

  (* function felemvalue (a : array bitvec32) : Int *)
  (*   =  *)
  
end

module My_nth_32

  use import bitvec.BitVector_32

  function my_nth ( x : bitvec32 ) ( n : bitvec32 ) : bool =
    let mask = lsl_bv (of_int_const 1) n in
    bw_and x mask = mask

  lemma my_nth_and:
    forall x y n. my_nth (bw_and x y) n = ( my_nth x n /\ my_nth y n )

  lemma my_nth_or:
    forall x y n. my_nth (bw_or x y) n = ( my_nth x n \/ my_nth y n )

  lemma my_nth_not:
    forall x n. not (my_nth (bw_not x) n = my_nth x n)

  lemma my_nth_lsl : forall b n s. 
    ule zero n /\ ult n (sub (of_int_const 32) s) /\ ule zero s /\ ult s (of_int_const 32) -> 
      my_nth (lsl_bv b s) (add n s) = my_nth b n

  lemma my_nth_lsr : forall b n s. 
    ule s n /\ ult n (of_int_const 32) /\ ule zero s /\ ult s (of_int_const 32) -> 
      my_nth (lsr_bv b s) (sub n s) = my_nth b n

  lemma my_nth_zero:
    forall i. ule zero i /\ ult i (of_int_const 32) -> my_nth zero i = False

  lemma my_nth_ones:
    forall i. ule zero i /\ ult i (of_int_const 32) -> my_nth ones i = True

  lemma my_nth_nzero:
    forall n. zero <> n -> exists i. ule zero i /\ ult i (of_int_const 32) /\ my_nth n i = True
end

module My_nth_32_msd
  use import bitvec.BitVector_32
  use import My_nth_32
  use import ref.Ref

  (* Returns the digit index of the most significant (non-zero) digit of Number. (from N622-004) *)
  let get_MSD ( number : bitvec32 ) : bitvec32
    (* requires{ zero <> number } *)
    requires{ exists i. ule zero i /\ ult i (of_int_const 32) /\ my_nth number i = True }
    ensures{ ult result (of_int_const 32) }
    ensures{ forall i. ult result i -> my_nth number i = False }
  = 
    let digit_index = ref (of_int_const 0xFFFF_FFFF) in
    let i = ref zero in
    while ult !i (of_int_const 32) do
    variant{ !i with ugt }
    invariant{ ult !digit_index (of_int_const 32) \/ (exists j. ule !i j /\ ult j (of_int_const 32) /\ my_nth number j = True) }
    invariant { forall j. ult !digit_index j /\ ult j !i -> my_nth number j = False }

      if (my_nth number !i = True) then 	
        digit_index := !i;
        
      i := add !i (of_int_const 1)
    done;

    !digit_index
end

module Bitwalker
  use import int.Int
  use import array.Array
  use import bitvec.BitVector_32
  use bv.BV8
  use bv.BV64
  use bv.BVConverter_32_64 as C32_64
  use bv.BVConverter_8_32 as C8_32

  type bitvec8 = BV8.t
  type bitvec64 = BV64.t

  function nth_inv_64 (value : bitvec64) (i : int) : bool = BV64.nth value (63 - i)
  function nth_inv_8 (value : bitvec8) (i : int) : bool = BV8.nth value (7 - i)

  let poke_64bit (value : bitvec64) (left : bitvec32) (flag : int) =
  requires{ ult left (of_int_const 64) }
  ensures{ forall i. 0 <= i < 64 /\ i <> (to_uint left) -> BV64.nth result i = BV64.nth value i }
  ensures{ flag <> 0 <-> nth_inv_64 result (to_uint left) }
      let mask = BV64.lsl_bv (BV64.of_int_const 1) (C32_64.toBig (sub (of_int_const 63) left)) in
      
      if( flag = 0 )
      then
        BV64.bw_and value (BV64.bw_not mask)
      else
        BV64.bw_or value mask

  let peek_8bit (byte : bitvec8) (left : bitvec32) =
  requires{ ult left (of_int_const 8) }
  ensures{ result <> 0 <-> nth_inv_8 byte (to_uint left) }
      let mask = BV8.lsl_bv (BV8.of_int_const 1) (C8_32.toSmall (sub (of_int_const 7) left)) in
      let flag = BV8.bw_and byte mask in
      BV8.to_uint flag

  let peek_8bit_array (addr : array bitvec8) (ize : bitvec32) (left : bitvec32) =
    peek_8bit (addr[ to_uint( udiv left (of_int_const 8) ) ]) (urem left (of_int_const 8))

  use import ref.Ref  

  let peek (start : bitvec32) (length : bitvec32) (addr : array bitvec8) (size : bitvec32) =
  (* requires \valid_read(addr + (0..size-1)); *) (* ?? *)
  requires{ ule length (of_int_const 64) }
  requires{ ule (add start length) ones }
  requires{ ule (mul (of_int_const 8) size) ones }
  ensures{ ugt (add start length) (mul (of_int_const 8) size) -> result = BV64.zero }
    (* ensures \forall integer i; 0 <= i < length ==> *)
    (*           (LeftBitInStream(addr, start+i) <==> LeftBit64(\result, 64-length + i)); *)
  ensures{ ule (add start length) (mul (of_int_const 8) size) -> forall i. 0 <= i < (64 - (to_uint length)) ->
             nth_inv_64 result i = False }
  ensures{ ule (add start length) (mul (of_int_const 8) size) -> BV64.ult result (C32_64.toBig (lsl_bv length (of_int_const 1))) }

    if (ugt (add start length) (mul (of_int_const 8) size )) 
    then
      BV64.zero
    else

    let retval = ref BV64.zero in
    let i = ref zero in

    while ult !i length do
    variant{ !i with ugt }

      let flag = peek_8bit_array addr size (add start (of_int_const 1)) in
      retval := poke_64bit !retval (add (sub (of_int_const 64) length) !i) flag;

      i := add !i (of_int_const 1)
    done;

    !retval

end

module Test_firsts

  use import int.Int
  use import int.Power
  use import int.EuclideanDivision
  use import bitvec.BitVector_32

  constant bv1 : bitvec32 = of_int_const 1
  constant bv2 : bitvec32 = of_int_const 2
  constant bv31 : bitvec32 = of_int_const 31
  constant pow30 : int = 0x4000_0000
  constant pow32 : int = 0x1_0000_0000

  let test0 ( x : bitvec32 ) : bitvec32
    requires{ 0 <= to_uint x < pow30 }
    ensures{ to_uint result = 4 * to_uint x } 
  =
    lsl x bv2

  let test1 ( x : bitvec32 ) : bitvec32
    requires{ 0 <= to_uint x < power 2 30 }
    ensures{ result = mul (of_int_const 4) x }
    ensures{ to_uint result = 4 * to_uint x } 
  =
    assert{ lsl_bv x bv2 = mul (of_int_const 4) x };
    lsl x bv2

  let test2 (x y : bitvec32 ) : bitvec32
    requires{ 0 <= to_int y < 32 }
    requires{ 0 <= to_int x < (power 2 (32 - to_int y)) }
    ensures{ result = mul (lsl_bv bv1 y) x }
    ensures{ to_int result = power 2 (to_int y) * to_int x }
  = 	     
    assert{ lsl_bv x y = mul (lsl_bv bv1 y) x };
    assert{ to_int( lsl_bv bv1 y ) = power 2 (to_int y)};
    assert{ power 2 (to_int y) * to_int x < pow32 };
    lsl x y       	     

  let f (x y:bitvec32) (ghost k:bitvec32) : bitvec32
    requires { sle zero k }
    requires { slt k bv31 }
    requires { y = lsl_bv bv1 k }
    requires { to_int y = power 2 (to_int k) }
    ensures { sle zero result }
    ensures { slt result y }
    ensures { to_int result = mod (to_int x) (to_int y) } 
  = 
    bw_and x ( sub y bv1 )

  use import ref.Ref

  (* Returns the digit index of the most significant (non-zero) digit of Number. (from N622-004) *)
  let get_MSD ( number : int ) : int
    (* requires { number <> $0 } *)
    requires { 0 < number < pow32 }
    requires { not( (of_int number) = zero ) }
    ensures { result <> 0 }
    ensures { result < 32 }
    ensures { forall i. result < i < 32 -> nth ( of_int number ) i = False }
  = 
    let digit_index = ref 0 in
    for i = 0 to 31 do
	invariant { !digit_index < 32 }
    	invariant { !digit_index <> 0 \/
		     exists j. i <= j /\ j < 32 /\ nth ( of_int number ) j = True }
		   (* nth ( of_int number ) !digit_index = True } *)
	invariant { forall j. !digit_index < j /\ j < i -> nth ( of_int number ) j = False }

    	if( nth ( of_int number ) i = True )
	then 	
	    digit_index := i
    done;

    !digit_index

end

module Test_from_bitvector_example

  use import int.Int
  use import bitvec.BitVector_32

  goal Test1:
    let b = bw_and zero ones in nth b 1 = False

  goal Test2:
    let b = lsr ones 16 in nth b 15 = True

  goal Test3:
    let b = lsr ones 16 in nth b 16 = False

  goal Test4:
    let b = asr ones 16 in nth b 15 = True

  goal Test5:
    let b = asr ones 16 in nth b 16 = True

  goal Test6:
    let b = asr (lsr ones 1) 16 in nth b 16 = False

  let lsr31 () = 
    ensures{ to_uint result = 1 }
    lsr ones (of_int_const 31)

  let lsr30 () = 
    ensures{ to_uint result = 3 }
    lsr ones (of_int_const 30)

  let lsr29 () = 
    ensures{ to_uint result = 7 }
    lsr ones (of_int_const 29)

  let lsr28 () = 
    ensures{ to_uint result = 15 }
    lsr ones (of_int_const 28)

  let lsr27 () = 
    ensures{ to_uint result = 31 }
    lsr ones (of_int_const 27)

  let lsr26 () = 
    ensures{ to_uint result = 63 }
    lsr ones (of_int_const 26)

  let lsr20 () = 
    ensures{ to_uint result = 4095 }
    lsr ones (of_int_const 20)

  let lsr13 () = 
    ensures{ to_uint result = 524287 }
    lsr ones (of_int_const 13)

  let lsr8 () = 
    ensures{ to_uint result = 16777215 }
    lsr ones (of_int_const 8)

  goal to_uint_0x00000001:
    to_uint (lsr ones 31) = 1

  goal to_uint_0x00000003:
    to_uint (lsr ones 30) = 3

  goal to_uint_0x00000007:
    to_uint (lsr ones 29) = 7

  goal to_uint_0x0000000F:
    to_uint (lsr ones 28) = 15

  goal to_uint_0x0000001F:
    to_uint (lsr ones 27) = 31

  goal to_uint_0x0000003F:
    to_uint (lsr ones 26) = 63

  goal to_uint_0x0000007F:
    to_uint (lsr ones 25) = 127

  goal to_uint_0x000000FF:
    to_uint (lsr ones 24) = 255

  goal to_uint_0x000001FF:
    to_uint (lsr ones 23) = 511

  goal to_uint_0x000003FF:
    to_uint (lsr ones 22) = 1023

  goal to_uint_0x000007FF:
    to_uint (lsr ones 21) = 2047

  goal to_uint_0x00000FFF:
    to_uint (lsr ones 20) = 4095

  goal to_uint_0x00001FFF:
    to_uint (lsr ones 19) = 8191

  goal to_uint_0x00003FFF:
    to_uint (lsr ones 18) = 16383

  goal to_uint_0x00007FFF:
    to_uint (lsr ones 17) = 32767

  goal to_uint_0x0000FFFF:
    to_uint (lsr ones 16) = 65535

  goal to_uint_0x0001FFFF:
    to_uint (lsr ones 15) = 131071

  goal to_uint_0x0003FFFF:
    to_uint (lsr ones 14) = 262143

  goal to_uint_0x0007FFFF:
    to_uint (lsr ones 13) = 524287

  goal to_uint_0x000FFFFF:
    to_uint (lsr ones 12) = 1048575

  goal to_uint_0x00FFFFFF:
    to_uint (lsr ones 8) = 16777215

  goal to_uint_0xFFFFFFFF:
    to_uint ones = 4294967295

end

module Test_with_axioms

  use import int.Int
  use import int.Power
  use import int.EuclideanDivision
  use import bv.BV32Ax

  type bitvec32 = t

  (* shift is div example ---------------- *)

  let shift_is_div ( x : t ) ( y : t ) : t =
    requires{ 0 <= to_uint y < 32 }
    ensures{ to_uint result = div (to_uint x) 8 }
    let res = lsr_bv x ( of_int_const 1 ) in
    assert{ res = ( udiv x (of_int_const 2) ) };
    assert{ to_uint res = div (to_uint x) 2 };
    let res = lsr_bv res ( of_int_const 2 ) in
    assert{ res = ( udiv x (of_int_const 8) ) };
    (* assert{ to_uint res = div (to_uint x) 8 }; *)
    res


  (* test invariant from frama-c ---------------- *)

  use import ref.Ref

  let testVariant( n : bitvec32 ) =
    let i = ref n in
    let two = of_int_const 2 in

    while uge !i two do
    variant{ !i with ult }
      i := lsr_bv !i two
    done

end
