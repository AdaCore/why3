
(* Technical reason: type must be declared outside for clones to work
   properly. *)
theory ParamsTypes
  
  use import int.Int
  type view_base 'c 'd =
    | VEmpty
    | VNode 'c 'd 'c int
  
  type m_base 'c =
    | Empty
    | Node (m_base 'c) 'c (m_base 'c) int
  
end

(* AVL parameters: a binary tree structure
   (exact representation is unknown), + a positive balancing
   constant. *)
module Params
  
  use import int.Int
  
  (* type for data stored in the nodes. *)
  clone program_type.Type2 as Data
  
  (* Abstract binary tree structure. *)
  namespace Tree
  
    use export ParamsTypes
    type m 'a 'b = m_base (Data.m 'a 'b)
    
    clone export program_type.Type2 with type m = m
    
    type view 'a 'b = view_base (t 'a 'b) (Data.t 'a 'b)
    
    (* Construction/pattern-matching over the tree. *)
    val empty () : t 'a 'b
      ensures { result.m = Empty }
      ensures { c result }
    
    val node (l:t 'a 'b) (d:Data.t 'a 'b) (r:t 'a 'b) (h:int) : t 'a 'b
      requires { c l /\ Data.c d /\ c r }
      ensures { result.m = Node l.m d.Data.m r.m h }
      ensures { c result }
    
    val view (t:t 'a 'b) : view 'a 'b
      ensures { match result with
        | VEmpty -> t.m = Empty
        | VNode l d r h -> t.m = Node l.m d.Data.m r.m h /\
          c l /\ Data.c d /\ c r
        end }
    
  end
  
  (* Balancing constant for the tree. This will bound
     the height difference between the subtrees at a node of
     the avl. Larger constant mean deeper trees but less
     balancing operations. *)
  constant balancing : int
  axiom balancing_positive : balancing > 0
  
end

(* AVL, modeled as a doubly-ended list + a non-negative height. *)
module AVL
  
  use import int.Int
  use import bool.Bool
  use import list.Append
  use import HighOrd
  use import option.Option
  use import ref.Ref
  
  (* AVL Parameters. *)
  clone import Params as P
  
  (* The model of an avl is morally a list. *)
  type l 'a 'b = list (Data.m 'a 'b)
  (* Excepted that we also expose an integer (the height of the tree),
     and an additional invariant on data. *)
  type m 'a 'b = {
    lis : l 'a 'b;
    hgt : int;
    inv : Data.m 'a 'b -> bool;
  }
  
  (* Shortcut. *)
  function node_model (l:l 'a 'b) (d:Data.m 'a 'b) (r:l 'a 'b) : l 'a 'b =
    l ++ Cons d r
  
  (* list obtained from a tree by infix traversal. *)
  function list_model (t:Tree.m 'a 'b) : l 'a 'b = match t with
    | Tree.Empty -> Nil
    | Tree.Node l d r _ -> node_model (list_model l) d (list_model r)
    end
  
  (* Height of the tree. *)
  function real_height (t:Tree.m 'a 'b) : int = match t with
    | Tree.Empty -> 0
    | Tree.Node l _ r _ -> let hl = real_height l in let hr = real_height r in
      1 + if hl < hr then hr else hl
    end
  
  let rec lemma real_height_nonnegative (t:Tree.m 'a 'b) : unit
    ensures { real_height t >= 0 }
    variant { t }
  = match t with
    | Tree.Empty -> ()
    | Tree.Node l _ r _ -> real_height_nonnegative l; real_height_nonnegative r
    end
  
  (* Balanced tree + correctness of stored height. *)
  predicate balanced (t:Tree.m 'a 'b) = match t with
    | Tree.Empty -> true
    | Tree.Node l _ r h -> h = real_height t /\
      -balancing <= real_height r - real_height l <= balancing /\
      balanced l /\ balanced r
    end
  
  (* Well-formedness of the data is guaranteed by the parameters.
     We also allow user to specify additional properties satisfied
     by the stored data. *)
  predicate avl_data_correct (inv:Data.m 'a 'b -> bool)
    (t:Tree.m 'a 'b) = match t with
    | Tree.Empty -> true
    | Tree.Node l d r _ ->
      avl_data_correct inv l /\ inv d /\ avl_data_correct inv r
    end
  
  (* Tree rotations are the core of balancing, so we show that
     they preserve the model. *)
  lemma rotation_preserve_model : forall ld rd:Data.m 'a 'b,fl fm fr:l 'a 'b.
      node_model (node_model fl ld fm) rd fr =
        node_model fl ld (node_model fm rd fr)
  
  (* Avl type. *)
  type t 'a 'b = {
    (* Representation as a binary tree. *)
    repr : Tree.t 'a 'b;
    (* Model. *)
    ghost m : m 'a 'b;
  }
  
  (* Invariant. *)
  predicate c (a:t 'a 'b) =
    let tm = a.repr.Tree.m in
    balanced tm /\
    avl_data_correct a.m.inv tm /\
    a.m.lis = list_model tm /\
    a.m.hgt = real_height tm /\
    Tree.c a.repr
  
  (* Get the height of the avl. *)
  let height (a:t 'a 'b) : int
    requires { c a }
    ensures { result = a.m.hgt }
  = match Tree.view a.repr with Tree.VEmpty -> 0 | Tree.VNode _ _ _ h -> h end
  
  
  (* Constructors. *)
  (* The empty avl. *)
  let empty (ghost dinv:Data.m 'a 'b -> bool) : t 'a 'b
    ensures { c result }
    ensures { result.m.lis = Nil }
    ensures { result.m.inv = dinv }
    ensures { result.m.hgt = 0 }
  =
    { repr = Tree.empty (); m = { lis = Nil; inv = dinv; hgt = 0 } }
  
  (* Node. Restricted to perfect balancing. *)
  let node (l:t 'a 'b) (d:Data.t 'a 'b) (r:t 'a 'b) : t 'a 'b
    requires { l.m.inv = r.m.inv }
    requires { c l /\ Data.c d /\ c r }
    requires { r.m.inv d.Data.m }
    requires { -balancing <= l.m.hgt - r.m.hgt <= balancing }
    ensures { c result }
    ensures { result.m.inv = l.m.inv }
    ensures { result.m.hgt =
      1 + if l.m.hgt < r.m.hgt then r.m.hgt else l.m.hgt }
    ensures { result.m.lis = node_model l.m.lis d.Data.m r.m.lis }
  =
    let hl = height l in let hr = height r in
    let h = 1 + if hl < hr then hr else hl in
    { repr = Tree.node l.repr d r.repr h;
      m = { lis = node_model l.m.lis d.Data.m r.m.lis;
            inv = r.m.inv;
            hgt = h } }
  
  (* Useful constructor. *)
  let singleton (ghost dinv:Data.m 'a 'b -> bool) (d:Data.t 'a 'b) : t 'a 'b
    requires { Data.c d /\ dinv d.Data.m }
    ensures { c result }
    ensures { result.m.inv = dinv }
    ensures { result.m.lis = Cons d.Data.m Nil }
    ensures { result.m.hgt = 1 }
  =
    let e = Tree.empty () in
    { repr = Tree.node e d e 1;
      m = { lis = Cons d.Data.m Nil; inv = dinv; hgt = 1 } }
  
  (* View of an avl, in similar fashion to Tree.view. *)
  type view 'a 'b =
    | AEmpty
    | ANode (t 'a 'b) (Data.t 'a 'b) (t 'a 'b) int
  
  (* Pattern-matching. *)
  let view (t:t 'a 'b) : view 'a 'b
    requires { c t }
    ensures { match result with
      | AEmpty -> t.m.hgt = 0 /\ t.m.lis = Nil
      | ANode l d r h -> t.m.lis = node_model l.m.lis d.Data.m r.m.lis /\
        l.m.inv = t.m.inv = r.m.inv /\ c l /\ Data.c d /\ c r /\
        t.m.inv d.Data.m /\
        let hl = l.m.hgt in let hr = r.m.hgt in
        -balancing <= hl - hr <= balancing /\
         t.m.hgt = h = 1 + if hl < hr then hr else hl
      end }
  =
    match Tree.view t.repr with
    | Tree.VEmpty -> AEmpty
    | Tree.VNode l d r h -> ANode
      { repr = l; m = { lis = list_model l.Tree.m;
                        inv = t.m.inv;
                        hgt = real_height l.Tree.m } }
      d
      { repr = r; m = { lis = list_model r.Tree.m;
                        inv = t.m.inv;
                        hgt = real_height r.Tree.m } }
      h
    end
  
  (* Emptyness test. *)
  let is_empty (t:t 'a 'b) : bool
    requires { c t }
    ensures { result <-> match t.m.lis with Nil -> true | _ -> false end }
  =
    match Tree.view t.repr with
    | Tree.VEmpty -> true
    | _ -> false
    end
  
  (* Node constructor, defective balancing allowed in input. *)
  let balance (l:t 'a 'b) (d:Data.t 'a 'b) (r:t 'a 'b) : t 'a 'b
    requires { l.m.inv = r.m.inv }
    requires { c l /\ Data.c d /\ c r }
    requires { r.m.inv d.Data.m }
    requires { -balancing-1 <= l.m.hgt - r.m.hgt <= balancing+1 }
    ensures { result.m.inv = l.m.inv }
    ensures { let hl = l.m.hgt in let hr = r.m.hgt in
      let he = 1 + if hl < hr then hr else hl in
      let hres = result.m.hgt in
      0 <= he - hres <= 1 /\
      (* Necessary in order to prove that fuse change the height
         by at most one. *)
      (-balancing <= hl - hr <= balancing -> he = hres) }
    ensures { c result }
    ensures { result.m.lis = node_model l.m.lis d.Data.m r.m.lis }
  =
    (* Wonderful case of automatic proof ! *)
    let hl = height l in
    let hr = height r in
    let df = hl - hr in
    if df > balancing
    then match view l with
      | AEmpty -> absurd
      | ANode ll ld lr _ ->
        if height ll >= height lr
        then node ll ld (node lr d r)
        else match view lr with
          | AEmpty -> absurd
          | ANode lrl lrd lrr _ ->
            node (node ll ld lrl) lrd (node lrr d r)
          end
      end
    else if df < -balancing
    then match view r with
      | AEmpty -> absurd
      | ANode rl rd rr _ ->
        if height rr >= height rl
        then node (node l d rl) rd rr
        else match view rl with
          | AEmpty -> absurd
          | ANode rll rld rlr _ ->
            node (node l d rll) rld (node rlr rd rr)
          end
      end
    else node l d r
  
  (* Decompose l ++ [d] ++ r as head::tail,avl version. Internal function. *)
  let rec decompose_front_node
    (l:t 'a 'b) (d:Data.t 'a 'b) (r:t 'a 'b) : (Data.t 'a 'b,t 'a 'b)
    requires { c l /\ Data.c d /\ c r /\ l.m.inv = r.m.inv /\ l.m.inv d.Data.m }
    requires { -balancing <= l.m.hgt - r.m.hgt <= balancing }
    returns { (d2,res) ->
      node_model l.m.lis d.Data.m r.m.lis = Cons d2.Data.m res.m.lis /\
      let hl = l.m.hgt in let hr = r.m.hgt in
      let he = 1 + if hl < hr then hr else hl in
      0 <= he - res.m.hgt <= 1 /\ res.m.inv = r.m.inv /\ l.m.inv d2.Data.m /\
      Data.c d2 /\ c res }
    variant { l.m.hgt }
  = match view l with
    | AEmpty -> (d,r)
    | ANode l d2 r2 _ -> let (d3,left) = decompose_front_node l d2 r2 in
      (d3,balance left d r)
    end
  
  (* Pattern-matching over the model list front. *)
  let decompose_front (t:t 'a 'b) : option (Data.t 'a 'b,t 'a 'b)
    requires { c t }
    returns { None -> t.m.lis = Nil
      | Some (hd,tl) -> t.m.lis = Cons hd.Data.m tl.m.lis /\ c tl /\
        tl.m.inv = t.m.inv /\ t.m.inv hd.Data.m /\ Data.c hd }
  = match view t with
    | AEmpty -> None
    | ANode l d r _ -> Some (decompose_front_node l d r)
    end
  
  let rec decompose_back_node
    (l:t 'a 'b) (d:Data.t 'a 'b) (r:t 'a 'b) : (t 'a 'b,Data.t 'a 'b)
    requires { c l /\ Data.c d /\ c r /\ l.m.inv = r.m.inv /\ l.m.inv d.Data.m }
    requires { -balancing <= l.m.hgt - r.m.hgt <= balancing }
    returns { (res,d2) ->
      node_model l.m.lis d.Data.m r.m.lis = res.m.lis ++ Cons d2.Data.m Nil /\
      let hl = l.m.hgt in let hr = r.m.hgt in
      let he = 1 + if hl < hr then hr else hl in
      0 <= he - res.m.hgt <= 1 /\ res.m.inv = r.m.inv /\ l.m.inv d2.Data.m /\
      Data.c d2 /\ c res }
    variant { r.m.hgt }
  = match view r with
    | AEmpty -> (l,d)
    | ANode l2 d2 r _ -> let (right,d3) = decompose_back_node l2 d2 r in
      (balance l d right,d3)
    end
  
  (* Pattern-matching over the model list back. *)
  let decompose_back (t:t 'a 'b) : option (t 'a 'b,Data.t 'a 'b)
    requires { c t }
    returns { None -> t.m.lis = Nil
      | Some (cotl,cohd) -> t.m.lis = cotl.m.lis ++ Cons cohd.Data.m Nil /\
        c cotl /\ cotl.m.inv = t.m.inv /\ t.m.inv cohd.Data.m /\ Data.c cohd }
  = match view t with
    | AEmpty -> None
    | ANode l d r _ -> Some (decompose_back_node l d r)
    end
  
  let rec front_node (ghost li:ref (l 'a 'b)) (l:t 'a 'b)
    (d:Data.t 'a 'b) : Data.t 'a 'b
    requires { c l /\ Data.c d /\ l.m.inv d.Data.m }
    ensures { Cons result.Data.m !li = l.m.lis ++ Cons d.Data.m Nil /\
      l.m.inv result.Data.m /\ Data.c result }
    variant { l.m.hgt }
  = match view l with
    | AEmpty -> li := Nil; d
    | ANode l d2 r _ -> let res = front_node li l d2 in
      li := !li ++ r.m.lis ++ Cons d.Data.m Nil; res
    end
  
  (* Get the front of a non-empty list. *)
  let front (ghost li:ref (l 'a 'b)) (t:t 'a 'b) : Data.t 'a 'b
    requires { c t /\ match t.m.lis with Nil -> false | _ -> true end }
    ensures { Data.c result /\ t.m.inv result.Data.m /\
      Cons result.Data.m !li = t.m.lis }
  = match view t with
    | AEmpty -> absurd
    | ANode l d2 r _ -> let res = front_node li l d2 in
      li := !li ++ r.m.lis; res
    end
  
  let rec back_node (ghost li:ref (l 'a 'b)) (d:Data.t 'a 'b)
     (r:t 'a 'b) : Data.t 'a 'b
    requires { c r /\ Data.c d /\ r.m.inv d.Data.m }
    ensures { !li ++ Cons result.Data.m Nil = Cons d.Data.m r.m.lis /\
      r.m.inv result.Data.m /\ Data.c result }
    variant { r.m.hgt }
  = match view r with
    | AEmpty -> li := Nil; d
    | ANode l d2 r _ -> let res = back_node li d2 r in
      li := Cons d.Data.m l.m.lis ++ !li; res
    end
  
  (* Get the back of a non-empty list. *)
  let back (ghost li:ref (l 'a 'b)) (t:t 'a 'b) : Data.t 'a 'b
    requires { c t /\ match t.m.lis with Nil -> false | _ -> true end }
    ensures { Data.c result /\ t.m.inv result.Data.m /\
      !li ++ Cons result.Data.m Nil = t.m.lis }
  = match view t with
    | AEmpty -> absurd
    | ANode l d2 r _ -> let res = back_node li d2 r in
      li := l.m.lis ++ !li; res
    end
  
  (* Concatenation of avl, balancing hypothesis on inputs. *)
  let fuse (l r:t 'a 'b) : t 'a 'b
    requires { c l /\ c r /\ l.m.inv = r.m.inv }
    requires { -balancing <= l.m.hgt - r.m.hgt <= balancing }
    ensures { c result /\ result.m.inv = l.m.inv }
    ensures { let hl = l.m.hgt in let hr = r.m.hgt in
      let he = 1 + if hl < hr then hr else hl in
      1 >= he - result.m.hgt >= 0 }
    ensures { result.m.lis = l.m.lis ++ r.m.lis }
  =
    match view l with
    | AEmpty -> r
    | ANode _ _ _ _ -> match view r with
      | AEmpty -> l
      | ANode rl rd rr _ -> let (d0,r') = decompose_front_node rl rd rr in
        balance l d0 r'
      end
    end
  
  
  (* list cons with avl. *)
  let rec cons (d:Data.t 'a 'b) (t:t 'a 'b) : t 'a 'b
    requires { Data.c d /\ c t /\ t.m.inv d.Data.m }
    ensures { c result /\ result.m.inv = t.m.inv }
    ensures { result.m.lis = Cons d.Data.m t.m.lis }
    (* Not supposed to be exported, but necessary for implementation. *)
    ensures { 1 >= result.m.hgt - t.m.hgt >= 0 }
    variant { t.m.hgt }
  = match view t with
    | AEmpty -> singleton t.m.inv d
    | ANode l d2 r _ -> balance (cons d l) d2 r
    end
  
  (* Reverse cons. *)
  let rec snoc (t:t 'a 'b) (d:Data.t 'a 'b) : t 'a 'b
    requires { c t /\ Data.c d /\ t.m.inv d.Data.m }
    ensures { c result /\ result.m.inv = t.m.inv }
    ensures { result.m.lis = t.m.lis ++ Cons d.Data.m Nil }
    ensures { 1 >= result.m.hgt - t.m.hgt >= 0 }
    variant { t.m.hgt }
  = match view t with
    | AEmpty -> singleton t.m.inv d
    | ANode l d2 r _ -> balance l d2 (snoc r d)
    end
  
  (* Node constructor, allow no balancing hypothesis at all. *)
  let rec join (l:t 'a 'b) (d:Data.t 'a 'b) (r:t 'a 'b) : t 'a 'b
    requires { c l /\ Data.c d /\ c r }
    requires { l.m.inv = r.m.inv /\ l.m.inv d.Data.m }
    ensures { result.m.lis = node_model l.m.lis d.Data.m r.m.lis }
    ensures { c result /\ result.m.inv = l.m.inv }
    (* Again, not supposed to be exported. *)
    ensures { let hl = l.m.hgt in let hr = r.m.hgt in
      let he = 1 + if hl < hr then hr else hl in let hres = result.m.hgt in
      0 <= he - hres <= 1 }
    variant { l.m.hgt + r.m.hgt }
  = match view l with
    | AEmpty -> cons d r
    | ANode ll ld lr lh -> match view r with
      | AEmpty -> snoc l d
      | ANode rl rd rr rh -> let df = lh - rh in
        if df > balancing
        then balance ll ld (join lr d r)
        else if df < -balancing
        then balance (join l d rl) rd rr
        else node l d r
      end
    end
  
  (* Concatenation, no balancing hypothesis on inputs. *)
  let concat (l:t 'a 'b) (r:t 'a 'b) : t 'a 'b
    requires { c l /\ c r /\ l.m.inv = r.m.inv }
    ensures { c result /\ result.m.inv = l.m.inv }
    ensures { result.m.lis = l.m.lis ++ r.m.lis }
  = match view l with
    | AEmpty -> r
    | ANode _ _ _ _ -> match view r with
      | AEmpty -> l
      | ANode rl rd rr _ -> let (d0,r') = decompose_front_node rl rd rr in
        join l d0 r'
      end
    end
  
  (* Efficient enumeration of avl elements.
     Of course, it can be done by successful application of decompose,
     but this is O(n*log(n)), while this method is O(n). *)
  namespace Enum
    
    use import list.Reverse
    
    (* Missing in list.Reverse. *)
    let rec lemma reverse_append_gen (l1 l2:list 'a) : unit
      ensures { reverse (l1 ++ l2) = reverse l2 ++ reverse l1 }
      variant { l1 }
    = match l1 with Cons _ q -> reverse_append_gen q l2 | _ -> () end
    
    type base 'a 'b = End | More (Data.t 'a 'b) (t 'a 'b) (base 'a 'b)
    
    (* Model of a left-to-right enumeration. *)
    function model_lr (e:base 'a 'b) : l 'a 'b =
      match e with
      | End -> Nil
      | More d r q -> Cons d.Data.m (r.m.lis ++ model_lr q)
      end
    
    (* right-to-left version. *)
    function model_rl (e:base 'a 'b) : l 'a 'b =
      match e with
      | End -> Nil
      | More d l q -> Cons d.Data.m (reverse l.m.lis ++ model_rl q)
      end
    
    predicate base_correct (di:Data.m 'a 'b -> bool) (e:base 'a 'b) =
      match e with
      | End -> true
      | More d t next -> Data.c d /\ c t /\ base_correct di next /\
        t.m.inv = di /\ di d.Data.m
      end
    
    type m 'a 'b = {
      inv : Data.m 'a 'b -> bool;
      lis : l 'a 'b;
      left_to_right : bool;
    }
    
    type t 'a 'b = {
      repr : base 'a 'b;
      ghost m : m 'a 'b;
    }
    
    predicate c (e: t 'a 'b) =
      base_correct e.m.inv e.repr /\
      e.m.lis = if e.m.left_to_right
        then model_lr e.repr
        else model_rl e.repr
  end
  (* Trick to avoid aliasing. *)
  namespace Enum
    
    use import list.Reverse
    let empty_enum (ghost ltr:bool)
      (ghost dinv:Data.m 'a 'b -> bool) : Enum.t 'a 'b
      ensures { result.Enum.m.Enum.left_to_right = ltr }
      ensures { result.Enum.m.Enum.lis = Nil }
      ensures { result.Enum.m.Enum.inv = dinv }
      ensures { Enum.c result }
    = { Enum.repr = Enum.End;
        Enum.m = { Enum.inv = dinv; Enum.lis = Nil; Enum.left_to_right = ltr } }
    
    let rec enum_lr (t:t 'a 'b) (acc:Enum.t 'a 'b) : Enum.t 'a 'b
      requires { c t /\ Enum.c acc }
      requires { let accm = acc.Enum.m in
        accm.Enum.inv = t.m.inv /\ accm.Enum.left_to_right }
      ensures { Enum.c result /\ let rm = result.Enum.m in
        rm.Enum.inv = t.m.inv /\ rm.Enum.left_to_right /\
        rm.Enum.lis = t.m.lis ++ acc.Enum.m.Enum.lis }
      variant { t.m.hgt }
    = match view t with
      | AEmpty -> acc
      | ANode l d r _ -> let accm = acc.Enum.m in
        enum_lr l { Enum.repr = Enum.More d r acc.Enum.repr;
                    Enum.m = { accm with
                      Enum.lis = Cons d.Data.m (r.m.lis ++ accm.Enum.lis) } }
      end
    
    let rec enum_rl (t:t 'a 'b) (acc:Enum.t 'a 'b) : Enum.t 'a 'b
      requires { Enum.c acc /\ c t }
      requires { let accm = acc.Enum.m in
        accm.Enum.inv = t.m.inv /\ not accm.Enum.left_to_right }
      ensures { Enum.c result /\ let rm = result.Enum.m in
        rm.Enum.inv = t.m.inv /\ not rm.Enum.left_to_right /\
        rm.Enum.lis = reverse t.m.lis ++ acc.Enum.m.Enum.lis }
      variant { t.m.hgt }
    = match view t with
      | AEmpty -> acc
      | ANode l d r _ -> let accm = acc.Enum.m in
        let rl = reverse l.m.lis in
        enum_rl r { Enum.repr = Enum.More d l acc.Enum.repr;
                    Enum.m = { accm with
                      Enum.lis = Cons d.Data.m (rl ++ accm.Enum.lis) } }
      end
    
    let decompose_lr (t:Enum.t 'a 'b) : option (Data.t 'a 'b,Enum.t 'a 'b)
      requires { Enum.c t }
      requires { t.Enum.m.Enum.left_to_right }
      returns { None -> t.Enum.m.Enum.lis = Nil
        | Some (hd,tl) -> Data.c hd /\ Enum.c tl /\
          let tlm = tl.Enum.m in let tm = t.Enum.m in
          tlm.Enum.inv = tm.Enum.inv /\ tlm.Enum.inv hd.Data.m /\
          tm.Enum.lis = Cons hd.Data.m tlm.Enum.lis }
    = match t.Enum.repr with
      | Enum.End -> None
      | Enum.More d r q -> let l0 = (* Feel justified, since for some reason current version of
           Why3 refuse direct (ghost!) calls to the logic function.
           I believe there is some obscure reason about ghost field
           in avls that make Why3 believe it is an impure program type.
           If current version of why3 supports it, one can simplify
           those lines by removing the axiom. *)
        any l 'a 'b ensures { result = Enum.model_lr q } in
        let q' = { Enum.repr = q;
          Enum.m = { t.Enum.m with Enum.lis = l0 } } in
        Some (d,enum_lr r q')
      end
    
    let decompose_rl (t:Enum.t 'a 'b) : option (Data.t 'a 'b,Enum.t 'a 'b)
      requires { Enum.c t }
      requires { not t.Enum.m.Enum.left_to_right }
      returns { None -> t.Enum.m.Enum.lis = Nil
        | Some (hd,tl) -> Data.c hd /\ Enum.c tl /\
          let tlm = tl.Enum.m in let tm = t.Enum.m in
          tlm.Enum.inv = tm.Enum.inv /\ tlm.Enum.inv hd.Data.m /\
          tm.Enum.lis = Cons hd.Data.m tlm.Enum.lis }
    = match t.Enum.repr with
      | Enum.End -> None
      | Enum.More d l q -> let l0 = any l 'a 'b
        ensures { result = Enum.model_rl q } in
        let q' = { Enum.repr = q;
          Enum.m = { t.Enum.m with Enum.lis = l0 } } in
        Some (d,enum_rl l q')
      end
    
  end
  
end

theory SelectionTypes
  
  use import list.List
  use import option.Option
  
  type position_base 'a = {
    left : list 'a;
    middle : option 'a;
    right : list 'a;
  }
  
  type way_base 'a = Left 'a
    | Right 'a
    | Here
  
end

(* Addition/Removal/Etc(split,etc) algorithms based on selection.
   Basic idea: functions add/remove/split/etc on an avl do
     not need an order over the stored data, but rather a
     position in the list model and code to find that selection by branching
     over list positions.
     A position in a list can be two things:
     1) an element of the list, i.e a cut [...] ++  e ++ [...]
     2) a "hole" inside a list, i.e a cut [...] ++ [...]
     It happens (not a coincidence) that this it corresponds exactly to
     the return type of split.
   Possible usages:
   - Search over ordered avl, e.g ordered associative table.
   - Cut at the "minimum element over k", in an ordered associative table.
   - Index search over an avl, e.g random access list
     (the tree representation would need to store
     the cardinal at every node for efficiency reasons)
   Note: it would also work for non-deterministic selection.
     The result would be unspecified within the set of selected elements. *)
module Selection
  
  use import int.Int
  use import bool.Bool
  use import list.Append
  use import option.Option
  use import HighOrd
  
  clone export AVL
  use export SelectionTypes
  
  (* Position inside a list l. *)
  type position 'a 'b = position_base (P.Data.m 'a 'b)
  
  function rebuild (p:position 'a 'b) : l 'a 'b =
    match p.middle with
    | None -> p.left ++ p.right
    | Some d -> node_model p.left d p.right
    end
  
  function option_to_list (o:option 'a) : list 'a = match o with
    | None -> Nil
    | Some d -> Cons d Nil
    end
  
  lemma rebuild_alternative_def : forall p:position 'a 'b.
    rebuild p = p.left ++ option_to_list p.middle ++ p.right
  
  (* selector type. *)
  clone program_type.Type2 as S
  
  (* Correctness of a selector with respect to a list. *)
  predicate selector_correct (s:S.m 'a 'b) (l:l 'a 'b)
  
  (* A position is selected by a selector. *)
  predicate selected (s:S.m 'a 'b) (e:position 'a 'b)
  
  (* way to the position. *)
  type way 'a 'b = way_base (S.t 'a 'b)
  
  (* A correct selector for the empty list
     always select its only possible position. *)
  axiom selector_correct_empty : forall s:S.m 'a 'b.
    selector_correct s Nil ->
      selected s { left = Nil ; middle = None ; right = Nil }
  
  (* Branch on a position. *)
  val selected_way (s:S.t 'a 'b)
    (l:t 'a 'b) (d:P.Data.t 'a 'b) (r:t 'a 'b) : way 'a 'b
    requires { l.m.inv = r.m.inv }
    requires { P.Data.c d /\ l.m.inv d.P.Data.m }
    requires { c l /\ c r /\ S.c s }
    requires { selector_correct s.S.m (node_model l.m.lis d.P.Data.m r.m.lis) }
    (* A selected position can be found by following the given way. *)
    returns { Here -> selected s.S.m { left = l.m.lis;
        middle = Some d.P.Data.m;
        right = r.m.lis }
      | Left sl -> selector_correct sl.S.m l.m.lis /\ S.c sl /\
        forall e. selected sl.S.m e ->
        selected s.S.m { e with right = node_model e.right d.P.Data.m r.m.lis }
      | Right sr -> selector_correct sr.S.m r.m.lis /\ S.c sr /\
        forall e. selected sr.S.m e ->
        selected s.S.m { e with left = node_model l.m.lis d.P.Data.m e.left } }
  
  use import ref.Ref
  
  let ghost default_position () : position 'a 'b =
    { left = Nil; middle = None; right = Nil }
  
  let rec add (ghost r:ref (position 'a 'b)) (s:S.t 'a 'b)
    (d:P.Data.t 'a 'b) (t:t 'a 'b) : t 'a 'b
    requires { selector_correct s.S.m t.m.lis }
    requires { c t /\ S.c s /\ P.Data.c d /\ t.m.inv d.P.Data.m }
    ensures { result.m.lis = node_model !r.left d.P.Data.m !r.right }
    ensures { selected s.S.m !r /\ rebuild !r = t.m.lis }
    ensures { c result /\ result.m.inv = t.m.inv }
    writes { r }
    (* not intended for export. *)
    ensures { 1 >= result.m.hgt - t.m.hgt >= 0 }
    variant { t.m.hgt }
  = match view t with
    | AEmpty -> r := { left = Nil; middle = None; right = Nil};
      singleton t.m.inv d
    | ANode tl td tr _ -> match selected_way s tl td tr with
      | Left sl -> let nl = add r sl d tl in
        r := { !r with right = node_model !r.right td.P.Data.m tr.m.lis };
        balance nl td tr
      | Right sr -> let nr = add r sr d tr in
        r := { !r with left = node_model tl.m.lis td.P.Data.m !r.left };
        balance tl td nr
      | Here -> r := { left = tl.m.lis;
          middle = Some td.P.Data.m;
          right = tr.m.lis };
        node tl d tr
      end
    end
  
  let rec remove (ghost r:ref (position 'a 'b)) (s:S.t 'a 'b)
    (t:t 'a 'b) : t 'a 'b
    requires { selector_correct s.S.m t.m.lis }
    requires { c t /\ S.c s }
    ensures { result.m.lis = !r.left ++ !r.right }
    ensures { selected s.S.m !r /\ rebuild !r = t.m.lis }
    ensures { c result /\ result.m.inv = t.m.inv }
    writes { r }
    (* not intended for export. *)
    ensures { 1 >= t.m.hgt - result.m.hgt >= 0 }
    variant { t.m.hgt }
  = match view t with
    | AEmpty -> r := { left = Nil; middle = None; right = Nil};
      t
    | ANode tl td tr _ -> match selected_way s tl td tr with
      | Left sl -> let nl = remove r sl tl in
        r := { !r with right = node_model !r.right td.P.Data.m tr.m.lis };
        balance nl td tr
      | Right sr -> let nr = remove r sr tr in
        r := { !r with left = node_model tl.m.lis td.P.Data.m !r.left };
        balance tl td nr
      | Here -> r := { left = tl.m.lis;
          middle = Some td.P.Data.m;
          right = tr.m.lis };
        fuse tl tr
      end
    end
  
  let rec split (ghost r:ref (position 'a 'b)) (s:S.t 'a 'b)
    (t:t 'a 'b) : (t 'a 'b,option (P.Data.t 'a 'b),t 'a 'b)
    requires { selector_correct s.S.m t.m.lis }
    requires { c t /\ S.c s }
    ensures { selected s.S.m !r /\ rebuild !r = t.m.lis }
    returns { (lf,o,rg) -> lf.m.lis = !r.left /\ rg.m.lis = !r.right /\
      (match o with
       | None -> !r.middle = None
       | Some d -> !r.middle = Some (d.P.Data.m) /\ P.Data.c d /\
         t.m.inv d.P.Data.m
       end) /\ c lf /\ c rg /\ lf.m.inv = t.m.inv = rg.m.inv }
    writes { r }
    variant { t.m.hgt }
  = match view t with
    | AEmpty -> r := { left = Nil; middle = None; right = Nil };
      (t,None,t)
    | ANode tl td tr _ -> match selected_way s tl td tr with
      | Left sl -> let (tll,tlo,tlr) = split r sl tl in
        r := { !r with right = node_model !r.right td.P.Data.m tr.m.lis };
        (tll,tlo,join tlr td tr)
      | Right sr -> let (trl,tro,trr) = split r sr tr in
        r := { !r with left = node_model tl.m.lis td.P.Data.m !r.left };
        (join tl td trl,tro,trr)
      | Here -> r := { left = tl.m.lis;
          middle = Some td.P.Data.m;
          right = tr.m.lis };
        (tl,Some td,tr)
      end
    end
  
  let rec get (ghost r:ref (position 'a 'b)) (s:S.t 'a 'b)
    (t:t 'a 'b) : option (P.Data.t 'a 'b)
    requires { selector_correct s.S.m t.m.lis }
    requires { c t /\ S.c s }
    ensures { selected s.S.m !r /\ rebuild !r = t.m.lis }
    returns { None -> !r.middle = None
       | Some d -> !r.middle = Some (d.P.Data.m) /\ P.Data.c d /\
         t.m.inv d.P.Data.m }
    writes { r }
    variant { t.m.hgt }
  = match view t with
    | AEmpty -> r := { left = Nil; middle = None; right = Nil };
      None
    | ANode tl td tr _ -> match selected_way s tl td tr with
      | Left sl -> let res = get r sl tl in
        r := { !r with right = node_model !r.right td.P.Data.m tr.m.lis };
        res
      | Right sr -> let res = get r sr tr in
        r := { !r with left = node_model tl.m.lis td.P.Data.m !r.left };
        res
      | Here -> r := { left = tl.m.lis;
          middle = Some td.P.Data.m;
          right = tr.m.lis };
        Some td
      end
    end
  
  let rec mem (ghost r:ref (position 'a 'b)) (s:S.t 'a 'b)
    (t:t 'a 'b) : bool
    requires { selector_correct s.S.m t.m.lis }
    requires { c t /\ S.c s }
    ensures { selected s.S.m !r /\ rebuild !r = t.m.lis }
    ensures { result <-> match !r.middle with None -> false | _ -> true end }
    writes { r }
    variant { t.m.hgt }
  = match view t with
    | AEmpty -> r := { left = Nil; middle = None; right = Nil };
      false
    | ANode tl td tr _ -> match selected_way s tl td tr with
      | Left sl -> let res = mem r sl tl in
        r := { !r with right = node_model !r.right td.P.Data.m tr.m.lis };
        res
      | Right sr -> let res = mem r sr tr in
        r := { !r with left = node_model tl.m.lis td.P.Data.m !r.left };
        res
      | Here -> r := { left = tl.m.lis;
          middle = Some td.P.Data.m;
          right = tr.m.lis };
        true
      end
    end
  
end

(*

(* Instantiation to sorted (increasing) avl.
   Those implement ordered associative tables. *)
module AVLSorted
  
  use import int.Int
  use import option.Option
  use import bool.Bool
  use import HighOrd
  use import list.Append
  use import list.Mem
  use import list.Length
  
  clone import AVL as A
  
  (* Key used for ordering. *)
  type key 'a
  type key_model 'a
  (* Key well-formedness. *)
  predicate key_correct (key 'a)
  (* Get key model. *)
  function key_model (key 'a) : key_model 'a
  (* Key from data in pure and impure (program) worlds. *)
  function get_key_m (d:data_model 'a 'b) : key_model 'a
  val get_key (d:data 'a 'b) : key 'a
    requires { data_correct d }
    ensures { key_correct result }
    ensures { key_model result = get_key_m (data_model d) }
  (* Parameter for ordering. *)
  type order 'a
  clone association_list.AssocSorted as AS with
    type A.KT.key = key_model,
    type A.KT.t = data_model,
    type A.param = order
  
  
  (*
  
  (* Comparison is computable. *)
  val compare (o:order 'a) (k1 k2:key 'a) : int
    requires { correct_for_order o (key_model k1) /\ key_correct k1 }
    requires { correct_for_order o (key_model k2) /\ key_correct k2 }
    ensures { result > 0 <-> lt o (key_model k2) (key_model k1) }
    ensures { result < 0 <-> lt o (key_model k1) (key_model k2) }
    ensures { result = 0 <-> eq o (key_model k1) (key_model k2) }
  
  predicate majorate (o:order 'a) (k:key_model 'a) (l:list_model 'a 'b) =
    forall d0. mem d0 l -> let k0 = get_key_m d0 in
      correct_for_order o k0 /\ lt o k0 k
  
  predicate minorate (o:order 'a) (k:key_model 'a) (l:list_model 'a 'b) =
    forall d0. mem d0 l -> let k0 = get_key_m d0 in
      correct_for_order o k0 /\ lt o k k0
  
  predicate sorted (o:order 'a) (l:list_model 'a 'b) = match l with
      | Nil -> true
      | Cons d q -> let k = get_key_m d in
        correct_for_order o k /\ minorate o k q /\ sorted o q
    end
    
  (* Sorted with a midpoint. *)
  let rec lemma sorted_def_midpoint (o:order 'a) (l:list_model 'a 'b)
    (d:data_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { correct_for_order o (get_key_m d) }
    ensures { sorted o (node_model l d r) <->
      (minorate o (get_key_m d) r /\
        majorate o (get_key_m d) l /\
        sorted o l /\
        sorted o r) }
    variant { l }
  =
    match l with
      | Nil -> ()
      | Cons _ ql -> sorted_def_midpoint o ql d r
    end
  
  predicate before (o:order 'a) (l:list_model 'a 'b) (r:list_model 'a 'b) =
    forall d1 d2. mem d1 l /\ mem d2 r ->
      let k1 = get_key_m d1 in let k2 = get_key_m d2 in
      correct_for_order o k1 /\ correct_for_order o k2 /\ lt o k1 k2
  
  (* Other variant: condition for a concatenation to be sorted. *)
  let rec lemma sorted_def_concat (o:order 'a) (l:list_model 'a 'b)
    (r:list_model 'a 'b) : unit
    ensures { sorted o (l ++ r) <->
      (sorted o l /\ sorted o r /\ before o l r) }
    variant { l }
  =
    match l with
      | Nil -> ()
      | Cons _ ql -> sorted_def_concat o ql r
    end
  
  type position 'a 'b = {
    left : list_model 'a 'b;
    middle : option (data_model 'a 'b);
    right : list_model 'a 'b;
  }
  
  (* Selection will be done by ordered key. *)
  type selector 'a 'b = (order 'a,key 'a)
  
  (* Correctness is sortedness. *)
  predicate selector_correct (s:selector 'a 'b) (l:list_model 'a 'b) =
    let (o,k) = s in sorted o l /\ correct_for_order o (key_model k) /\
      key_correct k
    
  (* Selected position is:
     - The position of the element equivalent to the key for the
       corresponding order.
     - The position where it should be if it does not exists. *)
  predicate selected (s:selector 'a 'b) (e:position 'a 'b)
    (l:list_model 'a 'b) = let (o,k) = s in
      sorted o e.left /\ sorted o e.right /\
      minorate o (key_model k) e.right /\ majorate o (key_model k) e.left /\
      match e.middle with
        | None -> l = e.left ++ e.right
        | Some d -> l = node_model e.left d e.right /\
          eq o (get_key_m d) (key_model k) /\
          correct_for_order o (get_key_m d)
      end
  
  (* Way to the position. *)
  type way 'a 'b= Left (selector 'a 'b)
    | Right (selector 'a 'b)
    | Here
  
  (* Way selection. *)
  let selected_way (s:selector 'a 'b)
    (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) : way 'a 'b
    requires { l.data_inv = r.data_inv }
    requires { data_correct d /\ l.data_inv (data_model d) }
    requires { avl_correct l /\ avl_correct r }
    requires { selector_correct s (node_model l.model (data_model d) r.model) }
    returns { Here -> selected s { left = l.model;
        middle = Some (data_model d);
        right = r.model }
        (node_model l.model (data_model d) r.model)
      | Left sl -> selector_correct sl l.model /\
        forall e. selected sl e l.model ->
        selected s { e with right = node_model e.right (data_model d) r.model }
          (node_model l.model (data_model d) r.model)
      | Right sr -> selector_correct sr r.model /\
        forall e. selected sr e r.model ->
        selected s { e with left = node_model l.model (data_model d) e.left }
          (node_model l.model (data_model d) r.model) }
  =
    let (o,k) = s in
    let kd = get_key d in
    let cmp = compare o k kd in
    if cmp < 0
    then Left s
    else if cmp > 0
    then Right s
    else Here
  
  (* In an ideal world...
     1) It would be nice to have the two cloned AVL modules unified
        (they are intended to be the same), as well as the two (identical)
        definitions of type way.
     2) Routines (program code) could be used as argument. *)
  (* clone import AVLSelection as F with
       A = A,
       type selector 'a 'b = selector 'a 'b,
       predicate selector_correct = selector_correct,
       predicate selected = selected,
       type way 'a 'b = way 'a 'b,
       lemma selected_append,
       lemma selector_correct_empty,
       val selected_way = selected_way*)
  
  (* And we would get this (or something close).
     Right now, this is done by hand. *)
  
  namespace import F
    use import ref.Ref
    
    lemma selected_append : forall s,e,l:list_model 'a 'b.
      selected s e l /\ selector_correct s l -> match e.middle with
        | Some d -> l = node_model e.left d e.right
        | None -> l = e.left ++ e.right
      end
    
    lemma selector_correct_empty : forall s:selector 'a 'b.
      selector_correct s (Nil:list_model 'a 'b) ->
        selected s { left = Nil ; middle = None ; right = Nil }
          (Nil:list_model 'a 'b)
    
    val ghost default_position () : position 'a 'b
  
    val add (ghost r:ref (position 'a 'b)) (s:selector 'a 'b)
      (d:data 'a 'b) (a:avl 'a 'b) : avl 'a 'b
      requires { selector_correct s a.model }
      requires { avl_correct a }
      requires { data_correct d /\ a.data_inv (data_model d) }
      ensures { result.model = node_model !r.left (data_model d) !r.right }
      ensures { selected s !r a.model }
      ensures { 1 >= avl_height result - avl_height a >= 0 }
      ensures { avl_correct result }
      ensures { result.data_inv = a.data_inv }
      writes { r }
  
    val remove (ghost r:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : avl 'a 'b
      requires { selector_correct s a.model }
      requires { avl_correct a }
      ensures { result.model = !r.left ++ !r.right }
      ensures { selected s !r a.model }
      ensures { 1 >= avl_height a - avl_height result >= 0 }
      ensures { avl_correct result }
      ensures { result.data_inv = a.data_inv }
      writes { r }
  
    val split (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : (avl 'a 'b,option (data 'a 'b),avl 'a 'b)
      requires { avl_correct a }
      requires { selector_correct s a.model }
      returns { (l,o,r) ->
        !p.left = l.model /\ !p.right = r.model /\
        !p.middle = match o with None -> None | Some d -> Some (data_model d) end
        /\ selected s !p a.model /\
        avl_correct l /\ avl_correct r /\ match o with
          | None -> true | Some d -> data_correct d /\ a.data_inv (data_model d)
        end /\ l.data_inv = a.data_inv /\ r.data_inv = a.data_inv }
      writes { p }
    
    val get (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : option (data 'a 'b)
      requires { avl_correct a }
      requires { selector_correct s a.model }
      ensures { !p.middle = match result with
          | None -> None | Some d -> Some (data_model d)
        end /\ selected s !p a.model /\ match result with
          | None -> true | Some d -> data_correct d /\ a.data_inv (data_model d)
        end }
      writes { p }
  
    val mem (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : bool
      requires { avl_correct a }
      requires { selector_correct s a.model }
      ensures { (result <-> !p.middle <> None) /\
        selected s !p a.model }
      writes { p }
  end
  
  (* Functional model. *)
  type fun_model 'a 'b = key_model 'a -> option (data_model 'a 'b)
  
  function functional_model (o:order 'a)
    (l:list_model 'a 'b) : fun_model 'a 'b =
    match l with
      | Nil -> \y.None
      | Cons x q -> let f0 = functional_model o q in
        \y. if correct_for_order o y &&
          eq o y (get_key_m x) then Some x else f0 y
    end
  
  type map 'a 'b = {
    avl_repr : avl 'a 'b;
    order : order 'a;
    ghost fmodel : fun_model 'a 'b;
  }
  
  function map_data_inv (m:map 'a 'b) : data_model 'a 'b -> bool =
    m.avl_repr.data_inv
  
  predicate map_correct (m:map 'a 'b) =
    avl_correct m.avl_repr /\
    sorted m.order m.avl_repr.model /\
    m.fmodel = functional_model m.order m.avl_repr.model /\
    (forall d. m.map_data_inv d -> correct_for_order m.order (get_key_m d))
  
  (* A key that is either minorated/majorated in some list is not
     represented in its functional model. *)
  let rec lemma fun_model_minorate (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { minorate o k l }
    requires { correct_for_order o k }
    ensures { functional_model o l k = None }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_minorate o k ql end
  
  let rec lemma fun_model_majorate (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { majorate o k l }
    requires { correct_for_order o k }
    ensures { functional_model o (l++r) k = functional_model o r k }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_majorate o k ql r end
  
  let rec lemma fun_model_selected (o:order 'a) (k:key 'a)
    (p:position 'a 'b) (l:list_model 'a 'b) (ks:key_model 'a) : unit
    requires { selected (o,k) p l }
    requires { key_correct k }
    requires { correct_for_order o (key_model k) }
    requires { correct_for_order o ks }
    ensures { eq o (key_model k) ks ->
      functional_model o l ks = p.middle }
    ensures { lt o (key_model k) ks ->
      functional_model o l ks = functional_model o p.right ks }
    ensures { le o ks (key_model k) ->
      functional_model o p.right ks = None }
    ensures { lt o ks (key_model k) ->
      functional_model o l ks = functional_model o p.left ks }
    ensures { le o (key_model k) ks ->
      functional_model o p.left ks = None }
    variant { p.left }
  =
    assert { l = p.left ++ (match p.middle with
      | None -> Nil | Some d -> Cons d Nil end)
      ++ p.right };
    assert { match p.middle with None -> true | Some d ->
      eq o (get_key_m d) (key_model k) /\
      correct_for_order o (get_key_m d) end };
    match p.left , l with
      | Nil , Nil -> ()
      | Nil , Cons _ _ -> let km = key_model k in
        assert { eq o km ks -> not functional_model o l ks = p.middle ->
          match p.middle with
            | None -> minorate o ks p.right && false | Some d ->
              let dk = get_key_m d in
              eq o dk km &&
              eq o ks dk && false end }
      | _ , Nil -> absurd
      | Cons xpl qpl , Cons _ ql ->
        assert { let kpl = get_key_m xpl in
          le o (key_model k) ks -> mem xpl p.left && lt o kpl (key_model k)
          && not eq o kpl ks };
        fun_model_selected o k { p with left = qpl } ql ks
    end
  
  let rec lemma fun_model_concat (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { sorted o r }
    requires { before o l r }
    requires { correct_for_order o k }
    ensures { functional_model o (l++r) k = None <->
      functional_model o l k = None /\ functional_model o r k = None }
    ensures { forall d. functional_model o l k = Some d ->
      functional_model o (l++r) k = Some d }
    ensures { forall d. functional_model o r k = Some d ->
      functional_model o (l++r) k = Some d }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_concat o k ql r end
    
  
  (*
  (* Functional model of a concatenation. *)
  let rec lemma fun_model_concat (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { sorted o r }
    requires { minorate o k r }
    requires { correct_for_order o k }
    ensures { functional_model o (l++r) k = functional_model o l k }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_concat o k ql r end
  
  (* Node selection. *)
  let rec lemma fun_model_node (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (d:data_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o (node_model l d r) }
    requires { eq o k (get_key_m d) }
    requires { correct_for_order o k }
    ensures { functional_model o (node_model l d r) k = Some d }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_node o k ql d r end*)
  
  let rec lemma fun_model_incorrect (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) : unit
    requires { not(correct_for_order o k) }
    ensures { functional_model o l k = None }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_incorrect o k ql end
  
  let rec lemma fun_model_nonnone (o:order 'a) (d:data_model 'a 'b)
    (l:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { mem d l }
    ensures { functional_model o l (get_key_m d) <> None }
    variant { l }
  = match l with Nil -> () | Cons xl ql ->
      if d <> xl
      then fun_model_nonnone o d ql
      else ()
    end
  
  use import ref.Ref
  
  let map_empty (o:order 'a) (inv:data_model 'a 'b -> bool) : map 'a 'b
    requires { forall d. inv d -> correct_for_order o (get_key_m d) }
    ensures { result.order = o }
    ensures { result.map_data_inv = inv }
    ensures { forall k. result.fmodel k = None }
    ensures { map_correct result }
  =
    let rp = empty inv in
    { avl_repr = rp;
      order = o;
      fmodel = functional_model o rp.model }
  
  let map_singleton (o:order 'a) (inv:data_model 'a 'b -> bool)
    (d:data 'a 'b) : map 'a 'b
    requires { forall d. inv d -> correct_for_order o (get_key_m d) }
    requires { data_correct d }
    requires { inv (data_model d) }
    ensures { result.order = o }
    ensures { forall k. correct_for_order o k /\
      eq o k (get_key_m (data_model d)) ->
      result.fmodel k = Some (data_model d) }
    ensures { forall k. not correct_for_order o k ->
      result.fmodel k = None }
    ensures { forall k. not eq o k (get_key_m (data_model d)) ->
      result.fmodel k = None }
    ensures { result.map_data_inv = inv }
    ensures { map_correct result }
  =
    let rp = singleton inv d in
    { avl_repr = rp;
      order = o;
      fmodel = functional_model o rp.model }
  
  let map_add (d:data 'a 'b) (m:map 'a 'b) : map 'a 'b
    requires { m.map_data_inv (data_model d) /\ data_correct d }
    requires { map_correct m }
    ensures { forall k. not eq m.order k (get_key_m (data_model d)) ->
      result.fmodel k = m.fmodel k }
    ensures { forall k. not correct_for_order m.order k ->
      result.fmodel k = m.fmodel k }
    ensures { forall k. correct_for_order m.order k /\
      eq m.order k (get_key_m (data_model d)) ->
        result.fmodel k = Some (data_model d) }
    ensures { result.order = m.order /\ result.map_data_inv = m.map_data_inv }
    ensures { map_correct result }
  =
    let ghost r = ref (default_position ()) in
    let k = get_key d in
    let o = m.order in
    let res0 = add r (o,k) d m.avl_repr in
    let res = { avl_repr = res0;
      order = m.order;
      fmodel = functional_model o res0.model } in
    assert { selected (o,k)
      { !r with middle = Some (data_model d) } res0.model };
    res
  
  let map_mem (k:key 'a) (m:map 'a 'b) : bool
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    ensures { forall k2. correct_for_order m.order k2 /\
      eq m.order k2 (key_model k) -> (m.fmodel k2 <> None <-> result) }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    mem r (o,k) m.avl_repr
  
  let map_remove (k:key 'a) (m:map 'a 'b) : map 'a 'b
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    ensures { forall k2. not eq m.order k2 (key_model k) ->
      result.fmodel k2 = m.fmodel k2 }
    ensures { forall k2. not correct_for_order m.order k2 ->
      result.fmodel k2 = m.fmodel k2 }
    ensures { forall k2. correct_for_order m.order k2 /\
      eq m.order k2 (key_model k) -> result.fmodel k2 = None }
    ensures { result.order = m.order /\ result.map_data_inv = m.map_data_inv }
    ensures { map_correct result }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    let res0 = remove r (o,k) m.avl_repr in
    let res = { avl_repr = res0;
      order = m.order;
      fmodel = functional_model o res0.model } in
    assert { selected (o,k) { !r with middle = None } res0.model };
    res
  
  
  let map_find (k:key 'a) (m:map 'a 'b) : option (data 'a 'b)
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    ensures { forall k2. correct_for_order m.order k2 /\
      eq m.order k2 (key_model k) -> m.fmodel k2 = match result with
        | None -> None | Some d -> Some (data_model d) end }
    returns { None -> true
      | Some d -> data_correct d /\ m.map_data_inv (data_model d) }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    get r (o,k) m.avl_repr
  
  let map_split (k:key 'a)
    (m:map 'a 'b) : (map 'a 'b,option (data 'a 'b),map 'a 'b)
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    returns { (l,o,r) -> map_correct l /\ map_correct r /\
      l.order = m.order /\ r.order = m.order /\
      l.map_data_inv = m.map_data_inv /\ r.map_data_inv = m.map_data_inv /\
      (forall k2. not correct_for_order m.order k2 ->
        l.fmodel k2 = None = r.fmodel k2) /\
      (forall k2. correct_for_order m.order k2 /\ le m.order k2 (key_model k) ->
        r.fmodel k2 = None) /\
      (forall k2. correct_for_order m.order k2 /\ le m.order (key_model k) k2 ->
        l.fmodel k2 = None) /\
      (forall k2. correct_for_order m.order k2 /\ lt m.order k2 (key_model k) ->
        l.fmodel k2 = m.fmodel k2) /\
      (forall k2. correct_for_order m.order k2 /\ lt m.order (key_model k) k2 ->
        r.fmodel k2 = m.fmodel k2) /\
      (forall k2. correct_for_order m.order k2 /\ eq m.order (key_model k) k2 ->
        m.fmodel k2 = match o with
          | None -> None
          | Some d -> Some (data_model d)
        end) /\ match o with
          | None -> true
          | Some d -> data_correct d /\ m.map_data_inv (data_model d)
        end }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    let (l0,o0,r0) = split r (o,k) m.avl_repr in
    let l = { avl_repr = l0;
      order = m.order;
      fmodel = functional_model o l0.model } in
    let r = { avl_repr = r0;
      order = m.order;
      fmodel = functional_model o r0.model } in
    (l,o0,r)
  
  let map_concat (m1 m2:map 'a 'b) : map 'a 'b
    requires { map_correct m1 /\ map_correct m2 /\
      m1.map_data_inv = m2.map_data_inv /\
      m1.order = m2.order }
    requires { forall k1 k2. m1.fmodel k1 <> None /\ m2.fmodel k2 <> None ->
      lt m1.order k1 k2 }
    ensures { map_correct result }
    ensures { result.order = m1.order }
    ensures { result.map_data_inv = m1.map_data_inv }
    ensures { forall k. result.fmodel k = None <-> m1.fmodel k = None /\
      m2.fmodel k = None }
    ensures { forall k d. m1.fmodel k = Some d -> result.fmodel k = Some d }
    ensures { forall k d. m2.fmodel k = Some d -> result.fmodel k = Some d }
  =
    let o = m2.order in
    assert { before o m1.avl_repr.model m2.avl_repr.model };
    let r0 = concat m1.avl_repr m2.avl_repr in
    let res = { avl_repr = r0;
      order = o;
      fmodel = functional_model o r0.model } in
    res
  *)
end*)

