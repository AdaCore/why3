
module Ident
  
  (* Identifiers types from Why3.
     Note: as Why3 has no support for string whatsoever,
     any transformation that should create particular names (pre-id)
     (for readability) should do so by calling an abstract value
     implemented in drivers. Nothing will be verified about actual names
     anyway. *)
  type preid
  type ident
  
end

module Ty
  
  use import int.Int
  use import logic_syntax.Defs as D
  use import logic_syntax.VarsIn
  use import logic_syntax.Substs
  use import support.HO
  use import support.Finite
  use import ref.Ref
  use import list.List
  use import logic_typing.Env as E
  use import Ident
  use import option.Option
  
  
  (* 'World' in which type variables lives. It typically represent the binding
     context for such type variables. It should live only in spec/ghost code.
     There are two kinds of worlds: closed worlds, in which a particular
     inextensible set of variable lives, and open worlds, in which this set
     can grow indefinitely. *)
  type tv_world
  predicate tv_closed_world tv_world
  function tv_world_set tv_world : int -> bool
  
  (* Type variables. *)
  type tvname
  type tvsymbol model {
    tv_m : int;
    tv_world : tv_world;
  }
  (* Machinery for generation of fresh type variables: maintain an ever-growing
     finite set of used integer indexes for each world. *)
  type tv_all model { mutable tv_all : tv_world -> int -> bool }
  type tv_all_s model { tv_all_s : tv_world -> int -> bool }
  val ghost tv_all_set : tv_all
  (* Ensures growth of tv_all_set without having to state it in every
     post-condition. *)
  val ghost tv_all_snapshot () : tv_all_s
    ensures { result.tv_all_s = tv_all_set.tv_all }
  val ghost tv_all_growth (u:tv_all_s) : unit
    ensures { forall tvw x. u.tv_all_s tvw x -> tv_all_set.tv_all tvw x }
    ensures { forall tvw. tv_closed_world tvw ->
      u.tv_all_s tvw = tv_all_set.tv_all tvw }
  val ghost tv_closed_set (tvw:tv_world) : unit
    requires { tv_closed_world tvw }
    ensures { tv_all_set.tv_all tvw = tvw.tv_world_set }
  (* Every generated tvsymbol must be in its world set.
     Note: such an axiom is dangerous, as it may be a source of contradiction.
     It basically states a type invariant dependent of a mutable variable.
     However, the mentioned variable can only 'grow', and the invariant
     'increase' with its growth, so the invariant may never become wrong.
     (=> Actually, it corresponds to an history invariant)
     Such statement becomes dangerous iff it is somehow possible to do an
     infinite number of call to the statement => It is correct in current Why3,
     but would be wrong in an imaginable extension with a Dafny-like forall.
     (also, implementing a module with such a specification is currently
      unfeasible in Why3) *)
  val ghost tvsymbol_in (x:tvsymbol) : unit
    ensures { tv_all_set.tv_all x.tv_world x.tv_m }
  val create_tvsymbol (ghost tvw:tv_world) (x:preid) : tvsymbol
    writes { tv_all_set }
    requires { not tv_closed_world tvw }
    ensures { result.tv_world = tvw }
    ensures { not (old tv_all_set).tv_all tvw result.tv_m }
  val tv_name (x:tvsymbol) : ident
  val tv_equal (x y:tvsymbol) : bool
    requires { x.tv_world = y.tv_world }
    ensures { result <-> x.tv_m = y.tv_m }
  val ghost tv_world (x:tvsymbol) : tv_world
    ensures { result = x.tv_world }
  (* Global, empty world for top-level definitions. *)
  val ghost tv_global : tv_world
  val ghost tv_global_def () : unit
    ensures { tv_closed_world tv_global }
    ensures { tv_all_set.tv_all tv_global = none }
  (*
  axiom tv_global_closed : closed_world tv_global*)
  val ghost tv_global_empty () : unit
    ensures { tv_all_set.tv_all tv_global = none }
  (* Fully open world for free term creation. *)
  val ghost tv_open : tv_world
  val ghost tv_open_def () : unit
    ensures { not tv_closed_world tv_open }
  
  (* TODO: insert here creation of closed worlds from an arbitrary other
     and a domain. This is necessary for arbitrary creation of logical
     symbol, but probably not critical for transformation as we normally
     reuse existing worlds. *)
  
  (* Type symbols, types, and global signature.
     Global signature behave roughly like tv_all_set. *)
  
  (* Particular type symbol for propositions. Exists only at specification
     level, in Why3 it is encoded specially using options (hence cannot
     occur at any place beyond toplevel types) *)
  constant tys_prop : D.ty_symbol
  constant ty_prop : D.ty = D.TyApp tys_prop Nil
  (* Particular logical symbol for equality. This version exists only
     at specification level, and must be stated here because it is a signature
     built-in. *)
  constant ls_equ : D.lsymbol
  
  (* As we wish to cache the number of constructors in logical symbols,
     we have to extend the signature with a field containing that number. *)
  type signature model {
    mutable sig_m : E.signature ;
    mutable tsc_n : D.ty_symbol -> int;
  } invariant { sig_wf self.sig_m /\
      self.sig_m.E.tys_prop = tys_prop /\
      self.sig_m.E.ls_equ = ls_equ /\
      forall tys. self.sig_m.tys_belong tys ->
        let s = self.sig_m.tys_constr tys in
        let n0 = self.tsc_n tys in
        finite s /\ n0 >= cardinal s /\
        (n0 = cardinal s -> self.sig_m.tys_constr_complete tys) }
  type signature_s model {
    sig_s_m : E.signature;
    tsc_s_n : D.ty_symbol -> int;
  } invariant { sig_wf self.sig_s_m /\
      self.sig_s_m.E.tys_prop = tys_prop /\
      self.sig_s_m.E.ls_equ = ls_equ /\
      forall tys. self.sig_s_m.tys_belong tys ->
        let s = self.sig_s_m.tys_constr tys in
        let n0 = self.tsc_s_n tys in
        finite s /\ n0 >= cardinal s /\
        (n0 = cardinal s -> self.sig_s_m.tys_constr_complete tys) }
  val ghost global_sig : signature
  val ghost global_sig_snapshot () : signature_s
    ensures { result.sig_s_m = global_sig.sig_m }
  val ghost global_sig_growth (s:signature_s) : unit
    ensures { let so = s.sig_s_m in let sc = global_sig.sig_m in
      (forall tys. so.tys_belong tys -> sc.tys_belong tys /\
        sc.tys_arity tys = so.tys_arity tys) /\
      (forall tys ls. so.tys_belong tys /\ so.tys_constr tys ls ->
        sc.tys_constr tys ls) /\
      (forall ls. so.ls_belong ls -> sc.ls_belong ls /\
        sc.ls_ty_arity ls = so.ls_ty_arity ls /\
        sc.ls_args ls = so.ls_args ls /\
        sc.ls_ret ls = so.ls_ret ls) /\
      (forall ls. so.ls_constr ls -> sc.ls_constr ls) /\
      (forall tys. so.tys_belong tys /\ so.tys_constr_complete tys ->
        sc.tys_constr_complete tys) /\
      (forall tys. tys_alg so tys -> global_sig.tsc_n tys = s.tsc_s_n tys) }
  
  (* Signature worlds: describe the world in which a given type/term live in,
     e.g which are the authorized declarations. *)
  type sig_world
  type sig_world_set model {
    mutable decl_tys : sig_world -> D.ty_symbol -> bool;
    mutable decl_ls : sig_world -> D.lsymbol -> bool;
    mutable decl_constr : sig_world -> D.lsymbol -> bool;
  }
  predicate sig_closed_world sig_world
  function sig_decl_tys sig_world : D.ty_symbol -> bool
  function sig_decl_ls sig_world : D.lsymbol -> bool
  function sig_decl_constr sig_world : D.lsymbol -> bool
  type sig_world_set_s model {
    decl_tys_s : sig_world -> D.ty_symbol -> bool;
    decl_ls_s : sig_world -> D.lsymbol -> bool;
    decl_constr_s : sig_world -> D.lsymbol -> bool;
  }
  val ghost sig_world_s_inv (sw:sig_world_set_s) : unit
    ensures { forall sg tys. sw.decl_tys_s sg tys ->
      global_sig.sig_m.tys_belong tys }
    ensures { forall sg ls. sw.decl_ls_s sg ls ->
      global_sig.sig_m.ls_belong ls }
    ensures { forall sg ls. sw.decl_constr_s sg ls ->
      sw.decl_ls_s sg ls /\ global_sig.sig_m.ls_constr ls }
    ensures { forall sg ls. sw.decl_ls_s sg ls ->
      let ty = global_sig.sig_m.ls_ret ls in
        ty_vars_in all (sw.decl_tys_s sg) ty }
    ensures { forall sg ls. sw.decl_ls_s sg ls ->
      let tyl = global_sig.sig_m.ls_args ls in
        tyl_vars_in all (sw.decl_tys_s sg) tyl }
  val ghost sig_world_all : sig_world_set
  val ghost sig_world_snapshot () : sig_world_set_s
    ensures { result.decl_tys_s = sig_world_all.decl_tys }
    ensures { result.decl_ls_s = sig_world_all.decl_ls }
    ensures { result.decl_constr_s = sig_world_all.decl_constr }
  let ghost sig_world_inv () : unit
    ensures { let sw = sig_world_all in
      let gs = global_sig.sig_m in
      (forall sg tys. sw.decl_tys sg tys -> gs.tys_belong tys) /\
      (forall sg ls. sw.decl_ls sg ls -> gs.ls_belong ls) /\
      (forall sg ls. sw.decl_constr sg ls ->
        sw.decl_ls sg ls /\ gs.ls_constr ls) /\
      (forall sg ls. sw.decl_ls sg ls ->
        let ty = gs.ls_ret ls in ty_vars_in all (sw.decl_tys sg) ty) /\
      (forall sg ls. sw.decl_ls sg ls ->
        let tyl = gs.ls_args ls in tyl_vars_in all (sw.decl_tys sg) tyl) }
  = sig_world_s_inv (sig_world_snapshot ())
  val ghost sig_world_growth (s:sig_world_set_s) : unit
    ensures { forall x y. s.decl_tys_s x y -> sig_world_all.decl_tys x y }
    ensures { forall x y. s.decl_ls_s x y -> sig_world_all.decl_ls x y }
    ensures { forall x y. s.decl_constr_s x y -> sig_world_all.decl_constr x y }
    ensures { forall x. sig_closed_world x ->
      s.decl_tys_s x = sig_world_all.decl_tys x /\
      s.decl_ls_s x = sig_world_all.decl_ls x /\
      s.decl_constr_s x = sig_world_all.decl_constr x }
  val ghost sig_closed_fields (sg:sig_world) : unit
    requires { sig_closed_world sg }
    ensures { sig_decl_tys sg = sig_world_all.decl_tys sg }
    ensures { sig_decl_ls sg = sig_world_all.decl_ls sg }
    ensures { sig_decl_constr sg = sig_world_all.decl_constr sg }
  val ghost make_sig_world (tys:ty_symbol -> bool)
    (ls:lsymbol -> bool)
    (constr:lsymbol -> bool)
    (closed:bool) : sig_world
    requires { forall x. tys x -> global_sig.sig_m.tys_belong x }
    requires { forall x. ls x -> global_sig.sig_m.ls_belong x }
    requires { forall x. constr x -> ls x /\ global_sig.sig_m.ls_constr x }
    requires { forall x. ls x -> let ty = global_sig.sig_m.ls_ret x in
      ty_vars_in all tys ty }
    requires { forall x. ls x -> let tyl = global_sig.sig_m.ls_args x in
      tyl_vars_in all tys tyl }
    ensures { sig_closed_world result <-> closed }
    ensures { sig_world_all.decl_tys result = sig_decl_tys result = tys }
    ensures { sig_world_all.decl_ls result = sig_decl_ls result = ls }
    ensures { sig_world_all.decl_constr result =
              sig_decl_constr result = constr }
  val ghost update_sig_world (tys:ty_symbol -> bool)
    (ls:lsymbol -> bool)
    (constr:lsymbol -> bool)
    (sw:sig_world) : unit
    requires { forall x. tys x -> global_sig.sig_m.tys_belong x }
    requires { forall x. ls x -> global_sig.sig_m.ls_belong x }
    requires { forall x. constr x -> ls x /\ global_sig.sig_m.ls_constr x }
    requires { forall x. ls x -> let ty = global_sig.sig_m.ls_ret x in
      ty_vars_in all tys ty }
    requires { forall x. ls x -> let tyl = global_sig.sig_m.ls_args x in
      tyl_vars_in all tys tyl }
    requires { forall x. sig_world_all.decl_tys sw x -> tys x }
    requires { forall x. sig_world_all.decl_ls sw x -> ls x }
    requires { forall x. sig_world_all.decl_constr sw x -> constr x }
    writes { sig_world_all }
    ensures { sig_world_all.decl_tys = update sig_world_all.decl_tys sw tys }
    ensures { sig_world_all.decl_ls = update sig_world_all.decl_ls sw ls }
    ensures { sig_world_all.decl_constr =
      update sig_world_all.decl_constr sw constr }
  
  type tysymbol model {
    ts_m : D.ty_symbol;
    ts_arity : int;
  }
  type ty model {
    ty_m : D.ty;
    ty_tv_world : tv_world;
    ty_sig_world : sig_world;
  }
  val ghost ty_sig_world (ty:ty) : sig_world
    ensures { result = ty.ty_sig_world }
  type ty_node =
    | Tyvar tvsymbol
    | Tyapp tysymbol (list ty)
  predicate tyl_worlds (tvw:tv_world) (sw:sig_world) (tyl:list ty) =
    match tyl with
    | Nil -> true
    | Cons x q -> x.ty_tv_world = tvw /\ x.ty_sig_world = sw /\
      tyl_worlds tvw sw q
    end
  function tyl_m (tyl:list ty) : list D.ty = match tyl with
    | Nil -> Nil
    | Cons x q -> Cons x.ty_m (tyl_m q)
    end
  val ghost tysymbol_inv (tys:tysymbol) : unit
    ensures { global_sig.sig_m.tys_belong tys.ts_m }
    ensures { global_sig.sig_m.tys_arity tys.ts_m = tys.ts_arity }
    ensures { ts_m tys <> tys_prop }
  val ghost ty_inv (ty:ty) : unit
    ensures { ty_wf global_sig.sig_m ty.ty_m }
    ensures { let s0 = tv_all_set.tv_all ty.ty_tv_world in
      ty_vars_in s0 global_sig.sig_m.tys_belong ty.ty_m /\
      ty_vars_in s0 (sig_world_all.decl_tys ty.ty_sig_world) ty.ty_m }
  let rec ghost tyl_inv (ghost tvw:tv_world) (ghost sw:sig_world)
    (tyl:list ty) : unit
    requires { tyl_worlds tvw sw tyl }
    ensures { tyl_wf global_sig.sig_m (tyl_m tyl) }
    ensures { let s0 = tv_all_set.tv_all tvw in
      tyl_vars_in s0 global_sig.sig_m.tys_belong (tyl_m tyl) /\
      tyl_vars_in s0 (sig_world_all.decl_tys sw) (tyl_m tyl) }
    variant { tyl }
  = match tyl with Cons x q -> ty_inv x;tyl_inv tvw sw q | _ -> () end
  (* Extracted as identity... *)
  val ty_change_world (ghost sw:sig_world) (ty:ty) : ty
    requires { ty_vars_in all (sig_world_all.decl_tys sw) ty.ty_m }
    ensures { result.ty_tv_world = ty.ty_tv_world }
    ensures { result.ty_sig_world = sw }
    ensures { result.ty_m = ty.ty_m }
  val tyl_change_world (ghost tvw:tv_world) (ghost sw1 sw2:sig_world)
    (tyl:list ty) : list ty
    requires { tyl_vars_in all (sig_world_all.decl_tys sw2) (tyl_m tyl) }
    requires { tyl_worlds tvw sw1 tyl }
    ensures { tyl_worlds tvw sw2 result }
    ensures { tyl_m result = tyl_m tyl }
  
  val ts_equal (u v:tysymbol) : bool
    ensures { result -> u = v }
    ensures { u.ts_m = v.ts_m -> result }
  val ts_arity (u:tysymbol) : int
    ensures { result = u.ts_arity = global_sig.sig_m.tys_arity u.ts_m }
  val create_tysymbol (p:preid) (ar:int) : tysymbol
    writes { global_sig }
    ensures { not (old global_sig).sig_m.tys_belong result.ts_m }
    ensures { ts_arity result = ar = global_sig.sig_m.tys_arity result.ts_m }
    (* Preservation postcondition. We could ensure a lot more such
       postconditions, but from the programmer perspective there is only
       one kind of writes which can reduce possibilities: constructor
       addition. Hence for simplicity it is the only things ensured to be
       preserved, though of course no other symbol should be added. *)
    ensures { (old global_sig).sig_m.ls_constr = global_sig.sig_m.ls_constr }
  
  val ty_var (tyv:tvsymbol) : ty
    ensures { result.ty_m = D.TyVar tyv.tv_m }
    ensures { result.ty_tv_world = tyv.tv_world }
  val ty_app (ghost tvw:tv_world) (ghost sw:sig_world)
    (tys:tysymbol) (tyl:list ty) : ty
    requires { tyl_worlds tvw sw tyl }
    ensures { ty_m result = D.TyApp tys.ts_m tyl.tyl_m }
    ensures { result.ty_tv_world = tvw }
    ensures { result.ty_sig_world = sw }
  val ty_case (ty:ty) : ty_node
    returns { Tyvar tv -> ty.ty_m = D.TyVar tv.tv_m /\
        tv.tv_world = ty.ty_tv_world
      | Tyapp tys tyl -> ty.ty_m = D.TyApp tys.ts_m tyl.tyl_m /\
        tyl_worlds ty.ty_tv_world ty.ty_sig_world tyl }
  
  predicate tyo_worlds (tvw:tv_world) (sw:sig_world) (ty:option ty) =
    match ty with
    | None -> true
    | Some ty -> ty.ty_tv_world = tvw /\ ty.ty_sig_world = sw
    end
  function tyo_m (ty:option ty) : D.ty = match ty with
    | None -> ty_prop
    | Some ty -> ty.ty_m
    end
  
  (*
  
  (* TODO: Replace the functional arguments in substitution, using
     some kind of maps abstraction.
     Though relatively easy to specify as itself, requires backup from
     such specified implementation of maps, which is not written yet. *)
  
  val ty_inst (ghost tvg:tvgroup) (f:tvsymbol -> ty) (ty:ty) : ty
    requires { forall x. ty_var_g x = ty_g ty -> ty_g (f x) = tvg }
    ensures { let f0 = compose ty_m (compose f (get_tvs (ty_g ty))) in
      ty_g result = tvg /\
      ty_m result = ty_subst f0 identity (ty_m ty) /\
      ty_wf env.sig_m (ty_m result) }
  
  (* TODO: type matching...  *)
  
  (* TODO: add other various built-in type symbols. *)
  *)
end

module Term
  
  use import logic_syntax.Defs as D
  use import logic_syntax.VarsIn
  use import logic_syntax.Substs
  use import logic_syntax.FreeVars
  use import support.HO
  use import support.Finite
  use import support.Bind
  use import support.Choice
  use import ref.Ref
  use import list.List
  use import list.Nth
  use import list.Length
  use import logic_typing.Env as E
  use import option.Option
  use import int.Int
  use import Ident
  use import Ty
  
  (* First, logical symbols. *)
  
  type lsymbol model {
    ls_m : D.lsymbol;
    ls_constr : int;
    ls_world : tv_world;
    ls_ty_arity : int;
    ls_args : list D.ty;
    ls_ret : D.ty;
  }
  
  predicate ls_constant D.lsymbol
  
  type const model { cst_m : D.lsymbol }
  
  val ls_name lsymbol : ident
  val ls_args (ghost sw:sig_world) (ls:lsymbol) : list ty
    requires { tyl_vars_in all (sig_world_all.decl_tys sw)
      (global_sig.sig_m.E.ls_args ls.ls_m) }
    ensures { tyl_m result = ls.ls_args = global_sig.sig_m.E.ls_args ls.ls_m }
    ensures { tyl_worlds ls.ls_world sw result }
  val ls_value (ghost sw:sig_world) (ls:lsymbol) : option ty
    requires { ty_vars_in all (sig_world_all.decl_tys sw)
      (global_sig.sig_m.E.ls_ret ls.ls_m) }
    ensures { tyo_m result = ls.ls_ret = global_sig.sig_m.E.ls_ret ls.ls_m }
    ensures { tyo_worlds ls.ls_world sw result }
  val ghost ls_ty_arity (ls:lsymbol) : int
    ensures { result = ls.ls_ty_arity = global_sig.sig_m.E.ls_ty_arity ls.ls_m }
  val ghost ls_world (ls:lsymbol) : tv_world
    ensures { result = ls.ls_world }
  (* ls_constr is a complicated field: if it is > 0, then the lsymbol
     is a constructor, and the cardinal of constructors in the same type
     being ls_constr is equivalent to the type being complete for this
     decomposition. *)
  val ls_constr (ls:lsymbol) : int
    ensures { result >= 0 }
    ensures { result = ls.ls_constr }
    ensures { result <> 0 -> let sig = global_sig.sig_m in
      sig.E.ls_constr ls.ls_m /\ match sig.E.ls_ret ls.ls_m with
        | D.TyVar _ -> false
        | D.TyApp tys _ -> result = global_sig.tsc_n tys end }
  (* Recover the lsymbol invariant. *)
  val ghost ls_inv (ls:lsymbol) : unit
    ensures { not ls_constant ls.ls_m /\ let sig = global_sig.sig_m in
      sig.ls_belong ls.ls_m /\ ls.ls_ty_arity = sig.E.ls_ty_arity ls.ls_m /\
      ls.ls_ret = sig.E.ls_ret ls.ls_m /\ ls.ls_args = sig.E.ls_args ls.ls_m /\
      ls.ls_constr >= 0 /\ (ls.ls_constr <> 0 <-> sig.E.ls_constr ls.ls_m) /\
      (ls.ls_constr <> 0 -> match sig.E.ls_ret ls.ls_m with
        | D.TyVar _ -> false
        | D.TyApp tys _ -> ls.ls_constr = global_sig.tsc_n tys end) }
  val ghost cst_inv (cst:const) : unit
    ensures { ls_constant cst.cst_m /\ let sig = global_sig.sig_m in
      sig.ls_belong cst.cst_m /\ sig.E.ls_ty_arity cst.cst_m = 0 /\
      sig.E.ls_args cst.cst_m = Nil /\ not sig.E.ls_constr cst.cst_m }
  val ls_equal (a b:lsymbol) : bool
    ensures { result -> a = b }
    ensures { ls_m a = ls_m b -> result }
  (* NOTE: Such spec does not permit on-demand creation
     pattern (like the one which can be found in Why3 internal cloning code).
     However, it is compatible with an extension in which symbols
     can be first virtually added to the environment and then realized
     (only once). *)
  (* TODO: requires that all world variables do occur somewhere in the
     symbol type. *)
  val create_lsymbol (ghost tvw:tv_world) (ghost sw:sig_world) (ghost ty_ar:int)
    (constr:int) (p:preid) (tyl:list ty) (vl:option ty) : lsymbol
    writes { global_sig }
    requires { tv_closed_world tvw }
    requires { tv_world_set tvw = range 0 ty_ar }
    requires { tyo_worlds tvw sw vl /\ tyl_worlds tvw sw tyl }
    requires { constr >= 0 }
    requires { constr <> 0 -> match tyo_m vl with
      | D.TyApp tys _ -> tys_alg global_sig.sig_m tys ->
        constr = global_sig.tsc_n tys /\
        not global_sig.sig_m.tys_constr_complete tys
      | _ -> false
      end }
    ensures { not (old global_sig).sig_m.ls_belong result.ls_m }
    ensures { result.ls_ty_arity = ty_ar }
    ensures { result.ls_constr = constr }
    ensures { result.ls_args = tyl_m tyl }
    ensures { result.ls_ret = tyo_m vl }
    ensures { result.ls_world = tvw }
    ensures { constr = 0 ->
      global_sig.sig_m.E.ls_constr = (old global_sig).sig_m.E.ls_constr }
    ensures { constr > 0 -> global_sig.sig_m.E.ls_constr =
      update (old global_sig).sig_m.E.ls_constr result.ls_m true }
  
  (* TODO: MISSING: equivalent of ls_ty_freevars.
     (which yield the set of type variables actually bound by the lsymbol
     world)
   *)
  
  
  
  
  (* Variable symbols. *)
  type vname
  type vsymbol model {
    v_m : vname;
    v_tv_world : tv_world;
    v_sig_world : sig_world;
    v_ty : D.ty;
  }
  function vl_ty (vl:list vsymbol) : list D.ty = match vl with
    | Nil -> Nil
    | Cons x q -> Cons x.v_ty (vl_ty q)
    end
  
  let rec lemma vl_ty_len_nth (vl:list vsymbol) : unit
    ensures { length vl = length (vl_ty vl) }
    ensures { forall n. match nth n vl with
      | None -> nth n (vl_ty vl) = None
      | Some u -> match nth n (vl_ty vl) with
        | None -> false
        | Some v -> v = u.v_ty
        end
      end }
    variant { vl }
  = match vl with
    | Cons _ q -> vl_ty_len_nth q
    | _ -> ()
    end
  
  predicate vl_worlds (tvw:tv_world) (sw:sig_world) (vl:list vsymbol) =
    match vl with
    | Nil -> true
    | Cons x q -> x.v_tv_world = tvw /\ x.v_sig_world = sw /\
      vl_worlds tvw sw q
    end
  
  val vs_equal (a b:vsymbol) : bool
    requires { a.v_tv_world = b.v_tv_world /\ a.v_sig_world = b.v_sig_world }
    ensures { a.v_m = b.v_m -> result }
    ensures { result -> a = b }
  
  (* Term environment: bidirectional mapping between program variable symbols
     and logical variable symbols, + current worlds. *)
  type t_env 'tv model {
    e_ldom : 'tv -> bool;
    e_pdom : vname -> bool;
    e_ltp : 'tv -> vname;
    e_ptl : vname -> 'tv;
    e_tv_world : tv_world;
    e_sig_world : sig_world;
  }
  
  (* Invariant on environments: the bidirectional mapping is indeed a
     bijection. *)
  val ghost t_env_inv (e:t_env 'tv) : unit
    ensures { forall x. e.e_ldom x -> e.e_pdom (e.e_ltp x) }
    ensures { forall x. e.e_pdom x -> e.e_ldom (e.e_ptl x) }
    ensures { forall x. e.e_ldom x -> e.e_ptl (e.e_ltp x) = x }
    ensures { forall x. e.e_pdom x -> e.e_ltp (e.e_ptl x) = x }
  
  (* Crucial for binding: notion of fusion between old and
     extending environment. *)
  predicate fused (e1:t_env 'old) (e2:t_env 'new) (e3:t_env (bind 'old 'new)) =
    e3.e_tv_world = e1.e_tv_world = e2.e_tv_world /\
    e3.e_sig_world = e1.e_sig_world = e2.e_sig_world /\
    e3.e_ldom = bfold e1.e_ldom e2.e_ldom /\
    e3.e_ltp = bfold e1.e_ltp e2.e_ltp /\
    (forall x. e1.e_pdom x -> e3.e_ptl x = Old (e1.e_ptl x)) /\
    (forall x. e2.e_pdom x -> e3.e_ptl x = Fresh (e2.e_ptl x)) /\
    (forall x. e3.e_pdom x <-> e1.e_pdom x \/ e2.e_pdom x)
  
  type term 'tv model {
    t_env : t_env 'tv;
    t_ty : D.ty;
    t_m : D.term 'tv;
  }
  
  function tl_m (tl:list (term 'tv)) : list (D.term 'tv) = match tl with
    | Nil -> Nil
    | Cons x q -> Cons (t_m x) (tl_m q)
    end
  function tl_ty (tl:list (term 'tv)) : list D.ty = match tl with
    | Nil -> Nil
    | Cons x q -> Cons (t_ty x) (tl_ty q)
    end
  predicate tl_env (e:t_env 'tv) (tl:list (term 'tv)) = match tl with
    | Nil -> true
    | Cons x q -> x.t_env = e /\ tl_env e q
    end
  (* For triggers. *)
  type trigger 'tv = list (list (term (bind 'tv int)))
  predicate tll_env (e:t_env (bind 'tv int)) (tr:trigger 'tv) = match tr with
    | Nil -> true
    | Cons x q -> tl_env e x /\ tll_env e q
    end
  
  type quant = Tforall | Texists
  
  type binop = Tand | Tor | Timplies | Tiff
  
  type term_bound 'tv model {
    tb_env : t_env 'tv;
    tb_bty : D.ty;
    tb_m : D.term (bind 'tv unit);
  }
  
  predicate bound_env (x:vname) (e:t_env unit) =
    e.e_ldom = all /\
    (forall y. e.e_pdom y <-> x = y) /\
    e.e_ltp () = x /\ e.e_ptl x = ()
  
  type term_branch 'tv model {
    tbr_env : t_env 'tv;
    tbr_bty : D.ty;
    tbr_m : D.branch 'tv;
  }
  
  predicate branch_env (pat:D.pattern) (e:t_env pat_var) =
    e.e_ldom = pat_pv_free_var pat
  
  type term_quant 'tv model {
    tq_env : t_env 'tv;
    tq_qty : list D.ty;
    tq_m : D.term (bind 'tv int);
  }
  
  predicate quant_env (l:list D.ty) (e:t_env int) =
    e.e_ldom = range 0 (length l)
  
  predicate brl_env (e:t_env 'tv) (brl:list (term_branch 'tv)) = match brl with
    | Nil -> true
    | Cons x q -> x.tbr_env = e /\ brl_env e q
    end
  function brl_m (brl:list (term_branch 'tv)) : list (D.branch 'tv) =
    match brl with
    | Nil -> Nil
    | Cons x q -> Cons x.tbr_m q.brl_m
    end
  
  type term_node 'tv =
    | Tvar vsymbol
    | Tconst const
    | Tapp lsymbol (ghost list D.ty) (list (term 'tv))
    | Tif (term 'tv) (term 'tv) (term 'tv)
    | Tlet (term 'tv) (term_bound 'tv)
    | Tcase (term 'tv) (list (term_branch 'tv))
    | Teps (term_bound 'tv)
    | Tquant quant (term_quant 'tv)
    | Tbinop binop (term 'tv) (term 'tv)
    | Tnot (term 'tv)
    | Ttrue
    | Tfalse
  
  val t_ty (t:term 'tv) : ty
    ensures { result.ty_tv_world = t.t_env.e_tv_world }
    ensures { result.ty_sig_world = t.t_env.e_sig_world }
    ensures { result.ty_m = t.t_ty }
  
  (* Case analysis on terms. *)
  val t_case (t:term 'tv) : term_node 'tv
    returns {
      | Tvar v -> t.t_m = D.TVar (t.t_env.e_ptl v.v_m) /\
        t.t_env.e_pdom v.v_m
      | Tconst cst -> t.t_m = D.TApp cst.cst_m Nil Nil
      | Tapp f tyl tl -> tl_env t.t_env tl /\ t.t_m = D.TApp f.ls_m tyl tl.tl_m
      | Tif b th el -> b.t_env = th.t_env = el.t_env = t.t_env /\
        t.t_m = D.TIf b.t_m th.t_m el.t_m
      | Tlet u v -> u.t_env = v.tb_env = t.t_env /\
        v.tb_bty = u.t_ty /\ t.t_m = D.TLet u.t_m v.tb_m
      | Tcase u brl -> u.t_env = t.t_env /\ brl_env t.t_env brl /\
        t.t_m = D.TCase u.t_m brl.brl_m
      | Teps u -> u.tb_env = t.t_env /\ t.t_m = D.TEps u.tb_bty u.tb_m
      | Tquant q tq -> tq.tq_env = t.t_env /\ match q with
        | Tforall -> t.t_m = D.TForall tq.tq_qty tq.tq_m
        | Texists -> t.t_m = D.TExists tq.tq_qty tq.tq_m
        end
      | Tbinop bp a b -> a.t_env = b.t_env = t.t_env /\ match bp with
        | Tand -> t.t_m = D.TAnd a.t_m b.t_m
        | Tor -> t.t_m = D.TOr a.t_m b.t_m
        | Timplies -> t.t_m = D.TImplies a.t_m b.t_m
        | Tiff -> t.t_m = D.TIff a.t_m b.t_m
        end
      | Tnot u -> u.t_env = t.t_env /\ t.t_m = D.TNot u.t_m
      | Ttrue -> t.t_m = D.TTrue
      | Tfalse -> t.t_m = D.TFalse
    }
  
  val t_close_bound (ghost e0:t_env 'tv) (ghost e1:t_env unit)
                    (v:vsymbol) (t:term (bind 'tv unit)) : term_bound 'tv
    requires { t.t_env.e_tv_world = v.v_tv_world }
    requires { t.t_env.e_sig_world = v.v_sig_world }
    requires { fused e0 e1 t.t_env }
    requires { bound_env v.v_m e1 }
    ensures { result.tb_env = e0 }
    ensures { result.tb_bty = v.v_ty }
    ensures { result.tb_m = t.t_m }
  
  (*val t_close_branch (ghost e0:t_env 'tv) (ghost e1:t_env pat_var)
                     (pat:pattern) *)
  
  (* Note: simple open/close impose preservation of variable order.
     One will have to use a semantic helper in order to shamble variable
     order.
     Note: presence of triggers. Those terms do not have any semantic,
     hence are not present as such in the term modelisation. However,
     they must live in a sane environment as well, with is checked
     via environment. *)
  val t_close_quant (ghost e0:t_env 'tv) (ghost e1:t_env int)
                    (vsl:list vsymbol) (tr:trigger 'tv)
                    (t:term (bind 'tv int)) : term_quant 'tv
    requires { vl_worlds t.t_env.e_tv_world t.t_env.e_sig_world vsl }
    requires { fused e0 e1 t.t_env }
    requires { forall n. match nth n vsl with
      | None -> true
      | Some u -> u.v_m = e1.e_ltp n
      end }
    requires { quant_env (vl_ty vsl) e1 }
    requires { tll_env t.t_env tr }
    ensures { result.tq_env = e0 }
    ensures { result.tq_qty = vl_ty vsl }
    ensures { result.tq_m = t.t_m }
  
  val t_open_bound (tb:term_bound 'tv)
    (ghost r:ref (t_env unit)) : (vsymbol,term (bind 'tv unit))
    returns { (vs,t) -> let e1 = !r in
      fused tb.tb_env e1 t.t_env /\ bound_env vs.v_m e1 /\
      t.t_m = tb.tb_m /\ vs.v_tv_world = tb.tb_env.e_tv_world /\
      vs.v_sig_world = tb.tb_env.e_sig_world /\ vs.v_ty = tb.tb_bty }
  
  (* val t_open_branch ... *)
  
  val t_open_quant (tq:term_quant 'tv)
    (ghost r:ref (t_env int)) : (list vsymbol,trigger 'tv,term (bind 'tv int))
    returns { (vsl,tr,t) -> let e1 = !r in
      fused tq.tq_env e1 t.t_env /\ quant_env tq.tq_qty e1 /\
      tll_env t.t_env tr /\ t.t_m = tq.tq_m /\ vl_ty vsl = tq.tq_qty /\
      vl_worlds tq.tq_env.e_tv_world tq.tq_env.e_sig_world vsl }
  
end



