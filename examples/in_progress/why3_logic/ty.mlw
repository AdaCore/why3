
module Tv
  
  use import support.HO
  use import ident.String
  use import ident.Ident
  use import ident.Label
  use import list.List
  use import option.Option
  
  (* Toplevel declaration: ident class of type variables. *)
  constant tv_id_class_name : ident_name
  val ghost tv_id_class () : id_class
    ensures { result.id_class_name = tv_id_class_name }
  
  (* Contexts for type variables. Represents the type variables allowed at
     a given location and the correspondance with their models.
     TODO: implements a type for general variable contexts, which is
     basically a bijection between two domains on different types:
     ident_name & int for type variable context,
     ident_name & 'a for term variable context. *)
  type tv_context
  (*function ctv_m tv_context : context *)
  function tv_dom tv_context : ident_name -> bool
  function tv_fun tv_context : ident_name -> int
  function tv_rfun tv_context : int -> ident_name
  axiom tv_context_inv : forall ctv id.
    ctv.tv_dom id -> ctv.tv_rfun (ctv.tv_fun id) = id
  val ghost tv_bounds (ctv:tv_context) : unit
    ensures { subset ctv.tv_dom ids.ids }
  val ghost tv_make_context (dm:ident_name -> bool)
    (fn:ident_name -> int) (rfn:int -> ident_name) : tv_context
    requires { forall x. dm x -> rfn (fn x) = x }
    ensures { result.tv_dom = dm }
    ensures { result.tv_fun = fn }
    ensures { result.tv_rfun = rfn }
  
  (* Context injection in another. *)
  predicate tv_ctx_inj (tv1:tv_context) (f:int -> int) (tv2:tv_context) =
    forall i. tv1.tv_dom i -> tv2.tv_dom i /\ tv2.tv_fun i = f (tv1.tv_fun i)
  
  type tvsymbol
  function tv_name tvsymbol : ident
  function tv_idn (vty:tvsymbol) : ident_name = vty.tv_name.id_name
  axiom tv_inv : forall x. exists y z.
    x.tv_name.id_class = Cons y z /\ y.id_class_name = tv_id_class_name
    
  
  val tv_name (vty:tvsymbol) : ident
    ensures { result = vty.tv_name }
  
  val tv_equal (vty1 vty2:tvsymbol) : bool
    ensures { vty1.tv_name.id_name = vty2.tv_name.id_name -> result }
    ensures { result -> vty1 = vty2 }
  
  val create_tv_symbol (ghost idc:list id_class) (p:preid) : tvsymbol
    writes { ids }
    ensures { result.tv_name.id_string = p.pre_name }
    ensures { result.tv_name.id_label = p.pre_label.Mlab.domain }
    ensures { result.tv_name.id_loc = p.pre_loc }
    ensures { exists y. result.tv_name.id_class = Cons y idc /\
                        y.id_class_name = tv_id_class_name }
    ensures { not (old ids).ids result.tv_name.id_name }
    ensures { subset (old ids).ids ids.ids }
    ensures { ids.ids result.tv_name.id_name }
  
  val tv_of_string (s:string) : tvsymbol
    writes { ids }
    ensures { result.tv_name.id_string = s }
    ensures { result.tv_name.id_label = none }
    ensures { result.tv_name.id_loc = None }
    ensures { exists y. result.tv_name.id_class = Cons y Nil /\
                        y.id_class_name = tv_id_class_name }
    ensures { subset (old ids).ids ids.ids }
    ensures { ids.ids result.tv_name.id_name }
  
end

module Ty
  
  use import logic_syntax.Defs as D
  use import logic_syntax.Maps
  use import list.List
  use import list.Length
  use import support.HO
  use import support.HOList
  use import ident.Ident
  use import signature.Sig
  use import Tv
  
  
  constant ts_id_class_name : ident_name
  axiom ts_id_class_name_distinct : ts_id_class_name <> tv_id_class_name
  val ghost ts_id_class () : id_class
    ensures { result.id_class_name = ts_id_class_name }
  
  (* Type symbol may be defined or abstract (expanded alias). *)
  type tysymbol
  function ts_name tysymbol : ident
  function ts_arity tysymbol : int
  function ts_abs tysymbol : bool
  function ts_m tysymbol : D.ty_symbol
  function ts_def tysymbol : D.ty
  axiom tv_inv : forall x. exists y z.
    x.ts_name.id_class = Cons y z /\ y.id_class_name = ts_id_class_name
  
  function ts_idn (tys:tysymbol) : ident_name = tys.ts_name.id_name
  
  val ts_name (tys:tysymbol) : ident
    ensures { result = tys.ts_name }
  
  (* Correspondance from type symbols to identifiers.
     FIXME ? using a logical function imply that all identifiers
     can be pulled back to a type symbols, e.g that the cardinality
     of the ident_name type is lower than the cardinality of the
     type symbol type, which is a priori not evident.
     (otherwise, type symbol generation simply cannot be implemented)
     The other technique is to use a growing map, but this is much
     more convoluted. *)
  function tys_idn (tys:D.ty_symbol) : ident_name
  
  (* TODO: type symbol generation: function from global signature ty_symbols to
     identifiers & reciprocal. *)
  
  (* Context mechanism: a type has sense only in a context. *)
  type ty
  
  (* Type context: allowed type variables/symbols and
     variable name -> integer correspondance.
     From the point of view of types, corresponds to a domain and
     an interpretation. *)
  type ty_ctx model {
    cty_tv : tv_context;
    cty_sym : sym_context;
    cty_d : ty -> bool;
    cty_m : ty -> D.ty;
  }
  
  type ty_node =
    | Tyvar tvsymbol
    | Tyapp tysymbol (list ty)
  
  val ty_var (ghost cty:ty_ctx) (vty:tvsymbol) : ty
    requires { cty.cty_tv.tv_dom vty.tv_idn }
    ensures { cty.cty_m result = D.TyVar (cty.cty_tv.tv_fun vty.tv_idn) }
    ensures { cty.cty_d result }
  
  val ty_app (ghost cty:ty_ctx) (tys:tysymbol) (tyl:list ty) : ty
    requires { for_all cty.cty_d tyl /\ length tyl = tys.ts_arity }
    requires { if tys.ts_abs
      then cty.cty_sym.d_tys tys.ts_m
      else false (* TODO: enable application to defined type symbols. *) }
    ensures { cty.cty_d result }
    ensures { if tys.ts_abs
      then cty.cty_m result = D.TyApp tys.ts_m (map cty.cty_m tyl)
      else false (* TODO. *) }
  
  (* context creation. *)
  val ghost make_ty_ctx (ctv:tv_context) (cts:sym_context) : ty_ctx
    ensures { result.cty_tv = ctv /\ result.cty_sym = cts }
  
  (* Context injection in another and effect on model. *)
  val ghost ty_ctx_inj (cty1:ty_ctx) (f:int -> int) (cty2:ty_ctx) : ty_ctx
    requires { tv_ctx_inj cty1.cty_tv f cty2.cty_tv }
    requires { sub_sym_context cty1.cty_sym cty2.cty_sym }
    ensures { subset cty1.cty_d cty2.cty_d }
    ensures { forall ty. cty1.cty_d ty ->
      cty2.cty_m ty = ty_map f id (cty1.cty_m ty) }
  
  val ghost ty_node (ghost cty:ty_ctx) (ty:ty) : ty_node
    requires { cty.cty_d ty }
    returns { Tyvar vty -> cty.cty_m ty = D.TyVar (cty.cty_tv.tv_fun vty.tv_idn)
      | Tyapp tys tyl -> tys.ts_abs /\
        cty.cty_m ty = D.TyApp tys.ts_m (map cty.cty_m tyl) /\
        for_all cty.cty_d tyl }
  
end

