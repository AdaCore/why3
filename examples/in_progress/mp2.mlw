module M


  use import map.Map
  use import mach.int.Unsigned
  use import mach.int.Int32
  use import mach.int.UInt32
  use import array.Array
  use import int.Int
  predicate in_us_bounds (n:int) = 0 <= n <= max_uint32
  predicate in_bounds (n:int) = min_int32 <= n <= max_int32
  use import ref.Ref

  type ptr 'a = {
    data : ref (array 'a) ;
    offset : int ;
  }
  (*invariant { in_us_bounds data.length }*)
  (* it is not required the offset is in 0..elts.length *)

  function plength (p:ptr 'a) : int
  = p.data.contents.length

  function pelts (p:ptr 'a) : int -> 'a
  = p.data.contents.elts

  val p2i (n:int32):int
    ensures { result = Int32.to_int n }

  val predicate is_null (p:ptr 'a) : bool
    ensures { result <-> plength p = 0 }

  val null () : ptr 'a
    ensures { plength result = 0 }

  let incr (p:ptr 'a) (ofs:int32) : ptr 'a
    ensures { result.offset = p.offset + Int32.to_int ofs }
    ensures { result.data = p.data }
   =
    { data = p.data; offset = p.offset + p2i ofs }

  val get (p:ptr 'a) : 'a
    requires { 0 <= p.offset < plength p }
    ensures { result = !(p.data)[p.offset] }

  let get_ofs (p:ptr 'a) (ofs:int32) : 'a
    requires { 0 <= p.offset + Int32.to_int ofs < plength p }
    ensures { result = !(p.data)[p.offset + Int32.to_int ofs] }
  = get (incr p ofs)

  val set (p:ptr 'a) (v:'a) : unit
    requires { 0 <= p.offset < plength p }
    ensures { pelts p = Map.set (pelts (old p)) p.offset v }
    writes { p.data.contents.elts }

  let set_ofs (p:ptr 'a) (ofs:int32) (v:'a) : unit
    requires { 0 <= p.offset + Int32.to_int ofs < plength p }
    ensures { pelts p = Map.set (pelts (old p))
              (p.offset + Int32.to_int ofs) v }
    writes { p.data.contents.elts }
 =
    set (incr p ofs) v

  predicate valid_ptr_shift (p:ptr 'a) (i:int) =
    0 <= p.offset + i < plength p

  predicate valid_ptr_itv (p:ptr 'a) (sz:int) =
    in_bounds sz /\ 0 <= sz /\ 0 <= p.offset /\ p.offset + sz <= plength p

  let lemma valid_itv_to_shift (p:ptr 'a) (sz:int)
    requires { valid_ptr_itv p sz }
    ensures { forall i. 0 <= i < sz -> valid_ptr_shift p i }
  = ()

  val malloc (sz:uint32) : ptr 'a
    ensures { plength result = UInt32.to_int sz \/ plength result = 0 }
    ensures { result.offset = 0 }

 (* How to specify that the data array is reset by free/realloc ?*)
(*  let free (p:ptr 'a) : unit
    requires { p.offset = 0 }
    writes { p }
    ensures { p.data.length = 0 }
  =  if is_null p then ()
     else begin
     let c = incr p (Int32.of_int 0) in
     p.data <- Array.make 0 (get p);
     check { c.data.length = 0 }
     end *)
  val free (p:ptr 'a) : unit
    requires { p.offset = 0 }
    writes { p.data }
    ensures { plength p = 0 }
 (* = if is_null p then ()
    else begin
   (* let c = incr p (Int32.of_int 0) in*)
    p.data := Array.make 0 (get p);
    (*check { plength c = 0 }*)
    end
  *)

  val realloc (p:ptr 'a) (sz:int32) : ptr 'a
    requires { Int32.to_int sz > 0 } (* for simplicity, though 0 is legal in C *)
    requires { p.offset = 0 }
    writes { p.data }
    ensures { plength result = Int32.to_int sz \/ plength result = 0 }
    ensures { plength result = Int32.to_int sz -> plength p = 0 }
    ensures { plength result = Int32.to_int sz ->
                forall i:int. 0 <= i < plength (old p) /\ i < Int32.to_int sz ->
                  !(result.data)[i] = !((old p).data)[i] }
    ensures { plength result <> Int32.to_int sz -> p = old p }


end
(*
module Limb

  use import int.Int
  clone export mach.int.UInt32

  type limb = uint32

  val add_carry (x y:limb) : limb
    ensures { 0 <= to_int result <= 1 }

  val add_res (x y:limb) : limb
    ensures { result + add_carry x y = add_with_carry x y zero_unsigned }

end *)

module N

 (**)
  use import array.Array
  use import mach.int.Int32
  use import M
  use import mach.int.UInt32 as Limb
  use import int.Int
  use import int.Power
  use import map.Map
  use import ref.Ref
  type limb = uint32

  lemma limb_max_bound: 1 <= max_uint32

  constant radix : int = max_uint32 + 1

  function l2i (x:limb) : int = UInt32.to_int x

  function p2i (i:int32) : int = Int32.to_int i

  type t = ptr limb

  (** {2 Integer value of a natural number} *)

  (** [value_sub x n m] denotes the integer represented by
     the digits x[n..m-1] with lsb at index n *)
  let rec ghost function value_sub (x:map int limb) (n:int) (m:int) : int
     variant {m - n}
   =
     if n < m then
       l2i x[n] + radix * value_sub x (n+1) m
       else 0

  function value (x:t) : int =
     value_sub (pelts x) 0 (plength x)

  function value_sub_shift (x:t) (sz:int) : int =
     value_sub (pelts x) x.offset (x.offset + sz)

  use map.MapEq
  use map.Const

  predicate map_eq_sub_shift (x y:map int 'a) (xi yi sz:int) =
    forall i. 0 <= i < sz -> x[xi+i] = y[yi+i]

  let lemma map_eq_shift (x y:map int 'a) (xi yi sz k:int)
    requires { map_eq_sub_shift x y xi yi sz }
    requires { 0 <= k < sz }
    ensures { x[xi+k] = y[yi+k] }
  = ()

  let rec lemma map_eq_shift_zero (x y: map int 'a) (n m: int)
    requires { map_eq_sub_shift x y n n (m-n) }
    variant { m - n }
    ensures { MapEq.map_eq_sub x y n m }
  =
    if n < m then
    begin
      assert { forall i. 0 <= i < m-n -> x[n+i] = y[n+i] };
      assert { forall i. n <= i < m ->
                 let j = i - n in 0 <= j < m-n ->
                     x[n+j] = y[n+j] -> x[i] = y[i]};
      map_eq_shift_zero x y (n+1) m;
    end
    else assert { 1+2=3 }

  let rec lemma value_sub_frame (x y:map int limb) (n m:int)
    requires { MapEq.map_eq_sub x y n m }
    variant  { m - n }
    ensures  { value_sub x n m = value_sub y n m }
  =
    if n < m then value_sub_frame x y (n+1) m else ()

  let rec lemma value_sub_frame_shift (x y:map int limb) (xi yi sz:int)
    requires { map_eq_sub_shift x y xi yi sz }
    variant { sz }
    ensures { value_sub x xi (xi+sz) = value_sub y yi (yi+sz) }
 =
    if sz>0
    then begin
      map_eq_shift x y xi yi sz 0;
      assert { forall i. 0 <= i < sz-1 ->
                 0 <= 1+i < sz ->
                 let j = 1+i in x[xi+j] = y[yi+j] ->
                   x[xi+1+i] = y[yi+1+i]  };
      value_sub_frame_shift x y (xi+1) (yi+1) (sz-1)
      end
    else assert { 1+2 = 3 }

  let rec lemma value_sub_tail (x:map int limb) (n m:int)
    requires { n <= m }
    variant  { m - n }
    ensures  {
      value_sub x n (m+1) =
        value_sub x n m + l2i (Map.get x m) * power radix (m-n) }
  = "vc:sp" if n < m then value_sub_tail x (n+1) m else ()(*assert { 1+2=3 }*)

  let rec lemma value_sub_concat (x:map int limb) (n m l:int)
    requires { n <= m <= l}
    variant  { m - n }
    ensures  {
      value_sub x n l =
        value_sub x n m + value_sub x m l * power radix (m-n) }
  =
  if n < m then
     begin
     assert {n<m};
     value_sub_concat x (n+1) m l
     end
  else ()

  let lemma value_sub_update (x:map int limb) (i n m:int) (v:limb)
    requires { n <= i < m }
    ensures {
      value_sub (Map.set x i v) n m =
      value_sub x n m + power radix (i - n) * (l2i v - l2i (Map.get x i))
    }
  = assert { MapEq.map_eq_sub x (Map.set x i v) n i };
    assert { MapEq.map_eq_sub x (Map.set x i v) (i+1) m };
    value_sub_concat x n i m;
    value_sub_concat (Map.set x i v) n i m

  let rec lemma value_zero (x:map int limb) (n m:int)
    requires { MapEq.map_eq_sub x (Const.const UInt32.zero_unsigned) n m }
    variant  { m - n }
    ensures  { value_sub x n m = 0 }
  = if n < m then value_zero x (n+1) m else ()

  let lemma value_sub_update_no_change (x: map int limb) (i n m: int) (v:limb)
     requires { n <= m }
     requires { i < n \/ m <= i }
     ensures { value_sub x n m = value_sub (Map.set x i v) n m }
  = value_sub_frame x (Map.set x i v) n m

  let lemma value_sub_shift_no_change (x:map int limb) (ofs i sz:int) (v:limb)
     requires { i < 0 \/ sz <= i }
     requires { 0 <= sz }
     ensures { value_sub x ofs (ofs + sz) =
               value_sub (Map.set x (ofs+i) v) ofs (ofs+sz) }
  = value_sub_frame_shift x (Map.set x (ofs+i) v) ofs ofs sz

  (** {2 Comparisons} *)

    let rec lemma value_sub_lower_bound (x:map int limb) (x1 x2:int)
    variant  { x2 - x1 }
    ensures  { 0 <= value_sub x x1 x2 }
  = if x2 <= x1 then () else
      begin
        assert { value_sub x x1 x2 = l2i (Map.get x x1) + radix * value_sub x (x1+1) x2};
        value_sub_lower_bound x (x1+1) x2
      end

  let rec lemma value_sub_upper_bound (x:map int limb) (x1 x2:int)
    requires { x1 <= x2 }
    variant  { x2 - x1 }
    ensures  { value_sub x x1 x2 < power radix (x2 - x1) }
  = if x1 = x2 then () else
      begin
      assert { value_sub x x1 x2 <= value_sub x x1 (x2-1) + power radix (x2-x1-1) * (radix - 1) };
      value_sub_upper_bound x x1 (x2-1)
      end

  let lemma value_sub_lower_bound_tight (x:map int limb) (x1 x2:int)
    requires { x1 < x2 }
    ensures  { power radix (x2-x1-1) *  l2i (Map.get x (x2-1)) <= value_sub x x1 x2 }
  = assert   { value_sub x x1 x2 = value_sub x x1 (x2-1)
               + power radix (x2-x1-1) * l2i (Map.get x (x2-1)) }

  let lemma value_sub_upper_bound_tight (x:map int limb) (x1 x2:int)
    requires { x1 < x2 }
    ensures  { value_sub x x1 x2 < power radix (x2-x1-1) *  (l2i (Map.get x (x2-1)) + 1) }
  = value_sub_upper_bound x x1 (x2-1)

  let lemma prod_compat_strict_r (a b c:int)
    requires { 0 <= a < b }
    requires { 0 < c }
    ensures { c * a < c * b }
  = ()

  exception Break32 int32

  use import ref.Refint

  function compare_int (x y:int) : int =
    if x < y then -1 else if x=y then 0 else 1

  (** [compare_same_size] compares [x[0..sz-1]] and [y[0..sz-1]] as unsigned integers. It corresponds to [GMPN_CMP]. *)
  let compare_same_size (x y:t) (sz:int32) : int32
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    ensures { p2i result = compare_int (value_sub_shift x (p2i sz))
              (value_sub_shift y (p2i sz))
              }
  =
   let i = ref sz in
   let zero = Int32.of_int 0 in
   let uzero = UInt32.of_int 0 in
   let lx = ref uzero in
   let ly = ref uzero in
   let res = ref zero in
   try
     while Int32.(>=) !i (Int32.of_int 1) do
       variant { p2i !i }
       invariant { 0 <= p2i !i <= p2i sz }
       invariant { forall j. p2i !i <= j < p2i sz ->
                   (pelts x)[x.offset+j] = (pelts y)[y.offset+j] }
       assert { forall j. 0 <= j < p2i sz - (p2i !i) ->
                let k = p2i !i+j in
                p2i !i <= k < p2i sz ->
                (pelts x)[x.offset+k] = (pelts y)[y.offset+k] /\
                (pelts x)[p2i !i+x.offset+j] = (pelts y)[p2i !i+y.offset+j] };
       value_sub_frame_shift (pelts x) (pelts y) (p2i !i+x.offset) (p2i !i+y.offset) ((p2i sz) - (p2i !i));
       let ghost k = p2i !i in
       i := Int32.(-) !i (Int32.of_int 1);

       assert { 0 <= p2i !i < p2i sz };
       lx := get_ofs x !i;
       ly := get_ofs y !i;
       if (UInt32.ne !lx !ly)
       then begin
            value_sub_concat (pelts x) x.offset (x.offset+k) (x.offset+ p2i sz);
            value_sub_concat (pelts y) y.offset (y.offset+k) (y.offset+ p2i sz);
            assert { compare_int (value_sub_shift x (p2i sz))
                       (value_sub_shift y (p2i sz))
                   = compare_int (value_sub_shift x k) (value_sub_shift y k) };
            value_sub_tail (pelts x) x.offset (x.offset+k-1);
            value_sub_tail (pelts y) y.offset (y.offset+k-1);
            if UInt32.(>) !lx !ly
            then begin
             value_sub_upper_bound (pelts y) y.offset (y.offset+k-1);
             value_sub_lower_bound (pelts x) x.offset (x.offset+k-1);
             assert { value_sub_shift x k - value_sub_shift y k =
                      (l2i !lx - l2i !ly) * (power radix (k-1))
                    - ((value_sub_shift y (k-1)) - (value_sub_shift x (k-1)))
                       };
             assert { (l2i !lx - l2i !ly) * (power radix (k-1))
                      >= power radix (k-1)
                      > ((value_sub_shift y (k-1)) - (value_sub_shift x (k-1)))
                       };
             res := Int32.of_int 1
            end
            else begin
             assert { l2i !ly > l2i !lx };
             value_sub_upper_bound (pelts x) x.offset (x.offset+k-1);
             value_sub_lower_bound (pelts y) y.offset (y.offset+k-1);
             assert { value_sub_shift y k - value_sub_shift x k =
                    (l2i !ly - l2i !lx) * (power radix (k-1))
                    - ((value_sub_shift x (k-1)) - (value_sub_shift y (k-1)))
                     };
             assert { (l2i !ly - l2i !lx) * (power radix (k-1))
                      >= power radix (k-1)
                      > ((value_sub_shift x (k-1)) - (value_sub_shift y (k-1)))
                     };
            res := Int32.of_int (-1)
            end;
         raise Break32 !res
         end
       else ()
     done;
     value_sub_frame_shift (pelts x) (pelts y) x.offset y.offset (p2i sz);
     zero
   with Break32 r -> r
   end

   (* [is_zero] checks if [x[0..sz-1]] is zero. It corresponds to [mpn_zero_p]. *)
   let is_zero (x:t) (sz:int32) : int32
     requires { valid_ptr_itv x (p2i sz) }
     ensures { 0 <= Int32.to_int result <= 1 }
     ensures { Int32.to_int result = 1 <-> value_sub_shift x (p2i sz) = 0 }
   =
     let i = ref sz in
     let uzero = UInt32.of_int 0 in
     let lx = ref uzero in
     try
       while Int32.(>=) !i (Int32.of_int 1) do
         variant { p2i !i }
         invariant { 0 <= p2i !i <= p2i sz }
         invariant { value_sub (pelts x) (x.offset + p2i !i) (x.offset + p2i sz)=0 }
         let ghost k = p2i !i in
         i := Int32.(-) !i (Int32.of_int 1);
         assert { 0 <= p2i !i < p2i sz };
         lx := get_ofs x !i;
         if (UInt32.ne !lx uzero)
         then begin
           value_sub_concat (pelts x) x.offset (x.offset+k) (x.offset + p2i sz);
           value_sub_lower_bound_tight (pelts x) x.offset (x.offset+k);
           value_sub_lower_bound (pelts x) (x.offset+k) (x.offset + p2i sz);
           raise Break32 (Int32.of_int 0)
         end
         else begin
           assert { 1+2=3 };
         end
       done;
       Int32.of_int 1
     with Break32 r -> r
     end

  (** [zero r sz] sets [(r,sz)] to zero. Corresponds to [mpn_zero]. *)
  let zero (r:t) (sz:int32) : unit
    requires { valid_ptr_itv r (p2i sz) }
    ensures { value_sub_shift r (p2i sz) = 0 }
  =
    let i = ref (Int32.of_int 0) in
    let lzero = Limb.of_int 0 in
    while Int32.(<) !i sz do
      invariant { 0 <= p2i !i <= p2i sz }
      variant { p2i sz - p2i !i }
      invariant { value_sub_shift r (p2i !i) = 0 }
      set_ofs r !i lzero;
      value_sub_tail (pelts r) r.offset (r.offset + p2i !i);
      i := Int32.(+) !i (Int32.of_int 1);
    done

  (** {2 Addition} *)

  exception Break

  (** [add_limb r x y sz] adds to [x] the value of the limb [y],
      writes the result in [r] and returns the carry. [r] and [x]
      have size [sz]. This corresponds to the function [mpn_add_1] *)
  (* r and x must be separated. This is enforced by Why3 regions in typing *)
  let add_limb (r x:t) (y:limb) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    requires { p2i sz > 0 } (* ? GMP does the same for 0 and 1*)
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result =
              value_sub_shift x (p2i sz) + l2i y }
    ensures { 0 <= l2i result <= 1 }
    writes { r.data.contents.elts }
  =
    let limb_zero = UInt32.of_int 0 in
    let c = ref y in
    let lx = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz && UInt32.ne !c limb_zero do
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { p2i !i > 0 -> 0 <= l2i !c <= 1 }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y}
      variant { p2i sz - p2i !i }
      label StartLoop in
      lx := get_ofs x !i;
      let (res, carry) = add_with_carry !lx !c limb_zero in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      let ghost m = power radix k in
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
             = value_sub_shift x (p2i !i) + l2i y
             by
             value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
             = value_sub_shift r k + (power radix k) * l2i res
                               + (power radix (p2i !i)) * l2i !c
             = value_sub_shift r k + (power radix k) * l2i res
                               + (power radix k) * radix * l2i !c
             = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
             = value_sub_shift r k +
               (power radix k) * (l2i !lx + l2i (!c at StartLoop))
             = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                               + (power radix k) * l2i !lx
             = value_sub_shift x k + l2i y + (power radix k) * l2i !lx
             = value_sub_shift x (p2i !i) + l2i y }
    done;
    assert { p2i !i = p2i sz \/ l2i !c = 0 };
    assert { p2i !i < p2i sz -> l2i !c = 0 };
    if Int32.eq !i sz then !c
    else begin
    while Int32.(<) !i sz do
      invariant { l2i !c  = 0 }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y}
      variant { p2i sz - p2i !i }
      lx := get_ofs x !i;
      set_ofs r !i !lx;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y };
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
    done;
    !c
    end


  (** [add_limbs r x y sz] adds [x[0..sz-1]] and [y[0..sz-1]] and writes the result in [r].
      Returns the carry, either [0] or [1]. Corresponds to the function [mpn_add_n]. *)

  let add_limbs (r x y:t) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    ensures { 0 <= l2i result <= 1 }
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result =
            value_sub_shift x (p2i sz) + value_sub_shift y (p2i sz) }
    writes { r.data.contents.elts }
    =
    let limb_zero = UInt32.of_int 0 in
    let lx = ref limb_zero in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) }
      invariant { 0 <= l2i !c <= 1 }
      label StartLoop in
      lx := get_ofs x !i;
      ly := get_ofs y !i;
      let res, carry = add_with_carry !lx !ly !c in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i)
              by
              value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix k) * radix * l2i !c
              = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
              = value_sub_shift r k +
                  (power radix k) * (l2i !lx + l2i !ly + l2i (!c at StartLoop))
              = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + value_sub_shift y k
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + (power radix k) * l2i !lx
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + (value_sub_shift y k + (power radix k) * l2i !ly)
              = value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) }
    done;
    !c

  (** [add r x y sx sy] adds [x] of size [sx] and [y] of size [sy] and writes the result in [r].
      [sx] must be greater than or equal to [sy]. Returns carry, either 0 or 1. Corresponds to
      [mpn_add]. *)
  let add (r x y:t) (sx sy:int32) : limb
    requires { 0 <= p2i sy <= p2i sx }
    requires { valid_ptr_itv x (p2i sx) }
    requires { valid_ptr_itv y (p2i sy) }
    requires { valid_ptr_itv r (p2i sx) }
    ensures { value_sub_shift r (p2i sx) + (power radix (p2i sx)) * l2i result =
              value_sub_shift x (p2i sx) + value_sub_shift y (p2i sy) }
    ensures { 0 <= l2i result <= 1 }
    writes { r.data.contents.elts }
 =
    let limb_zero = UInt32.of_int 0 in
    let lx = ref limb_zero in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sy do
      variant { p2i sy - p2i !i }
      invariant { 0 <= p2i !i <= p2i sy }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) }
      invariant { 0 <= l2i !c <= 1 }
      label StartLoop in
      lx := get_ofs x !i;
      ly := get_ofs y !i;
      let res, carry = add_with_carry !lx !ly !c in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i)
              by
              value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix k) * radix * l2i !c
              = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
              = value_sub_shift r k +
                  (power radix k) * (l2i !lx + l2i !ly + l2i (!c at StartLoop))
              = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + value_sub_shift y k
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + (power radix k) * l2i !lx
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + (value_sub_shift y k + (power radix k) * l2i !ly)
              = value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) };
    done;
    while Int32.(<) !i sx do
      variant { p2i sx - p2i !i }
      invariant { p2i sy <= p2i !i <= p2i sx }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i sy) }
      invariant { 0 <= l2i !c <= 1 }
      label StartLoop2 in
      lx := get_ofs x !i;
      let res, carry = add_with_carry !lx limb_zero !c in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i sy) };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i sy)
              by
              value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix k) * radix * l2i !c
              = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
              = value_sub_shift r k +
                  (power radix k) * (l2i !lx + 0 + l2i (!c at StartLoop2))
              = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop2)
                 + (power radix k) * l2i !lx
              = value_sub_shift x k + value_sub_shift y (p2i sy)
                 + (power radix k) * l2i !lx
              = value_sub_shift x (p2i !i)
                 + value_sub_shift y (p2i sy) }
    done;
    !c

    (** {2 Multiplication} *)

    (** [mul_limb r x y sz] multiplies [x[0..sz-1]] by the limb [y] and
    writes the n least significant limbs in [r], and returns the most
    significant limb. It corresponds to [mpn_mul_1]. *)
  let mul_limb (r x:t) (y:limb) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result
                = value_sub_shift x (p2i sz) * l2i y }
    writes { r.data.contents.elts }
  =
    let limb_zero = UInt32.of_int 0 in
    let lx = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) * l2i y }
      label StartLoop in
      lx := get_ofs x !i;
      let rl, rh = Limb.mul_double !lx y in
      let res, carry = Limb.add_with_carry rl !c limb_zero in
      label BeforeWrite in
      value_sub_shift_no_change (pelts r) r.offset (p2i !i) (p2i !i) res;
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) * l2i y };
      assert { l2i rh < radix - 1
               by
               (l2i !lx * l2i y <= l2i !lx * (radix-1) <= (radix-1)*(radix-1)
                 by
                0 <= l2i !lx <= radix - 1 /\ 0 <= l2i y <= radix -1)
                 /\
               (radix * l2i rh <= l2i !lx * l2i y
                 by
               l2i rl + radix * l2i rh = l2i !lx * l2i y)
               so
               radix * l2i rh <= (radix -1) * (radix -1)
               };
      c := Limb.(+) rh carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
               value_sub_shift x (p2i !i) * l2i y
               by
                 value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
               = value_sub_shift r k + (power radix k) * l2i res
                     + (power radix (p2i !i)) * l2i !c
               = value_sub_shift r k + (power radix k) * l2i res
                     + (power radix k) * radix * l2i !c
               = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
               = value_sub_shift r k + (power radix k) *
                                   (l2i res + radix * (l2i rh + l2i carry))
               = value_sub_shift r k + (power radix k) *
                                   (l2i res + radix * l2i carry + radix * l2i rh)
               = value_sub_shift r k + (power radix k) *
                                   (l2i (!c at StartLoop) + l2i rl + radix*l2i rh)
               = value_sub_shift r k + (power radix k) *
                                   (l2i (!c at StartLoop) + l2i !lx * l2i y)
               = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                                 + (power radix k) * l2i !lx * l2i y
               = value_sub_shift x k * l2i y + (power radix k) * l2i !lx * l2i y
               = (value_sub_shift x k + (power radix k) * l2i !lx) * l2i y
               = value_sub_shift x (p2i !i) * l2i y
               };
    done;
    !c

  (** [addmul_limb r x y sz] multiplies [(x, sz)] by [i], adds the [sz]
      least significant limbs to [(r, sz)] and writes the result in [(r,sz)].
      Returns the most significant limb of the product plus the carry
      of the addition. Corresponds to [mpn_addmul_1].*)

  let addmul_limb (r x:t) (y:limb) (sz:int32):limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result
            = value_sub_shift (old r) (p2i sz)
              + value_sub_shift x (p2i sz) * l2i y }
    writes { r.data.contents.elts }
    ensures { forall j. j < r.offset \/ r.offset + p2i sz <= j ->
              (pelts r)[j] = (pelts (old r))[j] }
  =
    let limb_zero = Limb.of_int 0 in
    let lx = ref limb_zero in
    let lr = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
                 = value_sub_shift (old r) (p2i !i)
                   + value_sub_shift x (p2i !i) * l2i y }
      invariant { forall j. p2i !i <= j < p2i sz ->
                 (pelts (old r)) [r.offset+j] = (pelts r)[r.offset + j]  }
      invariant { forall j. j < r.offset \/ r.offset + p2i sz <= j ->
                 (pelts r)[j] = (pelts (old r))[j] }
      label StartLoop in
      let ghost k = p2i !i in
      lx := get_ofs x !i;
      lr := get_ofs r !i;
      assert { l2i !lr = l2i (pelts (old r))[r.offset+ p2i !i] };
      let rl, rh = Limb.mul_double !lx y in
      let res, carry = Limb.add3 !lr rl !c in
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_update (pelts r) (r.offset + p2i !i) r.offset (r.offset + p2i !i +1) res;
      set_ofs r !i res;
      assert { forall j. (p2i !i + 1) <= j < p2i sz ->
               (pelts (old r))[r.offset+j] = (pelts r)[r.offset+j]
               by
               (pelts r)[r.offset+j] = ((pelts r) at StartLoop)[r.offset+j]
                                  = (pelts (old r))[r.offset+j] };
      assert { value_sub_shift r (p2i !i + 1)
              = value_sub_shift (r at StartLoop) (p2i !i + 1)
                + (power radix (p2i !i)) * (l2i res - l2i !lr) };
      assert { l2i rl + radix * l2i rh <= (radix-1)*(radix-1)
               by
               (l2i !lx * l2i y <= l2i !lx * (radix-1) <= (radix-1)*(radix-1)
                 by
                0 <= l2i !lx <= radix - 1 /\ 0 <= l2i y <= radix -1)
                /\
                l2i rl + radix * l2i rh = l2i !lx * l2i y
                };
      assert { l2i rh < radix - 1
               by
               l2i rl + radix * l2i rh  <= (radix -1) * (radix -1)
               so
               radix * l2i rh <= (radix -1) * (radix -1)
               };
      assert { l2i rh = radix - 2 -> l2i rl <= 1
               by
               l2i rl + radix * l2i rh <= (radix-1)*(radix-1) };
      assert { l2i rh = radix - 2 -> l2i carry <= 1
               by l2i rl <= 1 };
      c := Limb.(+) rh carry;
      i := Int32.(+) !i (Int32.of_int 1);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
                 = value_sub_shift (old r) (p2i !i)
                   + value_sub_shift x (p2i !i) * l2i y
               by
                (value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr)
                   + (power radix (p2i !i)) * l2i !c
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr)
                   + (power radix (p2i !i)) * (l2i rh + l2i carry)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr)
                   + (power radix k) * radix * (l2i rh + l2i carry)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr
                                   + radix * (l2i rh + l2i carry))
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res + radix * l2i carry
                          - l2i !lr + radix * l2i rh)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i rl + l2i !lr + l2i (!c at StartLoop)
                          - l2i !lr + radix * l2i rh)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i rl + radix * l2i rh + l2i (!c at StartLoop))
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i !lx * l2i y + l2i (!c at StartLoop))
                = value_sub_shift (r at StartLoop) k
                    + (power radix k) * l2i !lr
                    + (power radix k) * (l2i !lx * l2i y + l2i (!c at StartLoop))
                = value_sub_shift (r at StartLoop) k
                    + (power radix k) * l2i (!c at StartLoop)
                    + (power radix k) * (l2i !lx * l2i y + l2i !lr)
                = value_sub_shift (old r) k
                    + value_sub_shift x k * l2i y
                    + (power radix k) * (l2i !lx * l2i y + l2i !lr)
                = value_sub_shift (old r) k
                    + (power radix k) * l2i !lr
                    + (value_sub_shift x k + (power radix k)*l2i !lx) * l2i y
                = value_sub_shift (old r) (p2i !i)
                    + (value_sub_shift x k + (power radix k)*l2i !lx) * l2i y
                = value_sub_shift (old r) (p2i !i)
                    + value_sub_shift x (p2i !i) * l2i y
                    by
                  value_sub_shift (old r) (p2i !i) = value_sub_shift (old r) k
                     + (power radix k) * l2i !lr
                     )
                    };
    done;
    !c

  (** [mul_limbs r x y sz] multiplies [(x, sz)] and [(y, sz)] and
  writes the result to [(r, 2*sz)]. [r] must not overlap with either
  [x] or [y]. Corresponds to [mpn_mul_n].  *)
  let mul_limbs (r x y:t) (sz:int32) : unit
    requires { p2i sz > 0 }
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    requires { valid_ptr_itv r (p2i sz +  p2i sz) }
    writes { r.data.contents.elts }
    ensures { value_sub_shift r (p2i sz + p2i sz)
              = value_sub_shift x (p2i sz) * value_sub_shift y (p2i sz) }
  =
    zero r sz;
    let limb_zero = Limb.of_int 0 in
    let one = Int32.of_int 1 in
    let rp = ref r in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i !i) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { plength !rp = plength r }
      invariant { pelts !rp = pelts r }
      invariant { 0 <= l2i !c <= 1 }
      variant { p2i sz - p2i !i }
      label StartLoop in
      let ghost k = p2i !i in
      value_sub_concat (pelts r) r.offset (r.offset + k)
                       (r.offset + k + p2i sz);
      assert { value_sub_shift r k
             + (power radix k) * value_sub (pelts r) (r.offset + k)
                                                   (r.offset + k + p2i sz)
             = value_sub_shift r (k + p2i sz) };
      ly := get_ofs y !i;
      let c' =  addmul_limb !rp x !ly sz in
      assert { value_sub_shift !rp (p2i sz) + power radix (p2i sz) * l2i c'
              = value_sub_shift (!rp at StartLoop) (p2i sz)
                + value_sub_shift x (p2i sz) * l2i !ly };
      assert { MapEq.map_eq_sub (pelts r) (pelts r at StartLoop)
                r.offset (!rp).offset
                by (!rp).offset = r.offset + p2i !i
                so forall j. r.offset <= j < (!rp).offset
                   ->
                   (j < (!rp).offset
                    so (pelts !rp)[j] = (pelts !rp at StartLoop)[j]
                         = (pelts r at StartLoop)[j]) };
      let (res, carry) = add_with_carry c' limb_zero !c in
      label BeforeCarry in
      value_sub_update_no_change (pelts r) ((!rp).offset + p2i sz)
                        r.offset  (r.offset + p2i !i) res;
      set_ofs !rp sz res;
      c:= carry;
      i := Int32.(+) !i one;
      assert { value_sub_shift r k = value_sub_shift (r at BeforeCarry) k
             = value_sub_shift (r at StartLoop) k};
      value_sub_tail (pelts r) r.offset (r.offset + p2i sz + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      value_sub_concat (pelts r) r.offset (r.offset + k) (r.offset + k + p2i sz);
      assert { value_sub (pelts r) (r.offset+k) (r.offset+k+p2i sz)
               = value_sub_shift !rp (p2i sz) };
      assert { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i !i)
               by
                 power radix (k + p2i sz) = power radix k * power radix (p2i sz)
               so
                 value_sub_shift (r at StartLoop) k
                 + (power radix k) * value_sub (pelts r at StartLoop)
                                   (r.offset + k) (r.offset + k + p2i sz)
                 = value_sub_shift (r at StartLoop) (k + p2i sz)
               so
                 value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r (k + p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix k) * (power radix (p2i sz)) * radix * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i res + radix * l2i !c)
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i c' + l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sz)
                      + power radix (p2i sz) * l2i c'
                      + (power radix (p2i sz)) * l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift (!rp at StartLoop) (p2i sz)
                       + value_sub_shift x (p2i sz) * l2i !ly
                       + (power radix (p2i sz)) * l2i (!c at StartLoop))
               = value_sub_shift r k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub (pelts r at StartLoop) (r.offset+k)
                                              (r.offset+k+ p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix (k + p2i sz) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift x (p2i sz) * value_sub_shift y k
                + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift x (p2i sz) *
                 (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i)
             };
      rp := M.incr !rp one;
    done;
    value_sub_lower_bound (pelts r) r.offset (r.offset + p2i sz + p2i sz);
    value_sub_upper_bound (pelts x) x.offset (x.offset + p2i sz);
    value_sub_upper_bound (pelts y) y.offset (y.offset + p2i sz);
    assert { 0 <= value_sub_shift x (p2i sz) < power radix (p2i sz) };
    assert { 0 <= value_sub_shift y (p2i sz) < power radix (p2i sz) };
    prod_compat_strict_r (value_sub_shift y (p2i sz)) (power radix (p2i sz))
                         (power radix (p2i sz));
    assert { l2i !c = 0 by
             0 < power radix (p2i sz)
             so
             value_sub_shift r (p2i sz + p2i sz)
                    + (power radix (p2i sz + p2i sz)) * l2i !c
                  = value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i sz)
             so
             (power radix (p2i sz + p2i sz))*l2i !c <=
                    value_sub_shift x (p2i sz)
                    * value_sub_shift y (p2i sz)
                    <= (power radix (p2i sz)) * value_sub_shift y (p2i sz)
                    < (power radix (p2i sz))*(power radix (p2i sz))
             so
             (power radix (p2i sz + p2i sz))*l2i !c <
                    (power radix (p2i sz))*(power radix (p2i sz))  }

 let addmul_limbs (r x y:t) (sz:int32) : limb
    requires { p2i sz > 0 }
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    requires { valid_ptr_itv r (p2i sz +  p2i sz) }
    writes { r.data.contents.elts }
    ensures { value_sub_shift r (p2i sz + p2i sz)
                + power radix (p2i sz + p2i sz) * l2i result
              = value_sub_shift (old r) (p2i sz + p2i sz)
                + value_sub_shift x (p2i sz) * value_sub_shift y (p2i sz) }
  =
    let limb_zero = Limb.of_int 0 in
    let one = Int32.of_int 1 in
    let rp = ref r in
    let ly = ref limb_zero in
    let lr = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    let rec lemma old_tail_shift (i:int)
      requires { i >= 0 }
      variant { i }
      ensures { value_sub_shift (old r) (i+1) = value_sub_shift (old r) i
              + power radix i * l2i (pelts (old r))[r.offset+i] }
      =
        if i > 0 then old_tail_shift (i-1) else assert {1+2=3}  in
    while Int32.(<) !i sz do
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift (old r) (p2i !i + p2i sz)
                    + value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { r.data = (!rp).data }
      invariant { 0 <= l2i !c <= 1 }
      invariant { forall j. (!rp).offset + p2i sz <= j ->
                 (pelts (old r)) [j] = (pelts r)[j]  }
      variant { p2i sz - p2i !i }
      label StartLoop in
      let ghost k = p2i !i in
      value_sub_concat (pelts r) r.offset (r.offset + k)
                       (r.offset + k + p2i sz);
      assert { value_sub_shift r k
             + (power radix k) * value_sub (pelts r) (r.offset + k)
                                                   (r.offset + k + p2i sz)
             = value_sub_shift r (k + p2i sz) };
      ly := get_ofs y !i;
      let c' =  addmul_limb !rp x !ly sz in
      assert { value_sub_shift !rp (p2i sz) + power radix (p2i sz) * l2i c'
              = value_sub_shift (!rp at StartLoop) (p2i sz)
                + value_sub_shift x (p2i sz) * l2i !ly };
      assert { MapEq.map_eq_sub (pelts r) (pelts r at StartLoop)
                r.offset (!rp).offset
                by (!rp).offset = r.offset + p2i !i
                so forall j. r.offset <= j < (!rp).offset
                   ->
                   (j < (!rp).offset
                    so (pelts !rp)[j] = (pelts !rp at StartLoop)[j]
                         = (pelts r at StartLoop)[j]) };
      lr := get_ofs !rp sz;
      assert { l2i !lr = l2i (pelts (old r))[r.offset+ p2i !i + p2i sz] };
      let (res, carry) = add_with_carry c' !lr !c in
      label BeforeCarry in
      value_sub_update_no_change (pelts r) ((!rp).offset + p2i sz)
                        r.offset  (r.offset + p2i !i) res;
      set_ofs !rp sz res;
      assert { value_sub_shift !rp (p2i sz) = value_sub_shift (!rp at BeforeCarry) (p2i sz) };
      c:= carry;
      i := Int32.(+) !i one;
      assert { value_sub_shift r k = value_sub_shift (r at BeforeCarry) k
             = value_sub_shift (r at StartLoop) k};
      value_sub_tail (pelts r) r.offset (r.offset + p2i sz + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      old_tail_shift (k+p2i sz);
      value_sub_concat (pelts r) r.offset (r.offset + k) (r.offset + k + p2i sz);
      assert { value_sub (pelts r) (r.offset+k) (r.offset+k+p2i sz)
               = value_sub_shift !rp (p2i sz) };
      assert { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift (old r) (p2i !i + p2i sz)
                    + value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i !i)
               by
                 power radix (k + p2i sz) = power radix k * power radix (p2i sz)
               so
                 value_sub_shift (r at StartLoop) k
                 + (power radix k) * value_sub (pelts r at StartLoop)
                                   (r.offset + k) (r.offset + k + p2i sz)
                 = value_sub_shift (r at StartLoop) (k + p2i sz)
               so (value_sub_shift (old r) (p2i !i+p2i sz)
                  = value_sub_shift (old r) (k+p2i sz)
                  + power radix (k+p2i sz) * l2i !lr
                  by l2i !lr = l2i (pelts (old r))[r.offset + k + p2i sz])
               so
                  value_sub_shift !rp (p2i sz) + (power radix (p2i sz)) * l2i c' =
                  value_sub_shift (!rp at StartLoop) (p2i sz)
                  + value_sub_shift x (p2i sz) * l2i !ly
               so
                 value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r (k + p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix k) * (power radix (p2i sz)) * radix * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i res + radix * l2i !c)
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i c' + l2i (!c at StartLoop) + l2i !lr)
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sz)
                      + power radix (p2i sz) * (l2i c'+ l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sz)
                      + power radix (p2i sz) * l2i c'
                      + power radix (p2i sz) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift (!rp at StartLoop) (p2i sz)
                       + value_sub_shift x (p2i sz) * l2i !ly
                       + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift r k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub (pelts r at StartLoop) (r.offset+k)
                                              (r.offset+k+ p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop) + l2i !lr)
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop) + l2i !lr)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix (k + p2i sz) * (l2i (!c at StartLoop) + l2i !lr)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix (k + p2i sz) * (l2i (!c at StartLoop))
                 + power radix (k + p2i sz) * l2i !lr
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (old r) (k+p2i sz)
                 + value_sub_shift x (p2i sz) * value_sub_shift y k
                 + power radix (k + p2i sz) * l2i !lr
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (old r) (k+p2i sz)
                 + power radix (k + p2i sz) * l2i !lr
                 + value_sub_shift x (p2i sz) * value_sub_shift y k
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (old r) (k+p2i sz)
                 + power radix (k + p2i sz) * l2i !lr
                 + value_sub_shift x (p2i sz) * (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift (old r) (k+p2i sz)
                 + power radix (k + p2i sz) * l2i !lr
                 + value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i)
               = value_sub_shift (old r) (p2i !i +p2i sz)
                 + value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i)
             };
      rp := M.incr !rp one;
    done;
    !c

  (** [mul r x y sx sy] multiplies [(x, sx)] and [(y,sy)] and writes
  the result in [(r, sx+sy)]. [sx] must be greater than or equal to
  [sy]. Corresponds to [mpn_mul]. *)
  let mul (r x y:t) (sx sy:int32) : unit
    requires { 0 < p2i sy <= p2i sx }
    requires { valid_ptr_itv x (p2i sx) }
    requires { valid_ptr_itv y (p2i sy) }
    requires { valid_ptr_itv r (p2i sy + p2i sx) }
    writes { r.data.contents.elts }
    ensures { value_sub_shift r (p2i sy + p2i sx)
              = value_sub_shift x (p2i sx) * value_sub_shift y (p2i sy) }
  =
    zero r sx;
    let limb_zero = Limb.of_int 0 in
    let one = Int32.of_int 1 in
    let rp = ref r in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sy do
      invariant { 0 <= p2i !i <= p2i sy }
      invariant { value_sub_shift r (p2i !i + p2i sx)
                    + (power radix (p2i !i + p2i sx)) * l2i !c
                  = value_sub_shift x (p2i sx)
                      * value_sub_shift y (p2i !i) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { plength !rp = plength r }
      invariant { pelts !rp = pelts r }
      invariant { 0 <= l2i !c <= 1 }
      variant { p2i sy - p2i !i }
      label StartLoop in
      let ghost k = p2i !i in
      value_sub_concat (pelts r) r.offset (r.offset + k)
                       (r.offset + k + p2i sx);
      assert { value_sub_shift r k
             + (power radix k) * value_sub (pelts r) (r.offset + k)
                                                   (r.offset + k + p2i sx)
             = value_sub_shift r (k + p2i sx) };
      ly := get_ofs y !i;
      let c' =  addmul_limb !rp x !ly sx in
      assert { value_sub_shift !rp (p2i sx) + power radix (p2i sx) * l2i c'
              = value_sub_shift (!rp at StartLoop) (p2i sx)
                + value_sub_shift x (p2i sx) * l2i !ly };
      assert { MapEq.map_eq_sub (pelts r) (pelts r at StartLoop)
                r.offset (!rp).offset
                by (!rp).offset = r.offset + p2i !i
                so forall j. r.offset <= j < (!rp).offset
                   ->
                   (j < (!rp).offset
                    so (pelts !rp)[j] = (pelts !rp at StartLoop)[j]
                         = (pelts r at StartLoop)[j]) };
      let (res, carry) = add_with_carry c' limb_zero !c in
      label BeforeCarry in
      value_sub_update_no_change (pelts r) ((!rp).offset + p2i sx)
                        r.offset  (r.offset + p2i !i) res;
      set_ofs !rp sx res;
      c:= carry;
      i := Int32.(+) !i one;
      assert { value_sub_shift r k = value_sub_shift (r at BeforeCarry) k
             = value_sub_shift (r at StartLoop) k};
      value_sub_tail (pelts r) r.offset (r.offset + p2i sx + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      value_sub_concat (pelts r) r.offset (r.offset + k) (r.offset + k + p2i sx);
      assert { value_sub (pelts r) (r.offset+k) (r.offset+k+p2i sx)
               = value_sub_shift !rp (p2i sx) };
      assert { value_sub_shift r (p2i !i + p2i sx)
                    + (power radix (p2i !i + p2i sx)) * l2i !c
                  = value_sub_shift x (p2i sx)
                      * value_sub_shift y (p2i !i)
               by
                 power radix (k + p2i sx) = power radix k * power radix (p2i sx)
               so
                 value_sub_shift (r at StartLoop) k
                 + (power radix k) * value_sub (pelts r at StartLoop)
                                   (r.offset + k) (r.offset + k + p2i sx)
                 = value_sub_shift (r at StartLoop) (k + p2i sx)
               so
                 value_sub_shift r (p2i !i + p2i sx)
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r (k + p2i sx)
                    + (power radix (k + p2i sx)) * l2i res
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix (k + p2i sx)) * l2i res
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx)) * l2i res
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx)) * l2i res
                    + (power radix k) * (power radix (p2i sx)) * radix * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx))
                             * (l2i res + radix * l2i !c)
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx))
                             * (l2i c' + l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sx)
                      + power radix (p2i sx) * l2i c'
                      + (power radix (p2i sx)) * l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift (!rp at StartLoop) (p2i sx)
                       + value_sub_shift x (p2i sx) * l2i !ly
                       + (power radix (p2i sx)) * l2i (!c at StartLoop))
               = value_sub_shift r k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sx))
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sx))
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub (pelts r at StartLoop) (r.offset+k)
                                              (r.offset+k+ p2i sx))
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix k * value_sub_shift x (p2i sx) * l2i !ly
                 + power radix k * power radix (p2i sx) * (l2i (!c at StartLoop))
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix k * power radix (p2i sx) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sx) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix (k + p2i sx) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sx) * l2i !ly
               = value_sub_shift x (p2i sx) * value_sub_shift y k
                + power radix k * value_sub_shift x (p2i sx) * l2i !ly
               = value_sub_shift x (p2i sx) *
                 (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift x (p2i sx) * value_sub_shift y (p2i !i)
             };
      rp := M.incr !rp one;
    done;
    value_sub_lower_bound (pelts r) r.offset (r.offset + p2i sy + p2i sx);
    value_sub_upper_bound (pelts x) x.offset (x.offset + p2i sx);
    value_sub_upper_bound (pelts y) y.offset (y.offset + p2i sy);
    assert { 0 <= value_sub_shift x (p2i sx) < power radix (p2i sx) };
    assert { 0 <= value_sub_shift y (p2i sy) < power radix (p2i sy) };
    prod_compat_strict_r (value_sub_shift y (p2i sy)) (power radix (p2i sy))
                         (power radix (p2i sx));
    assert { l2i !c = 0 by
             0 < power radix (p2i sx)
             so
             value_sub_shift r (p2i sy + p2i sx)
                    + (power radix (p2i sy + p2i sx)) * l2i !c
                  = value_sub_shift x (p2i sx)
                      * value_sub_shift y (p2i sy)
             so
             (power radix (p2i sy + p2i sx))*l2i !c <=
                    value_sub_shift x (p2i sx)
                    * value_sub_shift y (p2i sy)
                    <= (power radix (p2i sx)) * value_sub_shift y (p2i sy)
                    < (power radix (p2i sx))*(power radix (p2i sy))
             so
             (power radix (p2i sx + p2i sy))*l2i !c <
                    (power radix (p2i sx))*(power radix (p2i sy))  }
end

(*
module Heap

  type elt


  type base

  type ptr model { base: base; mutable offset:int }

  (** heap of memory blocks storing values of type elt *)
  type heap = {

    ghost mutable length : map base int;  (* returns -1 for non-allocated block *)
    ghost mutable contents : map base (map int elt);
  }

  val ghost h : heap

  (** operation [*p] *)
  val get (p : ptr) :elt
    requires { 0 <= p.offset < h.length[p.base] }
    reads { h }
    ensures { result = h.contents[p.base][p.offset] }

  (** operations [p+i], [p[i]] *)

  val malloc(n:int32):ptr
    requires { n >= 0 }
    writes  { h.length }
    ensures { result.offset = 0 }
    ensures { h.length[result.base] = n  }
    ensures { (old h).length[result.base] = -1  }
    ensures { forall b:base. b <> result.base -> (old h).length[b] = h,length[b]  }


  val free ...

end
*)