module M

  use import map.Map
  use import mach.int.Unsigned
  use import mach.int.Int32
  use import mach.int.UInt32
  use import array.Array
  use import int.Int
  predicate in_us_bounds (n:int) = 0 <= n <= max_uint32
  predicate in_bounds (n:int) = min_int32 <= n <= max_int32
  use import ref.Ref

  type ptr 'a = {
    data : ref (array 'a) ;
    offset : int ;
  }
  (*invariant { in_us_bounds data.length }*)
  (* it is not required the offset is in 0..elts.length *)

  function plength (p:ptr 'a) : int
  = p.data.contents.length

  function pelts (p:ptr 'a) : int -> 'a
  = p.data.contents.elts

  val p2i (n:int32):int
    ensures { result = Int32.to_int n }

  val predicate is_null (p:ptr 'a) : bool
    ensures { result <-> plength p = 0 }

  val null () : ptr 'a
    ensures { plength result = 0 }

  let incr (p:ptr 'a) (ofs:int32) : ptr 'a
    ensures { result.offset = p.offset + Int32.to_int ofs }
    ensures { result.data = p.data }
   =
    { data = p.data; offset = p.offset + p2i ofs }

  val get (p:ptr 'a) : 'a
    requires { 0 <= p.offset < plength p }
    ensures { result = !(p.data)[p.offset] }

  let get_ofs (p:ptr 'a) (ofs:int32) : 'a
    requires { 0 <= p.offset + Int32.to_int ofs < plength p }
    ensures { result = !(p.data)[p.offset + Int32.to_int ofs] }
  = get (incr p ofs)

  val set (p:ptr 'a) (v:'a) : unit
    requires { 0 <= p.offset < plength p }
    ensures { pelts p = Map.set (pelts (old p)) p.offset v }
    writes { p.data.contents.elts }

  let set_ofs (p:ptr 'a) (ofs:int32) (v:'a) : unit
    requires { 0 <= p.offset + Int32.to_int ofs < plength p }
    ensures { pelts p = Map.set (pelts (old p))
              (p.offset + Int32.to_int ofs) v }
    writes { p.data.contents.elts }
 =
    set (incr p ofs) v

  predicate valid_ptr_shift (p:ptr 'a) (i:int) =
    0 <= p.offset + i < plength p

  predicate valid_ptr_itv (p:ptr 'a) (sz:int) =
    in_bounds sz /\ 0 <= sz /\ 0 <= p.offset /\ p.offset + sz <= plength p

  let lemma valid_itv_to_shift (p:ptr 'a) (sz:int)
    requires { valid_ptr_itv p sz }
    ensures { forall i. 0 <= i < sz -> valid_ptr_shift p i }
  = ()

  val malloc (sz:uint32) : ptr 'a
    ensures { plength result = UInt32.to_int sz \/ plength result = 0 }
    ensures { result.offset = 0 }

 (* How to specify that the data array is reset by free/realloc ?*)
(*  let free (p:ptr 'a) : unit
    requires { p.offset = 0 }
    writes { p }
    ensures { p.data.length = 0 }
  =  if is_null p then ()
     else begin
     let c = incr p (Int32.of_int 0) in
     p.data <- Array.make 0 (get p);
     check { c.data.length = 0 }
     end *)
  val free (p:ptr 'a) : unit
    requires { p.offset = 0 }
    writes { p.data }
    ensures { plength p = 0 }
 (* = if is_null p then ()
    else begin
   (* let c = incr p (Int32.of_int 0) in*)
    p.data := Array.make 0 (get p);
    (*check { plength c = 0 }*)
    end
  *)

  val realloc (p:ptr 'a) (sz:int32) : ptr 'a
    requires { Int32.to_int sz > 0 } (* for simplicity, though 0 is legal in C *)
    requires { p.offset = 0 }
    writes { p.data }
    ensures { plength result = Int32.to_int sz \/ plength result = 0 }
    ensures { plength result = Int32.to_int sz -> plength p = 0 }
    ensures { plength result = Int32.to_int sz ->
                forall i:int. 0 <= i < plength (old p) /\ i < Int32.to_int sz ->
                  !(result.data)[i] = !((old p).data)[i] }
    ensures { plength result <> Int32.to_int sz -> p = old p }


end
(*
module Limb

  use import int.Int
  clone export mach.int.UInt32

  type limb = uint32

  val add_carry (x y:limb) : limb
    ensures { 0 <= to_int result <= 1 }

  val add_res (x y:limb) : limb
    ensures { result + add_carry x y = add_with_carry x y zero_unsigned }

end *)

module N

 (**)
  use import array.Array
  use import mach.int.Int32
  use import M
  use import mach.int.UInt32 as Limb
  use import int.Int
  use import int.Power
  use import map.Map
  use import ref.Ref
  type limb = uint32

  lemma limb_max_bound: 1 <= max_uint32

  constant radix : int = max_uint32 + 1

  function l2i (x:limb) : int = UInt32.to_int x

  function p2i (i:int32) : int = Int32.to_int i

  type t = ptr limb

  (** {2 Integer value of a natural number} *)

  (** [value_sub x n m] denotes the integer represented by
     the digits x[n..m-1] with lsb at index n *)
  let rec ghost function value_sub (x:map int limb) (n:int) (m:int) : int
     variant {m - n}
   =
     if n < m then
       l2i x[n] + radix * value_sub x (n+1) m
       else 0

  function value (x:t) : int =
     value_sub (pelts x) 0 (plength x)

  function value_sub_shift (x:t) (sz:int) : int =
     value_sub (pelts x) x.offset (x.offset + sz)

  let from_limb (l:limb) : t
    ensures { is_null result \/ plength result = 1 }
    ensures { is_null result \/ value_sub_shift result 1 = l2i l }
  =
    let p = malloc (UInt32.of_int 1) in
    if not (is_null p)
    then M.set p l;
    p

  use map.MapEq
  use map.Const

  predicate map_eq_sub_shift (x y:map int 'a) (xi yi sz:int) =
    forall i. 0 <= i < sz -> x[xi+i] = y[yi+i]

  let lemma map_eq_shift (x y:map int 'a) (xi yi sz k:int)
    requires { map_eq_sub_shift x y xi yi sz }
    requires { 0 <= k < sz }
    ensures { x[xi+k] = y[yi+k] }
  = ()

  let rec lemma map_eq_shift_zero (x y: map int 'a) (n m: int)
    requires { map_eq_sub_shift x y n n (m-n) }
    variant { m - n }
    ensures { MapEq.map_eq_sub x y n m }
  =
    if n < m then
    begin
      assert { forall i. 0 <= i < m-n -> x[n+i] = y[n+i] };
      assert { forall i. n <= i < m ->
                 let j = i - n in 0 <= j < m-n ->
                     x[n+j] = y[n+j] -> x[i] = y[i]};
      map_eq_shift_zero x y (n+1) m;
    end
    else assert { 1+2=3 }

  let rec lemma value_sub_frame (x y:map int limb) (n m:int)
    requires { MapEq.map_eq_sub x y n m }
    variant  { m - n }
    ensures  { value_sub x n m = value_sub y n m }
  =
    if n < m then value_sub_frame x y (n+1) m else ()

  let rec lemma value_sub_frame_shift (x y:map int limb) (xi yi sz:int)
    requires { map_eq_sub_shift x y xi yi sz }
    variant { sz }
    ensures { value_sub x xi (xi+sz) = value_sub y yi (yi+sz) }
 =
    if sz>0
    then begin
      map_eq_shift x y xi yi sz 0;
      assert { forall i. 0 <= i < sz-1 ->
                 0 <= 1+i < sz ->
                 let j = 1+i in x[xi+j] = y[yi+j] ->
                   x[xi+1+i] = y[yi+1+i]  };
      value_sub_frame_shift x y (xi+1) (yi+1) (sz-1)
      end
    else assert { 1+2 = 3 }

  let rec lemma value_sub_tail (x:map int limb) (n m:int)
    requires { n <= m }
    variant  { m - n }
    ensures  {
      value_sub x n (m+1) =
        value_sub x n m + l2i (Map.get x m) * power radix (m-n) }
  = "vc:sp" if n < m then value_sub_tail x (n+1) m else ()(*assert { 1+2=3 }*)

  let rec lemma value_sub_concat (x:map int limb) (n m l:int)
    requires { n <= m <= l}
    variant  { m - n }
    ensures  {
      value_sub x n l =
        value_sub x n m + value_sub x m l * power radix (m-n) }
  =
  if n < m then
     begin
     assert {n<m};
     value_sub_concat x (n+1) m l
     end
  else ()

  let lemma value_sub_head (x:map int limb) (n m:int)
    requires { n < m }
    ensures { value_sub x n m = l2i x[n] + radix * value_sub x (n+1) m }
  = value_sub_concat x n (n+1) m

  let lemma value_sub_update (x:map int limb) (i n m:int) (v:limb)
    requires { n <= i < m }
    ensures {
      value_sub (Map.set x i v) n m =
      value_sub x n m + power radix (i - n) * (l2i v - l2i (Map.get x i))
    }
  = assert { MapEq.map_eq_sub x (Map.set x i v) n i };
    assert { MapEq.map_eq_sub x (Map.set x i v) (i+1) m };
    value_sub_concat x n i m;
    value_sub_concat (Map.set x i v) n i m

  let rec lemma value_zero (x:map int limb) (n m:int)
    requires { MapEq.map_eq_sub x (Const.const UInt32.zero_unsigned) n m }
    variant  { m - n }
    ensures  { value_sub x n m = 0 }
  = if n < m then value_zero x (n+1) m else ()

  let lemma value_sub_update_no_change (x: map int limb) (i n m: int) (v:limb)
     requires { n <= m }
     requires { i < n \/ m <= i }
     ensures { value_sub x n m = value_sub (Map.set x i v) n m }
  = value_sub_frame x (Map.set x i v) n m

  let lemma value_sub_shift_no_change (x:map int limb) (ofs i sz:int) (v:limb)
     requires { i < 0 \/ sz <= i }
     requires { 0 <= sz }
     ensures { value_sub x ofs (ofs + sz) =
               value_sub (Map.set x (ofs+i) v) ofs (ofs+sz) }
  = value_sub_frame_shift x (Map.set x (ofs+i) v) ofs ofs sz

  (** {2 Comparisons} *)

    let rec lemma value_sub_lower_bound (x:map int limb) (x1 x2:int)
    variant  { x2 - x1 }
    ensures  { 0 <= value_sub x x1 x2 }
  = if x2 <= x1 then () else
      begin
        assert { value_sub x x1 x2 = l2i (Map.get x x1) + radix * value_sub x (x1+1) x2};
        value_sub_lower_bound x (x1+1) x2
      end

  let rec lemma value_sub_upper_bound (x:map int limb) (x1 x2:int)
    requires { x1 <= x2 }
    variant  { x2 - x1 }
    ensures  { value_sub x x1 x2 < power radix (x2 - x1) }
  = if x1 = x2 then () else
      begin
      assert { value_sub x x1 x2 <= value_sub x x1 (x2-1) + power radix (x2-x1-1) * (radix - 1) };
      value_sub_upper_bound x x1 (x2-1)
      end

  let lemma value_sub_lower_bound_tight (x:map int limb) (x1 x2:int)
    requires { x1 < x2 }
    ensures  { power radix (x2-x1-1) *  l2i (Map.get x (x2-1)) <= value_sub x x1 x2 }
  = assert   { value_sub x x1 x2 = value_sub x x1 (x2-1)
               + power radix (x2-x1-1) * l2i (Map.get x (x2-1)) }

  let lemma value_sub_upper_bound_tight (x:map int limb) (x1 x2:int)
    requires { x1 < x2 }
    ensures  { value_sub x x1 x2 < power radix (x2-x1-1) *  (l2i (Map.get x (x2-1)) + 1) }
  = value_sub_upper_bound x x1 (x2-1)

  let lemma prod_compat_strict_r (a b c:int)
    requires { 0 <= a < b }
    requires { 0 < c }
    ensures { c * a < c * b }
  = ()

  exception Break32 int32

  use import ref.Refint

  function compare_int (x y:int) : int =
    if x < y then -1 else if x=y then 0 else 1

  (** [compare_same_size] compares [x[0..sz-1]] and [y[0..sz-1]] as unsigned integers. It corresponds to [GMPN_CMP]. *)
  let compare_same_size (x y:t) (sz:int32) : int32
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    ensures { p2i result = compare_int (value_sub_shift x (p2i sz))
              (value_sub_shift y (p2i sz))
              }
  =
   let i = ref sz in
   let zero = Int32.of_int 0 in
   let uzero = UInt32.of_int 0 in
   let lx = ref uzero in
   let ly = ref uzero in
   let res = ref zero in
   try
     while Int32.(>=) !i (Int32.of_int 1) do
       variant { p2i !i }
       invariant { 0 <= p2i !i <= p2i sz }
       invariant { forall j. p2i !i <= j < p2i sz ->
                   (pelts x)[x.offset+j] = (pelts y)[y.offset+j] }
       assert { forall j. 0 <= j < p2i sz - (p2i !i) ->
                let k = p2i !i+j in
                p2i !i <= k < p2i sz ->
                (pelts x)[x.offset+k] = (pelts y)[y.offset+k] /\
                (pelts x)[p2i !i+x.offset+j] = (pelts y)[p2i !i+y.offset+j] };
       value_sub_frame_shift (pelts x) (pelts y) (p2i !i+x.offset) (p2i !i+y.offset) ((p2i sz) - (p2i !i));
       let ghost k = p2i !i in
       i := Int32.(-) !i (Int32.of_int 1);

       assert { 0 <= p2i !i < p2i sz };
       lx := get_ofs x !i;
       ly := get_ofs y !i;
       if (UInt32.ne !lx !ly)
       then begin
            value_sub_concat (pelts x) x.offset (x.offset+k) (x.offset+ p2i sz);
            value_sub_concat (pelts y) y.offset (y.offset+k) (y.offset+ p2i sz);
            assert { compare_int (value_sub_shift x (p2i sz))
                       (value_sub_shift y (p2i sz))
                   = compare_int (value_sub_shift x k) (value_sub_shift y k) };
            value_sub_tail (pelts x) x.offset (x.offset+k-1);
            value_sub_tail (pelts y) y.offset (y.offset+k-1);
            if UInt32.(>) !lx !ly
            then begin
             value_sub_upper_bound (pelts y) y.offset (y.offset+k-1);
             value_sub_lower_bound (pelts x) x.offset (x.offset+k-1);
             assert { value_sub_shift x k - value_sub_shift y k =
                      (l2i !lx - l2i !ly) * (power radix (k-1))
                    - ((value_sub_shift y (k-1)) - (value_sub_shift x (k-1)))
                       };
             assert { (l2i !lx - l2i !ly) * (power radix (k-1))
                      >= power radix (k-1)
                      > ((value_sub_shift y (k-1)) - (value_sub_shift x (k-1)))
                       };
             res := Int32.of_int 1
            end
            else begin
             assert { l2i !ly > l2i !lx };
             value_sub_upper_bound (pelts x) x.offset (x.offset+k-1);
             value_sub_lower_bound (pelts y) y.offset (y.offset+k-1);
             assert { value_sub_shift y k - value_sub_shift x k =
                    (l2i !ly - l2i !lx) * (power radix (k-1))
                    - ((value_sub_shift x (k-1)) - (value_sub_shift y (k-1)))
                     };
             assert { (l2i !ly - l2i !lx) * (power radix (k-1))
                      >= power radix (k-1)
                      > ((value_sub_shift x (k-1)) - (value_sub_shift y (k-1)))
                     };
            res := Int32.of_int (-1)
            end;
         raise Break32 !res
         end
       else ()
     done;
     value_sub_frame_shift (pelts x) (pelts y) x.offset y.offset (p2i sz);
     zero
   with Break32 r -> r
   end

   (* [is_zero] checks if [x[0..sz-1]] is zero. It corresponds to [mpn_zero_p]. *)
   let is_zero (x:t) (sz:int32) : int32
     requires { valid_ptr_itv x (p2i sz) }
     ensures { 0 <= Int32.to_int result <= 1 }
     ensures { Int32.to_int result = 1 <-> value_sub_shift x (p2i sz) = 0 }
   =
     let i = ref sz in
     let uzero = UInt32.of_int 0 in
     let lx = ref uzero in
     try
       while Int32.(>=) !i (Int32.of_int 1) do
         variant { p2i !i }
         invariant { 0 <= p2i !i <= p2i sz }
         invariant { value_sub (pelts x) (x.offset + p2i !i) (x.offset + p2i sz)=0 }
         let ghost k = p2i !i in
         i := Int32.(-) !i (Int32.of_int 1);
         assert { 0 <= p2i !i < p2i sz };
         lx := get_ofs x !i;
         if (UInt32.ne !lx uzero)
         then begin
           value_sub_concat (pelts x) x.offset (x.offset+k) (x.offset + p2i sz);
           value_sub_lower_bound_tight (pelts x) x.offset (x.offset+k);
           value_sub_lower_bound (pelts x) (x.offset+k) (x.offset + p2i sz);
           raise Break32 (Int32.of_int 0)
         end
         else begin
           assert { 1+2=3 };
         end
       done;
       Int32.of_int 1
     with Break32 r -> r
     end

  (** [zero r sz] sets [(r,sz)] to zero. Corresponds to [mpn_zero]. *)
  let zero (r:t) (sz:int32) : unit
    requires { valid_ptr_itv r (p2i sz) }
    ensures { value_sub_shift r (p2i sz) = 0 }
  =
    let i = ref (Int32.of_int 0) in
    let lzero = Limb.of_int 0 in
    while Int32.(<) !i sz do
      invariant { 0 <= p2i !i <= p2i sz }
      variant { p2i sz - p2i !i }
      invariant { value_sub_shift r (p2i !i) = 0 }
      set_ofs r !i lzero;
      value_sub_tail (pelts r) r.offset (r.offset + p2i !i);
      i := Int32.(+) !i (Int32.of_int 1);
    done

  (** {2 Addition} *)

  exception Break

  (** [add_limb r x y sz] adds to [x] the value of the limb [y],
      writes the result in [r] and returns the carry. [r] and [x]
      have size [sz]. This corresponds to the function [mpn_add_1] *)
  (* r and x must be separated. This is enforced by Why3 regions in typing *)
  let add_limb (r x:t) (y:limb) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    requires { p2i sz > 0 } (* ? GMP does the same for 0 and 1*)
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result =
              value_sub_shift x (p2i sz) + l2i y }
    ensures { 0 <= l2i result <= 1 }
    writes { r.data.contents.elts }
  =
    let limb_zero = UInt32.of_int 0 in
    let c = ref y in
    let lx = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz && UInt32.ne !c limb_zero do
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { p2i !i > 0 -> 0 <= l2i !c <= 1 }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y}
      variant { p2i sz - p2i !i }
      label StartLoop in
      lx := get_ofs x !i;
      let (res, carry) = add_with_carry !lx !c limb_zero in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      let ghost m = power radix k in
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
             = value_sub_shift x (p2i !i) + l2i y
             by
             value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
             = value_sub_shift r k + (power radix k) * l2i res
                               + (power radix (p2i !i)) * l2i !c
             = value_sub_shift r k + (power radix k) * l2i res
                               + (power radix k) * radix * l2i !c
             = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
             = value_sub_shift r k +
               (power radix k) * (l2i !lx + l2i (!c at StartLoop))
             = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                               + (power radix k) * l2i !lx
             = value_sub_shift x k + l2i y + (power radix k) * l2i !lx
             = value_sub_shift x (p2i !i) + l2i y }
    done;
    if Int32.eq !i sz then !c
    else begin
    while Int32.(<) !i sz do
      invariant { l2i !c  = 0 }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y}
      variant { p2i sz - p2i !i }
      lx := get_ofs x !i;
      set_ofs r !i !lx;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) + l2i y };
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
    done;
    !c
    end


  (** [add_limbs r x y sz] adds [x[0..sz-1]] and [y[0..sz-1]] and writes the result in [r].
      Returns the carry, either [0] or [1]. Corresponds to the function [mpn_add_n]. *)

  let add_limbs (r x y:t) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    ensures { 0 <= l2i result <= 1 }
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result =
            value_sub_shift x (p2i sz) + value_sub_shift y (p2i sz) }
    writes { r.data.contents.elts }
    =
    let limb_zero = UInt32.of_int 0 in
    let lx = ref limb_zero in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) }
      invariant { 0 <= l2i !c <= 1 }
      label StartLoop in
      lx := get_ofs x !i;
      ly := get_ofs y !i;
      let res, carry = add_with_carry !lx !ly !c in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i)
              by
              value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix k) * radix * l2i !c
              = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
              = value_sub_shift r k +
                  (power radix k) * (l2i !lx + l2i !ly + l2i (!c at StartLoop))
              = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + value_sub_shift y k
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + (power radix k) * l2i !lx
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + (value_sub_shift y k + (power radix k) * l2i !ly)
              = value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) }
    done;
    !c

  (** [add r x y sx sy] adds [(x, sx)] to [(y,sy)] and writes the
      result in [(r, sx)].  [sx] must be greater than or equal to
      [sy]. Returns carry, either 0 or 1. Corresponds to [mpn_add]. *)
  let add (r x y:t) (sx sy:int32) : limb
    requires { 0 <= p2i sy <= p2i sx }
    requires { valid_ptr_itv x (p2i sx) }
    requires { valid_ptr_itv y (p2i sy) }
    requires { valid_ptr_itv r (p2i sx) }
    ensures { value_sub_shift r (p2i sx) + (power radix (p2i sx)) * l2i result =
              value_sub_shift x (p2i sx) + value_sub_shift y (p2i sy) }
    ensures { 0 <= l2i result <= 1 }
    writes { r.data.contents.elts }
 =
    let limb_zero = Limb.of_int 0 in
    let lx = ref limb_zero in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sy do
      variant { p2i sy - p2i !i }
      invariant { 0 <= p2i !i <= p2i sy }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) }
      invariant { 0 <= l2i !c <= 1 }
      label StartLoop in
      lx := get_ofs x !i;
      ly := get_ofs y !i;
      let res, carry = add_with_carry !lx !ly !c in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i)
              by
              value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix k) * radix * l2i !c
              = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
              = value_sub_shift r k +
                  (power radix k) * (l2i !lx + l2i !ly + l2i (!c at StartLoop))
              = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + value_sub_shift y k
                 + (power radix k) * (l2i !lx + l2i !ly)
              = value_sub_shift x k + (power radix k) * l2i !lx
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + value_sub_shift y k + (power radix k) * l2i !ly
              = value_sub_shift x (p2i !i)
                 + (value_sub_shift y k + (power radix k) * l2i !ly)
              = value_sub_shift x (p2i !i) + value_sub_shift y (p2i !i) };
    done;
    while Int32.(<) !i sx do
      variant { p2i sx - p2i !i }
      invariant { p2i sy <= p2i !i <= p2i sx }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i sy) }
      invariant { 0 <= l2i !c <= 1 }
      label StartLoop2 in
      lx := get_ofs x !i;
      let res, carry = add_with_carry !lx limb_zero !c in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i sy) };
      c := carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                value_sub_shift x (p2i !i) + value_sub_shift y (p2i sy)
              by
              value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix (p2i !i)) * l2i !c
              = value_sub_shift r k + (power radix k) * l2i res
                   + (power radix k) * radix * l2i !c
              = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
              = value_sub_shift r k +
                  (power radix k) * (l2i !lx + 0 + l2i (!c at StartLoop2))
              = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop2)
                 + (power radix k) * l2i !lx
              = value_sub_shift x k + value_sub_shift y (p2i sy)
                 + (power radix k) * l2i !lx
              = value_sub_shift x (p2i !i)
                 + value_sub_shift y (p2i sy) }
    done;
    !c

  (** [sub_limb r x y sz] substracts [y] from [(x, sz)] and writes
      the result to [(r, sz)]. Returns borrow, either 0 or
      1. Corresponds to [mpn_sub_1]. *)
  let sub_limb (r x:t) (y:limb) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    requires { 0 < p2i sz }
    ensures { value_sub_shift r (p2i sz) - power radix (p2i sz) * l2i result
              = value_sub_shift x (p2i sz) - l2i y }
    ensures { 0 <= l2i result <= 1 }
    writes { r.data.contents.elts }
  =
    let limb_zero = Limb.of_int 0 in
    let b = ref y in
    let lx = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz && UInt32.ne !b limb_zero do
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { p2i !i > 0 -> 0 <= l2i !b <= 1 }
      invariant { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
                  = value_sub_shift x (p2i !i) - l2i y }
      variant { p2i sz - p2i !i }
      label StartLoop in
      lx := get_ofs x !i;
      let (res, borrow) = sub_with_borrow !lx !b limb_zero in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b =
                 value_sub_shift x (p2i !i) - l2i y };
      b := borrow;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      assert { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
                  = value_sub_shift x (p2i !i) - l2i y
             by
               value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
             = value_sub_shift r k + power radix k * l2i res
                 - power radix (p2i !i) * l2i !b
             = value_sub_shift r k + power radix k * l2i res
                 - power radix k * radix * l2i !b
             = value_sub_shift r k + power radix k * (l2i res - radix * l2i !b)
             = value_sub_shift r k +
                 (power radix k) * (l2i !lx - l2i (!b at StartLoop))
             = value_sub_shift r k - power radix k * l2i (!b at StartLoop)
                 + power radix k * l2i !lx
             = value_sub_shift x k - l2i y + power radix k * l2i !lx
             = value_sub_shift x (p2i !i) - l2i y
      };
    done;
    if Int32.eq !i sz then !b
    else begin
    while Int32.(<) !i sz do
      invariant { l2i !b = 0 }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
                   = value_sub_shift x (p2i !i) - l2i y }
      variant { p2i sz - p2i !i }
      lx := get_ofs x !i;
      set_ofs r !i !lx;
      assert { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
                   = value_sub_shift x (p2i !i) - l2i y };
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
    done;
    !b
  end

  (** [sub_limbs r x y sz] substracts [(y, sz)] from [(x, sz)] and
      writes the result to [(r, sz)]. Returns borrow, either 0 or
      1. Corresponds to [mpn_sub_n]. *)
  let sub_limbs (r x y:t) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    ensures { 0 <= l2i result <= 1 }
    ensures { value_sub_shift r (p2i sz) - power radix (p2i sz) * l2i result
              = value_sub_shift x (p2i sz) - value_sub_shift y (p2i sz) }
    writes { r.data.contents.elts }
  =
    let limb_zero = UInt32.of_int 0 in
    let lx = ref limb_zero in
    let ly = ref limb_zero in
    let b = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) - (power radix (p2i !i)) * l2i !b
                  = value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i) }
      invariant { 0 <= l2i !b <= 1 }
      label StartLoop in
      lx := get_ofs x !i;
      ly := get_ofs y !i;
      let res, borrow = sub_with_borrow !lx !ly !b in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) - (power radix (p2i !i)) * l2i !b =
      value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i) };
      b := borrow;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      assert { value_sub_shift r (p2i !i) - (power radix (p2i !i)) * l2i !b
                  = value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i)
               by
                 value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
               = value_sub_shift r k + power radix k * l2i res
                   - power radix (p2i !i) * l2i !b
               = value_sub_shift r k + power radix k * l2i res
                   - power radix k * radix * l2i !b
               = value_sub_shift r k
                 + power radix k * (l2i res - radix * l2i !b)
               = value_sub_shift r k
                 + power radix k * (l2i !lx - l2i !ly - l2i (!b at StartLoop))
               = value_sub_shift r k - power radix k * l2i (!b at StartLoop)
                 + power radix k * (l2i !lx - l2i !ly)
               = value_sub_shift x k - value_sub_shift y k
                 + power radix k * (l2i !lx - l2i !ly)
               = value_sub_shift x k - value_sub_shift y k
                 + power radix k * l2i !lx - power radix k * l2i !ly
               = value_sub_shift x k + power radix k * l2i !lx
                 - (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift x (p2i !i)
                 - (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i)
        };
      done;
      !b

  (** [sub r x y sx sy] adds [(x, sx)] to [(y,sy)] and writes the
      result in [(r, sx)]. [sx] must be greater than or equal to
      [sy]. Returns borrow, either 0 or 1. Corresponds to [mpn_sub]. *)
  let sub (r x y:t) (sx sy:int32) : limb
    requires { 0 <= p2i sy <= p2i sx }
    requires { valid_ptr_itv x (p2i sx) }
    requires { valid_ptr_itv y (p2i sy) }
    requires { valid_ptr_itv r (p2i sx) }
    ensures { value_sub_shift r (p2i sx)  - power radix (p2i sx) * l2i result
              = value_sub_shift x (p2i sx) - value_sub_shift y (p2i sy) }
    ensures { 0 <= l2i result <= 1 }
    writes { r.data.contents.elts }
  =
    let limb_zero = Limb.of_int 0 in
    let lx = ref limb_zero in
    let ly = ref limb_zero in
    let b = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    let one = Int32.of_int 1 in
    while Int32.(<) !i sy do
      variant { p2i sy - p2i !i }
      invariant { 0 <= p2i !i <= p2i sy }
      invariant { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b =
                  value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i) }
      invariant { 0 <= l2i !b <= 1 }
      label StartLoop in
      lx := get_ofs x !i;
      ly := get_ofs y !i;
      let res, borrow = sub_with_borrow !lx !ly !b in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b =
                  value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i) };
      b := borrow;
      let ghost k = p2i !i in
      i := Int32.(+) !i one;
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      assert { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b =
              value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i)
              by
              value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
              = value_sub_shift r k + power radix k * l2i res
                - power radix (p2i !i) * l2i !b
              = value_sub_shift r k + power radix k * l2i res
                - (power radix k) * radix * l2i !b
              = value_sub_shift r k
                + power radix k * (l2i res - radix * l2i !b)
              = value_sub_shift r k
                + power radix k * (l2i !lx - l2i !ly - l2i (!b at StartLoop))
              = value_sub_shift r k - (power radix k) * l2i (!b at StartLoop)
                + power radix k * (l2i !lx - l2i !ly)
              = value_sub_shift x k - value_sub_shift y k
                + power radix k * (l2i !lx - l2i !ly)
              = value_sub_shift x k + power radix k * l2i !lx
                - value_sub_shift y k - power radix k * l2i !ly
              = value_sub_shift x (p2i !i)
                - (value_sub_shift y k + power radix k * l2i !ly)
              = value_sub_shift x (p2i !i) - value_sub_shift y (p2i !i) };
    done;
    while Int32.(<) !i sx do
      variant { p2i sx - p2i !i }
      invariant { p2i sy <= p2i !i <= p2i sx }
      invariant { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b =
                  value_sub_shift x (p2i !i) - value_sub_shift y (p2i sy) }
      invariant { 0 <= l2i !b <= 1 }
      label StartLoop2 in
      lx := get_ofs x !i;
      let res, borrow = sub_with_borrow !lx limb_zero !b in
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b =
      value_sub_shift x (p2i !i) - value_sub_shift y (p2i sy) };
      b := borrow;
      let ghost k = p2i !i in
      i := Int32.(+) !i one;
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      assert { value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b =
               value_sub_shift x (p2i !i) - value_sub_shift y (p2i sy)
            by
              value_sub_shift r (p2i !i) - power radix (p2i !i) * l2i !b
            = value_sub_shift r k + power radix k * l2i res
              - (power radix (p2i !i)) * l2i !b
            = value_sub_shift r k + power radix k * l2i res
              - (power radix k) * radix * l2i !b
            = value_sub_shift r k + power radix k * (l2i res - radix * l2i !b)
            = value_sub_shift r k
              + power radix k * (l2i !lx - 0 - l2i (!b at StartLoop2))
            = value_sub_shift r k - (power radix k) * l2i (!b at StartLoop2)
              + (power radix k) * l2i !lx
            = value_sub_shift x k - value_sub_shift y (p2i sy)
              + (power radix k) * l2i !lx
            = value_sub_shift x (p2i !i)
              - value_sub_shift y (p2i sy) }
    done;
    !b

    (** {2 Multiplication} *)

    (** [mul_limb r x y sz] multiplies [x[0..sz-1]] by the limb [y] and
    writes the n least significant limbs in [r], and returns the most
    significant limb. It corresponds to [mpn_mul_1]. *)
  let mul_limb (r x:t) (y:limb) (sz:int32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result
                = value_sub_shift x (p2i sz) * l2i y }
    writes { r.data.contents.elts }
  =
    let limb_zero = UInt32.of_int 0 in
    let lx = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) * l2i y }
      label StartLoop in
      lx := get_ofs x !i;
      let rl, rh = Limb.mul_double !lx y in
      let res, carry = Limb.add_with_carry rl !c limb_zero in
      label BeforeWrite in
      value_sub_shift_no_change (pelts r) r.offset (p2i !i) (p2i !i) res;
      set_ofs r !i res;
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
                  value_sub_shift x (p2i !i) * l2i y };
      assert { l2i rh < radix - 1
               by
               (l2i !lx * l2i y <= l2i !lx * (radix-1) <= (radix-1)*(radix-1)
                 by
                0 <= l2i !lx <= radix - 1 /\ 0 <= l2i y <= radix -1)
                 /\
               (radix * l2i rh <= l2i !lx * l2i y
                 by
               l2i rl + radix * l2i rh = l2i !lx * l2i y)
               so
               radix * l2i rh <= (radix -1) * (radix -1)
               };
      c := Limb.(+) rh carry;
      let ghost k = p2i !i in
      i := Int32.(+) !i (Int32.of_int 1);
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c =
               value_sub_shift x (p2i !i) * l2i y
               by
                 value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
               = value_sub_shift r k + (power radix k) * l2i res
                     + (power radix (p2i !i)) * l2i !c
               = value_sub_shift r k + (power radix k) * l2i res
                     + (power radix k) * radix * l2i !c
               = value_sub_shift r k + (power radix k) * (l2i res + radix * l2i !c)
               = value_sub_shift r k + (power radix k) *
                                   (l2i res + radix * (l2i rh + l2i carry))
               = value_sub_shift r k + (power radix k) *
                                   (l2i res + radix * l2i carry + radix * l2i rh)
               = value_sub_shift r k + (power radix k) *
                                   (l2i (!c at StartLoop) + l2i rl + radix*l2i rh)
               = value_sub_shift r k + (power radix k) *
                                   (l2i (!c at StartLoop) + l2i !lx * l2i y)
               = value_sub_shift r k + (power radix k) * l2i (!c at StartLoop)
                                 + (power radix k) * l2i !lx * l2i y
               = value_sub_shift x k * l2i y + (power radix k) * l2i !lx * l2i y
               = (value_sub_shift x k + (power radix k) * l2i !lx) * l2i y
               = value_sub_shift x (p2i !i) * l2i y
               };
    done;
    !c

  (** [addmul_limb r x y sz] multiplies [(x, sz)] by [i], adds the [sz]
      least significant limbs to [(r, sz)] and writes the result in [(r,sz)].
      Returns the most significant limb of the product plus the carry
      of the addition. Corresponds to [mpn_addmul_1].*)

  let addmul_limb (r x:t) (y:limb) (sz:int32):limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result
            = value_sub_shift (old r) (p2i sz)
              + value_sub_shift x (p2i sz) * l2i y }
    writes { r.data.contents.elts }
    ensures { forall j. j < r.offset \/ r.offset + p2i sz <= j ->
              (pelts r)[j] = (pelts (old r))[j] }
  =
    let limb_zero = Limb.of_int 0 in
    let lx = ref limb_zero in
    let lr = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
                 = value_sub_shift (old r) (p2i !i)
                   + value_sub_shift x (p2i !i) * l2i y }
      invariant { forall j. p2i !i <= j < p2i sz ->
                 (pelts (old r)) [r.offset+j] = (pelts r)[r.offset + j]  }
      invariant { forall j. j < r.offset \/ r.offset + p2i sz <= j ->
                 (pelts r)[j] = (pelts (old r))[j] }
      label StartLoop in
      let ghost k = p2i !i in
      lx := get_ofs x !i;
      lr := get_ofs r !i;
      assert { l2i !lr = l2i (pelts (old r))[r.offset+ p2i !i] };
      let rl, rh = Limb.mul_double !lx y in
      let res, carry = Limb.add3 !lr rl !c in
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts x) x.offset (x.offset + k);
      value_sub_update (pelts r) (r.offset + p2i !i) r.offset (r.offset + p2i !i +1) res;
      set_ofs r !i res;
      assert { forall j. (p2i !i + 1) <= j < p2i sz ->
               (pelts (old r))[r.offset+j] = (pelts r)[r.offset+j]
               by
               (pelts r)[r.offset+j] = ((pelts r) at StartLoop)[r.offset+j]
                                  = (pelts (old r))[r.offset+j] };
      assert { value_sub_shift r (p2i !i + 1)
              = value_sub_shift (r at StartLoop) (p2i !i + 1)
                + (power radix (p2i !i)) * (l2i res - l2i !lr) };
      assert { l2i rl + radix * l2i rh <= (radix-1)*(radix-1)
               by
               (l2i !lx * l2i y <= l2i !lx * (radix-1) <= (radix-1)*(radix-1)
                 by
                0 <= l2i !lx <= radix - 1 /\ 0 <= l2i y <= radix -1)
                /\
                l2i rl + radix * l2i rh = l2i !lx * l2i y
                };
      assert { l2i rh < radix - 1
               by
               l2i rl + radix * l2i rh  <= (radix -1) * (radix -1)
               so
               radix * l2i rh <= (radix -1) * (radix -1)
               };
      assert { l2i rh = radix - 2 -> l2i rl <= 1
               by
               l2i rl + radix * l2i rh <= (radix-1)*(radix-1) };
      assert { l2i rh = radix - 2 -> l2i carry <= 1
               by l2i rl <= 1 };
      c := Limb.(+) rh carry;
      i := Int32.(+) !i (Int32.of_int 1);
      assert { value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
                 = value_sub_shift (old r) (p2i !i)
                   + value_sub_shift x (p2i !i) * l2i y
               by
                (value_sub_shift r (p2i !i) + (power radix (p2i !i)) * l2i !c
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr)
                   + (power radix (p2i !i)) * l2i !c
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr)
                   + (power radix (p2i !i)) * (l2i rh + l2i carry)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr)
                   + (power radix k) * radix * (l2i rh + l2i carry)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res - l2i !lr
                                   + radix * (l2i rh + l2i carry))
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i res + radix * l2i carry
                          - l2i !lr + radix * l2i rh)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i rl + l2i !lr + l2i (!c at StartLoop)
                          - l2i !lr + radix * l2i rh)
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i rl + radix * l2i rh + l2i (!c at StartLoop))
                = value_sub_shift (r at StartLoop) (p2i !i) +
                   (power radix k) * (l2i !lx * l2i y + l2i (!c at StartLoop))
                = value_sub_shift (r at StartLoop) k
                    + (power radix k) * l2i !lr
                    + (power radix k) * (l2i !lx * l2i y + l2i (!c at StartLoop))
                = value_sub_shift (r at StartLoop) k
                    + (power radix k) * l2i (!c at StartLoop)
                    + (power radix k) * (l2i !lx * l2i y + l2i !lr)
                = value_sub_shift (old r) k
                    + value_sub_shift x k * l2i y
                    + (power radix k) * (l2i !lx * l2i y + l2i !lr)
                = value_sub_shift (old r) k
                    + (power radix k) * l2i !lr
                    + (value_sub_shift x k + (power radix k)*l2i !lx) * l2i y
                = value_sub_shift (old r) (p2i !i)
                    + (value_sub_shift x k + (power radix k)*l2i !lx) * l2i y
                = value_sub_shift (old r) (p2i !i)
                    + value_sub_shift x (p2i !i) * l2i y
                    by
                  value_sub_shift (old r) (p2i !i) = value_sub_shift (old r) k
                     + (power radix k) * l2i !lr
                     )
                    };
    done;
    !c

  (** [mul_limbs r x y sz] multiplies [(x, sz)] and [(y, sz)] and
  writes the result to [(r, 2*sz)]. [r] must not overlap with either
  [x] or [y]. Corresponds to [mpn_mul_n].  *)
  let mul_limbs (r x y:t) (sz:int32) : unit
    requires { p2i sz > 0 }
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    requires { valid_ptr_itv r (p2i sz +  p2i sz) }
    writes { r.data.contents.elts }
    ensures { value_sub_shift r (p2i sz + p2i sz)
              = value_sub_shift x (p2i sz) * value_sub_shift y (p2i sz) }
  =
    zero r sz;
    let limb_zero = Limb.of_int 0 in
    let one = Int32.of_int 1 in
    let rp = ref r in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sz do
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i !i) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { plength !rp = plength r }
      invariant { pelts !rp = pelts r }
      invariant { 0 <= l2i !c <= 1 }
      variant { p2i sz - p2i !i }
      label StartLoop in
      let ghost k = p2i !i in
      value_sub_concat (pelts r) r.offset (r.offset + k)
                       (r.offset + k + p2i sz);
      assert { value_sub_shift r k
             + (power radix k) * value_sub (pelts r) (r.offset + k)
                                                   (r.offset + k + p2i sz)
             = value_sub_shift r (k + p2i sz) };
      ly := get_ofs y !i;
      let c' =  addmul_limb !rp x !ly sz in
      assert { value_sub_shift !rp (p2i sz) + power radix (p2i sz) * l2i c'
              = value_sub_shift (!rp at StartLoop) (p2i sz)
                + value_sub_shift x (p2i sz) * l2i !ly };
      assert { MapEq.map_eq_sub (pelts r) (pelts r at StartLoop)
                r.offset (!rp).offset
                by (!rp).offset = r.offset + p2i !i
                so forall j. r.offset <= j < (!rp).offset
                   ->
                   (j < (!rp).offset
                    so (pelts !rp)[j] = (pelts !rp at StartLoop)[j]
                         = (pelts r at StartLoop)[j]) };
      let (res, carry) = add_with_carry c' limb_zero !c in
      label BeforeCarry in
      value_sub_update_no_change (pelts r) ((!rp).offset + p2i sz)
                        r.offset  (r.offset + p2i !i) res;
      set_ofs !rp sz res;
      c:= carry;
      i := Int32.(+) !i one;
      assert { value_sub_shift r k = value_sub_shift (r at BeforeCarry) k
             = value_sub_shift (r at StartLoop) k};
      value_sub_tail (pelts r) r.offset (r.offset + p2i sz + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      value_sub_concat (pelts r) r.offset (r.offset + k) (r.offset + k + p2i sz);
      assert { value_sub (pelts r) (r.offset+k) (r.offset+k+p2i sz)
               = value_sub_shift !rp (p2i sz) };
      assert { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i !i)
               by
                 power radix (k + p2i sz) = power radix k * power radix (p2i sz)
               so
                 value_sub_shift (r at StartLoop) k
                 + (power radix k) * value_sub (pelts r at StartLoop)
                                   (r.offset + k) (r.offset + k + p2i sz)
                 = value_sub_shift (r at StartLoop) (k + p2i sz)
               so
                 value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r (k + p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix k) * (power radix (p2i sz)) * radix * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i res + radix * l2i !c)
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i c' + l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sz)
                      + power radix (p2i sz) * l2i c'
                      + (power radix (p2i sz)) * l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift (!rp at StartLoop) (p2i sz)
                       + value_sub_shift x (p2i sz) * l2i !ly
                       + (power radix (p2i sz)) * l2i (!c at StartLoop))
               = value_sub_shift r k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub (pelts r at StartLoop) (r.offset+k)
                                              (r.offset+k+ p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix (k + p2i sz) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift x (p2i sz) * value_sub_shift y k
                + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift x (p2i sz) *
                 (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i)
             };
      rp := M.incr !rp one;
    done;
    value_sub_lower_bound (pelts r) r.offset (r.offset + p2i sz + p2i sz);
    value_sub_upper_bound (pelts x) x.offset (x.offset + p2i sz);
    value_sub_upper_bound (pelts y) y.offset (y.offset + p2i sz);
    assert { 0 <= value_sub_shift x (p2i sz) < power radix (p2i sz) };
    assert { 0 <= value_sub_shift y (p2i sz) < power radix (p2i sz) };
    prod_compat_strict_r (value_sub_shift y (p2i sz)) (power radix (p2i sz))
                         (power radix (p2i sz));
    assert { l2i !c = 0 by
             0 < power radix (p2i sz)
             so
             value_sub_shift r (p2i sz + p2i sz)
                    + (power radix (p2i sz + p2i sz)) * l2i !c
                  = value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i sz)
             so
             (power radix (p2i sz + p2i sz))*l2i !c <=
                    value_sub_shift x (p2i sz)
                    * value_sub_shift y (p2i sz)
                    <= (power radix (p2i sz)) * value_sub_shift y (p2i sz)
                    < (power radix (p2i sz))*(power radix (p2i sz))
             so
             (power radix (p2i sz + p2i sz))*l2i !c <
                    (power radix (p2i sz))*(power radix (p2i sz))  }

 let addmul_limbs (r x y:t) (sz:int32) : limb
    requires { p2i sz > 0 }
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv y (p2i sz) }
    requires { valid_ptr_itv r (p2i sz +  p2i sz) }
    writes { r.data.contents.elts }
    ensures { value_sub_shift r (p2i sz + p2i sz)
                + power radix (p2i sz + p2i sz) * l2i result
              = value_sub_shift (old r) (p2i sz + p2i sz)
                + value_sub_shift x (p2i sz) * value_sub_shift y (p2i sz) }
  =
    let limb_zero = Limb.of_int 0 in
    let one = Int32.of_int 1 in
    let rp = ref r in
    let ly = ref limb_zero in
    let lr = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    let rec lemma old_tail_shift (i:int)
      requires { i >= 0 }
      variant { i }
      ensures { value_sub_shift (old r) (i+1) = value_sub_shift (old r) i
              + power radix i * l2i (pelts (old r))[r.offset+i] }
      =
        if i > 0 then old_tail_shift (i-1) else assert {1+2=3}  in
    while Int32.(<) !i sz do
      invariant { 0 <= p2i !i <= p2i sz }
      invariant { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift (old r) (p2i !i + p2i sz)
                    + value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { r.data = (!rp).data }
      invariant { 0 <= l2i !c <= 1 }
      invariant { forall j. (!rp).offset + p2i sz <= j ->
                 (pelts (old r)) [j] = (pelts r)[j]  }
      variant { p2i sz - p2i !i }
      label StartLoop in
      let ghost k = p2i !i in
      value_sub_concat (pelts r) r.offset (r.offset + k)
                       (r.offset + k + p2i sz);
      assert { value_sub_shift r k
             + (power radix k) * value_sub (pelts r) (r.offset + k)
                                                   (r.offset + k + p2i sz)
             = value_sub_shift r (k + p2i sz) };
      ly := get_ofs y !i;
      let c' =  addmul_limb !rp x !ly sz in
      assert { value_sub_shift !rp (p2i sz) + power radix (p2i sz) * l2i c'
              = value_sub_shift (!rp at StartLoop) (p2i sz)
                + value_sub_shift x (p2i sz) * l2i !ly };
      assert { MapEq.map_eq_sub (pelts r) (pelts r at StartLoop)
                r.offset (!rp).offset
                by (!rp).offset = r.offset + p2i !i
                so forall j. r.offset <= j < (!rp).offset
                   ->
                   (j < (!rp).offset
                    so (pelts !rp)[j] = (pelts !rp at StartLoop)[j]
                         = (pelts r at StartLoop)[j]) };
      lr := get_ofs !rp sz;
      assert { l2i !lr = l2i (pelts (old r))[r.offset+ p2i !i + p2i sz] };
      let (res, carry) = add_with_carry c' !lr !c in
      label BeforeCarry in
      value_sub_update_no_change (pelts r) ((!rp).offset + p2i sz)
                        r.offset  (r.offset + p2i !i) res;
      set_ofs !rp sz res;
      assert { value_sub_shift !rp (p2i sz) = value_sub_shift (!rp at BeforeCarry) (p2i sz) };
      c:= carry;
      i := Int32.(+) !i one;
      assert { value_sub_shift r k = value_sub_shift (r at BeforeCarry) k
             = value_sub_shift (r at StartLoop) k};
      value_sub_tail (pelts r) r.offset (r.offset + p2i sz + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      old_tail_shift (k+p2i sz);
      value_sub_concat (pelts r) r.offset (r.offset + k) (r.offset + k + p2i sz);
      assert { value_sub (pelts r) (r.offset+k) (r.offset+k+p2i sz)
               = value_sub_shift !rp (p2i sz) };
      assert { value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
                  = value_sub_shift (old r) (p2i !i + p2i sz)
                    + value_sub_shift x (p2i sz)
                      * value_sub_shift y (p2i !i)
               by
                 power radix (k + p2i sz) = power radix k * power radix (p2i sz)
               so
                 value_sub_shift (r at StartLoop) k
                 + (power radix k) * value_sub (pelts r at StartLoop)
                                   (r.offset + k) (r.offset + k + p2i sz)
                 = value_sub_shift (r at StartLoop) (k + p2i sz)
               so (value_sub_shift (old r) (p2i !i+p2i sz)
                  = value_sub_shift (old r) (k+p2i sz)
                  + power radix (k+p2i sz) * l2i !lr
                  by l2i !lr = l2i (pelts (old r))[r.offset + k + p2i sz])
               so
                  value_sub_shift !rp (p2i sz) + (power radix (p2i sz)) * l2i c' =
                  value_sub_shift (!rp at StartLoop) (p2i sz)
                  + value_sub_shift x (p2i sz) * l2i !ly
               so
                 value_sub_shift r (p2i !i + p2i sz)
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r (k + p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix (k + p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix (p2i !i + p2i sz)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz)) * l2i res
                    + (power radix k) * (power radix (p2i sz)) * radix * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i res + radix * l2i !c)
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sz)
                    + (power radix k) * (power radix (p2i sz))
                             * (l2i c' + l2i (!c at StartLoop) + l2i !lr)
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sz)
                      + power radix (p2i sz) * (l2i c'+ l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sz)
                      + power radix (p2i sz) * l2i c'
                      + power radix (p2i sz) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift (!rp at StartLoop) (p2i sz)
                       + value_sub_shift x (p2i sz) * l2i !ly
                       + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift r k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub (pelts r at StartLoop) (r.offset+k)
                                              (r.offset+k+ p2i sz))
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * (value_sub_shift x (p2i sz) * l2i !ly
                    + (power radix (p2i sz)) * (l2i (!c at StartLoop) + l2i !lr))
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop) + l2i !lr)
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix k * power radix (p2i sz) * (l2i (!c at StartLoop) + l2i !lr)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix (k + p2i sz) * (l2i (!c at StartLoop) + l2i !lr)
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sz)
                 + power radix (k + p2i sz) * (l2i (!c at StartLoop))
                 + power radix (k + p2i sz) * l2i !lr
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (old r) (k+p2i sz)
                 + value_sub_shift x (p2i sz) * value_sub_shift y k
                 + power radix (k + p2i sz) * l2i !lr
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (old r) (k+p2i sz)
                 + power radix (k + p2i sz) * l2i !lr
                 + value_sub_shift x (p2i sz) * value_sub_shift y k
                 + power radix k * value_sub_shift x (p2i sz) * l2i !ly
               = value_sub_shift (old r) (k+p2i sz)
                 + power radix (k + p2i sz) * l2i !lr
                 + value_sub_shift x (p2i sz) * (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift (old r) (k+p2i sz)
                 + power radix (k + p2i sz) * l2i !lr
                 + value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i)
               = value_sub_shift (old r) (p2i !i +p2i sz)
                 + value_sub_shift x (p2i sz) * value_sub_shift y (p2i !i)
             };
      rp := M.incr !rp one;
    done;
    !c

  (** [mul r x y sx sy] multiplies [(x, sx)] and [(y,sy)] and writes
  the result in [(r, sx+sy)]. [sx] must be greater than or equal to
  [sy]. Corresponds to [mpn_mul]. *)
  let mul (r x y:t) (sx sy:int32) : unit
    requires { 0 < p2i sy <= p2i sx }
    requires { valid_ptr_itv x (p2i sx) }
    requires { valid_ptr_itv y (p2i sy) }
    requires { valid_ptr_itv r (p2i sy + p2i sx) }
    writes { r.data.contents.elts }
    ensures { value_sub_shift r (p2i sy + p2i sx)
              = value_sub_shift x (p2i sx) * value_sub_shift y (p2i sy) }
  =
    zero r sx;
    let limb_zero = Limb.of_int 0 in
    let one = Int32.of_int 1 in
    let rp = ref r in
    let ly = ref limb_zero in
    let c = ref limb_zero in
    let i = ref (Int32.of_int 0) in
    while Int32.(<) !i sy do
      invariant { 0 <= p2i !i <= p2i sy }
      invariant { value_sub_shift r (p2i !i + p2i sx)
                    + (power radix (p2i !i + p2i sx)) * l2i !c
                  = value_sub_shift x (p2i sx)
                      * value_sub_shift y (p2i !i) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { plength !rp = plength r }
      invariant { pelts !rp = pelts r }
      invariant { 0 <= l2i !c <= 1 }
      variant { p2i sy - p2i !i }
      label StartLoop in
      let ghost k = p2i !i in
      value_sub_concat (pelts r) r.offset (r.offset + k)
                       (r.offset + k + p2i sx);
      assert { value_sub_shift r k
             + (power radix k) * value_sub (pelts r) (r.offset + k)
                                                   (r.offset + k + p2i sx)
             = value_sub_shift r (k + p2i sx) };
      ly := get_ofs y !i;
      let c' =  addmul_limb !rp x !ly sx in
      assert { value_sub_shift !rp (p2i sx) + power radix (p2i sx) * l2i c'
              = value_sub_shift (!rp at StartLoop) (p2i sx)
                + value_sub_shift x (p2i sx) * l2i !ly };
      assert { MapEq.map_eq_sub (pelts r) (pelts r at StartLoop)
                r.offset (!rp).offset
                by (!rp).offset = r.offset + p2i !i
                so forall j. r.offset <= j < (!rp).offset
                   ->
                   (j < (!rp).offset
                    so (pelts !rp)[j] = (pelts !rp at StartLoop)[j]
                         = (pelts r at StartLoop)[j]) };
      let (res, carry) = add_with_carry c' limb_zero !c in
      label BeforeCarry in
      value_sub_update_no_change (pelts r) ((!rp).offset + p2i sx)
                        r.offset  (r.offset + p2i !i) res;
      set_ofs !rp sx res;
      c:= carry;
      i := Int32.(+) !i one;
      assert { value_sub_shift r k = value_sub_shift (r at BeforeCarry) k
             = value_sub_shift (r at StartLoop) k};
      value_sub_tail (pelts r) r.offset (r.offset + p2i sx + k);
      value_sub_tail (pelts y) y.offset (y.offset + k);
      value_sub_concat (pelts r) r.offset (r.offset + k) (r.offset + k + p2i sx);
      assert { value_sub (pelts r) (r.offset+k) (r.offset+k+p2i sx)
               = value_sub_shift !rp (p2i sx) };
      assert { value_sub_shift r (p2i !i + p2i sx)
                    + (power radix (p2i !i + p2i sx)) * l2i !c
                  = value_sub_shift x (p2i sx)
                      * value_sub_shift y (p2i !i)
               by
                 power radix (k + p2i sx) = power radix k * power radix (p2i sx)
               so
                 value_sub_shift (r at StartLoop) k
                 + (power radix k) * value_sub (pelts r at StartLoop)
                                   (r.offset + k) (r.offset + k + p2i sx)
                 = value_sub_shift (r at StartLoop) (k + p2i sx)
               so
                 value_sub_shift r (p2i !i + p2i sx)
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r (k + p2i sx)
                    + (power radix (k + p2i sx)) * l2i res
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix (k + p2i sx)) * l2i res
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx)) * l2i res
                    + (power radix (p2i !i + p2i sx)) * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx)) * l2i res
                    + (power radix k) * (power radix (p2i sx)) * radix * l2i !c
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx))
                             * (l2i res + radix * l2i !c)
               = value_sub_shift r k
                    + (power radix k) * value_sub_shift !rp (p2i sx)
                    + (power radix k) * (power radix (p2i sx))
                             * (l2i c' + l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift !rp (p2i sx)
                      + power radix (p2i sx) * l2i c'
                      + (power radix (p2i sx)) * l2i (!c at StartLoop))
               = value_sub_shift r k + (power radix k)
                    * (value_sub_shift (!rp at StartLoop) (p2i sx)
                       + value_sub_shift x (p2i sx) * l2i !ly
                       + (power radix (p2i sx)) * l2i (!c at StartLoop))
               = value_sub_shift r k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sx))
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub_shift (!rp at StartLoop) (p2i sx))
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) k
                 + power radix k * (value_sub (pelts r at StartLoop) (r.offset+k)
                                              (r.offset+k+ p2i sx))
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix k * (value_sub_shift x (p2i sx) * l2i !ly
                    + (power radix (p2i sx)) * (l2i (!c at StartLoop)))
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix k * value_sub_shift x (p2i sx) * l2i !ly
                 + power radix k * power radix (p2i sx) * (l2i (!c at StartLoop))
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix k * power radix (p2i sx) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sx) * l2i !ly
               = value_sub_shift (r at StartLoop) (k + p2i sx)
                 + power radix (k + p2i sx) * (l2i (!c at StartLoop))
                 + power radix k * value_sub_shift x (p2i sx) * l2i !ly
               = value_sub_shift x (p2i sx) * value_sub_shift y k
                + power radix k * value_sub_shift x (p2i sx) * l2i !ly
               = value_sub_shift x (p2i sx) *
                 (value_sub_shift y k + power radix k * l2i !ly)
               = value_sub_shift x (p2i sx) * value_sub_shift y (p2i !i)
             };
      rp := M.incr !rp one;
    done;
    value_sub_lower_bound (pelts r) r.offset (r.offset + p2i sy + p2i sx);
    value_sub_upper_bound (pelts x) x.offset (x.offset + p2i sx);
    value_sub_upper_bound (pelts y) y.offset (y.offset + p2i sy);
    assert { 0 <= value_sub_shift x (p2i sx) < power radix (p2i sx) };
    assert { 0 <= value_sub_shift y (p2i sy) < power radix (p2i sy) };
    prod_compat_strict_r (value_sub_shift y (p2i sy)) (power radix (p2i sy))
                         (power radix (p2i sx));
    assert { l2i !c = 0 by
             0 < power radix (p2i sx)
             so
             value_sub_shift r (p2i sy + p2i sx)
                    + (power radix (p2i sy + p2i sx)) * l2i !c
                  = value_sub_shift x (p2i sx)
                      * value_sub_shift y (p2i sy)
             so
             (power radix (p2i sy + p2i sx))*l2i !c <=
                    value_sub_shift x (p2i sx)
                    * value_sub_shift y (p2i sy)
                    <= (power radix (p2i sx)) * value_sub_shift y (p2i sy)
                    < (power radix (p2i sx))*(power radix (p2i sy))
             so
             (power radix (p2i sx + p2i sy))*l2i !c <
                    (power radix (p2i sx))*(power radix (p2i sy))  }


  (** {2 Logical operations} *)

  use import int.ComputerDivision

  (* is a logical lemma in ComputerDivision*)
  let lemma mod_mult (x y z:int)
    requires { x > 0 /\ y >= 0 /\ z >= 0}
    ensures { mod (x * y + z) x = mod z x }
  =
    ()

  val lsld (x cnt:limb) : (limb,limb)
    requires { 0 < l2i cnt < 32 }
    returns { (r,d) -> l2i r + radix * l2i d =
              (power 2 (l2i cnt)) * l2i x }

  let lemma pow2_32 ()
    ensures { power 2 32 = radix }
  =
    assert { power 2 2 = 4 };
    assert { power 2 4 = (power 2 2)*(power 2 2) };
    assert { power 2 8 = (power 2 4)*(power 2 4) };
    assert { power 2 16 = (power 2 8)*(power 2 8) };
    assert { power 2 32 = (power 2 16)*(power 2 16) = radix };
    ()

  let lsld_ext (x cnt:limb) : (limb,limb)
    requires { 0 < l2i cnt < 32 }
    returns { (r,d) -> l2i r + radix * l2i d =
              (power 2 (l2i cnt)) * l2i x }
    returns { (r,_d) ->  mod (l2i r) (power 2 (l2i cnt)) = 0 }
    returns { (r,_d) ->  l2i r <= radix - (power 2 (l2i cnt)) }
    returns { (_r,d) -> l2i d < power 2 (l2i cnt) }
  =
    let r,d = lsld x cnt in
    let p = power 2 (l2i cnt) in
    let q = power 2 (32 - l2i cnt) in
    assert { p > 0 /\ q > 0 };
    assert { radix = p * q by
                radix = power 2 32 = power 2 (l2i cnt + (32 - l2i cnt))
                = p*q };
    assert { mod radix p = 0
             by mod radix p
                = mod (p * q + 0) p
                = mod 0 p
                = 0 };
    assert { l2i r < radix };
    mod_mult p (q*l2i d) (l2i r);
    mod_mult p (l2i x) 0;
    assert { mod (l2i r) p = 0
             by
             mod (l2i r) p = mod (p * (q * l2i d) + l2i r) p
             so p * (q * l2i d) = radix * l2i d
             so mod (l2i r) p = mod (radix * l2i d + l2i r) p
                = mod (p * l2i x) p
                = mod 0 p
                = 0 };
    assert { l2i r <= radix - p
             by
             l2i r = p * (div (l2i r) p) + (mod (l2i r) p)
                   = p * (div (l2i r) p)
             so
             radix = p * q
             so
             l2i r < radix
             so (div (l2i r) p >= q -> (l2i r = p * div (l2i r) p >= p*q = radix)
                                   -> false)
             so div (l2i r) p <= q-1
             so l2i r = p * div (l2i r) p <= p * (q-1) = p*q - p = radix - p };
    assert { l2i d < p
             by
             l2i r + radix * l2i d = p * l2i x
             so
             radix * l2i d <= p * l2i x
             so
             l2i x < radix /\ p > 0
             so p * l2i x < p * radix
             so radix * l2i d < p * radix
             so l2i d < p
             };
    (r,d)

  val lsl (x cnt:limb) : limb
    requires { 0 < l2i cnt < 32 }
    ensures { l2i result =
              (l2i x) * (mod (power 2 (l2i cnt)) radix) }

  val lsr (x cnt:limb) : limb
    requires { 0 < l2i cnt < 32 }
    ensures { l2i result = div (l2i x) (power 2 (l2i cnt)) }

  (** [lshift r x sz cnt] shifts [(x,sz)] [cnt] bits to the left and
      writes the result in [(r, sz)]. Returns the [cnt] most significant
      bits of [(x, sz)]. Corresponds to [mpn_lshift]. *)
  (*TODO overlapping allowed if r >= x*)
  let lshift (r x:t) (sz:int32) (cnt:uint32) : limb
    requires { 0 < l2i cnt < 32 }
    requires { valid_ptr_itv r (p2i sz) }
    requires { valid_ptr_itv x (p2i sz) }
    requires { 0 < p2i sz }
    ensures { value_sub_shift r (p2i sz) + (power radix (p2i sz)) * l2i result =
              value_sub_shift x (p2i sz) * (power 2 (l2i cnt)) }
  =
    let limb_zero = Limb.of_int 0 in
    let zero = Int32.of_int 0 in
    let one = Int32.of_int 1 in
    let minus_one = Int32.of_int (-1) in
    let msb = Int32.(-) sz one in
    let xp = ref (M.incr x msb) in
    let rp = ref (M.incr r msb) in
    let high = ref limb_zero in
    let low = ref (M.get !xp) in
    let i = ref msb in
    let l, retval = lsld_ext !low cnt in
    high := l;
    while (Int32.(>) !i zero) do
      variant { p2i !i }
      invariant { 0 <= p2i !i < p2i sz }
      invariant { radix * value_sub (pelts r) (r.offset + 1 + p2i !i) (r.offset + p2i sz)
                  + (power radix (p2i sz - p2i !i)) * l2i retval + l2i !high
                = value_sub_shift !xp (p2i sz - p2i !i)
                  * (power 2 (l2i cnt)) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { (!xp).offset = x.offset + p2i !i }
      invariant { plength !rp = plength r }
      invariant { pelts !rp = pelts r }
      invariant { plength !xp = plength x }
      invariant { pelts !xp = pelts x }
      invariant { l2i !high <= radix - power 2 (l2i cnt) }
      label StartLoop in
      xp := M.incr !xp minus_one;
      low := M.get !xp;
      let l,h = lsld_ext !low cnt in
      assert { l2i !high + l2i h < radix  };
      let ghost v = Limb.(+) !high h in
      value_sub_update_no_change (pelts r) (!rp).offset (r.offset + 1+ p2i !i)
                                 (r.offset + p2i sz) v;
      M.set !rp (Limb.(+) !high h);
      rp := M.incr !rp minus_one;
      high := l;
      let ghost k = p2i !i in
      i := Int32.(-) !i one;
      value_sub_head (pelts r) (r.offset + k) (r.offset + p2i sz);
      value_sub_head (pelts !xp) (!xp).offset (x.offset + p2i sz);
      assert { radix
               * value_sub (pelts r) (r.offset + k) (r.offset + p2i sz)
               + (power radix (p2i sz - p2i !i)) * l2i retval + l2i !high
              = value_sub_shift !xp (p2i sz - p2i !i)
                * (power 2 (l2i cnt))
             by
               l2i (pelts r)[r.offset + k]
             = l2i (pelts r)[(!rp.offset at StartLoop)]
             = l2i (!high at StartLoop) + l2i h
             so
                power radix (p2i sz - p2i !i)
              = power radix (p2i sz - (k - 1))
              = power radix ((p2i sz - k) +1)
              = radix * power radix (p2i sz - k)
             so
              l2i !low = l2i (pelts x)[(!xp).offset]
             so
               radix * value_sub (pelts r) (r.offset + k) (r.offset + p2i sz)
                + (power radix (p2i sz - p2i !i)) * l2i retval + l2i !high
             = radix * value_sub (pelts r) (r.offset + k) (r.offset + p2i sz)
                + radix * (power radix (p2i sz - k)) * l2i retval + l2i !high
             = radix * ( l2i (pelts r)[r.offset + k]
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz)))
               + radix * (power radix (p2i sz - k)) * l2i retval + l2i !high
             =  radix * ( l2i (!high at StartLoop) + l2i h
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz)))
               + radix * (power radix (p2i sz - k)) * l2i retval + l2i !high
             = radix * ( l2i (!high at StartLoop)
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz)))
               + radix * l2i h
               + radix * (power radix (p2i sz - k)) * l2i retval + l2i !high
             = radix * ( l2i (!high at StartLoop)
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz)))
               + radix * l2i h
               + radix * (power radix (p2i sz - k)) * l2i retval + l2i l
             = radix * ( l2i (!high at StartLoop)
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz)))
               + radix * (power radix (p2i sz - k)) * l2i retval + l2i l
               + radix * l2i h
             = radix * ( l2i (!high at StartLoop)
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz)))
               + radix * (power radix (p2i sz - k)) * l2i retval
               + (power 2 (l2i cnt)) * l2i !low
             = radix * ( l2i (!high at StartLoop)
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz)))
               + radix * (power radix (p2i sz - k)) * l2i retval
               + (power 2 (l2i cnt)) * l2i (pelts x)[(!xp).offset]
             = radix * ( l2i (!high at StartLoop)
                          + radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz))
                          + power radix (p2i sz - k) * l2i retval )
               + (power 2 (l2i cnt)) * l2i (pelts x)[(!xp).offset]
             = radix * ( radix * (value_sub (pelts r)
                                         (r.offset + 1 + k) (r.offset + p2i sz))
                         + power radix (p2i sz - k) * l2i retval
                         + l2i (!high at StartLoop) )
               + (power 2 (l2i cnt)) * l2i (pelts x)[(!xp).offset]
             = radix * value_sub_shift (!xp at StartLoop) (p2i sz - k)
                     * (power 2 (l2i cnt))
               + (power 2 (l2i cnt)) * l2i (pelts x)[(!xp).offset]
             = (power 2 (l2i cnt)) *
                      (l2i (pelts x)[(!xp).offset]
                      + radix * value_sub_shift (!xp at StartLoop) (p2i sz - k))
             = (power 2 (l2i cnt)) * value_sub_shift !xp (p2i sz - p2i !i)
   };
   done;
   assert { l2i !high + radix * value_sub (pelts r) (r.offset + 1) (r.offset + p2i sz)
                  + (power radix (p2i sz)) * l2i retval
                = value_sub_shift !xp (p2i sz)
                  * (power 2 (l2i cnt)) };
   value_sub_head (pelts r) r.offset (r.offset + p2i sz);
   value_sub_update_no_change (pelts r) r.offset (r.offset+1)
                              (r.offset + p2i sz) !high;
   M.set r !high;
   retval

  (** [rshift r x sz cnt] shifts [(x,sz)] [cnt] bits to the right and
      writes the result in [(r, sz)]. Returns the [cnt] least significant
      bits of [(x, sz)]. Corresponds to [mpn_rshift]. *)
  (*TODO overlapping allowed if r <= x*)
  let rshift (r x:t) (sz:int32) (cnt:uint32) : limb
    requires { valid_ptr_itv x (p2i sz) }
    requires { valid_ptr_itv r (p2i sz) }
    requires { 0 < l2i cnt < 32 }
    requires { 0 < p2i sz }
    ensures { l2i result + radix * value_sub_shift r (p2i sz)
              = value_sub_shift x (p2i sz) * (power 2 (32- l2i cnt)) }
  =
    let tnc = UInt32.(-) (UInt32.of_int 32) cnt in
    let limb_zero = Limb.of_int 0 in
    let zero = Int32.of_int 0 in
    let one = Int32.of_int 1 in
    let msb = Int32.(-) sz one in
    let xp = ref x in
    let rp = ref r in
    let high = ref (M.get !xp) in
    let retval, h = lsld_ext !high tnc in
    let low = ref h in
    let i = ref zero in
    while (Int32.(<) !i msb) do
      variant { p2i sz - p2i !i }
      invariant { 0 <= p2i !i <= p2i msb }
      invariant { l2i retval + radix * (value_sub_shift r (p2i !i)
                  + (power radix (p2i !i)) * l2i !low)
                  = value_sub_shift x (1 + p2i !i) * (power 2 (l2i tnc)) }
      invariant { (!rp).offset = r.offset + p2i !i }
      invariant { (!xp).offset = x.offset + p2i !i }
      invariant { plength !rp = plength r }
      invariant { plength !xp = plength x }
      invariant { pelts !rp = pelts r }
      invariant { pelts !xp = pelts x }
      invariant { l2i !low < power 2 (l2i tnc) }
      label StartLoop in
      let ghost k = p2i !i in
      xp := M.incr !xp one;
      high := M.get !xp;
      let l,h = lsld_ext !high tnc in
      assert { l2i !low + l2i l < radix };
      let ghost v = Limb.(+) !low l in
      value_sub_shift_no_change (pelts r) r.offset (p2i !i) (p2i !i) v;
      M.set !rp (Limb.(+) !low l);
      assert { value_sub_shift r k = value_sub_shift (r at StartLoop) k };
      rp := M.incr !rp one;
      low := h;
      i := Int32.(+) !i one;
      value_sub_tail (pelts r) r.offset (r.offset + k);
      value_sub_tail (pelts r) x.offset (x.offset + p2i !i);
      assert { l2i retval + radix * (value_sub_shift r (p2i !i)
                 + (power radix (p2i !i)) * l2i !low)
                 = value_sub_shift x (1 + p2i !i) * (power 2 (l2i tnc))
               by
                 l2i (pelts r)[r.offset + k]
               = l2i (pelts r)[(!rp.offset at StartLoop)]
               = l2i (!low at StartLoop) + l2i l
               so
                 l2i !high = l2i (pelts x)[(!xp).offset]
               so
                 l2i retval + radix * (value_sub_shift r (p2i !i)
                                      + (power radix (p2i !i)) * l2i !low)
               = l2i retval + radix * (value_sub_shift r k
                              + power radix k * l2i (pelts r)[r.offset+k]
                              + power radix (p2i !i) * l2i !low)
               = l2i retval + radix * (value_sub_shift r k
                              + power radix k * (l2i (!low at StartLoop) + l2i l)
                              + power radix (p2i !i) * l2i !low)
               = l2i retval + radix * (value_sub_shift r k
                              + power radix k * l2i (!low at StartLoop)
                              + power radix k * l2i l
                              + power radix (p2i !i) * l2i !low)
               = l2i retval + radix * (value_sub_shift r k
                              + power radix k * l2i (!low at StartLoop))
                 + radix * (power radix k * l2i l
                            + power radix (p2i !i) * l2i !low)
               = value_sub_shift x (k+1) * power 2 (l2i tnc)
                 + radix * (power radix k * l2i l
                            + power radix (p2i !i) * l2i !low)
               = value_sub_shift x (p2i !i) * power 2 (l2i tnc)
                 + radix * (power radix k * l2i l
                            + power radix (p2i !i) * l2i !low)
               = value_sub_shift x (p2i !i) * power 2 (l2i tnc)
                 + radix * (power radix k * l2i l
                            + power radix k * radix * l2i !low)
               = value_sub_shift x (p2i !i) * power 2 (l2i tnc)
                 + radix * (power radix k * (l2i l + radix * l2i !low))
               = value_sub_shift x (p2i !i) * power 2 (l2i tnc)
                 + radix * (power radix k * l2i !high * power 2 (l2i tnc))
               = value_sub_shift x (p2i !i) * power 2 (l2i tnc)
                 + power radix (p2i !i) * l2i !high * power 2 (l2i tnc)
               = (value_sub_shift x (p2i !i) + power radix (p2i !i) * l2i !high)
                 * power 2 (l2i tnc)
               = (value_sub_shift x (p2i !i)
                  + power radix (p2i !i) * l2i (pelts x)[x.offset + p2i !i])
                 * power 2 (l2i tnc)
               = value_sub_shift x (1 + p2i !i) * power 2 (l2i tnc)
      };
    done;
    label EndLoop in
    assert { l2i retval + radix * (value_sub_shift r (p2i msb)
                  + (power radix (p2i msb)) * l2i !low)
             = value_sub_shift x (p2i sz) * (power 2 (l2i tnc)) };
    value_sub_tail (pelts r) r.offset (r.offset + p2i msb);
    assert { (!rp).offset = r.offset + p2i msb };
    value_sub_shift_no_change (pelts r) r.offset (p2i sz) (p2i sz) !low;
    M.set !rp !low;
    assert { value_sub_shift r (p2i sz)
           = value_sub_shift r (p2i msb) + power radix (p2i msb) * l2i !low };
    assert { value_sub_shift r (p2i sz)
           = value_sub_shift (r at EndLoop) (p2i msb)
             + power radix (p2i msb) * l2i !low
           by
           value_sub_shift r (p2i msb) = value_sub_shift (r at EndLoop) (p2i msb)
           };
    retval

  (** {2 Division} *)

  (** Based on Niels Mller and Torbjrn Granlund, Improved
      division by invariant integers 2010 *)

  use import int.MinMax

  val invert_limb (d:limb) : limb
    requires { l2i d >= div radix 2 }
    ensures { l2i result = (div (radix*radix - 1) (l2i d)) - radix }


  let div2by1_inv (uh ul d v:limb) : (limb,limb)
    requires { l2i d >= div radix 2 }
    requires { l2i uh < l2i d }
    requires { l2i v = (div (radix*radix - 1) (l2i d)) - radix }
    returns { q,r -> l2i q * l2i d + l2i r = l2i ul + radix * l2i uh }
    returns { _q, r -> 0 <= l2i r < l2i d }
  =
    let zero = Limb.of_int 0 in
    let one = Limb.of_int 1 in
    let ghost k = radix * radix - (radix + l2i v) * l2i d in
    assert { 1 <= k <= l2i d };
    let l,h = mul_double v uh in
    let sl,c = add_with_carry l ul zero in
    let sh,c' = add_with_carry uh h c in  (* <c',sh,sl> = <uh, ul> + <h,l> *)
    assert { l2i sl + radix * l2i sh + radix * radix * l2i c'
    	     = l2i l + radix * l2i h + l2i ul + radix * l2i uh };
    assert { l2i c' = 0
    	     by
	     l2i uh < l2i d
	     so l2i v * l2i uh <= l2i v * l2i d
	     so k = radix * radix - (radix + l2i v) * l2i d
	     	  = radix * radix - radix * l2i d - l2i v * l2i d
             so l2i v * l2i d = radix * radix - radix * l2i d - k
	     	      	      = radix * (radix - l2i d) - k
	     so k > 0
	     so l2i v * l2i d < radix * (radix - l2i d)
	     so l2i v * l2i uh < radix * (radix - l2i d)
	     so l2i l + radix * l2i h = l2i v * l2i uh
	     so l2i l + radix * l2i h < radix * (radix - l2i d)
	     so l2i uh <= l2i d - 1
	     so radix * l2i uh <= radix * (l2i d - 1) = radix * l2i d - radix
	     so l2i l + radix * l2i h + radix * l2i uh
	     	< radix * (radix - l2i d) + radix * l2i uh
	     	<= radix * (radix - l2i d) + radix * l2i d - radix
		<= radix * (radix - l2i d + l2i d) - radix = radix * radix - radix
             so l2i ul < radix
	     so l2i l + radix * l2i h + l2i ul + radix * l2i uh
	     	= l2i l + radix * l2i h + radix * l2i uh + l2i ul
		< radix * radix - radix + l2i ul
		< radix * radix - radix + radix = radix * radix
	     so l2i sl + radix * l2i sh + radix * radix * l2i c'
	     	= l2i l + radix * l2i h + l2i ul + radix * l2i uh
		< radix * radix
             so radix * radix * l2i c' <= l2i sl + radix * l2i sh + radix * radix * l2i c'
	     so radix * radix * l2i c' < radix * radix
     };
    assert { l2i sl + radix * l2i sh = l2i l + radix * l2i h + l2i ul + radix * l2i uh
    	     = l2i v * l2i uh + l2i ul + radix * l2i uh
	     = l2i ul + (radix + l2i v) * l2i uh };
    let ql = ref sl in
    let qh = ref sh in
    let ghost q0 = l2i !ql in
    let ghost cq = l2i sh + 1 in (*candidate quotient*)
    let ghost cr = l2i ul - cq * l2i d + radix * l2i uh in (*candidate remainder*)
    assert { cq * l2i d + cr = l2i ul + radix * l2i uh };
    qh := add_mod !qh one;
    assert { l2i !qh = mod cq radix };
    let p = mul_mod !qh d in
    let r = ref (sub_mod ul p) in
    let ghost r' = l2i !r in
    assert { r' = mod cr radix
    	     by
	     let a = (- div (l2i !qh * l2i d) radix) in
	     r' = l2i !r
	     = mod (l2i ul - l2i p) radix
	     = mod (l2i ul - mod (l2i !qh * l2i d) radix) radix
	     = mod (radix * a
	       	   + l2i ul - mod (l2i !qh * l2i d) radix) radix
	     = mod (l2i ul - mod (l2i !qh * l2i d) radix
	         	   - radix * div (l2i !qh * l2i d) radix) radix
	     = mod (l2i ul - l2i !qh * l2i d) radix
	     = mod (l2i ul - mod cq radix * l2i d) radix
	     = mod (radix * (- (div cq radix)) * l2i d + l2i ul - mod cq radix * l2i d) radix
	     = mod (l2i ul - (mod cq radix + radix * div cq radix) * l2i d) radix
	     = mod (l2i ul - cq * l2i d) radix
	     = mod (radix * l2i uh + l2i ul - cq * l2i d) radix
	     = mod (l2i ul - cq * l2i d + radix * l2i uh) radix
	     = mod cr radix };
    assert { radix * cr = l2i uh * k + l2i ul * (radix - l2i d) + q0 * l2i d - radix * l2i d };
    assert { (* Theorem 2 of Mller&Granlund 2010 *)
    	     (max (radix - l2i d) (q0 + 1)) - radix <= cr < max (radix - l2i d) q0
	     by radix * cr = l2i uh * k + l2i ul * (radix - l2i d) + q0 * l2i d - radix * l2i d
	     so (l2i uh * k + l2i ul * (radix - l2i d) >= 0
	     	by l2i uh >= 0 /\ k >= 0 /\ l2i ul >= 0 /\ radix - l2i d >= 0)
	     so radix * cr >= q0 * l2i d - radix * l2i d
	     so radix * cr >= - radix * l2i d
	     so cr >= - l2i d
	     so radix * cr >= q0 * l2i d - radix * l2i d = (q0 - radix) * l2i d
	     so radix > l2i d
	     so cr >= q0 - radix
	     so 1 <= k < d so l2i uh < l2i d
	     so l2i uh * k < l2i d * k < l2i d * l2i d
	     so radix * cr < l2i d * l2i d + l2i ul * (radix - l2i d) + q0 * l2i d - radix * l2i d
	     so l2i ul < radix
	     so radix - l2i d > 0
	     so l2i ul * (radix - l2i d) < radix * (radix - l2i d)
	     so radix * cr < l2i d * l2i d + radix * (radix - l2i d) + q0 * l2i d - radix * l2i d
	     so (radix * cr = (radix - l2i d) * (radix - l2i d) + q0 * l2i d
	     	by
	     	l2i d * l2i d + radix * (radix - l2i d) + q0 * l2i d - radix * l2i d
			= radix * (radix - l2i d) + l2i d * l2i d - radix * l2i d + q0 * l2i d
			= radix * (radix - l2i d) + (l2i d - radix) l2i d +  q0 * l2i d
			= radix * (radix - l2i d) - l2i d (radix - l2i d) + q0 * l2i d
			= (radix - l2i d) * (radix - l2i d) + q0 * l2i d)
	     so let m = max (radix - l2i d) q0 in
	     	radix - l2i d <= m
	     so (radix - l2i d) * (radix - l2i d) <= m* (radix - l2i d)
	     so q0 * l2i d <= m * l2i d
	     so radix * cr = (radix - l2i d) * (radix - l2i d) + q0 * l2i d
	     	      	   <= m* (radix - l2i d) + q0 * l2i d
			   <= m* (radix - l2i d) + m * l2i d
			   = m * radix
	     so cr <= m
		 )
	   };
    assert { cr >= 0 -> r' = cr };
    assert { cr < 0 -> r' = cr + radix };
    assert { cr < 0 ->
    	     	( l2i !r > l2i !ql
		by max (radix - l2i d) (q0 + 1) >= q0 + 1 > q0
		so cr >= (max (radix - l2i d) (q0 +1)) - radix > q0 - radix
		so r' = cr + radix > q0 - radix + radix = q0 ) };
    if Limb.(>) !r !ql
    then begin
      qh := sub_mod !qh one;
      r := add_mod !r d;
      assert { cr >= 0 ->
    	       	  ( l2i !r >= l2i d
		  by r' = cr
		  so r' < max (radix - l2i d) q0
		  so r' > q0
		  so 0 <= r' < radix - l2i d
		  so l2i d <= r' + l2i d < radix
		  so l2i !r = mod (r' + l2i d) radix >= l2i d ) };
      assert { cr < 0 ->
      	          ( 0 <= l2i !r < l2i d
		  by r' = cr + radix < radix
		  so cr >= max (radix - l2i d) (q0 + 1) - radix >= radix - l2i d - radix = - l2i d
		  so r' = cr + radix >= radix - l2i d
		  so l2i !r = mod (r' + l2i d) radix
		  so radix + radix >= r' + l2i d >= radix
		  so l2i !r = mod (r' + l2i d) radix = r' + l2i d - radix
		  so l2i !r >= 0
		  so l2i !r = r' + l2i d - radix < l2i d )
	    };
    end
    else assert { cr >= 0 };
    assert { l2i !qh * l2i d + l2i !r = l2i ul + radix * l2i uh };
    if Limb.(>=) !r d
    then begin
      assert { cr >= 0 };
      assert { l2i !qh < radix - 1
      	       by
	       l2i !qh * l2i d = l2i ul + radix * l2i uh  - l2i !r
	       so l2i uh <= l2i d - 1
	       so l2i ul + radix * l2i uh - l2i !r
	       	  <= l2i ul + radix * (l2i d - 1) - l2i !r
		  = l2i ul + radix * l2i d - radix - l2i !r
		  = (l2i ul - radix)  + radix * l2i d - l2i !r
		  <  radix * l2i d - l2i !r
		  <= radix * l2i d - l2i d
		  = (radix - 1) * l2i d
	       so l2i !qh * l2i d < (radix - 1) * l2i d
	       so l2i d > 0
	       so l2i !qh < radix - 1 };
      qh := Limb.(+) !qh one;
      r := Limb.(-) !r d;
      assert { 0 <= l2i !r < l2i d };
      assert { l2i !qh * l2i d + l2i !r = l2i ul + radix * l2i uh };
    end;
    assert { 0 <= l2i !r < l2i d };
    assert { l2i !qh * l2i d + l2i !r = l2i ul + radix * l2i uh };
    (!qh,!r)




  let main () = from_limb (Limb.of_int 42)

end




(*
module Heap

  type elt


  type base

  type ptr model { base: base; mutable offset:int }

  (** heap of memory blocks storing values of type elt *)
  type heap = {

    ghost mutable length : map base int;  (* returns -1 for non-allocated block *)
    ghost mutable contents : map base (map int elt);
  }

  val ghost h : heap

  (** operation [*p] *)
  val get (p : ptr) :elt
    requires { 0 <= p.offset < h.length[p.base] }
    reads { h }
    ensures { result = h.contents[p.base][p.offset] }

  (** operations [p+i], [p[i]] *)

  val malloc(n:int32):ptr
    requires { n >= 0 }
    writes  { h.length }
    ensures { result.offset = 0 }
    ensures { h.length[result.base] = n  }
    ensures { (old h).length[result.base] = -1  }
    ensures { forall b:base. b <> result.base -> (old h).length[b] = h,length[b]  }


  val free ...

end
*)