
(* AVL parameters: a binary tree structure
   (exact representation is unknown), + a positive balancing
   constant. *)
module AVLParams
  
  use import int.Int
  
  (* Data stored in the tree nodes. It is polymorphic so that
     instances may be polymorphic as well. The tree is not fully polymorphic
     so that storage can be specialized for different instances of data. *)
  type data 'a 'b
  (* Model for data stored in nodes. *)
  type data_model 'a 'b
  (* Data structure invariant. *)
  predicate data_correct (data 'a 'b)
  (* Model function. *)
  function data_model (d:data 'a 'b) : data_model 'a 'b
  
  (* Abstract binary tree structure. *)
  type t 'a 'b
  (* Model of the tree structure. *)
  type tree_model 'a 'b =
    | Empty
    | Node (tree_model 'a 'b) (data_model 'a 'b) (tree_model 'a 'b) int
  (* One-step unraveling of the abstract tree structure (pattern-matching). *)
  type t_view 'a 'b =
    | VEmpty
    | VNode (t 'a 'b) (data 'a 'b) (t 'a 'b) int
  
  (* Tree representation invariant. *)
  predicate t_correct (t 'a 'b)
  (* Model function for tree. *)
  function t_model (t 'a 'b) : tree_model 'a 'b
  
  (* Construction/pattern-matching over the tree. *)
  val t_empty () : t 'a 'b
    ensures { t_model result = Empty }
    ensures { t_correct result }
  
  val t_node (l:t 'a 'b) (d:data 'a 'b) (r:t 'a 'b) (h:int) : t 'a 'b
    requires { t_correct l /\ data_correct d /\ t_correct r }
    ensures { t_model result = Node (t_model l) (data_model d) (t_model r) h }
    ensures { t_correct result }
  
  val t_view (t:t 'a 'b) : t_view 'a 'b
    ensures { match result with
      | VEmpty -> t_model t = Empty
      | VNode l d r h ->
        t_model t = Node (t_model l) (data_model d) (t_model r) h /\
        t_correct l /\ data_correct d /\ t_correct r end }
  
  (* Balancing constant for the tree. This will bound
     the height difference between the subtrees at a node of
     the avl. Larger constant mean deeper trees but less
     balancing operations. *)
  constant balancing : int
  axiom balancing_positive : balancing > 0
  
end

module AVL
  
  use import int.Int
  use import bool.Bool
  use import list.Append
  use import HighOrd
  
  clone export AVLParams
  
  (* Model of the avl as a list. *)
  type list_model 'a 'b = list (data_model 'a 'b)
  
  function node_model (l:list_model 'a 'b)
    (d:data_model 'a 'b)
    (r:list_model 'a 'b) : list_model 'a 'b = l ++ Cons d r
  
  (* Model of an avl as the list obtained by infix traversal. *)
  function list_model (t:tree_model 'a 'b) : list_model 'a 'b = match t with
      | Empty -> Nil
      | Node l d r _ -> node_model (list_model l) d (list_model r)
    end
  
  (* Height of the tree. *)
  function real_height (t:tree_model 'a 'b) : int = match t with
      | Empty -> 0
      | Node l _ r _ -> let hl = real_height l in let hr = real_height r in
        1 + if hl < hr then hr else hl
    end
  
  let rec lemma real_height_nonnegative (t:tree_model 'a 'b) : unit
    ensures { real_height t >= 0 }
    variant { t }
  =
    match t with
      | Empty -> ()
      | Node l _ r _ -> real_height_nonnegative l;
        real_height_nonnegative r
    end
  
  (* Balanced tree + correctness of stored height. *)
  predicate balanced (t:tree_model 'a 'b) = match t with
      | Empty -> true
      | Node l _ r h -> h = real_height t /\
        -balancing <= real_height r - real_height l <= balancing /\
        balanced l /\ balanced r
    end
  
  (* Well-formedness of the data is guaranteed by the parameters.
     We also allow user to specify additional properties satisfied
     by the stored data. *)
  predicate avl_data_correct (inv:data_model 'a 'b -> bool)
    (t:tree_model 'a 'b) = match t with
      | Empty -> true
      | Node l d r _ ->
        avl_data_correct inv l /\ inv d /\ avl_data_correct inv r
    end
  
  (* Tree rotations are the core of balancing, so we show that
     they preserve the model. *)
  lemma rotation_preserve_model : forall ld rd:data_model 'a 'b,
    fl fm fr:list_model 'a 'b.
      node_model (node_model fl ld fm) rd fr =
      node_model fl ld (node_model fm rd fr)
  
  (* Avl type. *)
  type avl 'a 'b = {
    (* Representation as a binary tree. *)
    repr : t 'a 'b;
    (* Additional invariant on stored data. *)
    ghost data_inv : data_model 'a 'b -> bool;
    (* Model as a list. *)
    ghost model : list_model 'a 'b;
  }
  
  predicate avl_correct (a:avl 'a 'b) =
    let tm = t_model a.repr in
    balanced tm /\
    a.model = list_model tm /\
    avl_data_correct a.data_inv tm /\
    t_correct a.repr
  
  (* Shortcut for tree height. *)
  function avl_height (a:avl 'a 'b) : int =
    real_height (t_model a.repr)
  
  lemma avl_height_nonnegative : forall a:avl 'a 'b.
    avl_correct a -> avl_height a >= 0
  
  (* Get the height of the avl. *)
  let height (a:avl 'a 'b) : int
    requires { avl_correct a }
    ensures { result = avl_height a }
  = match t_view a.repr with VEmpty -> 0 | VNode _ _ _ h -> h end
  
  (* Constructors. *)
  (* The empty avl. *)
  let empty (ghost dinv:data_model 'a 'b -> bool) : avl 'a 'b
    ensures { avl_correct result }
    ensures { result.model = Nil }
    ensures { result.data_inv = dinv }
    ensures { avl_height result = 0 }
  =
    { repr = t_empty (); data_inv = dinv; model = Nil }
  
  (* Node. Restricted to perfect balancing. *)
  let node (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) : avl 'a 'b
    requires { l.data_inv = r.data_inv }
    requires { avl_correct l /\ data_correct d /\ avl_correct r }
    requires { r.data_inv (data_model d) }
    requires { -balancing <= avl_height l - avl_height r <= balancing }
    ensures { result.data_inv = l.data_inv }
    ensures { avl_height result = let hl = avl_height l in
      let hr = avl_height r in 1 + if hl < hr then hr else hl }
    ensures { avl_correct result }
    ensures { result.model = node_model l.model (data_model d) r.model }
  =
    let hl = height l in let hr = height r in
    let h = 1 + if hl < hr then hr else hl in
    { repr = t_node l.repr d r.repr h;
      data_inv = r.data_inv;
      model = node_model l.model (data_model d) r.model }
  
  (* Useful constructor. *)
  let singleton (ghost dinv:data_model 'a 'b -> bool) (d:data 'a 'b) : avl 'a 'b
    requires { data_correct d /\ dinv (data_model d) }
    ensures { avl_correct result }
    ensures { result.data_inv = dinv }
    ensures { result.model = Cons (data_model d) Nil }
    ensures { avl_height result = 1 }
  =
    let e = t_empty () in
    { repr = t_node e d e 1; data_inv = dinv; model = Cons (data_model d) Nil }
  
  (* View of an avl, in similar fashion to t_view. *)
  type avl_view 'a 'b =
    | AEmpty
    | ANode (avl 'a 'b) (data 'a 'b) (avl 'a 'b) int
  
  (* Pattern-matching. *)
  let view (a:avl 'a 'b) : avl_view 'a 'b
    requires { avl_correct a }
    ensures { match result with
        | AEmpty -> a.avl_height = 0 /\ a.model = Nil
        | ANode l d r h -> a.model = node_model l.model (data_model d) r.model /\
          l.data_inv = a.data_inv = r.data_inv /\
          avl_correct l /\ data_correct d /\ avl_correct r /\
          a.data_inv (data_model d) /\
          let hl = avl_height l in let hr = avl_height r in
          -balancing <= hl - hr <= balancing /\
           avl_height a = h = 1 + if hl < hr then hr else hl
      end }
  =
    match t_view a.repr with
      | VEmpty -> AEmpty
      | VNode l d r h -> ANode
        { repr = l; data_inv = a.data_inv; model = list_model (t_model l) }
        d
        { repr = r; data_inv = a.data_inv; model = list_model (t_model r) }
        h
    end
  
  (* Emptyness test. *)
  
  let is_empty (a:avl 'a 'b) : bool
    requires { avl_correct a }
    ensures { result <-> a.model = Nil }
  =
    match t_view a.repr with
      | VEmpty -> true
      | _ -> false
    end
  
  (* Node constructor, defective balancing allowed in input. *)
  let balance (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) : avl 'a 'b
    requires { l.data_inv = r.data_inv }
    requires { avl_correct l /\ data_correct d /\ avl_correct r }
    requires { r.data_inv (data_model d) }
    requires { -balancing-1 <= avl_height l - avl_height r <= balancing+1 }
    ensures { result.data_inv = l.data_inv }
    ensures { let hl = avl_height l in let hr = avl_height r in
      let he = 1 + if hl < hr then hr else hl in
      let hres = avl_height result in
      0 <= he - hres <= 1 /\
      (* Necessary in order to prove that fuse change the height
         by at most one. *)
      (-balancing <= hl - hr <= balancing -> he = hres) }
    ensures { avl_correct result }
    ensures { result.model = node_model l.model (data_model d) r.model }
  =
    (* Wonderful case of automatic proof ! *)
    let hl = height l in
    let hr = height r in
    let df = hl - hr in
    if df > balancing
    then match view l with
        | AEmpty -> absurd
        | ANode ll ld lr _ ->
          if height ll >= height lr
          then node ll ld (node lr d r)
          else match view lr with
              | AEmpty -> absurd
              | ANode lrl lrd lrr _ ->
                node (node ll ld lrl) lrd (node lrr d r)
            end
      end
    else if df < -balancing
    then match view r with
        | AEmpty -> absurd
        | ANode rl rd rr _ ->
          if height rr >= height rl
          then node (node l d rl) rd rr
          else match view rl with
              | AEmpty -> absurd
              | ANode rll rld rlr _ ->
                node (node l d rll) rld (node rlr rd rr)
            end
      end
    else node l d r
  
  (* Decompose l ++ [d] ++ r as head :: tail, but with avl. Internal
     function. *)
  let rec remove_first_on_node (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) :
     (data 'a 'b,avl 'a 'b)
     requires { avl_correct l /\ data_correct d /\ avl_correct r }
     requires { -balancing <= avl_height l - avl_height r <= balancing }
     requires { l.data_inv (data_model d) /\ l.data_inv = r.data_inv }
     variant { avl_height l }
     returns { (d2,res) -> node_model l.model (data_model d) r.model =
       Cons (data_model d2) res.model /\
       let hl = avl_height l in
       let hr = avl_height r in
       let he = 1 + if hl < hr then hr else hl in
       0 <= he - avl_height res <= 1 /\
       res.data_inv = r.data_inv /\
       l.data_inv (data_model d2) /\
       data_correct d2 /\
       avl_correct res
     }
   =
     match view l with
       | AEmpty -> (d,r)
       | ANode l d2 r2 _ -> let (d3,left) = remove_first_on_node l d2 r2 in
         (d3,balance left d r)
     end
  
  (* Decompose l ++ [d] ++ r as cotail ++ [cohead], but with avl. Internal
     function. *)
  let rec remove_last_on_node (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) :
     (avl 'a 'b,data 'a 'b)
     requires { avl_correct l /\ data_correct d /\ avl_correct r }
     requires { -balancing <= avl_height l - avl_height r <= balancing }
     requires { l.data_inv (data_model d) /\ l.data_inv = r.data_inv }
     variant { avl_height r }
     returns { (res,d2) -> node_model l.model (data_model d) r.model =
       res.model ++ Cons (data_model d2) Nil /\
       let hl = avl_height l in
       let hr = avl_height r in
       let he = 1 + if hl < hr then hr else hl in
       0 <= he - avl_height res <= 1 /\
       res.data_inv = r.data_inv /\
       l.data_inv (data_model d2) /\
       data_correct d2 /\
       avl_correct res
     }
   =
     match view r with
       | AEmpty -> (l,d)
       | ANode l2 d2 r _ -> let (right,d3) = remove_last_on_node l2 d2 r in
         (balance l d right,d3)
     end
  
  (* Decompose an avl into head::tail. Requires non-emptyness. *)
  let remove_first (t:avl 'a 'b) : (data 'a 'b,avl 'a 'b)
    requires { avl_correct t }
    requires { t.model <> Nil }
    returns { (d,res) -> t.model = Cons (data_model d) res.model /\
        0 <= avl_height t - avl_height res <= 1 /\
        res.data_inv = t.data_inv /\
        t.data_inv (data_model d) /\
        data_correct d /\
        avl_correct res }
   =
     match view t with
       | AEmpty -> absurd
       | ANode l d r _ -> remove_first_on_node l d r
     end
  
  (* Decompose an avl into cotail ++ [cohead]. Requires non-emptyness. *)
  let remove_last (t:avl 'a 'b) : (avl 'a 'b,data 'a 'b)
    requires { avl_correct t }
    requires { t.model <> Nil }
    returns { (res,d) -> t.model = res.model ++ Cons (data_model d) Nil /\
      0 <= avl_height t - avl_height res <= 1 /\
      res.data_inv = t.data_inv /\
      t.data_inv (data_model d) /\
      data_correct d /\
      avl_correct res }
  =
    match view t with
      | AEmpty -> absurd
      | ANode l d r _ -> remove_last_on_node l d r
    end
  
  (* Concatenation of avl, balancing hypothesis on inputs. *)
  let fuse (l r:avl 'a 'b) : avl 'a 'b
    requires { avl_correct l /\ avl_correct r /\ l.data_inv = r.data_inv }
    requires { -balancing <= avl_height l - avl_height r <= balancing }
    ensures { avl_correct result /\ result.data_inv = l.data_inv }
    ensures { let hl = avl_height l in let hr = avl_height r in
      let he = 1 + if hl < hr then hr else hl in
      1 >= he - avl_height result >= 0 }
    ensures { result.model = l.model ++ r.model }
  =
    match view l with
      | AEmpty -> r
      | ANode _ _ _ _ -> match view r with
          | AEmpty -> l
          | ANode rl rd rr _ -> let (d0,r') = remove_first_on_node rl rd rr in
            balance l d0 r'
        end
    end
  
  
  (* list cons with avl. *)
  let rec avl_cons (d:data 'a 'b) (a:avl 'a 'b) : avl 'a 'b
    requires { data_correct d /\ avl_correct a /\ a.data_inv (data_model d) }
    ensures { avl_correct result /\ result.data_inv = a.data_inv }
    ensures { result.model = Cons (data_model d) a.model }
    ensures { 1 >= avl_height result - avl_height a >= 0 }
    variant { avl_height a }
  =
    match view a with
      | AEmpty -> singleton a.data_inv d
      | ANode l d2 r _ -> balance (avl_cons d l) d2 r
    end
  
  (* Reverse cons with avl. *)
  let rec avl_snoc (a:avl 'a 'b) (d:data 'a 'b) : avl 'a 'b
    requires { avl_correct a /\ data_correct d /\ a.data_inv (data_model d) }
    ensures { avl_correct result /\ result.data_inv = a.data_inv }
    ensures { result.model = a.model ++ Cons (data_model d) Nil }
    ensures { 1 >= avl_height result - avl_height a >= 0 }
    variant { avl_height a }
  =
    match view a with
      | AEmpty -> singleton a.data_inv d
      | ANode l d2 r _ -> balance l d2 (avl_snoc r d)
    end
  
  (* Node constructor, allow no balancing at all for inputs. *)
  let rec join (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) : avl 'a 'b
    requires { avl_correct l /\ data_correct d /\ avl_correct r }
    requires { l.data_inv = r.data_inv /\ l.data_inv (data_model d) }
    ensures { result.model = node_model l.model (data_model d) r.model }
    ensures { avl_correct result /\ result.data_inv = l.data_inv }
    ensures { let hl = avl_height l in let hr = avl_height r in
      let he = 1 + if hl < hr then hr else hl in
      let hres = avl_height result in
      0 <= he - hres <= 1 }
    variant { avl_height l + avl_height r }
  =
    match view l with
      | AEmpty -> avl_cons d r
      | ANode ll ld lr lh -> match view r with
          | AEmpty -> avl_snoc l d
          | ANode rl rd rr rh -> let df = lh - rh in
            if df > balancing
            then balance ll ld (join lr d r)
            else if df < -balancing
            then balance (join l d rl) rd rr
            else node l d r
        end
    end
  
  (* Avl concatenation, without balancing hypothesis on inputs. *)
  let concat (l:avl 'a 'b) (r:avl 'a 'b) : avl 'a 'b
    requires { avl_correct l /\ avl_correct r /\ l.data_inv = r.data_inv }
    ensures { avl_correct result /\ result.data_inv = l.data_inv }
    ensures { result.model = l.model ++ r.model }
    (* This post is true (but not with 1 instead of 2). However,
        *)
    (*ensures { let hl = avl_height l in let hr = avl_height r in
      let he = 1 + if hl < hr then hr else hl in
      2 >= he - avl_height result >= 0 }*)
  =
    match view l with
      | AEmpty -> r
      | ANode _ _ _ _ -> match view r with
          | AEmpty -> l
          | ANode rl rd rr _ -> let (d0,r') = remove_first_on_node rl rd rr in
            join l d0 r'
        end
    end
  
  (*(* Alternative to concat, performing one more test to
     ensures that heights remain inside a 1-sized interval.
     However, do not feel like it has any use. *)
  let concat_2 (l:avl 'a 'b) (r:avl 'a 'b) : avl 'a 'b
    requires { avl_correct l /\ avl_correct r /\ l.data_inv = r.data_inv }
    ensures { avl_correct result /\ result.data_inv = l.data_inv }
    ensures { result.model = l.model ++ r.model }
    ensures { let hl = avl_height l in let hr = avl_height r in
      let he = 1 + if hl < hr then hr else hl in
      1 >= he - avl_height result >= 0 }
  =
    match view l with
      | AEmpty -> r
      | ANode ll ld lr lh -> match view r with
          | AEmpty -> l
          | ANode rl rd rr rh -> if lh > rh
            then let (d0,r') = remove_first_on_node rl rd rr in
              join l d0 r'
            else let (l',d0) = remove_last_on_node ll ld lr in
              join l' d0 r
        end
    end*)
  
  (* Enumeration. *)
  
  use import list.Reverse
  use import option.Option
  
  (* Missing in list.Reverse. *)
  let rec lemma reverse_append_gen (l1 l2:list 'a) : unit
    ensures { reverse (l1 ++ l2) = reverse l2 ++ reverse l1 }
    variant { l1 }
  =
    match l1 with
      | Nil -> ()
      | Cons _ q -> reverse_append_gen q l2
    end
  
  (* AVL enumeration. *)
  type avl_enum_base 'a 'b =
    | End
    | More (data 'a 'b) (avl 'a 'b) (avl_enum_base 'a 'b)
  
  (* left-to-right enumeration model. *)
  function avl_enum_model_lr (e:avl_enum_base 'a 'b) : list_model 'a 'b =
    match e with
      | End -> Nil
      | More d r q ->
        Cons (data_model d) (r.model ++ avl_enum_model_lr q)
    end
  
  (* right-to-left version. *)
  function avl_enum_model_rl (e:avl_enum_base 'a 'b) : list_model 'a 'b =
    match e with
      | End -> Nil
      | More d l q ->
        Cons (data_model d) (reverse l.model ++ avl_enum_model_rl q)
    end
  
  predicate avl_enum_base_correct (di:data_model 'a 'b -> bool)
    (e:avl_enum_base 'a 'b) =
    match e with
      | End -> true
      | More d a next ->
        data_correct d /\ avl_correct a /\ avl_enum_base_correct di next /\
        a.data_inv = di /\ di (data_model d)
    end
  
  (* Wrapping in a record. *)
  type avl_enum 'a 'b = {
    enum_repr : avl_enum_base 'a 'b;
    ghost enum_inv : data_model 'a 'b -> bool;
    ghost enum_model : list_model 'a 'b;
    ghost left_to_right : bool;
  }
  
  predicate avl_enum_correct (e:avl_enum 'a 'b) =
    avl_enum_base_correct e.enum_inv e.enum_repr /\
    e.enum_model = if e.left_to_right
      then avl_enum_model_lr e.enum_repr
      else avl_enum_model_rl e.enum_repr
  
  (* create empty enumeration. *)
  let empty_enum (ghost ltr:bool)
    (ghost dinv:data_model 'a 'b -> bool) : avl_enum 'a 'b
    ensures { result.left_to_right = ltr }
    ensures { result.enum_model = Nil }
    ensures { result.enum_inv = dinv }
    ensures { avl_enum_correct result }
  = { enum_repr = End; enum_inv = dinv; enum_model = Nil; left_to_right = ltr }
  
  (* Convert avl to left-to-right enumeration. *)
  let rec avl_to_enum_lr (t:avl 'a 'b) (acc:avl_enum 'a 'b) : avl_enum 'a 'b
    requires { avl_correct t /\ avl_enum_correct acc }
    requires { acc.enum_inv = t.data_inv /\ acc.left_to_right }
    ensures { avl_enum_correct result /\ result.enum_inv = t.data_inv }
    ensures { result.left_to_right }
    ensures { result.enum_model = t.model ++ acc.enum_model }
    variant { avl_height t }
  =
    match view t with
      | AEmpty -> acc
      | ANode l d r _ -> avl_to_enum_lr l
        { acc with enum_repr = More d r acc.enum_repr;
          enum_model = Cons (data_model d) (r.model ++ acc.enum_model) }
    end
  
  (* Right-to-left variant. *)
  let rec avl_to_enum_rl (t:avl 'a 'b) (acc:avl_enum 'a 'b) : avl_enum 'a 'b
    requires { avl_correct t /\ avl_enum_correct acc }
    requires { acc.enum_inv = t.data_inv /\ not acc.left_to_right }
    ensures { avl_enum_correct result /\ result.enum_inv = t.data_inv }
    ensures { not result.left_to_right }
    ensures { result.enum_model = (reverse t.model) ++ acc.enum_model }
    variant { avl_height t }
  =
    match view t with
      | AEmpty -> acc
      | ANode l d r _ -> avl_to_enum_rl r
        { acc with enum_repr = More d l acc.enum_repr;
          enum_model =
            Cons (data_model d) ((reverse l.model) ++ acc.enum_model) }
    end
  
  let enumerate_lr (e:avl_enum 'a 'b) : option (data 'a 'b,avl_enum 'a 'b)
    requires { avl_enum_correct e }
    requires { e.left_to_right }
    returns { None -> e.enum_model = Nil
      | Some (d,r) -> e.enum_model = Cons (data_model d) r.enum_model /\
        avl_enum_correct r /\ r.enum_inv = e.enum_inv /\
        data_correct d /\ e.enum_inv (data_model d) /\
        r.left_to_right }
  =
    match e.enum_repr with
      | End -> None
      | More d r q -> Some (d,avl_to_enum_lr r
        { e with enum_repr = q; enum_model =
          (* Feel justified, since for some reason current version of
             Why3 refuse direct (ghost!) calls to the logic function.
             I believe there is some obscure reason about ghost field
             in avls that make Why3 believe it is an impure program type.
             If current version of why3 supports it, one can simplify
             those lines by removing the axiom. *)
          any list_model 'a 'b ensures { result = avl_enum_model_lr q } })
    end
  
  let enumerate_rl (e:avl_enum 'a 'b) : option (data 'a 'b,avl_enum 'a 'b)
    requires { avl_enum_correct e }
    requires { not e.left_to_right }
    returns { None -> e.enum_model = Nil
      | Some (d,r) -> e.enum_model = Cons (data_model d) r.enum_model /\
        avl_enum_correct r /\ r.enum_inv = e.enum_inv /\
        data_correct d /\ e.enum_inv (data_model d) /\
        not r.left_to_right }
  =
    match e.enum_repr with
      | End -> None
      | More d l q -> Some (d,avl_to_enum_rl l
        { e with enum_repr = q; enum_model =
          (* Same as above. *)
          any list_model 'a 'b ensures { result = avl_enum_model_rl q } })
    end
  
end

(* Addition/Removal/Etc(split,etc) algorithm based on selection.
   Basic idea: functions add/remove/split/etc on an avl do
     not need an order over the stored data, but rather a
     position in the list model and code to find that selection.
     A position in a list can be two things:
     1) an element of the list, i.e a cut [...] ++  e ++ [...]
     2) a "hole" inside a list, i.e a cut [...] ++ [...]
     It happens (not a coincidence) that this it corresponds exactly to
     the return type of split.
   Possible usages:
   - Search over ordered avl, e.g ordered associative table.
   - Cut at the "minimum element over k", in an ordered associative table.
   - Index search over an avl, e.g random access list
     (the tree representation would need to store
     the cardinal at every node for efficiency reasons)
   Note: it would also work for non-deterministic selection.
     The result would be unspecified within the set of selected elements. *)
module AVLSelection
  
  use import int.Int
  use import bool.Bool
  use import list.Append
  use import option.Option
  use import HighOrd
  
  clone import AVL as A
  
  (* Position in a list l: cut l either as
     left ++ right or left ++ [middle] ++ right.
     Note: position computation corresponds exactly to avl splitting. *)
  type position 'a 'b = {
    left : list_model 'a 'b;
    middle : option (data_model 'a 'b);
    right : list_model 'a 'b;
  }
  
  
  (* Data used to perform the selection. *)
  type selector 'a 'b
  
  (* Correctness of the selector with respect to a list. *)
  predicate selector_correct (s:selector 'a 'b) (l:list_model 'a 'b)
  
  (* A selector selects a position in a list. *)
  predicate selected (s:selector 'a 'b) (e:position 'a 'b)
    (l:list_model 'a 'b)
  
  (* Way to the position. *)
  type way 'a 'b= Left (selector 'a 'b)
    | Right (selector 'a 'b)
    | Here
  
  (* Any selected position in a list is a correct
     emplacement for this list. *)
  axiom selected_append : forall s,e,l:list_model 'a 'b.
    selected s e l /\ selector_correct s l -> match e.middle with
      | Some d -> l = node_model e.left d e.right
      | None -> l = e.left ++ e.right
    end
  (* A correct selector always select the only possible position
     in the empty list. *)
  axiom selector_correct_empty : forall s:selector 'a 'b.
    selector_correct s Nil ->
      selected s { left = Nil ; middle = None ; right = Nil } Nil
  
  (* Program version of way selection. *)
  val selected_way (s:selector 'a 'b)
    (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) : way 'a 'b
    requires { l.data_inv = r.data_inv }
    requires { data_correct d /\ l.data_inv (data_model d) }
    requires { avl_correct l /\ avl_correct r }
    requires { selector_correct s (node_model l.model (data_model d) r.model) }
    (* A selected position can be found by following the given way. *)
    returns { Here -> selected s { left = l.model;
        middle = Some (data_model d);
        right = r.model }
        (node_model l.model (data_model d) r.model)
      | Left sl -> selector_correct sl l.model /\
        forall e. selected sl e l.model ->
        selected s { e with right = node_model e.right (data_model d) r.model }
          (node_model l.model (data_model d) r.model)
      | Right sr -> selector_correct sr r.model /\
        forall e. selected sr e r.model ->
        selected s { e with left = node_model l.model (data_model d) e.left }
          (node_model l.model (data_model d) r.model) }
  
  use import ref.Ref
  
  (* create a dummy position. *)
  let ghost default_position () : position 'a 'b =
    { left = Nil; middle = None; right = Nil }
  
  (* Selection-based destructive addition.
     Note: both addition and removal could be implemented
     by first splitting along the desired position,
     then rebuilding the avl completely, but that would be
     computationally more expensive. *)
  let rec add (ghost r:ref (position 'a 'b)) (s:selector 'a 'b)
    (d:data 'a 'b) (a:avl 'a 'b) : avl 'a 'b
    requires { selector_correct s a.model }
    requires { avl_correct a }
    requires { data_correct d /\ a.data_inv (data_model d) }
    ensures { result.model = node_model !r.left (data_model d) !r.right }
    ensures { selected s !r a.model }
    ensures { 1 >= avl_height result - avl_height a >= 0 }
    ensures { avl_correct result }
    ensures { result.data_inv = a.data_inv }
    variant { avl_height a }
    writes { r }
  =
    match view a with
      | AEmpty -> r := { left = Nil; middle = None; right = Nil};
        singleton a.data_inv d
      | ANode al ad ar _ -> match selected_way s al ad ar with
          | Left sl -> let nl = add r sl d al in
            r := { !r with right =
              node_model !r.right (data_model ad) ar.model };
            balance nl ad ar
          | Right sr -> let nr = add r sr d ar in
            r := { !r with left =
              node_model al.model (data_model ad) !r.left };
            balance al ad nr
          | Here -> r := { left = al.model;
              middle = Some (data_model ad);
              right = ar.model };
            node al d ar
        end
    end
  
  (* Selection-based removal. *)
  let rec remove (ghost r:ref (position 'a 'b)) (s:selector 'a 'b)
    (a:avl 'a 'b) : avl 'a 'b
    requires { selector_correct s a.model }
    requires { avl_correct a }
    ensures { result.model = !r.left ++ !r.right }
    ensures { selected s !r a.model }
    ensures { 1 >= avl_height a - avl_height result >= 0 }
    ensures { avl_correct result }
    ensures { result.data_inv = a.data_inv }
    variant { avl_height a }
    writes { r }
  =
    match view a with
      | AEmpty -> r := { left = Nil; middle = None; right = Nil}; a
      | ANode al ad ar _ -> match selected_way s al ad ar with
          | Left sl -> let nl = remove r sl al in
            r := { !r with right =
              node_model !r.right (data_model ad) ar.model };
            balance nl ad ar
          | Right sr -> let nr = remove r sr ar in
            r := { !r with left =
              node_model al.model (data_model ad) !r.left };
            balance al ad nr
          | Here -> r := { left = al.model;
              middle = Some (data_model ad);
              right = ar.model };
            fuse al ar
        end
    end
  
  (* Splitting. *)
  let rec split (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
    (a:avl 'a 'b) : (avl 'a 'b,option (data 'a 'b),avl 'a 'b)
    requires { avl_correct a }
    requires { selector_correct s a.model }
    returns { (l,o,r) ->
      !p.left = l.model /\ !p.right = r.model /\
      !p.middle = match o with None -> None | Some d -> Some (data_model d) end
      /\ selected s !p a.model /\
      avl_correct l /\ avl_correct r /\ match o with
        | None -> true | Some d -> data_correct d /\ a.data_inv (data_model d)
      end /\ l.data_inv = a.data_inv /\ r.data_inv = a.data_inv }
    variant { avl_height a }
    writes { p }
  =
    match view a with
      | AEmpty -> p := { left = Nil; middle = None; right = Nil };
        (a,None,a)
      | ANode al ad ar _ -> match selected_way s al ad ar with
          | Left sl -> let (all,ald,alr) = split p sl al in
            p := { !p with right =
              node_model !p.right (data_model ad) ar.model };
            (all,ald,join alr ad ar)
          | Right sr -> let (arl,ard,arr) = split p sr ar in
            p := { !p with left = node_model al.model (data_model ad) !p.left };
            (join al ad arl,ard,arr)
          | Here -> p := { left = al.model;
            middle = Some (data_model ad);
            right = ar.model };
            (al,Some ad,ar)
        end
    end
  
  (* Less powerful variants of split, but more efficient
     (less/none tree rebuilding). *)
  
  (* Get the selected element (if there is one). *)
  let rec get (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
    (a:avl 'a 'b) : option (data 'a 'b)
    requires { avl_correct a }
    requires { selector_correct s a.model }
    ensures { !p.middle = match result with
        | None -> None | Some d -> Some (data_model d)
      end /\ selected s !p a.model /\ match result with
        | None -> true | Some d -> data_correct d /\ a.data_inv (data_model d)
      end }
    variant { avl_height a }
    writes { p }
  =
    match view a with
      | AEmpty -> p := { left = Nil; middle = None; right = Nil }; None
      | ANode al ad ar _ -> match selected_way s al ad ar with
          | Left sl -> let res = get p sl al in
            p := { !p with right =
              node_model !p.right (data_model ad) ar.model }; res
          | Right sr -> let res = get p sr ar in
            p := { !p with left = node_model al.model (data_model ad) !p.left };
            res
          | Here -> p := { left = al.model;
            middle = Some (data_model ad);
            right = ar.model }; Some ad
        end
    end
  
  let rec mem (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
    (a:avl 'a 'b) : bool
    requires { avl_correct a }
    requires { selector_correct s a.model }
    ensures { (result <-> !p.middle <> None) /\
      selected s !p a.model }
    variant { avl_height a }
    writes { p }
  =
    match view a with
      | AEmpty -> p := { left = Nil; middle = None; right = Nil }; false
      | ANode al ad ar _ -> match selected_way s al ad ar with
          | Left sl -> let res = mem p sl al in
            p := { !p with right =
              node_model !p.right (data_model ad) ar.model }; res
          | Right sr -> let res = mem p sr ar in
            p := { !p with left = node_model al.model (data_model ad) !p.left };
            res
          | Here -> p := { left = al.model;
            middle = Some (data_model ad);
            right = ar.model }; true
        end
    end
  
end

(* Instantiation to sorted (increasing) avl.
   Those implement ordered associative tables. *)
module AVLSorted
  
  use import int.Int
  use import option.Option
  use import bool.Bool
  use import HighOrd
  use import list.Append
  use import list.Mem
  use import list.Length
  
  clone import AVL as A
  
  (* Key used for ordering. *)
  type key 'a
  type key_model 'a
  (* Key well-formedness. *)
  predicate key_correct (key 'a)
  (* Get key model. *)
  function key_model (key 'a) : key_model 'a
  (* Key from data in pure and impure (program) worlds. *)
  function get_key_m (d:data_model 'a 'b) : key_model 'a
  val get_key (d:data 'a 'b) : key 'a
    requires { data_correct d }
    ensures { key_correct result }
    ensures { key_model result = get_key_m (data_model d) }
  
  
  (* Parameter for ordering.
     Examples: - unit (fixed ordering)
               - 'a -> 'a -> int (dynamic ordering) *)
  type order 'a
  predicate correct_for_order (order 'a) (key_model 'a)
  predicate le (order 'a) (k1 k2:key_model 'a)
  axiom le_reflexive : forall o:order 'a,k.
    correct_for_order o k -> le o k k
  axiom le_transitive : forall o:order 'a,k1 k2 k3.
    correct_for_order o k1 /\ correct_for_order o k2 /\ correct_for_order o k3
    /\ le o k1 k2 /\ le o k2 k3 -> le o k1 k3
  axiom le_total : forall o:order 'a,k1 k2.
    correct_for_order o k1 /\ correct_for_order o k2 ->
      le o k1 k2 \/ le o k2 k1
  predicate lt (o:order 'a) (k1 k2:key_model 'a)
  axiom lt_def : forall o:order 'a,k1 k2.
    correct_for_order o k1 /\ correct_for_order o k2 ->
    lt o k1 k2 <-> le o k1 k2 /\ not le o k2 k1
  predicate eq (o:order 'a) (k1 k2:key_model 'a)
  axiom eq_def : forall o:order 'a,k1 k2.
    correct_for_order o k1 /\ correct_for_order o k2 ->
      eq o k1 k2 <-> le o k1 k2 /\ le o k2 k1
  
  (* Comparison is computable. *)
  val compare (o:order 'a) (k1 k2:key 'a) : int
    requires { correct_for_order o (key_model k1) /\ key_correct k1 }
    requires { correct_for_order o (key_model k2) /\ key_correct k2 }
    ensures { result > 0 <-> lt o (key_model k2) (key_model k1) }
    ensures { result < 0 <-> lt o (key_model k1) (key_model k2) }
    ensures { result = 0 <-> eq o (key_model k1) (key_model k2) }
  
  predicate majorate (o:order 'a) (k:key_model 'a) (l:list_model 'a 'b) =
    forall d0. mem d0 l -> let k0 = get_key_m d0 in
      correct_for_order o k0 /\ lt o k0 k
  
  predicate minorate (o:order 'a) (k:key_model 'a) (l:list_model 'a 'b) =
    forall d0. mem d0 l -> let k0 = get_key_m d0 in
      correct_for_order o k0 /\ lt o k k0
  
  predicate sorted (o:order 'a) (l:list_model 'a 'b) = match l with
      | Nil -> true
      | Cons d q -> let k = get_key_m d in
        correct_for_order o k /\ minorate o k q /\ sorted o q
    end
    
  (* Sorted with a midpoint. *)
  let rec lemma sorted_def_midpoint (o:order 'a) (l:list_model 'a 'b)
    (d:data_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { correct_for_order o (get_key_m d) }
    ensures { sorted o (node_model l d r) <->
      (minorate o (get_key_m d) r /\
        majorate o (get_key_m d) l /\
        sorted o l /\
        sorted o r) }
    variant { l }
  =
    match l with
      | Nil -> ()
      | Cons _ ql -> sorted_def_midpoint o ql d r
    end
  
  predicate before (o:order 'a) (l:list_model 'a 'b) (r:list_model 'a 'b) =
    forall d1 d2. mem d1 l /\ mem d2 r ->
      let k1 = get_key_m d1 in let k2 = get_key_m d2 in
      correct_for_order o k1 /\ correct_for_order o k2 /\ lt o k1 k2
  
  (* Other variant: condition for a concatenation to be sorted. *)
  let rec lemma sorted_def_concat (o:order 'a) (l:list_model 'a 'b)
    (r:list_model 'a 'b) : unit
    ensures { sorted o (l ++ r) <->
      (sorted o l /\ sorted o r /\ before o l r) }
    variant { l }
  =
    match l with
      | Nil -> ()
      | Cons _ ql -> sorted_def_concat o ql r
    end
  
  type position 'a 'b = {
    left : list_model 'a 'b;
    middle : option (data_model 'a 'b);
    right : list_model 'a 'b;
  }
  
  (* Selection will be done by ordered key. *)
  type selector 'a 'b = (order 'a,key 'a)
  
  (* Correctness is sortedness. *)
  predicate selector_correct (s:selector 'a 'b) (l:list_model 'a 'b) =
    let (o,k) = s in sorted o l /\ correct_for_order o (key_model k) /\
      key_correct k
    
  (* Selected position is:
     - The position of the element equivalent to the key for the
       corresponding order.
     - The position where it should be if it does not exists. *)
  predicate selected (s:selector 'a 'b) (e:position 'a 'b)
    (l:list_model 'a 'b) = let (o,k) = s in
      sorted o e.left /\ sorted o e.right /\
      minorate o (key_model k) e.right /\ majorate o (key_model k) e.left /\
      match e.middle with
        | None -> l = e.left ++ e.right
        | Some d -> l = node_model e.left d e.right /\
          eq o (get_key_m d) (key_model k) /\
          correct_for_order o (get_key_m d)
      end
  
  (* Way to the position. *)
  type way 'a 'b= Left (selector 'a 'b)
    | Right (selector 'a 'b)
    | Here
  
  (* Way selection. *)
  let selected_way (s:selector 'a 'b)
    (l:avl 'a 'b) (d:data 'a 'b) (r:avl 'a 'b) : way 'a 'b
    requires { l.data_inv = r.data_inv }
    requires { data_correct d /\ l.data_inv (data_model d) }
    requires { avl_correct l /\ avl_correct r }
    requires { selector_correct s (node_model l.model (data_model d) r.model) }
    returns { Here -> selected s { left = l.model;
        middle = Some (data_model d);
        right = r.model }
        (node_model l.model (data_model d) r.model)
      | Left sl -> selector_correct sl l.model /\
        forall e. selected sl e l.model ->
        selected s { e with right = node_model e.right (data_model d) r.model }
          (node_model l.model (data_model d) r.model)
      | Right sr -> selector_correct sr r.model /\
        forall e. selected sr e r.model ->
        selected s { e with left = node_model l.model (data_model d) e.left }
          (node_model l.model (data_model d) r.model) }
  =
    let (o,k) = s in
    let kd = get_key d in
    let cmp = compare o k kd in
    if cmp < 0
    then Left s
    else if cmp > 0
    then Right s
    else Here
  
  (* In an ideal world....
     1) It would be nice to have the two cloned AVL modules unified
        (they are intended to be the same), as well as the two (identical)
        definitions of type way.
     2) Routines (program code) could be used as argument. *)
  (* clone import AVLSelection as F with
       A = A,
       type selector 'a 'b = selector 'a 'b,
       predicate selector_correct = selector_correct,
       predicate selected = selected,
       type way 'a 'b = way 'a 'b,
       lemma selected_append,
       lemma selector_correct_empty,
       val selected_way = selected_way*)
  
  (* And we would get this (or something close).
     Right now, this is done by hand. *)
  
  namespace import F
    use import ref.Ref
    
    lemma selected_append : forall s,e,l:list_model 'a 'b.
      selected s e l /\ selector_correct s l -> match e.middle with
        | Some d -> l = node_model e.left d e.right
        | None -> l = e.left ++ e.right
      end
    
    lemma selector_correct_empty : forall s:selector 'a 'b.
      selector_correct s (Nil:list_model 'a 'b) ->
        selected s { left = Nil ; middle = None ; right = Nil }
          (Nil:list_model 'a 'b)
    
    val ghost default_position () : position 'a 'b
  
    val add (ghost r:ref (position 'a 'b)) (s:selector 'a 'b)
      (d:data 'a 'b) (a:avl 'a 'b) : avl 'a 'b
      requires { selector_correct s a.model }
      requires { avl_correct a }
      requires { data_correct d /\ a.data_inv (data_model d) }
      ensures { result.model = node_model !r.left (data_model d) !r.right }
      ensures { selected s !r a.model }
      ensures { 1 >= avl_height result - avl_height a >= 0 }
      ensures { avl_correct result }
      ensures { result.data_inv = a.data_inv }
      writes { r }
  
    val remove (ghost r:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : avl 'a 'b
      requires { selector_correct s a.model }
      requires { avl_correct a }
      ensures { result.model = !r.left ++ !r.right }
      ensures { selected s !r a.model }
      ensures { 1 >= avl_height a - avl_height result >= 0 }
      ensures { avl_correct result }
      ensures { result.data_inv = a.data_inv }
      writes { r }
  
    val split (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : (avl 'a 'b,option (data 'a 'b),avl 'a 'b)
      requires { avl_correct a }
      requires { selector_correct s a.model }
      returns { (l,o,r) ->
        !p.left = l.model /\ !p.right = r.model /\
        !p.middle = match o with None -> None | Some d -> Some (data_model d) end
        /\ selected s !p a.model /\
        avl_correct l /\ avl_correct r /\ match o with
          | None -> true | Some d -> data_correct d /\ a.data_inv (data_model d)
        end /\ l.data_inv = a.data_inv /\ r.data_inv = a.data_inv }
      writes { p }
    
    val get (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : option (data 'a 'b)
      requires { avl_correct a }
      requires { selector_correct s a.model }
      ensures { !p.middle = match result with
          | None -> None | Some d -> Some (data_model d)
        end /\ selected s !p a.model /\ match result with
          | None -> true | Some d -> data_correct d /\ a.data_inv (data_model d)
        end }
      writes { p }
  
    val mem (ghost p:ref (position 'a 'b)) (s:selector 'a 'b)
      (a:avl 'a 'b) : bool
      requires { avl_correct a }
      requires { selector_correct s a.model }
      ensures { (result <-> !p.middle <> None) /\
        selected s !p a.model }
      writes { p }
  end
  
  (* Functional model. *)
  type fun_model 'a 'b = key_model 'a -> option (data_model 'a 'b)
  
  function functional_model (o:order 'a)
    (l:list_model 'a 'b) : fun_model 'a 'b =
    match l with
      | Nil -> \y.None
      | Cons x q -> let f0 = functional_model o q in
        \y. if correct_for_order o y &&
          eq o y (get_key_m x) then Some x else f0 y
    end
  
  type map 'a 'b = {
    avl_repr : avl 'a 'b;
    order : order 'a;
    ghost fmodel : fun_model 'a 'b;
  }
  
  function map_data_inv (m:map 'a 'b) : data_model 'a 'b -> bool =
    m.avl_repr.data_inv
  
  predicate map_correct (m:map 'a 'b) =
    avl_correct m.avl_repr /\
    sorted m.order m.avl_repr.model /\
    m.fmodel = functional_model m.order m.avl_repr.model /\
    (forall d. m.map_data_inv d -> correct_for_order m.order (get_key_m d))
  
  (* A key that is either minorated/majorated in some list is not
     represented in its functional model. *)
  let rec lemma fun_model_minorate (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { minorate o k l }
    requires { correct_for_order o k }
    ensures { functional_model o l k = None }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_minorate o k ql end
  
  let rec lemma fun_model_majorate (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { majorate o k l }
    requires { correct_for_order o k }
    ensures { functional_model o (l++r) k = functional_model o r k }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_majorate o k ql r end
  
  let rec lemma fun_model_selected (o:order 'a) (k:key 'a)
    (p:position 'a 'b) (l:list_model 'a 'b) (ks:key_model 'a) : unit
    requires { selected (o,k) p l }
    requires { key_correct k }
    requires { correct_for_order o (key_model k) }
    requires { correct_for_order o ks }
    ensures { eq o (key_model k) ks ->
      functional_model o l ks = p.middle }
    ensures { lt o (key_model k) ks ->
      functional_model o l ks = functional_model o p.right ks }
    ensures { le o ks (key_model k) ->
      functional_model o p.right ks = None }
    ensures { lt o ks (key_model k) ->
      functional_model o l ks = functional_model o p.left ks }
    ensures { le o (key_model k) ks ->
      functional_model o p.left ks = None }
    variant { p.left }
  =
    assert { l = p.left ++ (match p.middle with
      | None -> Nil | Some d -> Cons d Nil end)
      ++ p.right };
    assert { match p.middle with None -> true | Some d ->
      eq o (get_key_m d) (key_model k) /\
      correct_for_order o (get_key_m d) end };
    match p.left , l with
      | Nil , Nil -> ()
      | Nil , Cons _ _ -> let km = key_model k in
        assert { eq o km ks -> not functional_model o l ks = p.middle ->
          match p.middle with
            | None -> minorate o ks p.right && false | Some d ->
              let dk = get_key_m d in
              eq o dk km &&
              eq o ks dk && false end }
      | _ , Nil -> absurd
      | Cons xpl qpl , Cons _ ql ->
        assert { let kpl = get_key_m xpl in
          le o (key_model k) ks -> mem xpl p.left && lt o kpl (key_model k)
          && not eq o kpl ks };
        fun_model_selected o k { p with left = qpl } ql ks
    end
  
  let rec lemma fun_model_concat (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { sorted o r }
    requires { before o l r }
    requires { correct_for_order o k }
    ensures { functional_model o (l++r) k = None <->
      functional_model o l k = None /\ functional_model o r k = None }
    ensures { forall d. functional_model o l k = Some d ->
      functional_model o (l++r) k = Some d }
    ensures { forall d. functional_model o r k = Some d ->
      functional_model o (l++r) k = Some d }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_concat o k ql r end
    
  
  (*
  (* Functional model of a concatenation. *)
  let rec lemma fun_model_concat (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { sorted o r }
    requires { minorate o k r }
    requires { correct_for_order o k }
    ensures { functional_model o (l++r) k = functional_model o l k }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_concat o k ql r end
  
  (* Node selection. *)
  let rec lemma fun_model_node (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) (d:data_model 'a 'b) (r:list_model 'a 'b) : unit
    requires { sorted o (node_model l d r) }
    requires { eq o k (get_key_m d) }
    requires { correct_for_order o k }
    ensures { functional_model o (node_model l d r) k = Some d }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_node o k ql d r end*)
  
  let rec lemma fun_model_incorrect (o:order 'a) (k:key_model 'a)
    (l:list_model 'a 'b) : unit
    requires { not(correct_for_order o k) }
    ensures { functional_model o l k = None }
    variant { l }
  = match l with Nil -> () | Cons _ ql -> fun_model_incorrect o k ql end
  
  let rec lemma fun_model_nonnone (o:order 'a) (d:data_model 'a 'b)
    (l:list_model 'a 'b) : unit
    requires { sorted o l }
    requires { mem d l }
    ensures { functional_model o l (get_key_m d) <> None }
    variant { l }
  = match l with Nil -> () | Cons xl ql ->
      if d <> xl
      then fun_model_nonnone o d ql
      else ()
    end
  
  use import ref.Ref
  
  let map_empty (o:order 'a) (inv:data_model 'a 'b -> bool) : map 'a 'b
    requires { forall d. inv d -> correct_for_order o (get_key_m d) }
    ensures { result.order = o }
    ensures { result.map_data_inv = inv }
    ensures { forall k. result.fmodel k = None }
    ensures { map_correct result }
  =
    let rp = empty inv in
    { avl_repr = rp;
      order = o;
      fmodel = functional_model o rp.model }
  
  let map_singleton (o:order 'a) (inv:data_model 'a 'b -> bool)
    (d:data 'a 'b) : map 'a 'b
    requires { forall d. inv d -> correct_for_order o (get_key_m d) }
    requires { data_correct d }
    requires { inv (data_model d) }
    ensures { result.order = o }
    ensures { forall k. correct_for_order o k /\
      eq o k (get_key_m (data_model d)) ->
      result.fmodel k = Some (data_model d) }
    ensures { forall k. not correct_for_order o k ->
      result.fmodel k = None }
    ensures { forall k. not eq o k (get_key_m (data_model d)) ->
      result.fmodel k = None }
    ensures { result.map_data_inv = inv }
    ensures { map_correct result }
  =
    let rp = singleton inv d in
    { avl_repr = rp;
      order = o;
      fmodel = functional_model o rp.model }
  
  let map_add (d:data 'a 'b) (m:map 'a 'b) : map 'a 'b
    requires { m.map_data_inv (data_model d) /\ data_correct d }
    requires { map_correct m }
    ensures { forall k. not eq m.order k (get_key_m (data_model d)) ->
      result.fmodel k = m.fmodel k }
    ensures { forall k. not correct_for_order m.order k ->
      result.fmodel k = m.fmodel k }
    ensures { forall k. correct_for_order m.order k /\
      eq m.order k (get_key_m (data_model d)) ->
        result.fmodel k = Some (data_model d) }
    ensures { result.order = m.order /\ result.map_data_inv = m.map_data_inv }
    ensures { map_correct result }
  =
    let ghost r = ref (default_position ()) in
    let k = get_key d in
    let o = m.order in
    let res0 = add r (o,k) d m.avl_repr in
    let res = { avl_repr = res0;
      order = m.order;
      fmodel = functional_model o res0.model } in
    assert { selected (o,k)
      { !r with middle = Some (data_model d) } res0.model };
    res
  
  let map_mem (k:key 'a) (m:map 'a 'b) : bool
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    ensures { forall k2. correct_for_order m.order k2 /\
      eq m.order k2 (key_model k) -> (m.fmodel k2 <> None <-> result) }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    mem r (o,k) m.avl_repr
  
  let map_remove (k:key 'a) (m:map 'a 'b) : map 'a 'b
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    ensures { forall k2. not eq m.order k2 (key_model k) ->
      result.fmodel k2 = m.fmodel k2 }
    ensures { forall k2. not correct_for_order m.order k2 ->
      result.fmodel k2 = m.fmodel k2 }
    ensures { forall k2. correct_for_order m.order k2 /\
      eq m.order k2 (key_model k) -> result.fmodel k2 = None }
    ensures { result.order = m.order /\ result.map_data_inv = m.map_data_inv }
    ensures { map_correct result }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    let res0 = remove r (o,k) m.avl_repr in
    let res = { avl_repr = res0;
      order = m.order;
      fmodel = functional_model o res0.model } in
    assert { selected (o,k) { !r with middle = None } res0.model };
    res
  
  
  let map_find (k:key 'a) (m:map 'a 'b) : option (data 'a 'b)
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    ensures { forall k2. correct_for_order m.order k2 /\
      eq m.order k2 (key_model k) -> m.fmodel k2 = match result with
        | None -> None | Some d -> Some (data_model d) end }
    returns { None -> true
      | Some d -> data_correct d /\ m.map_data_inv (data_model d) }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    get r (o,k) m.avl_repr
  
  let map_split (k:key 'a)
    (m:map 'a 'b) : (map 'a 'b,option (data 'a 'b),map 'a 'b)
    requires { key_correct k /\ correct_for_order m.order (key_model k) }
    requires { map_correct m }
    returns { (l,o,r) -> map_correct l /\ map_correct r /\
      l.order = m.order /\ r.order = m.order /\
      l.map_data_inv = m.map_data_inv /\ r.map_data_inv = m.map_data_inv /\
      (forall k2. not correct_for_order m.order k2 ->
        l.fmodel k2 = None = r.fmodel k2) /\
      (forall k2. correct_for_order m.order k2 /\ le m.order k2 (key_model k) ->
        r.fmodel k2 = None) /\
      (forall k2. correct_for_order m.order k2 /\ le m.order (key_model k) k2 ->
        l.fmodel k2 = None) /\
      (forall k2. correct_for_order m.order k2 /\ lt m.order k2 (key_model k) ->
        l.fmodel k2 = m.fmodel k2) /\
      (forall k2. correct_for_order m.order k2 /\ lt m.order (key_model k) k2 ->
        r.fmodel k2 = m.fmodel k2) /\
      (forall k2. correct_for_order m.order k2 /\ eq m.order (key_model k) k2 ->
        m.fmodel k2 = match o with
          | None -> None
          | Some d -> Some (data_model d)
        end) /\ match o with
          | None -> true
          | Some d -> data_correct d /\ m.map_data_inv (data_model d)
        end }
  =
    let ghost r = ref (default_position ()) in
    let o = m.order in
    let (l0,o0,r0) = split r (o,k) m.avl_repr in
    let l = { avl_repr = l0;
      order = m.order;
      fmodel = functional_model o l0.model } in
    let r = { avl_repr = r0;
      order = m.order;
      fmodel = functional_model o r0.model } in
    (l,o0,r)
  
  let map_concat (m1 m2:map 'a 'b) : map 'a 'b
    requires { map_correct m1 /\ map_correct m2 /\
      m1.map_data_inv = m2.map_data_inv /\
      m1.order = m2.order }
    requires { forall k1 k2. m1.fmodel k1 <> None /\ m2.fmodel k2 <> None ->
      lt m1.order k1 k2 }
    ensures { map_correct result }
    ensures { result.order = m1.order }
    ensures { result.map_data_inv = m1.map_data_inv }
    ensures { forall k. result.fmodel k = None <-> m1.fmodel k = None /\
      m2.fmodel k = None }
    ensures { forall k d. m1.fmodel k = Some d -> result.fmodel k = Some d }
    ensures { forall k d. m2.fmodel k = Some d -> result.fmodel k = Some d }
  =
    let o = m2.order in
    assert { before o m1.avl_repr.model m2.avl_repr.model };
    let r0 = concat m1.avl_repr m2.avl_repr in
    let res = { avl_repr = r0;
      order = o;
      fmodel = functional_model o r0.model } in
    res
  
end

