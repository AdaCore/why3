(** 

{1 Defunctionalization}

This is inspired from student exercises proposed by 
{h <a href="http://cs.au.dk/~danvy/">Olivier Danvy</a>}
at the {h <a href="http://jfla.inria.fr/2014/">JFLA 2014 conference</a>}

*)


(**{h }*)

(** {2 Simple Arithmetic Expressions} *)

module Expr

use export int.Int

(** Grammar of expressions 
{h <blockquote><pre>
n  :  int

e  :  expression
e ::= n | e - e

p  :  program
p ::= e 
</pre></blockquote>}
*)

type expr = Cte int | Sub expr expr

type prog = expr

(** Examples:
{h <blockquote><pre>
p0 = 0
p1 = 10 - 6
p2 = (10 - 6) - (7 - 2)
p3 = (7 - 2) - (10 - 6)
p4 = 10 - (2 - 3)
</pre></blockquote>}
*)

constant p0 : prog = Cte 0
constant p1 : prog = Sub (Cte 10) (Cte 6)
constant p2 : prog = Sub (Sub (Cte 10) (Cte 6)) (Sub (Cte 7) (Cte 2))
constant p3 : prog = Sub (Sub (Cte 7) (Cte 2)) (Sub (Cte 10) (Cte 6))
constant p4 : prog = Sub (Cte 10) (Sub (Cte 2) (Cte 3))

end


(** {2 Direct Semantics} *)

module DirectSem

use import Expr

(** Values:
{h <blockquote><pre>
v  :  value
v ::= n
</pre></blockquote>
}
Expressible Values:
{h <blockquote><pre>
ve  :  expressible_value
ve ::= v
</pre></blockquote>}
Interpretation:
{h <blockquote><pre>
------
n => n

e1 => n1   e2 => n2   n1 - n2 = n3
----------------------------------
      e1 - e2 => n3
</pre></blockquote>}
A program e is interpreted into a value n if judgement
{h <blockquote><pre>
  e => n
</pre></blockquote>}
holds.
*)

(** {4 Exercise 0.0}
  Program the interpreter above and test it on the examples.
{h <blockquote><pre>
  eval_0 : expression -> expressible_value
  interpret_0 : program -> expressible_value
</pre></blockquote>}
*)

(* Note: Why3 definitions introduced by "function" belong to the logic
   part of Why3 language *)

function eval_0 (e:expr) : int =
  match e with
  | Cte n -> n
  | Sub e1 e2 ->
     let v1 = eval_0 e1 in
     let v2 = eval_0 e2 in
     v1 - v2
  end

function interpret_0 (p:prog) : int = eval_0 p

(** Tests, can be replayed using
{h <blockquote><pre>
  why3 defunctionalization.mlw --exec DirectSem.t0
</pre></blockquote>}
resp. [DirectSem.t1], [DirectSem.t2], etc. (Why3 version at least 0.82 required)

*)

let t0 () = interpret_0 p0
let t1 () = interpret_0 p1
let t2 () = interpret_0 p2
let t3 () = interpret_0 p3
let t4 () = interpret_0 p4


end


(** {2 CPS: Continuation Passing Style} *)

module CPS

use import Expr

(** {4 Exercise 0.1}

  CPS-transform (call by value, left to right) the function [eval_0],
  and call it from the main interpreter with the identity function as
  initial continuation
{h <blockquote><pre>
      eval_1 : expression -> (expressible_value -> 'a) -> 'a
  interpret_1 : program -> expressible_value
</pre></blockquote>}

*)

use HighOrd (* import not needed, but why ? *)

function eval_1 (e:expr) (k:int -> 'a) : 'a =
  match e with
    | Cte n -> k n
    | Sub e1 e2 ->
      eval_1 e1 (\ v1. eval_1 e2 (\ v2. k (v1 - v2)))
  end

function interpret_1 (p : prog) : int = eval_1 p (\ n. n)


(** Soundness *)

use import DirectSem


let rec lemma cps_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k:int -> 'a. eval_1 e k = k (eval_0 e) }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps_correct_expr e1;
      cps_correct_expr e2
  end

lemma cps_correct: forall p. interpret_1 p = interpret_0 p

end



(** {2 Defunctionalization} *)

module Defunctionalization

use import Expr
use import DirectSem

(** {4 Exercise 0.2}

  De-functionalize the continuation of [eval_1].
{h <blockquote><pre>
         cont ::= ...

   continue_2 : cont -> value -> value
       eval_2 : expression -> cont -> value
  interpret_2 : program -> value
</pre></blockquote>}
  The data type [cont] represents the grammar of contexts.

  The two mutually recursive functions [eval_2] and [continue_2]
  implement an abstract machine, that is a state transition system.

*)

type cont = A1 expr cont | A2 int cont | I

(** One would want to write in Why:
{h <blockquote><pre>
function eval_cont (c:cont) (v:int) : int =
  match c with
  | A1 e2 k ->
    let v2 = eval_0 e2 in
    eval_cont (A2 v k) v2
  | A2 v1 k -> eval_cont k (v1 - v)
  | I -> v
  end
</pre></blockquote>}
But since the recursion is not structural, Why3 kernel rejects it
(definitions in the logic part of the language must be total)

We replace that with a relational definition, an inductive one.

*)

inductive eval_cont cont int int =
| a1 :
  forall e2:expr, k:cont, v:int, r:int.
  eval_cont (A2 v k) (eval_0 e2) r -> eval_cont (A1 e2 k) v r
| a2 :
  forall v1:int, k:cont, v:int, r:int.
  eval_cont k (v1 - v) r -> eval_cont (A2 v1 k) v r
| a3 :
  forall v:int. eval_cont I v v

(** Some functions to serve as measures for the termination proof *)

function size_e (e:expr) : int =
  match e with
  | Cte _ -> 1
  | Sub e1 e2 -> 3 + size_e e1 + size_e e2
  end

let rec lemma size_e_pos (e:expr) : unit
  variant { e }
  ensures { size_e e >= 1 }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 -> size_e_pos e1; size_e_pos e2
  end

function size_c (c:cont) : int =
  match c with
  | I -> 0
  | A1 e2 k -> 2 + size_e e2 + size_c k
  | A2 _ k -> 1 + size_c k
  end

let rec lemma size_c_pos (c:cont) : unit
  variant { c }
  ensures { size_c c >= 0 }
= match c with
  | I -> ()
  | A1 _ k -> size_c_pos k
  | A2 _ k -> size_c_pos k
  end

(** WhyML programs (declared with "let" instead of "function"),
   mutually recursive, resulting from de-functionalization *)

let rec continue_2 (c:cont) (v:int) : int
  variant { size_c c }
  ensures { eval_cont c v result }
  =
  match c with
    | A1 e2 k -> eval_2 e2 (A2 v k)
    | A2 v1 k -> continue_2 k (v1 - v)
    | I -> v
  end

with eval_2 (e:expr) (c:cont) : int
  variant { size_c c + size_e e }
  ensures { eval_cont c (eval_0 e) result }
  =
  match e with
    | Cte n -> continue_2 c n
    | Sub e1 e2 -> eval_2 e1 (A1 e2 c)
  end

(** The interpreter. The post-condition specifies that this program
    computes the same thing as [eval_0] *)

let interpret_2 (p:prog) : int
  ensures { result = eval_0 p }
  = eval_2 p I

let u0 () = interpret_2 p0
let u1 () = interpret_2 p1
let u2 () = interpret_2 p2
let u3 () = interpret_2 p3
let u4 () = interpret_2 p4

end




(** {2 Semantics with errors} *)

module SemWithError

use import Expr

(** Errors:
{h <blockquote><pre>
s  :  error
</pre></blockquote>}
Expressible values:
{h <blockquote><pre>
ve  :  expressible_value
ve ::= v | s
</pre></blockquote>}
*)

type value = Vnum int | Underflow

(** Interpretation:
{h <blockquote><pre>
------
n => n

     e1 => s
------------
e1 - e2 => s

e1 => n1   e2 => s
------------------
      e1 - e2 => s

e1 => n1   e2 => n2   n1 < n2
-----------------------------
      e1 - e2 => "underflow"

e1 => n1   e2 => n2   n1 >= n2   n1 - n2 = n3
---------------------------------------------
      e1 - e2 => n3
</pre></blockquote>}
We interpret the program [e] into value [n] if the judgement
{h <blockquote><pre>
  e => n
</pre></blockquote>}
holds, and into error [s] if the judgement
{h <blockquote><pre>
  e => s
</pre></blockquote>}
holds.


{4 Exercise 1.0}

  Program the interpreter above and test it on the examples.
{h <blockquote><pre>
  eval_0 : expr -> expressible_value
  interpret_0 : program -> expressible_value
</pre></blockquote>}
*)

function eval_0 (e:expr) : value =
  match e with
  | Cte n -> if n >= 0 then Vnum n else Underflow
  | Sub e1 e2 ->
     match eval_0 e1 with
     | Underflow -> Underflow
     | Vnum v1 ->
       match eval_0 e2 with
       | Underflow -> Underflow
       | Vnum v2 ->
         if v1 >= v2 then Vnum (v1 - v2) else Underflow
       end
     end
  end

function interpret_0 (p:prog) : value = eval_0 p

let t0 () = interpret_0 p0
let t1 () = interpret_0 p1
let t2 () = interpret_0 p2
let t3 () = interpret_0 p3
let t4 () = interpret_0 p4


(** {4 Exercise 1.1}
  CPS-transform (call by value, from left to right)
  the function [eval_0], call it from the main interpreter
  with the identity function as initial continuation.
{h <blockquote><pre>
      eval_1 : expr -> (expressible_value -> 'a) -> 'a
  interpret_1 : program -> expressible_value
</pre></blockquote>}
*)


use HighOrd

function eval_1 (e:expr) (k:value -> 'a) : 'a =
  match e with
    | Cte n -> k (if n >= 0 then Vnum n else Underflow)
    | Sub e1 e2 ->
      eval_1 e1 (\ v1.
       match v1 with
       | Underflow -> k Underflow
       | Vnum v1 ->
         eval_1 e2 (\ v2.
         match v2 with
         | Underflow -> k Underflow
         | Vnum v2 -> k (if v1 >= v2 then Vnum (v1 - v2) else Underflow)
         end)
       end)
  end

function interpret_1 (p : prog) : value = eval_1 p (\ n. n)


let rec lemma cps_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k:value -> 'a. eval_1 e k = k (eval_0 e) }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps_correct_expr e1;
      cps_correct_expr e2
  end

lemma cps_correct: forall p. interpret_1 p = interpret_0 p

(** {4 Exercise 1.2}

  Divide the continuation
{h <blockquote><pre>
    expressible_value -> 'a
</pre></blockquote>}
  in two: 
{h <blockquote><pre>
    (value -> 'a) * (error -> 'a)
</pre></blockquote>}
  and adapt [eval_1] and [interpret_1] as
{h <blockquote><pre>
       eval_2 : expr -> (value -> 'a) -> (error -> 'a) -> 'a
  interpret_2 : program -> expressible_value
</pre></blockquote>}
*)



(*
function eval_2 (e:expr) (k:int -> 'a) (kerr: unit -> 'a) : 'a =
  match e with
    | Cte n -> if n >= 0 then k n else kerr ()
    | Sub e1 e2 ->
      eval_2 e1 (\ v1.
         eval_2 e2 (\ v2.
           if v1 >= v2 then k (v1 - v2) else kerr ())
           kerr) kerr
  end
*)

function eval_2 (e:expr) (k:int -> 'a) (kerr: unit -> 'a) : 'a =
  match e with
    | Cte n -> if n >= 0 then k n else kerr ()
    | Sub e1 e2 ->
      eval_2 e1 (eval_2a e2 k kerr) kerr
  end

with eval_2a (e2:expr) (k:int -> 'a) (kerr : unit -> 'a) : int -> 'a =
  (\ v1. eval_2 e2 (eval_2b v1 k kerr) kerr)

with eval_2b (v1:int) (k:int -> 'a) (kerr : unit -> 'a) : int -> 'a =
  (\ v2. if v1 >= v2 then k (v1 - v2) else kerr ())



function interpret_2 (p : prog) : value = 
  eval_2 p (\ n. Vnum n) (\ u. Underflow)

let rec lemma cps2_correct_expr (e:expr) (kerr:unit -> 'a): unit
  variant { e }
  ensures { forall k. eval_2 e k kerr =
    match eval_0 e with Vnum n -> k n | Underflow -> kerr () end }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps2_correct_expr e1 kerr;
      cps2_correct_expr e2 kerr;
      assert {forall k. eval_2 e k kerr = eval_2 e1 (eval_2a e2 k kerr) kerr }
  end

lemma cps2_correct: forall p. interpret_2 p = interpret_0 p

(** {4 Exercise 1.3}

  Specialize the codomain of the continuations and of the evaluation function
  so that it is not polymorphic anymore but is [expressible_value], and
  then short-circuit the second continuation to stop in case of error
{h <blockquote><pre>
       eval_3 : expr -> (value -> expressible_value) -> expressible_value
  interpret_3 : program -> expressible_value
</pre></blockquote>}
  NB: Now there is only one continuation and it is applied only in
  absence of error.

*)


function eval_3 (e:expr) (k:int -> value) : value =
  match e with
    | Cte n -> if n >= 0 then k n else Underflow
    | Sub e1 e2 ->
      eval_3 e1 (eval_3a e2 k)
  end

with eval_3a (e2:expr) (k:int -> value) : int -> value =
  (\ v1. eval_3 e2 (eval_3b v1 k))

with eval_3b (v1:int) (k:int -> value) : int -> value =
  (\ v2. if v1 >= v2 then k (v1 - v2) else Underflow)


function interpret_3 (p : prog) : value = eval_3 p (\ n. Vnum n)

let rec lemma cps3_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k. eval_3 e k =
    match eval_0 e with Vnum n -> k n | Underflow -> Underflow end }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps3_correct_expr e1;
      cps3_correct_expr e2;
      assert {forall k. eval_3 e k = eval_3 e1 (eval_3a e2 k) }
  end

lemma cps3_correct: forall p. interpret_3 p = interpret_0 p


(** {4 Exercise 1.4}
  De-functionalize the continuation of [eval_3].
{h <blockquote><pre>
         cont ::= ...

    continue_4 : cont -> value -> expressible_value
        eval_4 : expr -> cont -> expressible_value
  interprete_4 : program -> expressible_value
</pre></blockquote>}
  The data type [cont] represents the grammar of contexts.
  (NB. has it changed w.r.t to previous exercise?)

  The two mutually recursive functions [eval_4] and [continue_4]
  implement an abstract machine, that is a transition system that
  stops immediately in case of error, or and the end of computation.

*)



type cont = I | A expr cont | B int cont

(**

One would want to write in Why:

[function eval_cont (c:cont) (v:int) : int =
  match c with
  | A1 e2 k ->
    let v2 = eval_0 e2 in
    eval_cont (A2 v k) v2
  | A2 v1 k -> eval_cont k (v1 - v)
  | I -> v
  end]

But since the recursion is not structural, Why3 kernel rejects it
(definitions in the logic part of the language must be total)

We replace that with a relational definition, an inductive one.

*)

(*
inductive eval_cont cont int int =
| a1 :
  forall e2:expr, k:cont, v:int, r:int.
  eval_cont (A2 v k) (eval_0 e2) r -> eval_cont (A1 e2 k) v r
| a2 :
  forall v1:int, k:cont, v:int, r:int.
  eval_cont k (v1 - v) r -> eval_cont (A2 v1 k) v r
| a3 :
  forall v:int. eval_cont I v v

(** Some functions to serve as measures for the termination proof *)

function size_e (e:expr) : int =
  match e with
  | Cte _ -> 1
  | Sub e1 e2 -> 3 + size_e e1 + size_e e2
  end

let rec lemma size_e_pos (e:expr) : unit
  variant { e }
  ensures { size_e e >= 1 }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 -> size_e_pos e1; size_e_pos e2
  end
*)

use Defunctionalization

function size_c (c:cont) : int =
  match c with
  | I -> 0
  | A e2 k -> 2 + Defunctionalization.size_e e2 + size_c k
  | B _ k -> 1 + size_c k
  end

let rec lemma size_c_pos (c:cont) : unit
  variant { c }
  ensures { size_c c >= 0 }
= match c with
  | I -> ()
  | A _ k -> size_c_pos k
  | B _ k -> size_c_pos k
  end

let rec continue_4 (c:cont) (v:int) : value
  variant { size_c c }
(*
  ensures { eval_cont c v result }
*)
  =
  match c with
    | A e2 k -> eval_4 e2 (B v k)
    | B v1 k -> if v1 >= v then continue_4 k (v1 - v) else Underflow
    | I -> Vnum v
  end

with eval_4 (e:expr) (c:cont) : value
  variant { size_c c + Defunctionalization.size_e e }
(*
  ensures { eval_cont c (eval_0 e) result }
*)
  =
  match e with
    | Cte n -> if n >= 0 then continue_4 c n else Underflow
    | Sub e1 e2 -> eval_4 e1 (A e2 c)
  end

(** The interpreter. The post-condition specifies that this program
    computes the same thing as [eval_0] *)

let interpret_4 (p:prog) : value
  ensures { result = eval_0 p }
  = eval_4 p I

let u0 () = interpret_4 p0
let u1 () = interpret_4 p1
let u2 () = interpret_4 p2
let u3 () = interpret_4 p3
let u4 () = interpret_4 p4


end


(** {2 The lambda-calculus} *)

(**
Terms:
{h <blockquote><pre>
n : int

x : identifier

t  : term
t ::= x | \x.t | t t

p  :  program
p ::= t
</pre></blockquote>}
      where t is ground (i.e. without any free variable)
*)

(** Examples:
{h <blockquote><pre>
p0 = (\x.x)
p1 = (\x.x) (\x.x)
p2 = (\x.\f.f x) (\y.y) (\x.x)
</pre></blockquote>}
*)

(** Values and environments:
{h <blockquote><pre>
e  :  environment
v ::= nil | (identifier, value) :: environment

v  :  value
v ::= (\x.t, e)
</pre></blockquote>}
*)

(** Operateur algebrique:
{h <blockquote><pre>
lookup : identificateur -> environnement -> value
</pre></blockquote>}
*)

(** Contextes d'evaluation:
{h <blockquote><pre>
C ::= [] | [C (t, e)] | [v C]
</pre></blockquote>}
*)

(** Machine abstraite (dite "CEK"):
{h <blockquote><pre>
    &lt;x, e, C&gt;_eval -> &lt;C, v&gt;_cont
                      where v = lookup x e
 &lt;\x.t, e, C&gt;_eval -> &lt;C, (\x.t, e)&gt;_cont
&lt;t0 t1, e, C&gt;_eval -> &lt;t0, e, [C (t1, e)]&gt;

           &lt;[], v&gt;_cont -> v
   &lt;[C (t, e)], v&gt;_cont -> &lt;t, e, [v C]&gt;_eval
&lt;[(\x.t, e) C], v&gt;_cont -> &lt;t, (x, v) :: e, C&gt;_eval
</pre></blockquote>}
*)

(** {4 Exercise 2.0}
  Program cette machine abstraite.
*)

(** {4 Exercise 2.1}
  Cette machine abstraite est en forme defonctionalisee.
  La refonctionaliser.
*)

(** {4 Exercise 2.2}
  Le resultat de l'Exercise 1 est en CPS.
  L'exprimer en style direct.
*)

(** {4 Exercise 2.3}
  Le resultat de l'Exercise 2 est en forme defonctionalisee
  (dans le sens que les fermetures sont en forme defonctionalisee
  triviale).
  Le refonctionaliser, et caracteriser le resultat.
*)





(** {2 Reduction Semantics} *)

module R

  use import Expr

  use import DirectSem

(*
Une semantique a petits pas iterative avec des contextes de reduction:

"Reduction semantics" pour les expressions arithmetiques
--------------------------------------------------------


Expressions:

n  :  int

e  :  expression
e ::= n | e - e

p  :  program
p ::= e


Exemples:

p0 = 0
p1 = 10 - 6
p2 = (10 - 6) - (7 - 2)
p3 = (7 - 2) - (10 - 6)
p4 = 10 - (2 - 3)


Values:

v  :  value
v ::= n


Redexes potentiels:

  rp ::= n1 - n2


Regle de reduction:

  n1 - n2 -> n3

(pour les entiers Z, tous les redexes potentiels sont de vrais redexes;
 pour les entiers naturels, pas tous ne le sont:
   n1 - n2 -> n3   si n1 >= n2
 un redex potentiel qui n'en est pas un vrai est "coince" (stuck).)


Fonction de contraction:

  contracte : redex_potentiel -> expression + stuck
  contracte (n1 - n2) = n3   si n3 = n1 - n2
*)


predicate is_a_redex (e:expr) =
  match e with
  | Sub (Cte _) (Cte _) -> true
  | _ -> false
  end

let contracte (e:expr) : expr
  requires { is_a_redex e }
  ensures { eval_0 result = eval_0 e }
  =
  match e with
  | Sub (Cte v1) (Cte v2) -> Cte (v1 - v2)
  | _ -> absurd
  end

(*
et si on n'a que des entiers naturels,

  contracte (n1 - n2) = n3     si n1 >= n2 et n3 = n1 - n2
  contracte (n1 - n2) = stuck  si n1 < n2


Contextes de reduction:

C  : cont
C ::= [] | [C e] | [v C]
*)

type context = Empty | Left context expr | Right int context

(*
Recomposition:

             recompose : cont * expression -> expression
     recompose ([], e) = e
recompose ([C e2], e1) = recompose (C, e1 - e2)
recompose ([n1 C], e2) = recompose (C, n1 - e2)
*)

function recompose (c:context) (e:expr) : expr =
  match c with
  | Empty -> e
  | Left c e2 -> recompose c (Sub e e2)
  | Right n1 c -> recompose c (Sub (Cte n1) e)
  end

let rec lemma recompose_values (c:context) (e1 e2:expr) : unit
  requires { eval_0 e1 = eval_0 e2 }
  variant  { c }
  ensures  { eval_0 (recompose c e1) = eval_0 (recompose c e2) }
= match c with
  | Empty -> ()
  | Left c e -> recompose_values c (Sub e1 e) (Sub e2 e)
  | Right n c -> recompose_values c (Sub (Cte n) e1) (Sub (Cte n) e2)
  end

let rec lemma recompose_inversion (c:context) (e:expr) 
  requires { 
      match c with Empty -> false | _ -> true end \/ 
      match e with Cte _ -> false | Sub _ _ -> true end }
  variant { c }
  ensures {  match recompose c e with 
               Cte _ -> false | Sub _ _ -> true end }
= match c with 
  | Empty -> ()
  | Left c e2 -> recompose_inversion c (Sub e e2)
  | Right n1 c -> recompose_inversion c (Sub (Cte n1) e)
  end

(*
Decomposition:

dec_ou_val = (C, rp) | v

fonction de decomposition:

             decompose_term : expression * cont -> dec_ou_val
      decompose_term (n, C) = decompose_cont (C, n)
decompose_term (e1 - e2, C) = decompose_term (e1, [C e2])

             decompose_cont : cont * value -> dec_ou_val
     decompose_cont ([], n) = n
  decompose_cont ([C e], n) = decompose_term (e, [n c])
decompose_term ([n1 C], n2) = (C, n1 - n2)

  decompose : expression -> dec_ou_val
decompose e = decompose_term (e, [])
*)

exception NoRedex

predicate is_a_value (e:expr) =
  match e with
  | Cte _ -> true
  | _ -> false
  end

let rec decompose_term (e:expr) (c:context) : (context, expr)
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c e /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value (recompose c e) }
  =
  match e with
  | Cte n -> decompose_cont c n
  | Sub e1 e2 -> decompose_term e1 (Left c e2)
  end

with decompose_cont (c:context) (n:int) : (context, expr)
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c (Cte n)  /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value (recompose c (Cte n)) }
  =
  match c with
  | Empty -> raise NoRedex
  | Left c e -> decompose_term e (Right n c)
  | Right n1 c -> (c, Sub (Cte n1) (Cte n))
  end

let decompose (e:expr) : (context, expr)
  ensures { let (c1,e1) = result in recompose c1 e1 = e  /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value e }
  =
  decompose_term e Empty

(*

Un pas de reduction:

reduis : expression -> expression + stuck

si decompose e = v
alors reduis e = stuck

si decompose e = (C, rp)
et contracte rp = stuck
alors reduis e = stuck

si decompose e = (C, rp)
et contracte rp = c
alors reduis e = recompose (C, c)

*)

(** {4 Exercise 3.0}
  Implementer la "reduction semantics" ci-dessus et la tester.
*)


let reduis (e:expr) : expr
  ensures { eval_0 result = eval_0 e }
  diverges
  raises { NoRedex -> is_a_value e }
  =
  let (c,r) = decompose e in
  recompose c (contracte r)

(*
Evaluation basee sur la reduction iteree:

itere : red_ou_val -> value + erreur

itere v = v

si contracte rp = stuck
alors itere (C, rp) = stuck

si contracte rp = c
alors itere (C, rp) = itere (decompose (recompose (C, c)))
*)


let rec itere (e:expr) : int
  diverges
  ensures { eval_0 e = result }
  =
  try
    let e' = reduis e in
    itere e'
  with NoRedex ->
     match e with
     | Cte n -> n
     | _ -> absurd
     end
  end

(** {4 Exercise 3.1}
  Optimiser l'etape de recomposition / decomposition
  en une fonction "refocus".
*)


let refocus c e
  diverges
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c e /\
            is_a_redex e1 }
  raises { NoRedex -> is_a_value (recompose c e) }
  = decompose_term e c

let rec itere_opt (c:context) (e:expr) : int
  diverges
  ensures { result = eval_0 (recompose c e) }
  =
  try
    let (c,r) = refocus c e in
    itere_opt c (contracte r)
  with NoRedex ->
     match recompose c e with
     | Cte n -> n
     | _ -> absurd
     end
  end

let rec normalize (e:expr)
 diverges
 = itere_opt Empty e




(** {4 Exercise 3.2}
  Obtenir une machine abstraite.
*)

(* TODO *)

end

