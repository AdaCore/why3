(** 

{1 Defunctionalization}

This is inspired from student exercises proposed by Olivier Danvy
<danvy@cs.au.dk> (cf JFLA 2014)

*)


(** {2 Simple Arithmetic Expressions} *)

module Expr

use export int.Int

(*

Grammar of expressions:

n  :  int

e  :  expression
e ::= n | e - e

p  :  program
p ::= e

*)

type expr = Cte int | Sub expr expr

type prog = expr

(*

Examples:

p0 = 0
p1 = 10 - 6
p2 = (10 - 6) - (7 - 2)
p3 = (7 - 2) - (10 - 6)
p4 = 10 - (2 - 3)

*)

constant p0 : prog = Cte 0
constant p1 : prog = Sub (Cte 10) (Cte 6)
constant p2 : prog = Sub (Sub (Cte 10) (Cte 6)) (Sub (Cte 7) (Cte 2))
constant p3 : prog = Sub (Sub (Cte 7) (Cte 2)) (Sub (Cte 10) (Cte 6))
constant p4 : prog = Sub (Cte 10) (Sub (Cte 2) (Cte 3))

end


(** {2 Direct Semantics} *)

module DirectSem

use import Expr

(*

Values:

v  :  value
v ::= n


Expressible Values:

ve  :  expressible_value
ve ::= v


Interpretation:

------
n => n

e1 => n1   e2 => n2   n1 - n2 = n3
----------------------------------
      e1 - e2 => n3


A program e is interpreted into a value n if judgement

  e => n

holds.


Exercise 0:
  Program the interpreter above and test it on the examples.

  eval_0 : expression -> expressible_value
  interpret_0 : program -> expressible_value
*)

(* Note: Why3 definition introduced by "function" belong to the logic
   part of Why3 language *)

function eval_0 (e:expr) : int =
  match e with
  | Cte n -> n
  | Sub e1 e2 ->
     let v1 = eval_0 e1 in
     let v2 = eval_0 e2 in
     v1 - v2
  end

function interpret_0 (p:prog) : int = eval_0 p

(*

Tests, can be replayed using

  why3 defunctionalization.mlw --exec DirectSem.t0

(resp DirectSem.t1, DirectSem.t2, etc.) 

(Why3 version at least 0.82 required)

*)

let t0 () = interpret_0 p0
let t1 () = interpret_0 p1
let t2 () = interpret_0 p2
let t3 () = interpret_0 p3
let t4 () = interpret_0 p4


end


(** {2 CPS: Continuation Passing Style} *)

module CPS

use import Expr

(*

Exercise 1:

  CPS-transform (call by value, left to right) the function eval_0,
  and call it from the main interpreter with the identity function as
  initial continuation

      eval_1 : expression -> (expressible_value -> 'a) -> 'a
  interpret_1 : program -> expressible_value

*)

use HighOrd (* import not needed, but why ? *)

function eval_1 (e:expr) (k:int -> 'a) : 'a =
  match e with
    | Cte n -> k n
    | Sub e1 e2 ->
      eval_1 e1 (\ v1. eval_1 e2 (\ v2. k (v1 - v2)))
  end

function interpret_1 (p : prog) : int = eval_1 p (\ n. n)


use import DirectSem


let rec lemma cps_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k:int -> 'a. eval_1 e k = k (eval_0 e) }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps_correct_expr e1;
      cps_correct_expr e2
  end

lemma cps_correct: forall p. interpret_1 p = interpret_0 p

end



(** {2 Defunctionalization} *)

module Defunctionalization

use import Expr
use import DirectSem

(**
Exercise 2:

  De-functionalize the continuation of [eval_1].

         cont ::= ...

   [continue_2 : cont -> value -> value]
       [eval_2 : expression -> cont -> value]
  [interpret_2 : program -> value]

  The data type cont represents the grammar of contexts.

  The two mutually recursive functions [eval_2] and [continue_2]
  implement an abstract machine, that is a state transition system.

*)

type cont = A1 expr cont | A2 int cont | I

(**

One would want to write in Why:

[function eval_cont (c:cont) (v:int) : int =
  match c with
  | A1 e2 k ->
    let v2 = eval_0 e2 in
    eval_cont (A2 v k) v2
  | A2 v1 k -> eval_cont k (v1 - v)
  | I -> v
  end]

But since the recursion is not structural, Why3 kernel rejects it
(definitions in the logic part of the language must be total)

We replace that with a relational definition, an inductive one.

*)

inductive eval_cont cont int int =
| a1 :
  forall e2:expr, k:cont, v:int, r:int.
  eval_cont (A2 v k) (eval_0 e2) r -> eval_cont (A1 e2 k) v r
| a2 :
  forall v1:int, k:cont, v:int, r:int.
  eval_cont k (v1 - v) r -> eval_cont (A2 v1 k) v r
| a3 :
  forall v:int. eval_cont I v v

(** Some functions to serve as measures for the termination proof *)

function size_e (e:expr) : int =
  match e with
  | Cte _ -> 1
  | Sub e1 e2 -> 3 + size_e e1 + size_e e2
  end

let rec lemma size_e_pos (e:expr) : unit
  variant { e }
  ensures { size_e e >= 1 }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 -> size_e_pos e1; size_e_pos e2
  end

function size_c (c:cont) : int =
  match c with
  | I -> 0
  | A1 e2 k -> 2 + size_e e2 + size_c k
  | A2 _ k -> 1 + size_c k
  end

let rec lemma size_c_pos (c:cont) : unit
  variant { c }
  ensures { size_c c >= 0 }
= match c with
  | I -> ()
  | A1 _ k -> size_c_pos k
  | A2 _ k -> size_c_pos k
  end

(** WhyML programs (declared with "let" instead of "function"),
   mutually recursive, resulting from de-functionalization *)

let rec continue_2 (c:cont) (v:int) : int
  variant { size_c c }
  ensures { eval_cont c v result }
  =
  match c with
    | A1 e2 k -> eval_2 e2 (A2 v k)
    | A2 v1 k -> continue_2 k (v1 - v)
    | I -> v
  end

with eval_2 (e:expr) (c:cont) : int
  variant { size_c c + size_e e }
  ensures { eval_cont c (eval_0 e) result }
  =
  match e with
    | Cte n -> continue_2 c n
    | Sub e1 e2 -> eval_2 e1 (A1 e2 c)
  end

(** The interpreter. The post-condition specifies that this program
    computes the same thing as [eval_0] *)

let interpret_2 (p:prog) : int
  ensures { result = eval_0 p }
  = eval_2 p I

let u0 () = interpret_2 p0
let u1 () = interpret_2 p1
let u2 () = interpret_2 p2
let u3 () = interpret_2 p3
let u4 () = interpret_2 p4

end




(** {2 Semantics with errors} *)

module SemWithError

use import Expr

(*


Errors:

s  :  error


Expressible values:

ve  :  expressible_value
ve ::= v | s

*)

type value = Vnum int | Underflow

(*
Interpretation:

------
n => n

     e1 => s
------------
e1 - e2 => s

e1 => n1   e2 => s
------------------
      e1 - e2 => s

e1 => n1   e2 => n2   n1 < n2
-----------------------------
      e1 - e2 => "underflow"

e1 => n1   e2 => n2   n1 >= n2   n1 - n2 = n3
---------------------------------------------
      e1 - e2 => n3

We interpret the program e into value n if the judgement

  e => n

holds, and into error s if the judgement

  e => s

holds.


Exercise 0:
  Program the interpretor above and test it on the examples.

  eval_0 : expr -> expressible_value
  interpret_0 : program -> expressible_value

*)

function eval_0 (e:expr) : value =
  match e with
  | Cte n -> if n >= 0 then Vnum n else Underflow
  | Sub e1 e2 ->
     match eval_0 e1 with
     | Underflow -> Underflow
     | Vnum v1 ->
       match eval_0 e2 with
       | Underflow -> Underflow
       | Vnum v2 ->
         if v1 >= v2 then Vnum (v1 - v2) else Underflow
       end
     end
  end

function interpret_0 (p:prog) : value = eval_0 p

let t0 () = interpret_0 p0
let t1 () = interpret_0 p1
let t2 () = interpret_0 p2
let t3 () = interpret_0 p3
let t4 () = interpret_0 p4


(*
Exercise 1:
  CPS-transform (call by value, from left to right)
  the function [eval_0], call it from the main interpreter
  with the identity function as initial continuation.

      eval_1 : expr -> (expressible_value -> 'a) -> 'a
  interpret_1 : program -> expressible_value

*)



use HighOrd (* import not needed, but why ? *)

function eval_1 (e:expr) (k:value -> 'a) : 'a =
  match e with
    | Cte n -> k (if n >= 0 then Vnum n else Underflow)
    | Sub e1 e2 ->
      eval_1 e1 (\ v1.
       match v1 with
       | Underflow -> k Underflow
       | Vnum v1 ->
         eval_1 e2 (\ v2.
         match v2 with
         | Underflow -> k Underflow
         | Vnum v2 -> k (if v1 >= v2 then Vnum (v1 - v2) else Underflow)
         end)
       end)
  end

function interpret_1 (p : prog) : value = eval_1 p (\ n. n)


let rec lemma cps_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k:value -> 'a. eval_1 e k = k (eval_0 e) }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps_correct_expr e1;
      cps_correct_expr e2
  end

lemma cps_correct: forall p. interpret_1 p = interpret_0 p

(*
Exercise 2:

  Divide the continuation

    expressible_value -> 'a

  in two: 

    (value -> 'a) * (error -> 'a)

  and adapt [eval_1] and [interpret_1] as

       eval_2 : expr -> (value -> 'a) -> (error -> 'a) -> 'a
  interpret_2 : program -> expressible_value

*)



(*
function eval_2 (e:expr) (k:int -> 'a) (kerr: unit -> 'a) : 'a =
  match e with
    | Cte n -> if n >= 0 then k n else kerr ()
    | Sub e1 e2 ->
      eval_2 e1 (\ v1.
         eval_2 e2 (\ v2.
           if v1 >= v2 then k (v1 - v2) else kerr ())
           kerr) kerr
  end
*)

function eval_2 (e:expr) (k:int -> 'a) (kerr: unit -> 'a) : 'a =
  match e with
    | Cte n -> if n >= 0 then k n else kerr ()
    | Sub e1 e2 ->
      eval_2 e1 (eval_2a e2 k kerr) kerr
  end

with eval_2a (e2:expr) (k:int -> 'a) (kerr : unit -> 'a) : int -> 'a =
  (\ v1. eval_2 e2 (eval_2b v1 k kerr) kerr)

with eval_2b (v1:int) (k:int -> 'a) (kerr : unit -> 'a) : int -> 'a =
  (\ v2. if v1 >= v2 then k (v1 - v2) else kerr ())



function interpret_2 (p : prog) : value = 
  eval_2 p (\ n. Vnum n) (\ u. Underflow)

let rec lemma cps2_correct_expr (e:expr) (kerr:unit -> 'a): unit
  variant { e }
  ensures { forall k. eval_2 e k kerr =
    match eval_0 e with Vnum n -> k n | Underflow -> kerr () end }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps2_correct_expr e1 kerr;
      cps2_correct_expr e2 kerr;
      assert {forall k. eval_2 e k kerr = eval_2 e1 (eval_2a e2 k kerr) kerr }
  end

lemma cps2_correct: forall p. interpret_2 p = interpret_0 p

(*

Exercise 3:
  Specialize the codomain of the continuations and of the evaluation function
  so that it is not polymorphic anymore but is [expressible_value], and
  then short-circuit the second continuation to stop in case of error

       eval_3 : expr -> (value -> expressible_value) -> expressible_value
  interpret_3 : program -> expressible_value

  NB: Now there is only one continuation and it is applied only in
  absence of error.

*)


function eval_3 (e:expr) (k:int -> value) : value =
  match e with
    | Cte n -> if n >= 0 then k n else Underflow
    | Sub e1 e2 ->
      eval_3 e1 (eval_3a e2 k)
  end

with eval_3a (e2:expr) (k:int -> value) : int -> value =
  (\ v1. eval_3 e2 (eval_3b v1 k))

with eval_3b (v1:int) (k:int -> value) : int -> value =
  (\ v2. if v1 >= v2 then k (v1 - v2) else Underflow)


function interpret_3 (p : prog) : value = eval_3 p (\ n. Vnum n)

let rec lemma cps3_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k. eval_3 e k =
    match eval_0 e with Vnum n -> k n | Underflow -> Underflow end }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps3_correct_expr e1;
      cps3_correct_expr e2;
      assert {forall k. eval_3 e k = eval_3 e1 (eval_3a e2 k) }
  end

lemma cps3_correct: forall p. interpret_3 p = interpret_0 p


(*
Exercise 4:
  De-functionalize the continuation of [eval_3].

         cont ::= ...

    continue_4 : cont -> value -> expressible_value
        eval_4 : expr -> cont -> expressible_value
  interprete_4 : program -> expressible_value

  The data type [cont] represents the grammar of contexts.
  (NB. has it changed w.r.t to previous exercise?)

  The two mutually recursive functions [eval_4] and [continue_4]
  implement an abstract machine, that is a transition system that
  stops immediately in case of error, or and the end of computation.

*)


(* TODO *)


end


(** {2 The lambda-calculus} *)

(*
Terms:

n : int

x : identifier

t  : term
t ::= x | \x.t | t t

p  :  program
p ::= t
      where t is ground (i.e. without any free variable)


Examples:

p0 = (\x.x)
p1 = (\x.x) (\x.x)
p2 = (\x.\f.f x) (\y.y) (\x.x)


Values and environments:

e  :  environment
v ::= nil | (identifier, value) :: environment

v  :  value
v ::= (\x.t, e)


Operateur algebrique:

lookup : identificateur -> environnement -> value


Contextes d'evaluation:

C ::= [] | [C (t, e)] | [v C]


Machine abstraite (dite "CEK"):

    <x, e, C>_eval -> <C, v>_cont
                      oÃ¹ v = lookup x e
 <\x.t, e, C>_eval -> <C, (\x.t, e)>_cont
<t0 t1, e, C>_eval -> <t0, e, [C (t1, e)]>

           <[], v>_cont -> v
   <[C (t, e)], v>_cont -> <t, e, [v C]>_eval
<[(\x.t, e) C], v>_cont -> <t, (x, v) :: e, C>_eval


Exercise 0:
  Programr cette machine abstraite.


Exercise 1:
  Cette machine abstraite est en forme defonctionalisee.
  La refonctionaliser.


Exercise 2:
  Le resultat de l'Exercise 1 est en CPS.
  L'exprimer en style direct.


Exercise 3:
  Le resultat de l'Exercise 2 est en forme defonctionalisee
  (dans le sens que les fermetures sont en forme defonctionalisee
  triviale).
  Le refonctionaliser, et caracteriser le resultat.

----------

% fin de danvy-ex1.txt

*)







(*
% danvy-ex2.txt
% exercices pour JFLA 2014
% 9 janvier 2014
% Olivier Danvy <danvy@cs.au.dk>

----------
*)

module R

  use import Expr

  use import DirectSem

(*
Une semantique a petits pas iterative avec des contextes de reduction:

"Reduction semantics" pour les expressions arithmetiques
--------------------------------------------------------


Expressions:

n  :  int

e  :  expression
e ::= n | e - e

p  :  program
p ::= e


Exemples:

p0 = 0
p1 = 10 - 6
p2 = (10 - 6) - (7 - 2)
p3 = (7 - 2) - (10 - 6)
p4 = 10 - (2 - 3)


Values:

v  :  value
v ::= n


Redexes potentiels:

  rp ::= n1 - n2


Regle de reduction:

  n1 - n2 -> n3

(pour les entiers Z, tous les redexes potentiels sont de vrais redexes;
 pour les entiers naturels, pas tous ne le sont:
   n1 - n2 -> n3   si n1 >= n2
 un redex potentiel qui n'en est pas un vrai est "coince" (stuck).)


Fonction de contraction:

  contracte : redex_potentiel -> expression + stuck
  contracte (n1 - n2) = n3   si n3 = n1 - n2
*)


predicate is_a_redex (e:expr) =
  match e with
  | Sub (Cte _) (Cte _) -> true
  | _ -> false
  end

let contracte (e:expr) : expr
  requires { is_a_redex e }
  ensures { eval_0 result = eval_0 e }
  =
  match e with
  | Sub (Cte v1) (Cte v2) -> Cte (v1 - v2)
  | _ -> absurd
  end

(*
et si on n'a que des entiers naturels,

  contracte (n1 - n2) = n3     si n1 >= n2 et n3 = n1 - n2
  contracte (n1 - n2) = stuck  si n1 < n2


Contextes de reduction:

C  : cont
C ::= [] | [C e] | [v C]
*)

type context = Empty | Left context expr | Right int context

(*
Recomposition:

             recompose : cont * expression -> expression
     recompose ([], e) = e
recompose ([C e2], e1) = recompose (C, e1 - e2)
recompose ([n1 C], e2) = recompose (C, n1 - e2)
*)

function recompose (c:context) (e:expr) : expr =
  match c with
  | Empty -> e
  | Left c e2 -> recompose c (Sub e e2)
  | Right n1 c -> recompose c (Sub (Cte n1) e)
  end

let rec lemma recompose_values (c:context) (e1 e2:expr) : unit
  requires { eval_0 e1 = eval_0 e2 }
  variant  { c }
  ensures  { eval_0 (recompose c e1) = eval_0 (recompose c e2) }
= match c with
  | Empty -> ()
  | Left c e -> recompose_values c (Sub e1 e) (Sub e2 e)
  | Right n c -> recompose_values c (Sub (Cte n) e1) (Sub (Cte n) e2)
  end

let rec lemma recompose_inversion (c:context) (e:expr) 
  requires { 
      match c with Empty -> false | _ -> true end \/ 
      match e with Cte _ -> false | Sub _ _ -> true end }
  variant { c }
  ensures {  match recompose c e with 
               Cte _ -> false | Sub _ _ -> true end }
= match c with 
  | Empty -> ()
  | Left c e2 -> recompose_inversion c (Sub e e2)
  | Right n1 c -> recompose_inversion c (Sub (Cte n1) e)
  end

(*
Decomposition:

dec_ou_val = (C, rp) | v

fonction de decomposition:

             decompose_term : expression * cont -> dec_ou_val
      decompose_term (n, C) = decompose_cont (C, n)
decompose_term (e1 - e2, C) = decompose_term (e1, [C e2])

             decompose_cont : cont * value -> dec_ou_val
     decompose_cont ([], n) = n
  decompose_cont ([C e], n) = decompose_term (e, [n c])
decompose_term ([n1 C], n2) = (C, n1 - n2)

  decompose : expression -> dec_ou_val
decompose e = decompose_term (e, [])
*)

exception NoRedex

predicate is_a_value (e:expr) =
  match e with
  | Cte _ -> true
  | _ -> false
  end

let rec decompose_term (e:expr) (c:context) : (context, expr)
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c e /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value (recompose c e) }
  =
  match e with
  | Cte n -> decompose_cont c n
  | Sub e1 e2 -> decompose_term e1 (Left c e2)
  end

with decompose_cont (c:context) (n:int) : (context, expr)
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c (Cte n)  /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value (recompose c (Cte n)) }
  =
  match c with
  | Empty -> raise NoRedex
  | Left c e -> decompose_term e (Right n c)
  | Right n1 c -> (c, Sub (Cte n1) (Cte n))
  end

let decompose (e:expr) : (context, expr)
  ensures { let (c1,e1) = result in recompose c1 e1 = e  /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value e }
  =
  decompose_term e Empty

(*

Un pas de reduction:

reduis : expression -> expression + stuck

si decompose e = v
alors reduis e = stuck

si decompose e = (C, rp)
et contracte rp = stuck
alors reduis e = stuck

si decompose e = (C, rp)
et contracte rp = c
alors reduis e = recompose (C, c)

*)

let reduis (e:expr) : expr
  ensures { eval_0 result = eval_0 e }
  diverges
  raises { NoRedex -> is_a_value e }
  =
  let (c,r) = decompose e in
  recompose c (contracte r)

(*
Evaluation basee sur la reduction iteree:

itere : red_ou_val -> value + erreur

itere v = v

si contracte rp = stuck
alors itere (C, rp) = stuck

si contracte rp = c
alors itere (C, rp) = itere (decompose (recompose (C, c)))
*)


let rec itere (e:expr) : int
  diverges
  ensures { eval_0 e = result }
  =
  try
    let e' = reduis e in
    itere e'
  with NoRedex ->
     match e with
     | Cte n -> n
     | _ -> absurd
     end
  end

(*

Exercise 1:
  Implementer la "reduction semantics" ci-dessus et la tester.


Exercise 2:
  Optimiser l'etape de recomposition / decomposition
  en une fonction "refocus".

*)


let refocus c e
  diverges
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c e /\
            is_a_redex e1 }
  raises { NoRedex -> is_a_value (recompose c e) }
  = decompose_term e c

let rec itere_opt (c:context) (e:expr) : int
  diverges
  ensures { result = eval_0 (recompose c e) }
  =
  try
    let (c,r) = refocus c e in
    itere_opt c (contracte r)
  with NoRedex ->
     match recompose c e with
     | Cte n -> n
     | _ -> absurd
     end
  end

let rec normalize (e:expr)
 diverges
 = itere_opt Empty e




(*

Exercise 3:
  Obtenir une machine abstraite.

*)

(* TODO *)

end

