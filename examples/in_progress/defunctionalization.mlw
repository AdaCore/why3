(*
% danvy-ex1.txt
% exercices pour JFLA 2014
% 8 janvier 2014
% Olivier Danvy <danvy@cs.au.dk>

----------
*)

module Expr

use export int.Int

(*
1. Les expressions arithmétiques
   -----------------------------

Expressions:

n  :  int

e  :  expression
e ::= n | e - e

p  :  programme
p ::= e
*)

type expr = Cte int | Sub expr expr

type prog = expr

(*

Exemples:

p0 = 0
p1 = 10 - 6
p2 = (10 - 6) - (7 - 2)
p3 = (7 - 2) - (10 - 6)
p4 = 10 - (2 - 3)

*)

constant p0 : prog = Cte 0
constant p1 : prog = Sub (Cte 10) (Cte 6)
constant p2 : prog = Sub (Sub (Cte 10) (Cte 6)) (Sub (Cte 7) (Cte 2))
constant p3 : prog = Sub (Sub (Cte 7) (Cte 2)) (Sub (Cte 10) (Cte 6))
constant p4 : prog = Sub (Cte 10) (Sub (Cte 2) (Cte 3))


end


module SemDirecte

use import Expr

(*
Valeurs:

v  :  valeur
v ::= n


Valeurs expressibles:

ve  :  valeur_expressible
ve ::= v


Interprétation:

------
n => n

e1 => n1   e2 => n2   n1 - n2 = n3
----------------------------------
      e1 - e2 => n3


On interprète le programme e en la valeur n si le jugement

  e => n

est satisfait.


Exercice 0:
  Programmer l'interprète ci-dessus (disons en OCaml)
  et le tester sur les exemples.

  evalue_0 : expression -> valeur_expressible
  interprete_0 : programme -> valeur_expressible
*)

(* Note: les definitions Why3 avec "function" sont dans la partie
logique du langage *)

function evalue_0 (e:expr) : int =
  match e with
  | Cte n -> n
  | Sub e1 e2 ->
     let v1 = evalue_0 e1 in
     let v2 = evalue_0 e2 in
     v1 - v2
  end

function interprete_0 (p:prog) : int = evalue_0 p

(*

tests, jouables avec

  why3 defunctionalization.mlw --exec SemDirecte.t0

(resp SemDirecte.t1, SemDirecte.t2, etc. version 0.82 requise)

*)

let t0 () = interprete_0 p0
let t1 () = interprete_0 p1
let t2 () = interprete_0 p2
let t3 () = interprete_0 p3
let t4 () = interprete_0 p4


end


module CPS

use import Expr

(*


Exercice 1:
  CPS-transformer (en appel par valeur, de gauche à droite)
  la fonction evalue_0,
  et l'appeler dans la fonction principale de l'interprète
  avec comme continuation initiale la fonction identité.

      evalue_1 : expression -> (valeur_expressible -> 'a) -> 'a
  interprete_1 : programme -> valeur_expressible

*)

(*

On voudrait ecrire

*)

use HighOrd (* import not needed, but why ? *)

function evalue_1 (e:expr) (k:int -> 'a) : 'a =
  match e with
    | Cte n -> k n
    | Sub e1 e2 ->
      evalue_1 e1 (\ v1. evalue_1 e2 (\ v2. k (v1 - v2)))
  end

function interprete_1 (p : prog) : int = evalue_1 p (\ n. n)


use import SemDirecte


let rec lemma cps_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k:int -> 'a. evalue_1 e k = k (evalue_0 e) }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps_correct_expr e1;
      cps_correct_expr e2
  end

lemma cps_correct: forall p. interprete_1 p = interprete_0 p

end



module Defonct

use import Expr
use import SemDirecte

(*
Exercice 2:
  Defonctionaliser la continuation de evalue_1.

         cont ::= ...

    continue_2 : cont -> valeur -> valeur
      evalue_2 : expression -> cont -> valeur
  interprete_2 : programme -> valeur

  Le type de donnees ("data type") cont represente
  la grammaire des contextes.

  Les deux fonctions mutuellement recursives evalue_2
  et continue_2 implementent une machine abstraite,
  c'est Ã  dire un systÃ¨me de transition d'etats.

*)

type cont = A1 expr cont | A2 int cont | I

(*

On voudrait ecrire

function evalue_cont (c:cont) (v:int) : int =
  match c with
  | A1 e2 k ->
    let v2 = evalue_0 e2 in
    evalue_cont (A2 v k) v2
  | A2 v1 k -> evalue_cont k (v1 - v)
  | I -> v
  end

Mais la recursion n'etant pas structurelle, le noyau de Why3 la refuse
(les definitions dans la logique doivent etre totales)

On remplace par une definition relationnelle, inductive.

*)

inductive evalue_cont cont int int =
| a1 :
  forall e2:expr, k:cont, v:int, r:int.
  evalue_cont (A2 v k) (evalue_0 e2) r -> evalue_cont (A1 e2 k) v r
| a2 :
  forall v1:int, k:cont, v:int, r:int.
  evalue_cont k (v1 - v) r -> evalue_cont (A2 v1 k) v r
| a3 :
  forall v:int. evalue_cont I v v

(* fonctions servant de mesure pour la preuve de terminaison *)

function size_e (e:expr) : int =
  match e with
  | Cte _ -> 1
  | Sub e1 e2 -> 3 + size_e e1 + size_e e2
  end

let rec lemma size_e_pos (e:expr) : unit
  variant { e }
  ensures { size_e e >= 1 }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 -> size_e_pos e1; size_e_pos e2
  end

function size_c (c:cont) : int =
  match c with
  | I -> 0
  | A1 e2 k -> 2 + size_e e2 + size_c k
  | A2 _ k -> 1 + size_c k
  end

let rec lemma size_c_pos (c:cont) : unit
  variant { c }
  ensures { size_c c >= 0 }
= match c with
  | I -> ()
  | A1 _ k -> size_c_pos k
  | A2 _ k -> size_c_pos k
  end

(* programmes WhyML (declarés avec "let" au lieu de "function"),
   mutuellement recursifs resultant de la defonctionalisation *)

let rec continue_2 (c:cont) (v:int) : int
  variant { size_c c }
  ensures { evalue_cont c v result }
  =
  match c with
    | A1 e2 k -> evalue_2 e2 (A2 v k)
    | A2 v1 k -> continue_2 k (v1 - v)
    | I -> v
  end

with evalue_2 (e:expr) (c:cont) : int
  variant { size_c c + size_e e }
  ensures { evalue_cont c (evalue_0 e) result }
  =
  match e with
    | Cte n -> continue_2 c n
    | Sub e1 e2 -> evalue_2 e1 (A1 e2 c)
  end

(* L'interprete. La post-condition specifie que ce programme calcule
   la meme chose que evalue_0 *)

let interprete_2 (p:prog) : int
  ensures { result = evalue_0 p }
  = evalue_2 p I

let u0 () = interprete_2 p0
let u1 () = interprete_2 p1
let u2 () = interprete_2 p2
let u3 () = interprete_2 p3
let u4 () = interprete_2 p4

end


module SemErreur

use import Expr

(*
2. Les expressions arithmetiques, avec des erreurs
   -----------------------------------------------

Expressions:

n  :  nat

e  :  terme
e ::= n | e - e

p  :  programme
p ::= e


Exemples:

p0 = 0
p1 = 10 - 6
p2 = (10 - 6) - (7 - 2)
p3 = (7 - 2) - (10 - 6)
p4 = 10 - (2 - 3)


Valeurs:

v  :  valeur
v ::= n


Erreurs:

s  :  erreur


Valeurs expressibles:

ve  :  valeur_expressible
ve ::= v | s

*)

type valeur = Vnum int | Underflow

(*
Interpretation:

------
n => n

     e1 => s
------------
e1 - e2 => s

e1 => n1   e2 => s
------------------
      e1 - e2 => s

e1 => n1   e2 => n2   n1 < n2
-----------------------------
      e1 - e2 => "underflow"

e1 => n1   e2 => n2   n1 >= n2   n1 - n2 = n3
---------------------------------------------
      e1 - e2 => n3

On interprÃ¨te le programme e en la valeur n si le jugement

  e => n

est satisfait, et en l'erreur s si le jugement

  e => s

est satisfait.


Exercice 0:
  Programmer l'interprete ci-dessus
  et le tester sur les exemples.

  evalue_0 : terme -> valeur_expressible
  interprete_0 : programme -> valeur_expressible

*)

function evalue_0 (e:expr) : valeur =
  match e with
  | Cte n -> if n >= 0 then Vnum n else Underflow
  | Sub e1 e2 ->
     match evalue_0 e1 with
     | Underflow -> Underflow
     | Vnum v1 ->
       match evalue_0 e2 with
       | Underflow -> Underflow
       | Vnum v2 ->
         if v1 >= v2 then Vnum (v1 - v2) else Underflow
       end
     end
  end

function interprete_0 (p:prog) : valeur = evalue_0 p

let t0 () = interprete_0 p0
let t1 () = interprete_0 p1
let t2 () = interprete_0 p2
let t3 () = interprete_0 p3
let t4 () = interprete_0 p4


(*
Exercice 1:
  CPS-transformer (en appel par valeur, de gauche a  droite)
  la fonction evalue_0,
  et l'appeler dans la fonction principale de l'interprete
  avec comme continuation initiale la fonction identite.

      evalue_1 : terme -> (valeur_expressible -> 'a) -> 'a
  interprÃ¨te_1 : programme -> valeur_expressible

*)



use HighOrd (* import not needed, but why ? *)

function evalue_1 (e:expr) (k:valeur -> 'a) : 'a =
  match e with
    | Cte n -> k (if n >= 0 then Vnum n else Underflow)
    | Sub e1 e2 ->
      evalue_1 e1 (\ v1.
       match v1 with
       | Underflow -> k Underflow
       | Vnum v1 ->
         evalue_1 e2 (\ v2.
         match v2 with
         | Underflow -> k Underflow
         | Vnum v2 -> k (if v1 >= v2 then Vnum (v1 - v2) else Underflow)
         end)
       end)
  end

function interprete_1 (p : prog) : valeur = evalue_1 p (\ n. n)


let rec lemma cps_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k:valeur -> 'a. evalue_1 e k = k (evalue_0 e) }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps_correct_expr e1;
      cps_correct_expr e2
  end

lemma cps_correct: forall p. interprete_1 p = interprete_0 p

(*
Exercice 2:
  Diviser la continuation
    valeur_expressible -> 'a
  en deux:
    (valeur -> 'a) * (erreur -> 'a)
  et adapter evalue_1 et interprÃ¨te_1.

      evalue_2 : terme -> (valeur -> 'a) -> (erreur -> 'a) -> 'a
  interprÃ¨te_2 : programme -> valeur_expressible

*)



(*
function evalue_2 (e:expr) (k:int -> 'a) (kerr: unit -> 'a) : 'a =
  match e with
    | Cte n -> if n >= 0 then k n else kerr ()
    | Sub e1 e2 ->
      evalue_2 e1 (\ v1.
         evalue_2 e2 (\ v2.
           if v1 >= v2 then k (v1 - v2) else kerr ())
           kerr) kerr
  end
*)

function evalue_2 (e:expr) (k:int -> 'a) (kerr: unit -> 'a) : 'a =
  match e with
    | Cte n -> if n >= 0 then k n else kerr ()
    | Sub e1 e2 ->
      evalue_2 e1 (evalue_2a e2 k kerr) kerr
  end

with evalue_2a (e2:expr) (k:int -> 'a) (kerr : unit -> 'a) : int -> 'a =
  (\ v1. evalue_2 e2 (evalue_2b v1 k kerr) kerr)

with evalue_2b (v1:int) (k:int -> 'a) (kerr : unit -> 'a) : int -> 'a =
  (\ v2. if v1 >= v2 then k (v1 - v2) else kerr ())



function interprete_2 (p : prog) : valeur = evalue_2 p (\ n. Vnum n) (\ u. Underflow)

let rec lemma cps2_correct_expr (e:expr) (kerr:unit -> 'a): unit
  variant { e }
  ensures { forall k. evalue_2 e k kerr =
    match evalue_0 e with Vnum n -> k n | Underflow -> kerr () end }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps2_correct_expr e1 kerr;
      cps2_correct_expr e2 kerr;
      assert {forall k. evalue_2 e k kerr = evalue_2 e1 (evalue_2a e2 k kerr) kerr }
  end

lemma cps2_correct: forall p. interprete_2 p = interprete_0 p

(*

Exercice 3:
  Specialiser le co-domaine des continuations et de la fonction
  d'evaluation pour qu'il ne soit plus polymorphique
  mais qu'il soit valeur_expressible, et
  court-circuiter la seconde continuation pour ne pas continuer
  en cas d'erreur.

      evalue_3 : terme -> (valeur -> valeur_expressible) -> valeur_expressible
  interprÃ¨te_3 : programme -> valeur_expressible

  (NB. Maintenant il n'y a plus qu'une continuation et elle n'est
  appliquee que s'il n'y a pas eu d'erreur.)

*)


function evalue_3 (e:expr) (k:int -> valeur) : valeur =
  match e with
    | Cte n -> if n >= 0 then k n else Underflow
    | Sub e1 e2 ->
      evalue_3 e1 (evalue_3a e2 k)
  end

with evalue_3a (e2:expr) (k:int -> valeur) : int -> valeur =
  (\ v1. evalue_3 e2 (evalue_3b v1 k))

with evalue_3b (v1:int) (k:int -> valeur) : int -> valeur =
  (\ v2. if v1 >= v2 then k (v1 - v2) else Underflow)


function interprete_3 (p : prog) : valeur = evalue_3 p (\ n. Vnum n)

let rec lemma cps3_correct_expr (e:expr) : unit
  variant { e }
  ensures { forall k. evalue_3 e k =
    match evalue_0 e with Vnum n -> k n | Underflow -> Underflow end }
= match e with
  | Cte _ -> ()
  | Sub e1 e2 ->
      cps3_correct_expr e1;
      cps3_correct_expr e2;
      assert {forall k. evalue_3 e k = evalue_3 e1 (evalue_3a e2 k) }
  end

lemma cps3_correct: forall p. interprete_3 p = interprete_0 p


(*
Exercice 4:
  Defonctionaliser la continuation de evalue_3.

         cont ::= ...

    continue_4 : cont -> valeur -> valeur_expressible
      evalue_4 : terme -> cont -> valeur_expressible
  interprÃ¨te_4 : programme -> valeur_expressible

  Le type de donnees ("data type") cont represente
  la grammaire des contextes.  (NB. A-t-il change
  par rapport Ã  l'exercice precedent?)

  Les deux fonctions mutuellement recursives evalue_4
  et continue_4 implementent une machine abstraite,
  c'est Ã  dire un systÃ¨me de transition d'etats,
  qui s'arrÃªte soit tout de suite en cas d'erreur,
  soit Ã  la fin du calcul.

----------

Le lambda-calcul
----------------

Termes:

n : int

x : identificateur

t  : terme
t ::= x | \x.t | t t

p  :  programme
p ::= t
      oÃ¹ t est ferme (i.e., sans variables libres)


Exemples:

p0 = (\x.x)
p1 = (\x.x) (\x.x)
p2 = (\x.\f.f x) (\y.y) (\x.x)


Valeurs et environnements:

e  :  environnement
v ::= nil | (identificateur, valeur) :: environnement

v  :  valeur
v ::= (\x.t, e)


Operateur algebrique:

lookup : identificateur -> environnement -> valeur


Contextes d'evaluation:

C ::= [] | [C (t, e)] | [v C]


Machine abstraite (dite "CEK"):

    <x, e, C>_eval -> <C, v>_cont
                      oÃ¹ v = lookup x e
 <\x.t, e, C>_eval -> <C, (\x.t, e)>_cont
<t0 t1, e, C>_eval -> <t0, e, [C (t1, e)]>

           <[], v>_cont -> v
   <[C (t, e)], v>_cont -> <t, e, [v C]>_eval
<[(\x.t, e) C], v>_cont -> <t, (x, v) :: e, C>_eval


Exercice 0:
  Programmer cette machine abstraite.


Exercice 1:
  Cette machine abstraite est en forme defonctionalisee.
  La refonctionaliser.


Exercice 2:
  Le resultat de l'Exercice 1 est en CPS.
  L'exprimer en style direct.


Exercice 3:
  Le resultat de l'Exercice 2 est en forme defonctionalisee
  (dans le sens que les fermetures sont en forme defonctionalisee
  triviale).
  Le refonctionaliser, et caracteriser le resultat.

----------

% fin de danvy-ex1.txt

*)


end



(*
% danvy-ex2.txt
% exercices pour JFLA 2014
% 9 janvier 2014
% Olivier Danvy <danvy@cs.au.dk>

----------
*)

module R

  use import Expr

  use import SemDirecte

(*
Une semantique a petits pas iterative avec des contextes de reduction:

"Reduction semantics" pour les expressions arithmetiques
--------------------------------------------------------


Expressions:

n  :  int

e  :  expression
e ::= n | e - e

p  :  programme
p ::= e


Exemples:

p0 = 0
p1 = 10 - 6
p2 = (10 - 6) - (7 - 2)
p3 = (7 - 2) - (10 - 6)
p4 = 10 - (2 - 3)


Valeurs:

v  :  valeur
v ::= n


Redexes potentiels:

  rp ::= n1 - n2


Regle de reduction:

  n1 - n2 -> n3

(pour les entiers Z, tous les redexes potentiels sont de vrais redexes;
 pour les entiers naturels, pas tous ne le sont:
   n1 - n2 -> n3   si n1 >= n2
 un redex potentiel qui n'en est pas un vrai est "coince" (stuck).)


Fonction de contraction:

  contracte : redex_potentiel -> expression + stuck
  contracte (n1 - n2) = n3   si n3 = n1 - n2
*)


predicate is_a_redex (e:expr) =
  match e with
  | Sub (Cte _) (Cte _) -> true
  | _ -> false
  end

let contracte (e:expr) : expr
  requires { is_a_redex e }
  ensures { evalue_0 result = evalue_0 e }
  =
  match e with
  | Sub (Cte v1) (Cte v2) -> Cte (v1 - v2)
  | _ -> absurd
  end

(*
et si on n'a que des entiers naturels,

  contracte (n1 - n2) = n3     si n1 >= n2 et n3 = n1 - n2
  contracte (n1 - n2) = stuck  si n1 < n2


Contextes de reduction:

C  : cont
C ::= [] | [C e] | [v C]
*)

type context = Empty | Left context expr | Right int context

(*
Recomposition:

             recompose : cont * expression -> expression
     recompose ([], e) = e
recompose ([C e2], e1) = recompose (C, e1 - e2)
recompose ([n1 C], e2) = recompose (C, n1 - e2)
*)

function recompose (c:context) (e:expr) : expr =
  match c with
  | Empty -> e
  | Left c e2 -> recompose c (Sub e e2)
  | Right n1 c -> recompose c (Sub (Cte n1) e)
  end

let rec lemma recompose_values (c:context) (e1 e2:expr) : unit
  requires { evalue_0 e1 = evalue_0 e2 }
  variant  { c }
  ensures  { evalue_0 (recompose c e1) = evalue_0 (recompose c e2) }
= match c with
  | Empty -> ()
  | Left c e -> recompose_values c (Sub e1 e) (Sub e2 e)
  | Right n c -> recompose_values c (Sub (Cte n) e1) (Sub (Cte n) e2)
  end

(*
Decomposition:

dec_ou_val = (C, rp) | v

fonction de decomposition:

             decompose_term : expression * cont -> dec_ou_val
      decompose_term (n, C) = decompose_cont (C, n)
decompose_term (e1 - e2, C) = decompose_term (e1, [C e2])

             decompose_cont : cont * valeur -> dec_ou_val
     decompose_cont ([], n) = n
  decompose_cont ([C e], n) = decompose_term (e, [n c])
decompose_term ([n1 C], n2) = (C, n1 - n2)

  decompose : expression -> dec_ou_val
decompose e = decompose_term (e, [])
*)

exception NoRedex

predicate is_a_value (e:expr) =
  match e with
  | Cte _ -> true
  | _ -> false
  end

let rec decompose_term (e:expr) (c:context) : (context, expr)
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c e /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value (recompose c e) }
  =
  match e with
  | Cte n -> decompose_cont c n
  | Sub e1 e2 -> decompose_term e1 (Left c e2)
  end

with decompose_cont (c:context) (n:int) : (context, expr)
  ensures { let (c1,e1) = result in
            recompose c1 e1 = recompose c (Cte n)  /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value (recompose c (Cte n)) }
  =
  match c with
  | Empty -> raise NoRedex
  | Left c e -> decompose_term e (Right n c)
  | Right n1 c -> (c, Sub (Cte n1) (Cte n))
  end

let decompose (e:expr) : (context, expr)
  ensures { let (c1,e1) = result in recompose c1 e1 = e  /\
            is_a_redex e1 }
  diverges
  raises { NoRedex -> is_a_value e }
  =
  decompose_term e Empty

(*

Un pas de reduction:

reduis : expression -> expression + stuck

si decompose e = v
alors reduis e = stuck

si decompose e = (C, rp)
et contracte rp = stuck
alors reduis e = stuck

si decompose e = (C, rp)
et contracte rp = c
alors reduis e = recompose (C, c)

*)

let reduis (e:expr) : expr
  ensures { evalue_0 result = evalue_0 e }
  diverges
  raises { NoRedex -> is_a_value e }
  =
  let (c,r) = decompose e in
  recompose c (contracte r)

(*
Evaluation basee sur la reduction iteree:

itere : red_ou_val -> valeur + erreur

itere v = v

si contracte rp = stuck
alors itere (C, rp) = stuck

si contracte rp = c
alors itere (C, rp) = itere (decompose (recompose (C, c)))
*)


let rec itere (e:expr) : int
  diverges
  ensures { evalue_0 e = result }
  =
  try
    let e' = reduis e in
    itere e'
  with NoRedex ->
     match e with
     | Cte n -> n
     | _ -> absurd
     end
  end

(*

Exercice 1:
  Implementer la "reduction semantics" ci-dessus et la tester.


Exercice 2:
  Optimiser l'etape de recomposition / decomposition
  en une fonction "refocus".

*)


let refocus c e
  diverges
  raises { NoRedex -> is_a_value e }
  = decompose_term e c

let rec itere_opt (c:context) (e:expr) : int
  diverges
  ensures { result = evalue_0 (recompose c e) }
  =
  try
    let (c,r) = refocus c e in
    itere_opt c (contracte r)
  with NoRedex ->
     match recompose c e with
     | Cte n -> n
     | _ -> absurd
     end
  end

let rec normalize (e:expr)
 diverges
 = itere_opt Empty e




(*

Exercice 3:
  Obtenir une machine abstraite.

----------

% fin de danvy-ex2.txt

*)

end

