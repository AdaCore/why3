module Compiler_logic
  use import int.Int
  use import list.List
  use import list.Length
  use import list.Append
  use import imp.Imp
  use import vm.Vm
  use import state.State
  use import HighOrd



  type pred  = machine_state -> bool
  type post  = machine_state -> pred

  (* Hoare triples with explicit pre & post *)
  type codespec =
   { code: code;
     ghost pre : pos -> pred;
     ghost post: pos -> post }

 (* Weakest Precondition Calculus *)
  type wp =
   { wcode : code;
     ghost wp : pos -> pred -> pred }

  (*
  function offset (ms : machine_state) (ofs: pos) : machine_state
    = match ms
      with (VMS p s m) -> (VMS (p + ofs) s m) end *)



 predicate contextual_irrelevance (c : code) (p: pos) (ms1 ms2 : machine_state)
  = forall c_global: code.
     codeseq_at c_global p c ->
      transition_star c_global ms1 ms2

 predicate total_correctness (cs : codespec) =
   forall p: pos, ms : machine_state. cs.pre p ms ->
      exists ms' : machine_state. cs.post p ms ms'
      /\ contextual_irrelevance cs.code p ms ms'

 predicate transformer (code : wp) =
  forall p: pos, post : pred, ms: machine_state.
   (code.wp p post) ms ->
    exists ms' : machine_state. (post ms')
    /\ contextual_irrelevance code.wcode p ms ms'


 function seq_wp (s1 s2: wp) : pos -> pred -> pred =
  \p q. s1.wp p (s2.wp (p + s1.wcode.length) q)

 let (~) (s1 s2 : wp) : wp
  requires { transformer s1 /\ transformer s2 }
  ensures  { transformer result }
  ensures  { result.wp = seq_wp s1 s2 }
  ensures  { result.wcode.length = s1.wcode.length + s2.wcode.length }
  = let wcode = s1.wcode ++ s2.wcode in
    let res   =
    { wcode = wcode ;
      wp    = any pos -> pred -> pred ensures {result = seq_wp s1 s2 } } in
   assert {
   forall p: pos, post : pred, ms: machine_state.
    (res.wp p post) ms ->
     not (exists ms' : machine_state. (post ms')
          /\ contextual_irrelevance res.wcode p ms ms') ->
    (forall ms' : machine_state. ((s2.wp (p + s1.wcode.length) post) ms')
    /\ contextual_irrelevance res.wcode p ms ms'  -> false) && false
   };
   res

 function towp_wp (c : codespec) : pos -> pred -> pred =
  \p q ms. c.pre p ms && (forall ms'. c.post p ms ms' -> q ms')


 let (!!) (c: codespec) : wp
 requires { total_correctness c }
 ensures  { transformer result  }
 ensures  { result.wcode = c.code }
 ensures  { result.wp = towp_wp c }
 =  { wcode = c.code; wp = any pos -> pred -> pred ensures {result = towp_wp c}}

 let hoare (ghost pre: pos -> pred) (c: wp)
           (ghost post: pos -> machine_state -> pred) : codespec
 requires { transformer c }
 requires { forall p ms. pre p ms -> (c.wp p (post p ms)) ms }
 ensures  { result.code = c.wcode }
 ensures  { total_correctness result }
 ensures  { result.pre = pre /\ result.post = post }
 = { code = c.wcode ; pre = pre; post = post }




 constant ibinop_pre : pos -> pred =
  \p ms . exists n1 n2 s m. ms = VMS p (push n2 (push n1 s)) m


 function iadd_post : pos -> machine_state -> pred =
   \p ms ms'. forall n1 n2 s m.
      ms = VMS p (push n2 (push n1 s)) m  ->
      ms' = VMS (p + 1) (push (n1 + n2) s) m


 let iaddf () : codespec
  ensures { forall p ms. result.pre p ms <-> ibinop_pre p ms}
  ensures { forall p ms ms'. result.post p ms ms' <-> iadd_post p ms ms' }
  ensures { total_correctness result }
  ensures { result.code.length = 1 }
  = let res = {code = Cons Iadd Nil; pre  = ibinop_pre ; post = iadd_post } in
    assert {
     forall p ms. res.pre p ms ->
     not (exists ms' : machine_state. res.post p ms ms' /\
      contextual_irrelevance res.code p ms ms') ->
      match ms with
        | VMS p' (Cons n2 (Cons n1 s)) m -> p' = p &&
           let ms' = VMS (p+1) (push (n1 + n2) s) m in
              contextual_irrelevance res.code p ms ms' && false
        | _ -> false end && false };
    res

end


(*Imp to ImpVm compiler *)
(**************************************************************************)
module Compile_aexpr

  use import int.Int
  use import list.List
  use import list.Length
  use import list.Append
  use import imp.Imp
  use import vm.Vm
  use import state.State
  use import Compiler_logic




  function aexpr_post (a:aexpr) (len:pos) : pos -> machine_state -> pred =
  \ p ms ms'.
   match ms with
    | VMS _ s m -> ms' = VMS (p + len) (push (aeval m a ) s) m
   end

  function aexpr_pre : pos -> machine_state -> bool = \p ms.
   match ms with
    | VMS p' _ _ -> p = p'
   end

  let rec compile_aexpr (a : aexpr) :  codespec
    variant { a }
    ensures { result.pre = aexpr_pre }
    ensures { result.post = aexpr_post a result.code.length }
    ensures {total_correctness result}
    = let c = match a with
     | Anum n -> absurd (* iconst n *)
     | Avar x ->  absurd (* ivar x *)
     | Aadd a1 a2 ->
        !! (compile_aexpr a1) ~ !! (compile_aexpr a2) ~ !! (iaddf ())
     | Asub a1 a2 -> absurd (* compile_aexpr a1 ~ compile_aexpr a2 ~ isubf () *)
     | Amul a1 a2 -> absurd (* compile_aexpr a1 ~ compile_aexpr a2 ~ imulf () *)
    end in
    let ghost pre = aexpr_pre in
    let ghost post = any pos -> machine_state -> pred
     ensures { result = aexpr_post a c.wcode.length } in
    hoare pre c post


end


(* *)
