(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require list.List.
Require list.Length.
Require list.Mem.
Require map.Map.
Require list.Append.

(* Why3 assumption *)
Definition unit := unit.

Axiom qtmark : Type.
Parameter qtmark_WhyType : WhyType qtmark.
Existing Instance qtmark_WhyType.

Axiom map : forall (a:Type) (b:Type), Type.
Parameter map_WhyType : forall (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b}, WhyType (map a b).
Existing Instance map_WhyType.

Parameter get: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (map a b) -> a -> b.

Parameter set: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (map a b) -> a -> b -> (map a b).

Axiom Select_eq : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (m:(map a b)), forall (a1:a) (a2:a), forall (b1:b), (a1 = a2) ->
  ((get (set m a1 b1) a2) = b1).

Axiom Select_neq : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (m:(map a b)), forall (a1:a) (a2:a),
  forall (b1:b), (~ (a1 = a2)) -> ((get (set m a1 b1) a2) = (get m a2)).

Parameter const: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  b -> (map a b).

Axiom Const : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (b1:b) (a1:a), ((get (const b1: (map a b)) a1) = b1).

(* Why3 assumption *)
Inductive id :=
  | Id : Z -> id.
Axiom id_WhyType : WhyType id.
Existing Instance id_WhyType.

(* Why3 assumption *)
Definition state := (map id Z).

(* Why3 assumption *)
Definition pos := Z.

(* Why3 assumption *)
Definition stack := (list Z).

(* Why3 assumption *)
Inductive machine_state :=
  | VMS : Z -> (list Z) -> (map id Z) -> machine_state.
Axiom machine_state_WhyType : WhyType machine_state.
Existing Instance machine_state_WhyType.

(* Why3 assumption *)
Inductive instr :=
  | Iconst : Z -> instr
  | Ivar : id -> instr
  | Isetvar : id -> instr
  | Ibranch : Z -> instr
  | Iadd : instr
  | Isub : instr
  | Imul : instr
  | Ibeq : Z -> instr
  | Ibne : Z -> instr
  | Ible : Z -> instr
  | Ibgt : Z -> instr
  | Ihalt : instr.
Axiom instr_WhyType : WhyType instr.
Existing Instance instr_WhyType.

(* Why3 assumption *)
Definition code := (list instr).

(* Why3 assumption *)
Inductive codeseq_at: (list instr) -> Z -> (list instr) -> Prop :=
  | codeseq_at_intro : forall (c1:(list instr)) (c2:(list instr))
      (c3:(list instr)) (pc:Z), (pc = (list.Length.length c1)) -> (codeseq_at
      (Init.Datatypes.app (Init.Datatypes.app c1 c2) c3) pc c2).

Axiom codeseq_at_app_right : forall (c:(list instr)) (c1:(list instr))
  (c2:(list instr)) (p:Z), (codeseq_at c p (Init.Datatypes.app c1 c2)) ->
  (codeseq_at c (p + (list.Length.length c1))%Z c2).

Axiom codeseq_at_app_left : forall (c:(list instr)) (c1:(list instr))
  (c2:(list instr)) (p:Z), (codeseq_at c p (Init.Datatypes.app c1 c2)) ->
  (codeseq_at c p c1).

(* Why3 assumption *)
Definition iconst (n:Z): (list instr) :=
  (Init.Datatypes.cons (Iconst n) Init.Datatypes.nil).

(* Why3 assumption *)
Definition ivar (x:id): (list instr) :=
  (Init.Datatypes.cons (Ivar x) Init.Datatypes.nil).

(* Why3 assumption *)
Definition isetvar (x:id): (list instr) :=
  (Init.Datatypes.cons (Isetvar x) Init.Datatypes.nil).

(* Why3 assumption *)
Definition ibeq (ofs:Z): (list instr) :=
  (Init.Datatypes.cons (Ibeq ofs) Init.Datatypes.nil).

(* Why3 assumption *)
Definition ible (ofs:Z): (list instr) :=
  (Init.Datatypes.cons (Ible ofs) Init.Datatypes.nil).

(* Why3 assumption *)
Definition ibne (ofs:Z): (list instr) :=
  (Init.Datatypes.cons (Ibne ofs) Init.Datatypes.nil).

(* Why3 assumption *)
Definition ibgt (ofs:Z): (list instr) :=
  (Init.Datatypes.cons (Ibgt ofs) Init.Datatypes.nil).

(* Why3 assumption *)
Definition ibranch (ofs:Z): (list instr) :=
  (Init.Datatypes.cons (Ibranch ofs) Init.Datatypes.nil).

(* Why3 assumption *)
Inductive transition: (list instr) -> machine_state -> machine_state ->
  Prop :=
  | trans_const : forall (c:(list instr)) (p:Z) (n:Z), (codeseq_at c p
      (iconst n)) -> forall (m:(map id Z)) (s:(list Z)), (transition c (VMS p
      s m) (VMS (p + 1%Z)%Z (Init.Datatypes.cons n s) m))
  | trans_var : forall (c:(list instr)) (p:Z) (x:id), (codeseq_at c p
      (ivar x)) -> forall (m:(map id Z)) (s:(list Z)), (transition c (VMS p s
      m) (VMS (p + 1%Z)%Z (Init.Datatypes.cons (get m x) s) m))
  | trans_set_var : forall (c:(list instr)) (p:Z) (x:id), (codeseq_at c p
      (isetvar x)) -> forall (n:Z) (s:(list Z)) (m:(map id Z)), (transition c
      (VMS p (Init.Datatypes.cons n s) m) (VMS (p + 1%Z)%Z s (set m x n)))
  | trans_add : forall (c:(list instr)) (p:Z), (codeseq_at c p
      (Init.Datatypes.cons Iadd Init.Datatypes.nil)) -> forall (n1:Z) (n2:Z)
      (s:(list Z)) (m:(map id Z)), (transition c (VMS p
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m) (VMS (p + 1%Z)%Z
      (Init.Datatypes.cons (n1 + n2)%Z s) m))
  | trans_sub : forall (c:(list instr)) (p:Z), (codeseq_at c p
      (Init.Datatypes.cons Isub Init.Datatypes.nil)) -> forall (n1:Z) (n2:Z)
      (s:(list Z)) (m:(map id Z)), (transition c (VMS p
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m) (VMS (p + 1%Z)%Z
      (Init.Datatypes.cons (n1 - n2)%Z s) m))
  | trans_mul : forall (c:(list instr)) (p:Z), (codeseq_at c p
      (Init.Datatypes.cons Imul Init.Datatypes.nil)) -> forall (n1:Z) (n2:Z)
      (s:(list Z)) (m:(map id Z)), (transition c (VMS p
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m) (VMS (p + 1%Z)%Z
      (Init.Datatypes.cons (n1 * n2)%Z s) m))
  | trans_beq : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ibeq ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (n1 = n2) -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS ((p1 + 1%Z)%Z + ofs)%Z s m))
  | trans_beq1 : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ibeq ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (~ (n1 = n2)) -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS (p1 + 1%Z)%Z s m))
  | trans_bne : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ibne ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (n1 = n2) -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS (p1 + 1%Z)%Z s m))
  | trans_bne1 : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ibne ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (~ (n1 = n2)) -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS ((p1 + 1%Z)%Z + ofs)%Z s m))
  | trans_ble : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ible ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (n1 <= n2)%Z -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS ((p1 + 1%Z)%Z + ofs)%Z s m))
  | trans_ble1 : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ible ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (~ (n1 <= n2)%Z) -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS (p1 + 1%Z)%Z s m))
  | trans_bgt : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ibgt ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (n1 <= n2)%Z -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS (p1 + 1%Z)%Z s m))
  | trans_bgt1 : forall (c:(list instr)) (p1:Z) (ofs:Z), (codeseq_at c p1
      (ibgt ofs)) -> forall (s:(list Z)) (m:(map id Z)) (n1:Z) (n2:Z),
      (~ (n1 <= n2)%Z) -> (transition c (VMS p1
      (Init.Datatypes.cons n2 (Init.Datatypes.cons n1 s)) m)
      (VMS ((p1 + 1%Z)%Z + ofs)%Z s m))
  | trans_branch : forall (c:(list instr)) (p:Z) (ofs:Z), (codeseq_at c p
      (ibranch ofs)) -> forall (m:(map id Z)) (s:(list Z)), (transition c
      (VMS p s m) (VMS ((p + 1%Z)%Z + ofs)%Z s m)).

(* Why3 assumption *)
Inductive trans :=
  | TransZero : trans
  | TransOne : machine_state -> trans -> trans.
Axiom trans_WhyType : WhyType trans.
Existing Instance trans_WhyType.

(* Why3 assumption *)
Fixpoint transition_star_proof (p:(list instr)) (s1:machine_state)
  (s3:machine_state) (pi:trans) {struct pi}: Prop :=
  match pi with
  | TransZero => (s1 = s3)
  | (TransOne s2 pi') => (transition p s1 s2) /\ (transition_star_proof p s2
      s3 pi')
  end.

Parameter transition_star: (list instr) -> machine_state -> machine_state ->
  Prop.

Axiom transition_star_def : forall (p:(list instr)) (s1:machine_state)
  (s3:machine_state), (transition_star p s1 s3) <-> exists pi:trans,
  (transition_star_proof p s1 s3 pi).

Axiom transZero : forall (p:(list instr)) (s:machine_state), (transition_star
  p s s).

Axiom transOne : forall (p:(list instr)) (s1:machine_state)
  (s2:machine_state) (s3:machine_state), (transition p s1 s2) ->
  ((transition_star p s2 s3) -> (transition_star p s1 s3)).

Axiom transition_star_one : forall (p:(list instr)) (s1:machine_state)
  (s2:machine_state), (transition p s1 s2) -> (transition_star p s1 s2).

Axiom trans_star : forall (p:(list instr)) (s1:machine_state)
  (s2:machine_state) (s3:machine_state) (pi:trans), ((transition_star_proof p
  s1 s2 pi) /\ (transition_star p s2 s3)) -> (transition_star p s1 s3).

Axiom transition_star_transitive : forall (p:(list instr)) (s1:machine_state)
  (s2:machine_state) (s3:machine_state), (transition_star p s1 s2) ->
  ((transition_star p s2 s3) -> (transition_star p s1 s3)).

(* Why3 assumption *)
Definition vm_terminates (c:(list instr)) (mi:(map id Z)) (mf:(map id
  Z)): Prop := exists p:Z, (codeseq_at c p
  (Init.Datatypes.cons Ihalt Init.Datatypes.nil)) /\ (transition_star c
  (VMS 0%Z Init.Datatypes.nil mi) (VMS p Init.Datatypes.nil mf)).

Axiom func : forall (a:Type) (b:Type), Type.
Parameter func_WhyType : forall (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b}, WhyType (func a b).
Existing Instance func_WhyType.

(* Why3 assumption *)
Definition pred (a:Type) := (func a bool).

Parameter infix_at: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, (func a b) -> a -> b.

(* Why3 assumption *)
Definition fst {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b} (p:(a*
  b)%type): a := match p with
  | (x, _) => x
  end.

(* Why3 assumption *)
Definition snd {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b} (p:(a*
  b)%type): b := match p with
  | (_, y) => y
  end.

(* Why3 assumption *)
Definition pred1 := (func machine_state bool).

(* Why3 assumption *)
Definition post := (func machine_state (func machine_state bool)).

(* Why3 assumption *)
Inductive hl
  (a:Type) :=
  | mk_hl : (list instr) -> (func a (func Z (func machine_state bool))) ->
      (func a (func Z (func machine_state (func machine_state bool)))) -> hl
      a.
Axiom hl_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (hl a).
Existing Instance hl_WhyType.
Implicit Arguments mk_hl [[a]].

(* Why3 assumption *)
Definition post1 {a:Type} {a_WT:WhyType a} (v:(hl a)): (func a (func Z (func
  machine_state (func machine_state bool)))) :=
  match v with
  | (mk_hl x x1 x2) => x2
  end.

(* Why3 assumption *)
Definition pre {a:Type} {a_WT:WhyType a} (v:(hl a)): (func a (func Z (func
  machine_state bool))) := match v with
  | (mk_hl x x1 x2) => x1
  end.

(* Why3 assumption *)
Definition code1 {a:Type} {a_WT:WhyType a} (v:(hl a)): (list instr) :=
  match v with
  | (mk_hl x x1 x2) => x
  end.

(* Why3 assumption *)
Inductive wp
  (a:Type) :=
  | mk_wp : (list instr) -> (func a (func Z (func (func machine_state bool)
      (func machine_state bool)))) -> wp a.
Axiom wp_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (wp a).
Existing Instance wp_WhyType.
Implicit Arguments mk_wp [[a]].

(* Why3 assumption *)
Definition wp1 {a:Type} {a_WT:WhyType a} (v:(wp a)): (func a (func Z (func
  (func machine_state bool) (func machine_state bool)))) :=
  match v with
  | (mk_wp x x1) => x1
  end.

(* Why3 assumption *)
Definition wcode {a:Type} {a_WT:WhyType a} (v:(wp a)): (list instr) :=
  match v with
  | (mk_wp x x1) => x
  end.

(* Why3 assumption *)
Definition contextual_irrelevance (c:(list instr)) (p:Z) (ms1:machine_state)
  (ms2:machine_state): Prop := forall (c_global:(list instr)), (codeseq_at
  c_global p c) -> (transition_star c_global ms1 ms2).

(* Why3 assumption *)
Definition hl_correctness {a:Type} {a_WT:WhyType a} (cs:(hl a)): Prop :=
  forall (x:a) (p:Z) (ms:machine_state),
  ((infix_at (infix_at (infix_at (pre cs) x) p) ms) = true) ->
  exists ms':machine_state,
  ((infix_at (infix_at (infix_at (infix_at (post1 cs) x) p) ms)
  ms') = true) /\ (contextual_irrelevance (code1 cs) p ms ms').

(* Why3 assumption *)
Definition wp_correctness {a:Type} {a_WT:WhyType a} (code2:(wp a)): Prop :=
  forall (x:a) (p:Z) (post2:(func machine_state bool)) (ms:machine_state),
  ((infix_at (infix_at (infix_at (infix_at (wp1 code2) x) p) post2)
  ms) = true) -> exists ms':machine_state, ((infix_at post2 ms') = true) /\
  (contextual_irrelevance (wcode code2) p ms ms').

Parameter seq_wp: forall {a:Type} {a_WT:WhyType a}, (wp a) -> (wp (a*
  machine_state)%type) -> (func a (func Z (func (func machine_state bool)
  (func machine_state bool)))).

Axiom seq_wp_def : forall {a:Type} {a_WT:WhyType a}, forall (s1:(wp a))
  (s2:(wp (a* machine_state)%type)) (x:a) (p:Z) (q:(func machine_state bool))
  (ms:machine_state), ((infix_at (infix_at (infix_at (infix_at (seq_wp s1 s2)
  x) p) q) ms) = (infix_at (infix_at (infix_at (infix_at (wp1 s1) x) p)
  (infix_at (infix_at (infix_at (wp1 s2) (x, ms))
  (p + (list.Length.length (wcode s1)))%Z) q)) ms)).

Axiom seq_wp_lemma : forall {a:Type} {a_WT:WhyType a}, forall (s1:(wp a))
  (s2:(wp (a* machine_state)%type)) (x:a) (p:Z) (q:(func machine_state bool))
  (ms:machine_state), ((infix_at (infix_at (infix_at (infix_at (seq_wp s1 s2)
  x) p) q) ms) = (infix_at (infix_at (infix_at (infix_at (wp1 s1) x) p)
  (infix_at (infix_at (infix_at (wp1 s2) (x, ms))
  (p + (list.Length.length (wcode s1)))%Z) q)) ms)).

Parameter fork_wp: forall {a:Type} {a_WT:WhyType a}, (wp a) -> (func a (func
  Z (func machine_state bool))) -> (func a (func Z (func (func machine_state
  bool) (func machine_state bool)))).

Axiom fork_wp_def : forall {a:Type} {a_WT:WhyType a}, forall (s2:(wp a))
  (exn:(func a (func Z (func machine_state bool)))) (x:a) (p:Z) (q:(func
  machine_state bool)) (ms:machine_state),
  ((infix_at (infix_at (infix_at (infix_at (fork_wp s2 exn) x) p) q)
  ms) = true) <-> ((((infix_at (infix_at (infix_at exn x) p) ms) = true) ->
  ((infix_at q ms) = true)) /\ ((~ ((infix_at (infix_at (infix_at exn x) p)
  ms) = true)) -> ((infix_at (infix_at (infix_at (infix_at (wp1 s2) x) p) q)
  ms) = true))).

Axiom fork_wp_lemma : forall {a:Type} {a_WT:WhyType a}, forall (s2:(wp a))
  (exn:(func a (func Z (func machine_state bool)))) (x:a) (p:Z) (q:(func
  machine_state bool)) (ms:machine_state),
  ((infix_at (infix_at (infix_at (infix_at (fork_wp s2 exn) x) p) q)
  ms) = true) <-> ((((infix_at (infix_at (infix_at exn x) p) ms) = true) ->
  ((infix_at q ms) = true)) /\ ((~ ((infix_at (infix_at (infix_at exn x) p)
  ms) = true)) -> ((infix_at (infix_at (infix_at (infix_at (wp1 s2) x) p) q)
  ms) = true))).

Parameter towp_wp: forall {a:Type} {a_WT:WhyType a}, (hl a) -> (func a (func
  Z (func (func machine_state bool) (func machine_state bool)))).

Axiom towp_wp_def : forall {a:Type} {a_WT:WhyType a}, forall (c:(hl a)) (x:a)
  (p:Z) (q:(func machine_state bool)) (ms:machine_state),
  ((infix_at (infix_at (infix_at (infix_at (towp_wp c) x) p) q)
  ms) = true) <-> (((infix_at (infix_at (infix_at (pre c) x) p)
  ms) = true) /\ forall (ms':machine_state),
  ((infix_at (infix_at (infix_at (infix_at (post1 c) x) p) ms)
  ms') = true) -> ((infix_at q ms') = true)).

Axiom towp_wp_lemma : forall {a:Type} {a_WT:WhyType a}, forall (c:(hl a))
  (x:a) (p:Z) (q:(func machine_state bool)) (ms:machine_state),
  ((infix_at (infix_at (infix_at (infix_at (towp_wp c) x) p) q)
  ms) = true) <-> (((infix_at (infix_at (infix_at (pre c) x) p)
  ms) = true) /\ forall (ms':machine_state),
  ((infix_at (infix_at (infix_at (infix_at (post1 c) x) p) ms)
  ms') = true) -> ((infix_at q ms') = true)).

Parameter trivial_pre: forall {a:Type} {a_WT:WhyType a}, (func a (func Z
  (func machine_state bool))).

Axiom trivial_pre_def : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (p:Z)
  (ms:machine_state), ((infix_at (infix_at (infix_at (trivial_pre : (func a
  (func Z (func machine_state bool)))) x) p) ms) = true) <->
  match ms with
  | (VMS p' _ _) => (p = p')
  end.

Axiom trivial_pre_lemma : forall {a:Type} {a_WT:WhyType a}, forall (x:a)
  (p:Z) (ms:machine_state),
  ((infix_at (infix_at (infix_at (trivial_pre : (func a (func Z (func
  machine_state bool)))) x) p) ms) = true) <->
  match ms with
  | (VMS p' _ _) => (p = p')
  end.

(* Why3 assumption *)
Inductive acc {a:Type} {a_WT:WhyType a}: (func a (func a bool)) -> a ->
  Prop :=
  | Acc : forall (r:(func a (func a bool))) (x:a), (forall (y:a),
      ((infix_at (infix_at r y) x) = true) -> (acc r y)) -> (acc r x).

Parameter loop_preservation: forall {a:Type} {a_WT:WhyType a}, (func a (func
  Z (func machine_state bool))) -> (func a (func Z (func machine_state (func
  machine_state bool)))) -> (func a (func Z (func machine_state bool))) ->
  (func a (func Z (func machine_state (func machine_state bool)))).

Axiom loop_preservation_def : forall {a:Type} {a_WT:WhyType a},
  forall (inv:(func a (func Z (func machine_state bool)))) (var:(func a (func
  Z (func machine_state (func machine_state bool))))) (post2:(func a (func Z
  (func machine_state bool)))) (x:a) (p:Z) (ms:machine_state)
  (ms':machine_state),
  ((infix_at (infix_at (infix_at (infix_at (loop_preservation inv var post2)
  x) p) ms) ms') = true) <-> ((((infix_at (infix_at (infix_at inv x) p)
  ms') = true) /\ ((infix_at (infix_at (infix_at (infix_at var x) p) ms')
  ms) = true)) \/ ((infix_at (infix_at (infix_at post2 x) p) ms') = true)).

Parameter forget_old: forall {a:Type} {a_WT:WhyType a}, (func a (func Z (func
  machine_state bool))) -> (func a (func Z (func machine_state (func
  machine_state bool)))).

Axiom forget_old_def : forall {a:Type} {a_WT:WhyType a}, forall (post2:(func
  a (func Z (func machine_state bool)))) (x:a) (p:Z) (ms:machine_state),
  ((infix_at (infix_at (infix_at (forget_old post2) x) p)
  ms) = (infix_at (infix_at post2 x) p)).

Require Import Why3.
Ltac ae := why3 "Alt-Ergo,0.95.2,".
Ltac cvc := why3 "CVC4,1.4,".

(* Why3 goal *)
Theorem WP_parameter_make_loop_hl : forall {a:Type} {a_WT:WhyType a},
  forall (c:(list instr)) (c1:(func a (func Z (func machine_state bool))))
  (c2:(func a (func Z (func machine_state (func machine_state bool)))))
  (inv:(func a (func Z (func machine_state bool)))) (var:(func a (func Z
  (func machine_state (func machine_state bool))))) (post2:(func a (func Z
  (func machine_state bool)))), ((hl_correctness (mk_hl c c1 c2)) /\
  ((forall (x:a) (p:Z) (ms:machine_state), ((infix_at (infix_at (infix_at inv
  x) p) ms) = true) -> (acc (infix_at (infix_at var x) p) ms)) /\
  ((c1 = inv) /\ (c2 = (loop_preservation inv var post2))))) ->
  (hl_correctness (mk_hl c inv (forget_old post2))).
(* Why3 intros a a_WT c c1 c2 inv var post2 (h1,(h2,(h3,h4))). *)
intros a a_WT c c1 c2 inv var post2 (h1,(h2,(h3,h4))).
unfold hl_correctness in *.
intros.
simpl in *.
remember H as H' eqn : eqn; clear eqn.
apply h2 in H'.
remember (infix_at (infix_at var x) p) as R eqn : eqR.
induction H'.
ae.
Qed.

