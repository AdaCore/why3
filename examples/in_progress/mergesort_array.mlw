
(** Sorting arrays using mergesort

    Author: Jean-Christophe Filli√¢tre (CNRS)
*)

module Elt

  use export int.Int
  use export array.Array

  type elt

  predicate le elt elt

  clone relations.TotalPreOrder with type t = elt, predicate rel = le

  predicate sorted_sub (a: array elt) (l u: int) =
    forall i1 i2 : int. l <= i1 <= i2 < u -> le a[i1] a[i2]

  predicate sorted (a: array elt) =
    forall i1 i2 : int. 0 <= i1 <= i2 < length a -> le a[i1] a[i2]

end

module Merge

  use export Elt
  use export ref.Refint
  use export array.Array
  use import map.Occ
  use export array.ArrayPermut

  (* merges a1[l..m[ and a1[m..r[ into a2[l..r[ *)
  let merge (a1 a2: array elt) (l m r: int) : unit
    requires { 0 <= l <= m <= r <= length a1 = length a2 }
    requires { sorted_sub a1 l m }
    requires { sorted_sub a1 m r }
    ensures  { sorted_sub a2 l r }
    ensures  { permut a1 a2 l r }
    ensures  { forall i: int.
               (0 <= i < l \/ r <= i < length a2) -> a2[i] = (old a2)[i] }
  = 'L:
    let i = ref l in
    let j = ref m in
    for k = l to r-1 do
      invariant { l <= !i <= m <= !j <= r }
      invariant { !i - l + !j - m = k - l }
      invariant { sorted_sub a2 l k }
      invariant { forall x y: int. l <= x < k -> !i <= y < m -> le a2[x] a1[y] }
      invariant { forall x y: int. l <= x < k -> !j <= y < r -> le a2[x] a1[y] }
      invariant { forall v: elt.
                  occ v a1.elts l !i + occ v a1.elts m !j = occ v a2.elts l k }
      invariant { forall i: int.
                  (0 <= i < l \/ r <= i < length a2) -> a2[i] = (at a2 'L)[i] }
      if !i < m && (!j = r || le a1[!i] a1[!j]) then begin
        a2[k] <- a1[!i];
        incr i
      end else begin
        a2[k] <- a1[!j];
        incr j
      end
    done

end

module TopDownMergesort

  use import Merge
  use import mach.int.Int

  let rec mergesort_rec (a tmp: array elt) (l r: int) : unit
    requires { 0 <= l <= r <= length a = length tmp }
    ensures { sorted_sub a l r }
    ensures { permut_sub (old a) a l r }
    variant { r - l }
  = 'L:
    if l < r-1 then begin
      let m = l + (r - l) / 2 in
      assert { l <= m < r };
      mergesort_rec a tmp l m;
      assert { permut_sub (at a 'L) a l r };
      'M:
      mergesort_rec a tmp m r;
      assert { permut_sub (at a 'M) a l r };
      (* if a[m-1] <= a[m] return; *) (* OPTIM *)
      'N:
      blit a l tmp l (r - l);
      merge tmp a l m r;
      assert { permut_sub (at a 'N) a l r };
    end

  let mergesort (a: array elt) : unit
    ensures { sorted a }
    ensures { permut_all (old a) a }
  =
    let tmp = Array.copy a in
    mergesort_rec a tmp 0 (length a)

end

module BottomUpMergesort

  use import Merge
  use import mach.int.Int
  use import int.MinMax

  let bottom_up_mergesort (a: array elt) : unit

  =
    let n = length a in
    let tmp = Array.copy a in
    let len = ref 1 in
    while !len < n do
      invariant { 1 <= !len }
      variant   { 2 * n - !len }
      let lo = ref 0 in
      while !lo < n - !len do
        invariant { 0 <= !lo <= n }
        variant   { n + !len - !lo }
        let mid = !lo + !len in
        let hi = min n (mid + !len) in
        blit a !lo tmp !lo (hi - !lo);
        merge tmp a !lo mid hi;
        lo := hi
      done;
      len := 2 * !len
    done

end

module NaturalMergesort

  use import Merge
  use import mach.int.Int
  use import int.MinMax

  (* returns hi such that a[lo..hi[ is sorted *)
  let find_run (a: array elt) (lo: int) : int
    requires { 0 <= lo < length a }
    ensures  { lo < result <= length a }
    ensures  { sorted_sub a lo result }
  =
    let i = ref (lo + 1) in
    while !i < length a && le a[!i - 1] a[!i] do
      invariant { lo < !i <= length a }
      invariant { sorted_sub a lo !i }
      variant   { length a - !i }
      incr i
    done;
    !i

  exception Break
  exception Return

  let natural_mergesort (a: array elt) : unit

  =
    let n = length a in
    let tmp = Array.copy a in
    try
    while true do
      let lo = ref 0 in
      try
      while !lo < n - 1 do
        invariant { 0 <= !lo <= n }
        variant   { n - !lo }
        let mid = find_run a !lo in
        if mid = n then begin if !lo = 0 then raise Return; raise Break end;
        let hi = find_run a mid in
        blit a !lo tmp !lo (hi - !lo);
        merge tmp a !lo mid hi;
        lo := hi
      done
      with Break -> () end
    done
    with Return -> () end

(*
  static void naturalMergesort(int[] a) {
    int n = a.length;
    if (n <= 1) return;
    int[] tmp = new int[n];
    while (true) {
      for (int lo = 0; lo < n-1; ) {
        // find first run a[lo..mid[
        int mid = findRun(a, lo);
        if (mid == n) { if (lo == 0) return; break; }
        // find second run a[mid..hi[
        int hi = findRun(a, mid);
        // merge
        for (int i = lo; i < hi; i++) tmp[i] = a[i];
        merge(tmp, a, lo, mid, hi);
        lo = hi;
      }
    }
  }
*)

end