
(** Sorting arrays using mergesort

    Author: Jean-Christophe Filli√¢tre (CNRS)
*)

module Elt

  use export int.Int
  use export array.Array

  type elt

  predicate le elt elt

  clone relations.TotalPreOrder with type t = elt, predicate rel = le

  clone export array.ArraySorted with type elt = elt, predicate le = le

end

module Merge

  use export Elt
  use export ref.Refint
  use export array.Array
  use import map.Occ
  use export array.ArrayPermut

  (* merges tmp[l..m[ and tmp[m..r[ into a[l..r[ *)
  let merge (tmp a: array elt) (l m r: int) : unit
    requires { 0 <= l <= m <= r <= length tmp = length a }
    requires { sorted_sub tmp l m }
    requires { sorted_sub tmp m r }
    ensures  { sorted_sub a l r }
    ensures  { permut tmp a l r }
    ensures  { forall i: int.
               (0 <= i < l \/ r <= i < length a) -> a[i] = (old a)[i] }
  = 'L:
    let i = ref l in
    let j = ref m in
    for k = l to r-1 do
      invariant { l <= !i <= m <= !j <= r }
      invariant { !i - l + !j - m = k - l }
      invariant { sorted_sub a l k }
      invariant { forall x y: int. l <= x < k -> !i <= y < m -> le a[x] tmp[y] }
      invariant { forall x y: int. l <= x < k -> !j <= y < r -> le a[x] tmp[y] }
      invariant { forall v: elt.
                  occ v tmp.elts l !i + occ v tmp.elts m !j = occ v a.elts l k }
      invariant { forall i: int.
                  (0 <= i < l \/ r <= i < length a) -> a[i] = (at a 'L)[i] }
      if !i < m && (!j = r || le tmp[!i] tmp[!j]) then begin
        a[k] <- tmp[!i];
        incr i
      end else begin
        a[k] <- tmp[!j];
        incr j
      end
    done

  (* merges a[l..m[ and a[m..r[ into a[l..r[, using tmp as a temporary *)
  let merge_using (tmp a: array elt) (l m r: int) : unit
    requires { 0 <= l <= m <= r <= length tmp = length a }
    requires { sorted_sub a l m }
    requires { sorted_sub a m r }
    ensures  { sorted_sub a l r }
    ensures  { permut (old a) a l r }
    ensures  { forall i: int.
               (0 <= i < l \/ r <= i < length a) -> a[i] = (old a)[i] }
  = if l < m && m < r then (* both sides are non empty *)
      if le a[m-1] a[m] then (* OPTIM: already sorted *)
        assert { forall i1 i2: int. l <= i1 < m -> m <= i2 < r ->
                 le a[i1] a[m-1] && le a[m] a[i2] }
      else begin
        'N:
        blit a l tmp l (r - l);
        merge tmp a l m r;
        assert { permut_sub (at a 'N) a l r }
      end

end

module TopDownMergesort

  use import Merge
  use import mach.int.Int

  let rec mergesort_rec (a tmp: array elt) (l r: int) : unit
    requires { 0 <= l <= r <= length a = length tmp }
    ensures { sorted_sub a l r }
    ensures { permut_sub (old a) a l r }
    variant { r - l }
  = 'L:
    if l < r-1 then begin
      let m = l + (r - l) / 2 in
      assert { l <= m < r };
      mergesort_rec a tmp l m;
      assert { permut_sub (at a 'L) a l r };
      'M:
      mergesort_rec a tmp m r;
      assert { permut_sub (at a 'M) a l r };
      merge_using tmp a l m r;
    end

  let mergesort (a: array elt) : unit
    ensures { sorted a }
    ensures { permut_all (old a) a }
  =
    let tmp = Array.copy a in
    mergesort_rec a tmp 0 (length a)

end

module BottomUpMergesort

  use import Merge
  use import mach.int.Int
  use import int.MinMax

  let bottom_up_mergesort (a: array elt) : unit

  =
    let n = length a in
    let tmp = Array.copy a in
    let len = ref 1 in
    while !len < n do
      invariant { 1 <= !len }
      variant   { 2 * n - !len }
      let lo = ref 0 in
      while !lo < n - !len do
        invariant { 0 <= !lo <= n }
        variant   { n + !len - !lo }
        let mid = !lo + !len in
        let hi = min n (mid + !len) in
        merge_using tmp a !lo mid hi;
        lo := hi
      done;
      len := 2 * !len
    done

end

module NaturalMergesort

  use import Merge
  use import mach.int.Int
  use import int.MinMax

  (* returns the maximal hi such that a[lo..hi[ is sorted *)
  let find_run (a: array elt) (lo: int) : int
    requires { 0 <= lo < length a }
    ensures  { lo < result <= length a }
    ensures  { sorted_sub a lo result }
    ensures  { result < length a -> not (le a[result-1] a[result]) }
  =
    let i = ref (lo + 1) in
    while !i < length a && le a[!i - 1] a[!i] do
      invariant { lo < !i <= length a }
      invariant { sorted_sub a lo !i }
      variant   { length a - !i }
      incr i
    done;
    !i

  exception Break
  exception Return

  let natural_mergesort (a: array elt) : unit

  =
    let n = length a in
    let tmp = Array.copy a in
    let ghost first_run = ref 0 in
    try
    while true do
      (* invariant { 0 <= !first_run && sorted_sub a 0 !first_run } *)
      variant   { n - !first_run }
      let lo = ref 0 in
      try
      while !lo < n - 1 do
        invariant { 0 <= !lo <= n }
        (* invariant { 0 <= !first_run && sorted_sub a 0 !first_run } *)
        variant   { n - !lo }
        let mid = find_run a !lo in
        if mid = n then begin if !lo = 0 then raise Return; raise Break end;
        let hi = find_run a mid in
        merge_using tmp a !lo mid hi;
        ghost if !lo = 0 then first_run := hi;
        lo := hi;
      done
      with Break -> () end
    done
    with Return -> () end

end