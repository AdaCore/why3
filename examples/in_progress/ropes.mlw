
module String "immutable strings"

  use import int.Int

  type char
  constant dummy_char: char

  type string

  (* axiomatized function length *)
  function length string: int
  axiom length_nonnegative: forall s: string. length s >= 0

  function ([]) string int: char (* access to i-th char *)

  (* string access routine *)
  val ([]) (s: string) (i:int) : char
    requires { 0 <= i < s.length }
    ensures  { result = s[i] }

  constant empty: string
  axiom empty_def: length empty = 0


  (* extensional equality for strings *)
  predicate (==) (s1 s2: string) =
    length s1 = length s2 /\
    forall i:int. 0 <= i < length s1 -> s1[i] = s2[i]

  (* axiomatized concatenation *)
  function app string string: string

  axiom app_def1:
    forall s1 s2: string. length (app s1 s2) = length s1 + length s2

  axiom app_def2:
    forall s1 s2: string, i: int.
    0 <= i < length s1 -> (app s1 s2)[i] = s1[i]

  axiom app_def3:
    forall s1 s2: string, i: int.
    length s1 <= i < length s1 + length s2 ->
    (app s1 s2)[i] = s2[i - length s1]


  (* axiomatized substring *)
  function sub string int int: string

  axiom sub_def1:
    forall s: string, ofs len: int.
    0 <= len -> 0 <= ofs <= length s -> ofs + len <= length s ->
    length (sub s ofs len) = len

  axiom sub_def2:
    forall s: string, ofs len: int.
    0 <= len -> 0 <= ofs <= length s -> ofs + len <= length s ->
    forall i: int. 0 <= i < len -> (sub s ofs len)[i] = s[ofs + i]

  (* substring routine *)
  val sub (s: string) (ofs len: int) : string
    requires { 0 <= len /\ 0 <= ofs <= length s /\ ofs + len <= length s }
    ensures  { result = sub s ofs len }

  (**
  namespace import S

    use HighOrd as HO
    type char
    constant dummy_char: char
    type string = { length: int; chars: HO.func int char }

    function ([]) (s: string) (i: int) : char = s.chars i

    val get (s: string) (i:int) : char
      requires { 0 <= i < s.length }
      ensures  { result = s.chars i }

    function app (s1 s2: string) : string =
      { length = s1.length + s2.length;
        chars = \ i: int.
          if i < s1.length then s1.chars i else s2.chars (i - s1.length) }
    function sub (s: string) (ofs: int) (len: int) : string =
      { length = len; chars = \ i: int. s.chars (i - ofs) }
    constant empty : string = { length = 0; chars = \ i: int. dummy_char }
    predicate (==) (s1 s2: string) =
      s1.length = s2.length /\
      forall i:int. 0 <= i < s1.length -> s1.chars i = s2.chars i

  end
  **)

end

module Sig

  use import int.Int
  use import String as S

  type rope

  function string rope: string

  function length rope: int

  val empty () : rope
    ensures { length result = 0 /\ string result == S.empty }

  val is_empty (r: rope) : bool
    ensures  { result <-> string r == empty }

  val of_string (s: string) : rope
    requires { 0 <= S.length s }
    ensures  { string result == s}

  (* access to the i-th character *)
  val get (r: rope) (i: int) : char
    requires { 0 <= i < length r }
    ensures  { result = (string r)[i] }

  val concat (r1 r2: rope) : rope
    ensures  { string result == S.app (string r1) (string r2) }

  (* sub-rope construction *)
  val sub (r: rope) (ofs len: int) : rope
    requires { 0 <= len /\ 0 <= ofs <= length r /\ ofs + len <= length r }
    ensures  { string result == S.sub (string r) ofs len }

  val balance (r: rope) : rope
    ensures  { string result == string r }

end

module Rope (* : Sig *)

  use import int.Int
  use import String as S

  (* ***** Logical description of rope type **** *)
  type rope =
    | Emp
    | Str string int  int  (* Str s ofs len is s[ofs..ofs+len[ *)
    | App rope   rope int  (* concatenation and total length   *)

  function length (r: rope) : int = match r with
    | Emp         -> 0
    | Str _ _ len -> len
    | App _ _ len -> len
  end

  (* invariant predicate for ropes *)
  predicate inv (r: rope) = match r with
    | Emp ->
        true
    | Str s ofs len ->
        0 < len /\ 0 <= ofs < S.length s /\ ofs + len <= S.length s
        (* s[ofs..ofs+len[ is a non-empty substring of s *)
    | App l r len ->
        0 < length l /\ inv l /\ 0 < length r /\ inv r /\
        len = length l + length r
        (* l and r are non-empty strings of the size (|l| + |r|) = len *)
  end

  (* the string model of a rope *)
  function string (r: rope) : string = match r with
    | Emp           -> S.empty
    | Str s ofs len -> S.sub s ofs len
    | App l r _     -> S.app (string l) (string r)
  end

  (* length of stored string is equal to the length of the corresponding rope *)
  lemma rope_length_is_string_length:
    forall r: rope. inv r -> S.length (string r) = length r

  (* NB: Here and below pay attention to the use of '==' predicate in
  contracts *)

  (* empty rope *)
  let empty () : rope
    ensures { length result = 0 /\ inv result /\ string result == S.empty }
  = Emp


  let is_empty (r: rope) : bool
    requires { inv r }
    ensures  { result <-> string r == empty }
  = r = Emp

  (* string conversion into a rope *)
  let of_string (s: string) : rope
    requires { 0 <= S.length s }
    ensures  { string result == s}
    ensures  { inv result }
  = if S.length s = 0 then Emp else Str s 0 (S.length s)

  (* access to the character of the given index i *)
  let rec get (r: rope) (i: int) : char
    requires { inv r }
    requires { 0 <= i < length r }
    ensures  { result = (string r)[i] }
    variant  { r }
  = match r with
    | Emp ->
        absurd
    | Str s ofs _ ->
       s[ofs + i]
    | App left right _   ->
        let n = length left in
        if i < n then get left i else get right (i - n)
    end

  (* concatenation of two ropes *)
  let concat (r1 r2: rope) : rope
    requires { inv r1 /\ inv r2 }
    ensures  { inv result }
    ensures  { string result == S.app (string r1) (string r2) }
  = match r1, r2 with
    | Emp, r | r, Emp -> r
    | _               -> App r1 r2 (length r1 + length r2)
    end

  (* sub-rope construction *)
  let rec sub (r: rope) (ofs len: int) : rope
    requires { inv r}
    requires { 0 <= len /\ 0 <= ofs <= length r /\ ofs + len <= length r }
    ensures  { inv result }
    ensures  { string result == S.sub (string r) ofs len }
    variant  { r }
  =
  match r with
    | Emp          -> assert { len = 0 }; Emp
    | Str s ofs' _ -> if len = 0 then Emp else Str s (ofs' + ofs) len
    | App r1 r2 _  ->
        let left  = length r1 - ofs in (* max chars to the left  *)
        let right = len - left      in (* max chars to the right *)
        if right <= 0 then sub r1 ofs len
        else if 0 >= left then sub r2 (- left) len
        else concat (sub r1 ofs left) (sub r2 0 right)
    end

  (* balancing *)

  use import int.Fibonacci
  use import int.MinMax
  use array.Array

  function height (r: rope) : int = match r with
    | Emp | Str _ _ _  -> 0
    | App left right _ -> 1 + max (height left) (height right)
  end

  constant max : int = 44

  (**
  TODO:
  1. code + safety
  2. ensures string result == string r
  3. ensures inv result
  4. file[i] <> Emp -> height(file[i]) <= i -2 /\ length file[i] >= fib i

  let balance (r: rope) : rope
  = let file = Array.make (max+1) Emp in
    ...
  **)

end
