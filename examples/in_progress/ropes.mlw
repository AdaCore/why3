
module Rope

  use import int.Int

  (* immutable strings *)

(**
  namespace import S

    use HighOrd as HO
    type char
    constant dummy_char: char
    type string = { length: int; chars: HO.func int char }

    function ([]) (s: string) (i: int) : char = s.chars i

    val get (s: string) (i:int) : char
      requires { 0 <= i < s.length }
      ensures  { result = s.chars i }

    function app (s1 s2: string) : string =
      { length = s1.length + s2.length;
        chars = \ i: int.
          if i < s1.length then s1.chars i else s2.chars (i - s1.length) }
    function sub (s: string) (ofs: int) (len: int) : string =
      { length = len; chars = \ i: int. s.chars (i - ofs) }
    constant empty : string = { length = 0; chars = \ i: int. dummy_char }
    predicate (==) (s1 s2: string) =
      s1.length = s2.length /\
      forall i:int. 0 <= i < s1.length -> s1.chars i = s2.chars i

  end
**)

  namespace import S

    type char
    constant dummy_char: char

    type string

    function length string: int
    axiom length_nonnegative: forall s: string. length s >= 0

    function ([]) string int: char

    val ([]) (s: string) (i:int) : char
      requires { 0 <= i < s.length }
      ensures  { result = s[i] }

    constant empty: string
    axiom empty_def: length empty = 0

    predicate (==) (s1 s2: string) =
      length s1 = length s2 /\
      forall i:int. 0 <= i < length s1 -> s1[i] = s2[i]

    function app string string: string
    axiom app_def1:
      forall s1 s2: string. length (app s1 s2) = length s1 + length s2
    axiom app_def2:
      forall s1 s2: string, i: int.
      0 <= i < length s1 -> (app s1 s2)[i] = s1[i]
    axiom app_def3:
      forall s1 s2: string, i: int.
      length s1 <= i < length s1 + length s2 ->
      (app s1 s2)[i] = s2[i - length s1]

    function sub string int int: string
    axiom sub_def1:
      forall s: string, ofs len: int.
      0 <= len -> 0 <= ofs < length s -> ofs + len <= length s ->
      length (sub s ofs len) = len
    axiom sub_def2:
      forall s: string, ofs len: int.
      0 <= len -> 0 <= ofs < length s -> ofs + len <= length s ->
      forall i: int. 0 <= i < len -> (sub s ofs len)[i] = s[ofs + i]

    val sub (s: string) (ofs len: int) : string
      requires { 0 <= len /\ 0 <= ofs < length s /\ ofs + len <= length s }
      ensures  { result = sub s ofs len }

  end

  type rope =
    | Emp
    | Str string int  int  (* Str s ofs len is s[ofs..ofs+len[ *)
    | App rope   rope int  (* concatenation and total length   *)

  function length (r: rope) : int = match r with
    | Emp         -> 0
    | Str _ _ len -> len
    | App _ _ len -> len
  end

  predicate inv (r: rope) = match r with
    | Emp ->
        true
    | Str s ofs len ->
        0 < len /\ 0 <= ofs < S.length s /\ ofs + len <= S.length s
    | App l r len ->
        0 < length l /\ inv l /\ 0 < length r /\ inv r /\
        len = length l + length r
  end

  function string (r: rope) : string = match r with
    | Emp           -> S.empty
    | Str s ofs len -> S.sub s ofs len
    | App l r _     -> S.app (string l) (string r)
  end

  lemma rope_length_is_string_length:
    forall r: rope. inv r -> S.length (string r) = length r

  let empty ()
    ensures { length result = 0 /\ inv result /\ string result == S.empty }
  = Emp

  let is_empty (r: rope) : bool
    requires { inv r }
    ensures  { result <-> string r == empty }
  = r = Emp

  let of_string (s: string) : rope
    requires { 0 <= S.length s }
    ensures  { string result == s }
    ensures  { inv result }
  = if S.length s = 0 then Emp else Str s 0 (S.length s)

  let rec get (r: rope) (i: int) : char
    requires { inv r /\ 0 <= i < length r }
    ensures  { result = (string r)[i] }
    variant  { r }
  = match r with
    | Emp ->
        absurd
    | Str s ofs _ ->
       s[ofs + i]
    | App left right _   ->
        let n = length left in
        if i < n then get left i else get right (i - n)
    end

  let concat (r1 r2: rope) : rope
    requires { inv r1 /\ inv r2 }
    ensures  { inv result }
    ensures  { string result == S.app (string r1) (string r2) }
  = match r1, r2 with
    | Emp, r | r, Emp -> r
    | _               -> App r1 r2 (length r1 + length r2)
    end

  let rec sub (r: rope) (ofs len: int) : rope
    requires { inv r }
    requires { 0 <= len /\ 0 <= ofs < length r /\ ofs + len <= length r }
    ensures  { inv result }
    ensures  { string result == S.sub (string r) ofs len }
  = match r with
    | Emp          -> absurd
    | Str s ofs' _ -> Str s (ofs' + ofs) len
    | App r1 r2 _  ->
        let left = length r1 - ofs in (* max chars to the left *)
        if len <= left then sub r1 ofs len
        else if 0 >= left then sub r2 (- left) len
        else concat (sub r1 ofs left) (sub r2 0 (len - left))
    end

end
