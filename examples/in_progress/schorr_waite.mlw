
(** Schorr-Waite algorithm

    The Schorr-Waite algorithm is the first mountain that any
    formalism for pointer aliasing should climb.
                                      -- Richard Bornat, 2000

*)

module SchorrWaite

  (*use import bool.Bool*)
  use import map.Map
  use import ref.Ref
  use import int.Int
  use import list.List
  use import list.Length
  use import list.Mem as L
  use import list.HdTlNoOpt
  use import list.Append
  use import set.Fset as S
  use import option.Option

  (** a small component-as-array memory model *)

  type loc
  constant null: loc

  val m: ref (map loc bool)
  val c: ref (map loc bool)
  val left: ref (map loc loc)
  val right: ref (map loc loc)
  (** record the path from the root to a node *)
  val ghost path_from_root : ref (map loc (list loc))

  val get_left (p: loc) : loc
    requires { p <> null }
    ensures  { result = !left[p] }

  val get_right (p: loc) : loc
    requires { p <> null }
    ensures  { result = !right[p] }

  val set_left (p: loc) (v: loc) : unit
    requires { p <> null }
    writes   { left }
    ensures  { !left = set (old !left) p v }

  val set_right (p: loc) (v: loc) : unit
    requires { p <> null }
    writes   { right }
    ensures  { !right = set (old !right) p v }

  val set_m (p: loc) (v: bool) : unit
    requires { p <> null }
    writes   { m }
    ensures  { !m = set (old !m) p v }

  val set_c (p: loc) (v: bool) : unit
    requires { p <> null }
    writes   { c }
    ensures  { !c = set (old !c) p v }

  val tl_stackNodes (stack : list loc) : list loc 
    requires { stack <> Nil }
    ensures  { result = tl stack }

  predicate edge (x y : loc) (left right : map loc loc) = 
    x <> null && (left[x] = y || right[x] = y)

  inductive path (left right : map loc loc) (x y : loc) (p : list loc) = 
  | path_nil   : forall x : loc, l r : map loc loc. path l r x x Nil
  | path_cons  : forall x y z : loc,
    	      	 l r : (map loc loc),
		 p : list loc.
		 edge x z l r -> path l r z y p ->
		 path l r x y (Cons x p)

  lemma reflex_path : forall x : loc, l r : map loc loc. path l r x x Nil

  let rec lemma trans_path (x y z : loc) (l r : map loc loc) (p1 p2 : list loc)
    variant  { length p1 }
    requires { path l r x y p1 }
    requires { path l r y z p2 }
    ensures  { path l r x z (p1++p2) }
  = match p1 with
    | Nil       -> ()
    | Cons _ p' -> 
      match p' with
      | Nil -> ()
      | Cons b _ ->
        trans_path b y z l r p' p2
      end
    end

  predicate reachable_via (x y : loc) (l r : map loc loc) (p : list loc) = 
    path l r x y p

  predicate reachable (x y : loc) (l r : map loc loc) =
    exists p : list loc. reachable_via x y l r p

  let rec lemma length_tl (l : list 'a) (* is this lemma really necessary? *)
    requires { l <> Nil }
    ensures  { length (tl l) < length l }
    variant  { l }
  = match l with
    | Nil        -> ()
    | Cons _ Nil -> ()
    | Cons _ y   -> length_tl y
    end

  (* auxiliar function the define the form of a stack *)
  function next (l r : map loc loc) (c : map loc bool) (p : loc) : loc = 
    if c[p] then r[p] else l[p]

  inductive stack_form (l r : map loc loc) (c : map loc bool) (p : loc) (stack : list loc) =
  | stack_nil  : forall l r : map loc loc, c : map loc bool, p : loc. stack_form l r c p Nil
  | stack_cons : forall l r : map loc loc,
    	       	 c : map loc bool,
		 p : loc, 
		 s : list loc. stack_form l r c (next l r c p) s -> 
		 stack_form l r c p (Cons p s)

  let schorr_waite (root: loc) (unmarked_nodes c_false_nodes : ref (set loc)) : unit
    requires { root <> null }
    (* graph starts with nothing marked and no child currently visited *)
    requires { forall x : loc. x <> null (*&& reachable root x !left !right*) ->
    	       not !m[x] /\ not !c[x] }
    requires { forall x : loc. x <> null /\ not !m[x] <-> S.mem x !unmarked_nodes } (* isto Ã© capaz de estar ao contrario *)
    requires { forall x : loc. x <> null /\ not !c[x] <-> S.mem x !c_false_nodes }  (* idem *)
    (* the structure of the graph is not changed *)
    ensures  { forall n : loc. 
    	       (old !left)[n] = !left[n] /\
	       (old !right)[n] = !right[n] }
    (* all the non-null vertices reachable from root
       are marked at the end of the algorithm *)
    ensures  { forall n : loc. 
    	       n <> null /\ reachable root n (old !left) (old !right) ->
	       !m[n] }
    (* every marked node was reachable from 'root' in the pre-state *)	       
    ensures  { forall n : loc. n <> null /\ 
    	       !m[n] -> reachable root n (old !left) (old !right) }
    (* forall non-reachable vertices the mark remains 
       the same as in the pre-state *)
    ensures  { forall n : loc. n <> null /\
    	       not reachable root n !left !right ->
	       !m[n] = (old !m)[n] }
  = 'Init:
    let t = ref root in
    let p = ref null in
    let ghost stackNodes = ref Nil in
    let ghost path = ref Nil in
    while !p <> null || (!t <> null && not !m[!t]) do
      invariant { not (L.mem !t !stackNodes) }
      invariant { length !stackNodes = 0 <-> !p = null }
      invariant { forall n : loc. n <> null /\ not !m[n] -> 
      		  S.mem n !unmarked_nodes }
      invariant { length !stackNodes > 0 -> hd !stackNodes = !p }
      invariant { forall n : loc. n <> null /\ (n = !p \/ L.mem n !stackNodes) ->
      		  !m[n] }
      (* the current pointers within the stack *)
      invariant { stack_form !left !right !c !p !stackNodes }
      		  
      invariant { forall n : loc. n <> null /\ not !c[n] -> 
      		  S.mem n !c_false_nodes }
      invariant { forall n : loc. not L.mem n !stackNodes /\ n <> !t ->
      		  !c[n] = (at !c 'Init)[n] }
      invariant { forall n : loc. L.mem n !stackNodes  \/ 
      		  (!right[n] = (at !right 'Init)[n] /\ !left[n] = (at !left 'Init)[n]) }
      invariant { !p <> null -> reachable_via root !p (at !left 'Init) (at !right 'Init) !path }
      invariant { forall n : loc, pth : list loc. n <> null /\ !m[n] /\ pth = !path_from_root[n] ->
      		  reachable_via root n (at !left 'Init) (at !right 'Init) pth }
      invariant { forall n : loc. n <> null /\ !m[n] -> reachable root n (at !left 'Init) (at !right 'Init) }
      variant   { S.cardinal !unmarked_nodes, S.cardinal !c_false_nodes, length !stackNodes }
      if !t = null || !m[!t] then begin
        (*assert { S.mem !p graph };*)
        if !c[!p] then begin (* pop *)
          let q = !t in
          t := !p;
	  stackNodes := tl_stackNodes !stackNodes;
          p := !right[!p];
          set_right !t q;
	  path := !path_from_root[!p];
        end else begin (* swing *)
          let q = !t in
          t := get_right !p;
          set_right !p (get_left !p);
          set_left !p q;
	  c_false_nodes := S.remove !p !c_false_nodes;
          set_c !p true;
        end
      end else begin (* push *)
        let q = !p in
        p := !t;
	stackNodes := Cons !p !stackNodes;
	if !p <> root then path := !path ++ (Cons !p Nil);
        t := get_left !t;
        set_left !p q;
        set_m !p true;
	!path_from_root[!p] = !path;
        (*set_c !p false;*) (* if we assume at the pre-condition that all nodes start with c = 0,
		   	       then this redundant *)
	unmarked_nodes := S.remove !p !unmarked_nodes
      end
    done 


end
