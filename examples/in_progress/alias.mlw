
module Test
  use import ref.Ref
  use import mach.int.UInt32
  use import mach.c.C

  let a () : unit diverges =
    let zero = Int32.of_int 0 in
    let r = ref 0 in
    let rr = ref r in
    let x = ref (ref 0) in
    x := !x;
    !x := 42;
    let p = malloc (UInt32.of_int 2) in
    c_assert (is_not_null p);
    let b = ref p in
    b := !b;
    let c = get p in
    let d = get !b in
(*    b := incr p zero;*)
    ()

  type t = {
     mutable f : int;
  }

  let t_alias (x:t) : t
    alias { x with result }
  = x
(*
  let f_alias (x:t) : t
    alias { x with result } (* does not happen *)
  = { f = x.f }
*)
  val c (x:t) : t
    ensures { x.f = result.f }
    alias { x with result }

  let test () =
    let x = { f = 42 } in
    let y = c x in
    assert { y.f = 42 };
    y.f <- 27;
    assert { x.f = 27 };
    if any bool then x else y

end

module Refptr
  use import mach.int.Int32
  use import mach.c.C

  type refp = { mutable pcontents "model_trace:" : ptr int }

  function (!!) (x: refp) : ptr int
  = x.pcontents

  let refp (v: ptr int) : refp
    requires { valid v 0 }
    ensures { result.pcontents.data = v.data }
    ensures { result.pcontents.offset = v.offset }
  (*  alias   { result.contents.data with v.data } *) (* ? *)
  = { pcontents = incr v (Int32.of_int 0) }

  let (!!) (x:refp) : ptr int
  ensures { result = !!x }
    = x.pcontents

  val (::=) (r: refp) (v: ptr int) : unit
  writes { r }
  ensures { !!r.data = v.data }
  ensures { !!r.offset = v.offset }
  (*= r.pcontents <- incr v (Int32.of_int 0)*)


end


module A

  use import map.Map
  use import mach.int.Int32
  use import mach.int.UInt32
  use import mach.c.C
  use import array.Array
  use import int.Int
  use import Refptr


  let test () : unit
  diverges
  =
    let zero = Int32.of_int 0 in
    let three = UInt32.of_int 3 in
    let p = malloc three in
    c_assert (is_not_null p);
    let q = incr p zero in
    set p 42;
    let x = get q in
    assert { x = 42 };
    set q 27;
    let y = get p in
    let s = refp p in
  (*  s ::= !!s;
    s ::= incr !!s zero;*) (*illegal alias*)
    let z = get !!s in
    assert { y = 27 = z }
end

