
module Test
  use import ref.Ref
  use import mach.int.UInt32
  use import mach.c.C

  let a () : unit diverges =
    let zero = Int32.of_int 0 in
    let r = ref zero in
    let rr = ref r in
    let x = ref (ref zero) in
    x := !x;
    !x := Int32.of_int 42;
    let p = malloc (UInt32.of_int 2) in
    c_assert (is_not_null p);
    let b = ref p in
    b := !b;
    let c = get p in
    let d = get !b in
(*    b := incr p zero;*)
    ()

  type t = {
     mutable f : int;
  }

  let t_alias (x:t) : t
    alias { x with result }
  = x
(*
  let f_alias (x:t) : t
    alias { x with result } (* does not happen *)
  = { f = x.f }
*)
  val c (x:t) : t
    ensures { x.f = result.f }
    alias { x with result }

  let test () =
    let x = { f = 42 } in
    let y = c x in
    assert { y.f = 42 };
    y.f <- 27;
    assert { x.f = 27 };
    if any bool then x else y

end

module Refptr
  use import mach.int.Int32
  use import mach.c.C

  type refp = { mutable pcontents "model_trace:" : ptr int }

 (* function (!!) (x: refp) : ptr int
  = x.pcontents*)

  let refp (v: ptr int) : refp
    requires { valid v 0 }
    ensures { result.pcontents.data = v.data }
    ensures { result.pcontents.offset = v.offset }
    alias   { result.pcontents.data with v.data } (* ? *)
    = { pcontents = incr v (Int32.of_int 0) }

  val function (!!) (x:refp) : ptr int
    ensures { result.data = x.pcontents.data }
    ensures { result.offset = x.pcontents.offset }
    alias   { result.data with x.pcontents.data }
  (*ensures { result = !!x } *) (* let ... = !!x => illegal alias when used*)

(*
  let (::=) (r: refp) (v: ptr int) : unit
    requires { valid v 0 }
    writes { r }
    ensures { !!r =  v }
  = let _ = if true then r.pcontents.data else v.data in
    r.pcontents <- incr v (Int32.of_int 0)
*)

end

(*
module A

  use import map.Map
  use import mach.int.Int32
  use import mach.int.UInt32
  use import mach.c.C
  use import array.Array
  use import int.Int
  use import Refptr


  let test () : unit
  diverges
  =
    let zero = Int32.of_int 0 in
    let one = Int32.of_int 1 in
    let three = UInt32.of_int 3 in
    let p = malloc three in
    c_assert (is_not_null p);
    let q = incr p zero in
    set p 42;
    let x = get q in
    assert { x = 42 };
    set q 27;
    let y = get p in
    let s = refp p in
    s.pcontents <- incr !!s zero;
    s ::=  incr !!s zero;
    let z = get !!s in
    assert { y = 27 = z };
    set_ofs p one 33;
    let a = get_ofs !!s one in
    assert { a = 33 };
    s ::= incr !!s one;
    let b = get !!s in
    assert { b = 33 };
end
*)