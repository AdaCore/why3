
(** Hash tables using linear probing *)

module LinearProbing

  use import int.Int
  use import int.ComputerDivision
  use import option.Option
  use import list.Mem
  use import map.Map
  use import array.Array

  type key

  constant dummy: key

  function hash key : int

  axiom hash_nonneg: forall k: key. 0 <= hash k

  function bucket (k: key) (n: int) : int = mod (hash k) n

  lemma bucket_bounds:
    forall n: int. 0 < n ->
    forall k: key. 0 <= bucket k n < n

  (* j lies between l and r, cyclically *)
  predicate between (l j r: int) =
    (* l <= j <= r || r <= l <= j || j <= r <= l *)
    l <= j < r || r < l <= j || j < r < l

  clone import array.NumOfEq with type elt = key

  type t = { mutable size: int;   (* total number of elements *)
             mutable data: array key;    (* buckets *)
       ghost mutable view: map key bool; (* pure model *)
    }
    (* at least one empty slot *)
    invariant { 0 <= self.size < length self.data }
    invariant { let n = Array.length self.data in
                self.size + numof self.data dummy 0 n = n }
    (* dummy not in the model *)
    invariant { not (Map.get self.view dummy) }
    (* any value in the array is in the model *)
    invariant { forall i: int. 0 <= i < Array.length self.data ->
                self.data[i] <> dummy -> Map.get self.view self.data[i] }
    (* any value in the model is in the array *)
    invariant { let n = Array.length self.data in
                forall x: key. Map.get self.view x ->
                exists i: int. 0 <= i < n && self.data[i] = x &&
                  forall j: int. 0 <= j < n ->
                  between (bucket x n) j i -> self.data[j] <> dummy }

  let rec lemma dummy_const (a: array key) (n: int)
    requires { 0 <= n } requires { forall i: int. 0 <= i < n -> a[i] = dummy }
    variant { n } ensures { numof a dummy 0 n = n }
  = if n > 0 then dummy_const a (n-1)

  let create (n: int) : t
    requires { 0 < n }
    ensures  { forall x: key. not (Map.get result.view x) }
  =
    { size = 0; data = Array.make n dummy; view = Map.const false; }

  let clear (h: t) : unit
    writes  { h.size, h.data.elts, h.view }
    ensures { h.size = 0 }
    ensures { forall x: key. not (Map.get h.view x) }
  =
    h.size <- 0;
    Array.fill h.data 0 (Array.length h.data) dummy;
    h.view <- Map.const false

  function next (n i: int) : int =
    let i = i+1 in if i = n then 0 else i

  let find (a: array key) (x: key) : int
    requires { x <> dummy }
    requires { let n = Array.length a in 0 < n /\ numof a dummy 0 n > 0 }
    ensures  { 0 <= result < Array.length a }
    ensures  { a[result] = dummy || a[result] = x }
    ensures  { forall j: int. 0 <= j < Array.length a ->
               between (bucket x (Array.length a)) j result ->
               a[j] <> x /\ a[j] <> dummy }
  =
    let n = Array.length a in
    let rec find (i: int) : int
      requires { 0 <= i < n }
      requires { forall j: int. 0 <= j < n -> between (bucket x n) j i ->
                 a[j] <> x /\ a[j] <> dummy }
      ensures  { 0 <= result < n }
      ensures  { a[result] = dummy || a[result] = x }
      ensures  { forall j: int. 0 <= j < n -> between (bucket x n) j result ->
                 a[j] <> x /\ a[j] <> dummy }
    =
      if a[i] = dummy || a[i] = x then i else find (next n i)
    in
    find (bucket x n)

  let mem (h: t) (x: key) : bool
    requires { x <> dummy }
    ensures  { result <-> Map.get h.view x }
   =
    h.data[find h.data x] <> dummy

  let resize (h: t) : unit
    writes  { h.data }
    ensures { Array.length h.data = 2 * old (Array.length h.data) }
  =
    let n = Array.length h.data in
    let n2 = 2 * n in
    let a = Array.make n2 dummy in
    for i = 0 to n - 1 do
      invariant { numof a dummy 0 n2 = numof h.data dummy 0 i + n2 - i }
      invariant { forall j: int. 0 <= j < n2 ->
                  a[i] <> dummy -> Map.get h.view a[i] }
      invariant { forall j: int. 0 <= j < i -> let x = h.data[i] in
                  x <> dummy ->
                  exists j2: int. 0 <= j2 < n2 ->
                    a[j2] = x /\
                    forall k: int. 0 <= k < n2 ->
                    between (bucket x n) k j2 -> a[k] <> dummy }
      let x = h.data[i] in
      if x <> dummy then a[find a x] <- x
    done;
    h.data <- a

  let add (h: t) (x: key) : unit
    requires { x <> dummy }
    writes   { h.size, h.data, h.data.elts, h.view }
    ensures  { h.view = Map.set (old h.view) x True }
   =
    if 2 * (h.size + 1) >= Array.length h.data then resize h;
    let i = find h.data x in
    if h.data[i] = dummy then h.size <- h.size + 1;
    ghost h.view <- Map.set h.view x True;
    h.data[i] <- x

end

(*

  let resize h =
    let old = h.data in
    h.data <- Array.make (2 * Array.length h.data) h.dummy;
    Array.iter (fun x -> h.data.(find h x) <- x) old

  let add h x =
    if 2 * h.size >= Array.length h.data then resize h;
    let i = find h x in
    if h.data.(i) == h.dummy then h.size <- h.size + 1;
    h.data.(i) <- x

  let remove h x =
    let n = Array.length h.data in
    let rec delete j i =
      let i = let i = i+1 in if i = n then 0 else i in
      let xi = h.data.(i) in
      if xi != h.dummy then begin
        let r = X.hash xi mod n in
        if j < r && r <= i || i < j && j < r || r <= i && i < j then
          delete j i
        else begin
          h.data.(j) <- h.data.(i); h.data.(i) <- h.dummy; delete i i
        end
      end
    in
    let j = find h x in
    if h.data.(j) != h.dummy then begin
      h.data.(j) <- h.dummy;
      delete j j;
      h.size <- h.size - 1;
    end

  let iter f h =
    Array.iter (fun x -> if x != h.dummy then f x) h.data

  let fold f h init =
    Array.fold_right (fun x acc -> if x != h.dummy then f x acc) h.data init

  let copy h =
    { size = h.size; dummy = h.dummy; data = Array.copy h.data }

  let print fmt h =
    Format.fprintf fmt "size = %d, length = %d@." h.size (Array.length h.data);
    Array.iter (fun x ->
      Format.fprintf fmt "%c" (if x == h.dummy then '.' else '#')) h.data

*)

