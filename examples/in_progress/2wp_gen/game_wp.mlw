
(* Common definitions. *)
module WpCommon

  use import ho_set.Set
  use import ho_rel.Rel
  use import ho_rel.Prod
  use import order.Ordered
  use import order.Chain
  use import fn.Fun
  use import fn.Image
  use import compute_elts.Quant

  (* Represent the usual structure of hypothesis:
     precondition-postcondition couples, with auxiliary (ghost) parameters
     'ig and 'il, and auxiliary (ghost) return values 'o.
     'ig and 'il represent the distinction between global (shared among
     hypothesis/'goal') and local (parameter of the current hypothesis)
     parameters.
     Finally, the 'input/output structure' will be used internally
     to build quantifications introducting the input/output result(s):
     input/output for inclusion tests, and output only for usage.
   *)
  type enf_hyp 'a 'ig 'il 'o = {
    pre : 'ig -> rel 'il 'a;
    post : 'ig -> 'il -> 'a -> rel 'o 'a;
    pre_strct : qstructure 'il;
    post_strct : qstructure 'o;
  }

  (* Definitions for domain shift
     (TODO: introduce a combinator & explain better) *)
  predicate invalid_sup_witness (r:rel 'a 'd) (o1:erel 'a) (o2:erel 'd) (sp:'d)
                                (ch:set ('a,'d)) (inh:('a,'d)) =
    chain (rprod o1 o2) ch /\ ch inh /\ supremum o2 (image snd ch) sp /\
    (forall x y. ch (x,y) -> r x y) /\
    (forall sp0. supremum o1 (image fst ch) sp0 -> not r sp0 sp)

end

module Wp "W:non_conservative_extension:N" (* Definitions in WpImpl *)

  use export WpCommon
  use import int.Int
  use import ho_set.Set
  use import ho_rel.Rel
  use import compute_elts.Base
  use import compute_elts.Quant

  (* Context: represent a sequential set of hypothesis,
     that can be referenced by index.
     Those behave as De Bruijn Indices. *)
  type context 'a
  (* An enforcement record (type enforce 'a 'i 'o) internally
     represent a game formula shaped as

     |- forall x Gamma Q. Gamma => < f(Gamma,Q,x) -> exists y. Q y >

     Here, the f(Gamma,Q,x) represent a backward predicate transformer,
     (as obtained by wp calculus), modified to take into account context
     correctly. The hypothesis set will contain hypothesis shaped as:
     forall x Q. < f(Q,x) -> exists y. Q y >, e.g regular backward predicate
     transformer. They do not depend on the context as they are part of it.

     On top of the theorem (which structure is represented by
     a 'transformer'), the enforcement box refer to the underlying game by:
     - the underlying game ordering
     - A validity predicate that indicate which states 'make sense'.
       The theorem above takes that predicate into account everywhere,
       as a global invariant.
     - A 'quantification structure' for the games states, that serve
       for decomposing quantification mentionning game states. *)
  type enforce 'a 'i 'o
  type transformer 'a 'i 'o
  function transformp (enforce 'a 'i 'o) : transformer 'a 'i 'o
  function game_order (enforce 'a 'i 'o) : erel 'a
  function game_valid (enforce 'a 'i 'o) : set 'a
  function game_strct (enforce 'a 'i 'o) : qstructure 'a
  (* Invariant *)
  predicate enforce_inv (enforce 'a 'i 'o)
  (* Common case: order/validity/structure associated to game are shared. *)
  predicate game_sames (enforce 'a 'i1 'o1) (enforce 'a 'i2 'o2)

  (* Exposed logical function to create contexts. *)
  function ctx_nil : 'ig -> context 'a
  function ctx_add (qstructure 'a) (enf_hyp 'a 'ig 'il 'o)
                   ('ig -> context 'a) : 'ig -> context 'a

  (* A potentially useful postcondition for abstractions:
     empty postcondition. *)
  function empty_post : 'ig -> 'il -> 'a -> rel 'o 'a

  (* Abstraction combinator: replace the backward predicate
     transformer by an explicit interface triple
     (context,precondition,postcondition).
     This generates proof obligations corresponding to the transformers. *)
  function abstraction_transformer (qstructure 'a)
                                   ('ig -> context 'a)
                                   (enf_hyp 'a 'ig 'il 'o) :
                                   transformer 'a ('ig,'il) 'o
  predicate proof_obligations (qstructure 'a)
                              (qstructure 'ig)
                              ('ig -> context 'a)
                              (transformer 'a ('ig,'il) 'o)
                              (enf_hyp 'a 'ig 'il 'o)
  val ghost abstraction (igs:qstructure 'ig)
                        (gf:'ig -> context 'a)
                        (eh:enf_hyp 'a 'ig 'il 'o)
                        (e:enforce 'a ('ig,'il) 'o) : enforce 'a ('ig,'il) 'o
    requires { enforce_inv e }
    requires { "expl:to be computed precondition"
      proof_obligations e.game_strct igs gf e.transformp eh }
    ensures { enforce_inv result }
    (* TODO: maybe add a shortcut predicate somewhere,
       this is a long line for something that will be user-written. *)
    ensures { result.transformp -->
      abstraction_transformer e.game_strct gf eh }
    ensures { game_sames result e }

  (* Kontinuation combinator: take an enforcement record that
     may use a continuation for the place right there as last
     hypothesis, and send back one which does not need it.
     Programming analogy: this is call/cc. *)
  function kontinuation_transformer
    (transformer 'a 'i 'o) : transformer 'a 'i 'o
  val ghost ktrap (e:enforce 'a 'i 'o) : enforce 'a 'i 'o
    requires { enforce_inv e }
    ensures { enforce_inv result }
    ensures { game_sames result e }
    ensures { result.transformp --> kontinuation_transformer e.transformp }

  (* Hide away from main namespace definitions & axioms
     related to computation rules *)
  namespace LOCAL

    predicate app_transformer
      (transformer 'a 'i 'o) (context 'a) (rel 'o 'a) 'i 'a

    type hyp 'a
    type ftransformer 'a 'i 'o
    predicate app_ftransformer (ftransformer 'a 'i 'o) (rel 'o 'a) 'i 'a

    function ctx_empty : context 'a
    function ctx_cons (hyp 'a) (context 'a) : context 'a
    function ctx_nth (context 'a) int : hyp 'a
    function ctx_len (context 'a) : int

    axiom ctx_nth_rule : forall h:hyp 'a,ctx n.
      ctx_nth (ctx_cons h ctx) n = if n = 0 then h else ctx_nth ctx (n-1)
    meta rewrite prop ctx_nth_rule
    meta remove_prop prop ctx_nth_rule

    axiom ctx_len_cons : forall h:hyp 'a,ctx.
      ctx_len (ctx_cons h ctx) = 1 + ctx_len ctx
    meta rewrite prop ctx_len_cons
    meta remove_prop prop ctx_len_cons

    axiom ctx_len_empty : ctx_len (ctx_empty:context 'a) = 0
    meta rewrite prop ctx_len_empty
    meta remove_prop prop ctx_len_empty

    function transf_hyp (ftransformer 'a 'i 'o) : hyp 'a

    function enf_transf_match_fn 'ig (ftransformer 'a 'il 'o)
                                 (enf_hyp 'a 'ig 'il 'o) : set ('il,'a)
    axiom enf_transf_match_fn_rule :
      forall xg ft xl xs,eh:enf_hyp 'a 'ig 'il 'o.
        enf_transf_match_fn xg ft eh (xl,xs) <->
        (eh.pre xg xl xs -> app_ftransformer ft (eh.post xg xl xs) xl xs)
    meta rewrite prop enf_transf_match_fn_rule
    meta remove_prop prop enf_transf_match_fn_rule

    predicate enf_transf_match (qstructure 'a) 'ig (ftransformer 'a 'il 'o)
                               (enf_hyp 'a 'ig 'il 'o)
    axiom enf_transf_match_rule : forall gs xg ft,eh:enf_hyp 'a 'ig 'il 'o.
      enf_transf_match gs xg ft eh <->
        let fn = enf_transf_match_fn xg ft eh in
        quant_structure true (q_pair eh.pre_strct gs) fn
    meta rewrite prop enf_transf_match_rule
    meta remove_prop prop enf_transf_match_rule

    function freeze_context 'ig (context 'a) (transformer 'a ('ig,'il) 'o) :
                                ftransformer 'a 'il 'o
    axiom freeze_context_rule :
      forall xg ctx q xl xs,t:transformer 'a ('ig,'il) 'o.
        app_ftransformer (freeze_context xg ctx t) q xl xs <->
        app_transformer t ctx q (xg,xl) xs
    meta rewrite prop freeze_context_rule
    meta remove_prop prop freeze_context_rule

    function proof_obligations_fn (qstructure 'a)
                                  ('ig -> context 'a)
                                  (transformer 'a ('ig,'il) 'o)
                                  (enf_hyp 'a 'ig 'il 'o) : set 'ig
    axiom proof_obligations_fn_rule :
      forall gs gf t xg,eh:enf_hyp 'a 'ig 'il 'o.
        proof_obligations_fn gs gf t eh xg <->
        enf_transf_match gs xg (freeze_context xg (gf xg) t) eh
    meta rewrite prop proof_obligations_fn_rule
    meta remove_prop prop proof_obligations_fn_rule

    axiom proof_obligations_rule :
      forall gs igs gf t,eh:enf_hyp 'a 'ig 'il 'o.
      proof_obligations gs igs gf t eh <->
      quant_structure true igs (proof_obligations_fn gs gf t eh)
    meta rewrite prop proof_obligations_rule
    meta remove_prop prop proof_obligations_rule

    function post_inclusion (q1 q2:rel 'o 'a) : set ('o,'a)
    axiom post_inclusion_rule : forall q1 q2:rel 'o 'a,y ys.
      post_inclusion q1 q2 (y,ys) <->
        (q1 y ys -> "expl:inner postcondition" (q2 y ys = true))
    meta rewrite prop post_inclusion_rule
    meta remove_prop prop post_inclusion_rule

    function enf_transf (qstructure 'a) 'ig
                        (enf_hyp 'a 'ig 'il 'o) : ftransformer 'a 'il 'o
    axiom enf_transf_rule : forall gs xg q xl xs,eh:enf_hyp 'a 'ig 'il 'o.
      app_ftransformer (enf_transf gs xg eh) q xl xs <->
      ("expl:inner precondition" (eh.pre xg xl xs = true)) &&
      quant_structure true (q_pair eh.post_strct gs)
                           (post_inclusion (eh.post xg xl xs) q)
    meta rewrite prop enf_transf_rule
    meta remove_prop prop enf_transf_rule

    axiom ctx_nil_apply : forall xg:'ig. ctx_nil xg = (ctx_empty:context 'a)
    meta rewrite prop ctx_nil_apply
    meta remove_prop prop ctx_nil_apply

    axiom ctx_add_apply : forall eh:enf_hyp 'a 'ig 'il 'o,q xg ctx.
      ctx_add q eh ctx xg = ctx_cons (transf_hyp (enf_transf q xg eh)) (ctx xg)
    meta rewrite prop ctx_add_apply
    meta remove_prop prop ctx_nil_apply

    predicate weaker_hypothesis (qstructure 'a) (h1 h2:hyp 'a)
    predicate weaker_hypothesis_prelude (h1 h2:hyp 'a)
    axiom weaker_hypothesis_rule :
      forall q1 q2 xg t,eh:enf_hyp 'a 'ig 'il 'o.
        weaker_hypothesis q1 (transf_hyp (enf_transf q2 xg eh)) (transf_hyp t)
        <-> (weaker_hypothesis_prelude (transf_hyp (enf_transf q2 xg eh))
                                       (transf_hyp t) ->
             enf_transf_match q1 xg t eh)
    meta rewrite prop weaker_hypothesis_rule
    meta remove_prop prop weaker_hypothesis_rule
    axiom weaker_hypothesis_refl : forall q,h:hyp 'a.
      weaker_hypothesis q h h <-> true
    meta rewrite prop weaker_hypothesis_refl
    meta remove_prop prop weaker_hypothesis_refl

    predicate sub_context (qstructure 'a) (a b:context 'a)
    axiom sub_context_empty : forall q:qstructure 'a,c.
      sub_context q ctx_empty c <-> true
    meta rewrite prop sub_context_empty
    meta remove_prop prop sub_context_empty
    axiom sub_context_add : forall q:qstructure 'a,h1 c1 h2 c2.
      sub_context q (ctx_cons h1 c1) (ctx_cons h2 c2) <->
        weaker_hypothesis q h1 h2 /\ sub_context q c1 c2
    meta rewrite prop sub_context_add
    meta remove_prop prop sub_context_add
    axiom sub_context_refl : forall q:qstructure 'a,c.
      sub_context q c c <-> true
    meta rewrite prop sub_context_refl
    meta remove_prop prop sub_context_refl

    axiom abstraction_transformer_rule :
      forall gs gf ctx q xg xl xs,eh:enf_hyp 'a 'ig 'il 'o.
      app_transformer (abstraction_transformer gs gf eh) ctx q (xg,xl) xs <->
        sub_context gs (gf xg) ctx /\
        app_ftransformer (enf_transf gs xg eh) q xl xs
    meta rewrite prop abstraction_transformer_rule
    meta remove_prop prop abstraction_transformer_rule

    axiom empty_post_rule :
      forall xg:'ig,xl:'il,xs:'a,y:'o,ys.
        empty_post xg xl xs y ys <-> false
    meta rewrite prop empty_post_rule
    meta remove_prop prop empty_post_rule

    function kont_pre (q:rel 'o 'a) : 'i -> rel 'o 'a
    axiom kont_pre_rule : forall q,xl:'i,y:'o,ys:'a.
      kont_pre q xl y ys <-> q y ys
    meta rewrite prop kont_pre_rule
    meta remove_prop prop kont_pre_rule

    axiom kontinuation_transformer_rule :
      forall t:transformer 'a 'i 'o,ctx q x xs.
        app_transformer (kontinuation_transformer t) ctx q x xs <->
        let eh = { pre = kont_pre q; post = empty_post;
                   pre_strct = q_def; post_strct = q_unit } in
        let ctx' = ctx_cons (transf_hyp (enf_transf q_def x eh)) ctx in
        app_transformer t ctx' q x xs
    meta rewrite prop kontinuation_transformer_rule
    meta remove_prop prop kontinuation_transformer_rule

  end

  (* TODO: erase those, they are harnesses. *)

  function h_eh (p:'i -> bool) (q:'i -> 'o -> bool) :
    enf_hyp unit 'g 'i 'o = {
    pre = \_ x _. p x;
    post = \_ x _ y _. q x y;
    pre_strct = q_def;
    post_strct = q_def;
  }
  meta rewrite_def function h_eh

  let ghost test (e:enforce unit ('g,'i) 'o)
                 (pc1 pc2:set 'ic) (qc1 qc2:rel 'ic 'oc)
                 (p1 p2:set 'i) (q1 q2:rel 'i 'o) : enforce unit ('g,'i) 'o
    requires { enforce_inv e }
    requires { e.game_strct --> q_unit }
    requires { e.transformp -->
      abstraction_transformer e.game_strct
      (ctx_add e.game_strct (h_eh pc1 qc1) ctx_nil)
      (h_eh p1 q1) }
    requires { subset p2 p1 }
    requires { forall x y. p2 x /\ q1 x y -> q2 x y }
    requires { subset pc1 pc2 }
    requires { forall x y. pc1 x /\ qc2 x y -> qc1 x y }
    ensures { enforce_inv result }
    ensures { game_sames result e }
    ensures { result.transformp -->
      abstraction_transformer e.game_strct
      (ctx_add e.game_strct (h_eh pc2 qc2) ctx_nil)
      (h_eh p2 q2) }
  = let c = ctx_add e.game_strct (h_eh pc2 qc2) ctx_nil in
    abstraction q_def c (h_eh p2 q2) e

end

module WpImpl

  use import WpCommon
  use import int.Int
  use import choice.Choice
  use import list.List
  use import list.Length
  use import ho_set.Set
  use import ho_rel.Rel
  use import ho_rel.Prod
  use import ho_rel.RelSet
  use import order.Ordered
  use import order.Chain
  use import fn.Fun
  use import fn.Image
  use import game.Game
  use import game.StratProps
  use import game_fmla.Fmla
  use import game_fmla.FmlaRules
  use import compute_elts.Quant

  (* Context definitions & a few lemmas about it. *)

  (* (flat) Hypothesis are set of pairs (precondition,postcondition)  *)
  type hyp 'a = set (set 'a,set 'a)
  (* Contexts are merely lists, hypothesis being referenced to by nth.
     (this is reminiscent to De Bruijn Indices) *)
  type context 'a = list (hyp 'a)
  (* Fusion of all hypothesis into one. *)
  predicate ctx_union (ctx:context 'a) (h:(set 'a,set 'a)) = match ctx with
    | Nil -> false
    | Cons x q -> x h \/ ctx_union q h
    end
  (* Hypothesis access. *)
  function ctx_nth (ctx:context 'a) (n:int) : hyp 'a = match ctx with
    | Nil -> witness
    | Cons x q -> if n = 0 then x else ctx_nth q (n-1)
    end
  (* Interpretation of a pre/post-condition tandem
     + relation to effective game as a game formula. *)
  function pre_post_fmla (r:rel 'a 'd) (pq:(set 'a,set 'a)) : fmla 'd =
    let (p,q) = pq in enforce (related r p) (related r q)
  (* Transform an hypothesis into a universal formula (quantification
     over all pre/post-condition tandems) *)
  function hyp_fmla (r:rel 'a 'd) (h:hyp 'a) : fmla 'd =
    b_universal h (pre_post_fmla r)
  (* A natural lemma about context update. *)
  lemma ctx_hyp_add_fmla : forall r:rel 'a 'd,h q g.
    game_wf g ->
    (hyp_fmla r h g /\ hyp_fmla r (ctx_union q) g <->
      hyp_fmla r (ctx_union (Cons h q)) g)
  (* Lifting of postcondition with auxiliary (ghost) return values *)
  function e_lift (q:rel 'a 'b) : set 'b = \y. exists x. q x y
  (* Transform a regular backward predicate transformer into an hypothesis. *)
  function transf_hyp (t:rel 'o 'a -> rel 'i 'a) : hyp 'a =
    \pr. let (p,q) = pr in exists x q'. q = e_lift q' /\ p = t q' x
  (* Directly transform a structured hypothesis into a flat one.
     Even though we will store all hypothesis in transformer form,
     this temporary form is useful when adding structured ones in context. *)
  function direct_enf_hyp
    (xg:'ig) (eh:enf_hyp 'a 'ig 'il 'o) : hyp 'a =
    \pr. let (p,q) = pr in
      exists xl xs. p = inter (eh.pre xg xl) ((=) xs) /\
                    q = e_lift (eh.post xg xl xs)
  (* Transform a structured hypothesis into a regular backward predicate
     transformer. *)
  function enf_transf (xg:'ig) (eh:enf_hyp 'a 'ig 'il 'o) :
                      rel 'o 'a -> rel 'il 'a =
    \q xl xs. eh.pre xg xl xs && forall y ys. eh.post xg xl xs y ys -> q y ys
  function enf_hyp (xg:'ig) (eh:enf_hyp 'a 'ig 'il 'o) : hyp 'a =
    transf_hyp (enf_transf xg eh)
  (* Lemma: both ways of creating a flat hypothesis from a structured
     one are equivalent. *)
  lemma enf_transf_identical :
    forall r:rel 'a 'd,xg,eh:enf_hyp 'a 'ig 'il 'o,g. game_wf g ->
    let hd = direct_enf_hyp xg eh in
    let ht = enf_hyp xg eh in
    (hyp_fmla r hd g -> hyp_fmla r ht g
      by let et = enf_transf xg eh in
        forall p q. ht (p,q) -> pre_post_fmla r (p,q) g
      by let pr = related r p in let qr = related r q in
        holds (hyp_fmla r hd) (enforce pr qr)
      by exists xl q'. q = e_lift q' /\ p = et q' xl
      so forall xd. pr xd -> holds (hyp_fmla r hd) (enforce ((=) xd) qr)
      by exists xs. r xs xd /\ p xs
      so let p0 = inter (eh.pre xg xl) ((=) xs) in
        let q0 = e_lift (eh.post xg xl xs) in
        hd (p0,q0)
      so holds (hyp_fmla r hd) (pre_post_fmla r (p0,q0))
      so subset ((=) xd) (related r p0)
      so subset (related r q0) qr
    ) /\ (hyp_fmla r ht g -> hyp_fmla r hd g
      by let et = enf_transf xg eh in
        forall p q. hd (p,q) -> pre_post_fmla r (p,q) g
      by let pr = related r p in let qr = related r q in
        holds (hyp_fmla r ht) (enforce pr qr)
      by exists xl xs. p = inter (eh.pre xg xl) ((=) xs) /\
                       q = e_lift (eh.post xg xl xs)
      so let p1 = et (eh.post xg xl xs) xl in ht (p1,q)
      so holds (hyp_fmla r ht) (pre_post_fmla r (p1,q))
      so subset pr (related r p1)
    )

  (* Notions related to pointwise context inclusion *)
  predicate weaker_hypothesis (h1 h2:hyp 'a) =
    forall p q x. h1 (p,q) /\ p x ->
      exists p' q'. h2 (p',q') /\ p' x /\ subset q' q
  predicate sub_context (g1 g2:context 'a) = match g1, g2 with
    | Nil, _ -> true
    | _, Nil -> false
    | Cons h1 q1, Cons h2 q2 -> weaker_hypothesis h1 h2 /\ sub_context q1 q2
    end
  lemma weaker_hypothesis_correct : forall r:rel 'a 'd,h1 h2.
    weaker_hypothesis h1 h2 ->
    holds (hyp_fmla r h2) (hyp_fmla r h1)
      by forall pq. h1 pq -> holds (hyp_fmla r h2) (pre_post_fmla r pq)
      by let (p,q) = pq in
        let pr = related r p in
        let qr = related r q in
        forall xd. pr xd -> holds (hyp_fmla r h2) (enforce ((=) xd) qr)
          by exists x. p x /\ r x xd
          so exists p' q'. h2 (p',q') /\ p' x /\ subset q' q
          so holds (hyp_fmla r h2) (pre_post_fmla r (p',q'))
          so subset ((=) xd) (related r p') /\ subset (related r q') qr
  (* if g1 sub g2, then g1 holds under g2. *)
  let rec lemma sub_context_correct (r:rel 'a 'd) (g1 g2:context 'a) : unit
    requires { sub_context g1 g2 }
    ensures { holds (hyp_fmla r (ctx_union g2)) (hyp_fmla r (ctx_union g1)) }
    variant { g1 }
  = match g1, g2 with
    | Nil, _ -> ()
    | _, Nil -> absurd
    | Cons h1 q1, Cons h2 q2 ->
      assert { holds (hyp_fmla r h2) (hyp_fmla r h1) };
      sub_context_correct r q1 q2
    end
  (* Obviously, reflexive. *)
  let rec lemma sub_context_refl (g:context 'a) : unit
    ensures { sub_context g g }
    variant { g }
  = match g with Nil -> () | Cons _ q -> sub_context_refl q end
  (* Useful lemma for actual computation-started resolution:
     a sufficient condition for hypothesis inclusion (which we will
     require in practice) is that one is transformer-based, the other
     is structurally-based, and that they match out *)
  predicate enf_transf_match (xg:'ig) (t:rel 'o 'a -> rel 'il 'a)
                             (eh:enf_hyp 'a 'ig 'il 'o) =
    forall xl xs. eh.pre xg xl xs -> t (eh.post xg xl xs) xl xs
  lemma weaker_hypothesis_sufficient : forall xg t,eh:enf_hyp 'a 'ig 'il 'o.
    enf_transf_match xg t eh ->
    let he = enf_hyp xg eh in
    let ht = transf_hyp t in
    weaker_hypothesis he ht
    by forall p q xs. he (p,q) /\ p xs ->
      let et = enf_transf xg eh in
      exists xl q'. q = e_lift q' /\ p = et q' xl
    so eh.pre xg xl xs
    so let q2 = eh.post xg xl xs in
       let p2 = t q2 xl in
       let q2' = e_lift q2 in
      p2 xs /\ subset q2' q /\ ht (p2,q2')


  (* enforce records definition, invariant, and a domain shift lemma. *)
  type ftransformer 'a 'i 'o = rel 'o 'a -> rel 'i 'a
  type transformer 'a 'i 'o = context 'a -> ftransformer 'a 'i 'o
  type enforce 'a 'i 'o = {
    game_order : erel 'a;
    game_valid : set 'a;
    transformp : transformer 'a 'i 'o;
    game_strct : qstructure 'a;
  }
  predicate game_sames (e1:enforce 'a 'i1 'o1) (e2:enforce 'a 'i2 'o2) =
    e1.game_order = e2.game_order /\ e1.game_valid = e2.game_valid /\
    e1.game_strct = e2.game_strct
  function sing_kont_fmla (x:'d) : fmla 'd = enforce ((=) x) none
  predicate invalid_sup (r:rel 'a 'd) (o1:erel 'a) (o2:erel 'd) (sp:'d) =
    exists ch inh. invalid_sup_witness r o1 o2 sp ch inh
  function vld_fmla (r:rel 'a 'd) (o1:erel 'a) (o2:erel 'd) : fmla 'd =
    b_universal (invalid_sup r o1 o2) sing_kont_fmla
  predicate eqv (s:set 'a) (x y:'a) = x = y /\ s x
  predicate valid_proj (e:enforce 'a 'i 'o) (r:rel 'a 'd) (o:erel 'd) =
    (forall x y. r x y -> e.game_valid x) /\
    (forall x y u v. r x y /\ r u v /\ o y v -> e.game_order x u)
  predicate enforce_inv (e:enforce 'a 'i 'o) =
    let o = e.game_order in
    order o /\
    forall x q ctx.
      let r = eqv e.game_valid in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let p2 = related r (e.transformp ctx q x) in
      let q2 = related r (e_lift q) in
      holds c (enforce p2 q2)

  (* Very important lemma: in the invariant, we fixed the game support type
     to be 'd = 'a, as well as we fixed the order and the relation.
     However, this will still holds for ANY support type 'd and order
     with a validity-compatible relation that maps ordering relation backward.
     This allows to port theorems to different domains.
     Note: monotonicity condition come from the fact that if
       (x -> Q) is in context, what is truly implied is
       (x -> \y. Q y /\ y >= x). However, related (\y. Q y /\ y >= x) is
       a priori not a superset of \y'. related(Q) y' /\ y' >= x'.
       The condition on the ordering relation is the simplest way to guarantee
       this.
     Method:
     1) build a canonical game satisfying the context
     2) Show the relation induce simulation from the canonical game
        to the 'd-one.
     This lemma will be used to switch between game supports.
     TODO: need to devise tools to carry out switching correctly on
       context, as it is non-trivial. We may need to enforce
       usage of a very particular kind of explicit contexts...
       but they cannot be explicited for obvious typing reasons ! *)

  lemma enforce_inv_reinforced : forall e:enforce 'a 'i 'o. enforce_inv e ->
    let oe = e.game_order in
    forall x q ctx rd,od:erel 'd. valid_proj e rd od ->
      let c = conj (hyp_fmla rd (ctx_union ctx))
                   (conj (vld_fmla rd oe od) (ordering od)) in
      let p0 = e.transformp ctx q x in let q0 = e_lift q in
      let pd = related rd p0 in let qd = related rd q0 in
      holds c (enforce pd qd)
      by forall gd. game_wf gd /\ c gd -> have_uniform_winning_strat gd pd qd
      by let re = eqv e.game_valid in
        let ctx0 = \p q. (exists p0 q0. ctx_union ctx (p0,q0) /\
                          p = related re p0 /\ q = related re q0) \/
                         (exists sp. invalid_sup re oe oe sp /\
                          p = (=) sp /\ q = none)
        in
        let tr = \x s. exists p q. ctx0 p q /\ p x /\ s = inter q (oe x) in
        let ge = { progress = oe; transition = tr } in
        game_wf ge
      (* Preliminary: related by re then rd is equivalent to relate
           directly by rd *)
      so ("stop_split" forall s. related rd (related re s) = related rd s
        by let rds = related rd s in let res = related re s in
          let rdes = related rd res in
          sext rdes rds
        by (forall x. rdes x -> rds x)
        /\ (forall x. rds x -> rdes x
          by exists y. s y /\ rd y x so res y by re y y)
      )
      (* All pre-post implied by the context are validated by ge
         (the canonical game associated to the theorem) *)
      so ("stop_split" forall p q. ctx0 p q -> enforce p q ge
        by forall x. p x -> have_winning_strat ge x q
        by let s = inter q (oe x) in
          subset s q /\ tr x s)
      (* Hence the context is validated by ge, and so the final
         pre/post holds. *)
      so let ce = conj (hyp_fmla re (ctx_union ctx))
                       (conj (vld_fmla re oe oe) (ordering oe))
        in ("stop_split" ce ge
          by hyp_fmla re (ctx_union ctx) ge
          /\ (vld_fmla re oe oe ge)
          /\ ordering oe ge
      )
      so let pe = related re p0 in let qe = related re q0 in
        (enforce pe qe ge by holds ce (enforce pe qe))
      (* To conclude, it remains only to notice that rd
         induce a step-by-step simulation from ge to gd. *)
      so step_simulate ge rd gd
      by ("stop_split" limit_compatible oe rd gd
        by forall ch inh sd. chain (rprod oe od) ch /\ ch inh /\
          (forall a b. ch (a,b) -> rd a b) /\ supremum od (image snd ch) sd ->
          (have_winning_strat gd sd none
          \/ exists se. supremum oe (image fst ch) se /\ rd se sd)
        by if invalid_sup rd oe od sd
        then have_winning_strat gd sd none
          by enforce ((=) sd) none gd
        else not invalid_sup_witness rd oe od sd ch inh
          so exists se. supremum oe (image fst ch) se /\ rd se sd
      )
      /\ "stop_split" forall x y s. tr x s /\ rd x y ->
        (* Out of the two transitions possibility, the invalid
           supremum one is unfeasible as this supremum may not be related. *)
        have_winning_strat gd y (related rd s)
        by exists p q. ctx0 p q /\ p x /\ s = inter q (oe x)
        so (false by exists sp. invalid_sup re oe oe sp /\
          p = (=) sp /\ q = none so exists ch inh.
            invalid_sup_witness re oe oe sp ch inh
          so image fst ch = image snd ch
          by sext (image fst ch) (image snd ch)
          by (forall x. image fst ch x <-> ch (x,x))
          /\ (forall x. image snd ch x <-> ch (x,x))
        )
        \/ (exists p0 q0. ctx_union ctx (p0,q0) /\
          p = related re p0 /\ q = related re q0
          so enforce (related rd p0) (related rd q0) gd
          so let cd = subgame gd in
            holds cd (enforce (related rd p0) (related rd q0))
          so let qr = related rd q in
            (holds cd (enforce ((=) y) qr)
            by subset ((=) y) (related rd p0))
          so holds cd (enforce ((=) y) (inter qr (od y)))
          so (holds cd (enforce ((=) y) (related rd s))
            by subset (inter qr (od y)) (related rd s)
          )
          so have_uniform_winning_strat gd ((=) y) (related rd s)
        )

  (* Another useful lemma: the invariant can be mostly reworded using
     hyp_fmla & transformer hypothesis. *)
  function freeze_context (xg:'ig) (g:context 'a)
                          (t:transformer 'a ('ig,'il) 'o) :
                          ftransformer 'a 'il 'o = \q xl. t g q (xg,xl)
  lemma enforce_inv_as_hyp_fmla : forall e:enforce 'a ('ig,'il) 'o.
    enforce_inv e -> forall xg ctx.
      let r = eqv e.game_valid in
      let o = e.game_order in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let ft = freeze_context xg ctx e.transformp in
      let ht = transf_hyp ft in
      holds c (hyp_fmla r ht)
      by forall pq. ht pq -> holds c (pre_post_fmla r pq)
      by let (p,q) = pq in
        let p2 = related r p in
        let q2 = related r q in
        holds c (enforce p2 q2)
      by exists xl q'. q = e_lift q' /\ p = ft q' xl
      so p = e.transformp ctx q' (xg,xl)



  (* First combinator: abstract away internal transformer by a given interface. *)
  function abstraction_transformer (gf:'ig -> context 'a)
                                   (eh:enf_hyp 'a 'ig 'il 'o) :
                                   transformer 'a ('ig,'il) 'o =
    \g q x xs. let (xg,xl) = x in
      sub_context (gf xg) g /\ enf_transf xg eh q xl xs
  (* Alternative (equivalent) invariant for enforcements that have
     an abstraction for transformer. *)
  predicate abstraction_inv (gf:'ig -> context 'a)
                            (eh:enf_hyp 'a 'ig 'il 'o)
                            (e:enforce 'a ('ig,'il) 'o) =
    let o = e.game_order in
    let r = eqv e.game_valid in
    order o /\
    forall xg xl xs. let ctx = gf xg in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      e.game_valid xs /\ eh.pre xg xl xs ->
      let qr = related r (e_lift (eh.post xg xl xs)) in
      holds c (enforce ((=) xs) qr)

  lemma enforce_inv_implies_abstraction_inv :
    forall gf,eh:enf_hyp 'a 'ig 'il 'o,e.
      e.transformp = abstraction_transformer gf eh ->
      enforce_inv e -> abstraction_inv gf eh e
      by forall xg xl xs. let ctx = gf xg in
        let r = eqv e.game_valid in let o = e.game_order in
        let c = conj (hyp_fmla r (ctx_union ctx))
                     (conj (vld_fmla r o o) (ordering o)) in
        e.game_valid xs /\ eh.pre xg xl xs ->
        let q = eh.post xg xl xs in
        let qr = related r (e_lift q) in
        holds c (enforce ((=) xs) qr)
      by let p1 = e.transformp ctx q (xg,xl) in
        let p2 = related r p1 in
        holds c (enforce p2 qr)
      so subset ((=) xs) p2
      by r xs xs /\ p1 xs

  lemma abstraction_inv_implies_enforce_inv :
    forall gf,eh:enf_hyp 'a 'ig 'il 'o,e.
      e.transformp = abstraction_transformer gf eh ->
      abstraction_inv gf eh e -> enforce_inv e
    by let o = e.game_order in let r = eqv e.game_valid in
      forall x q0 ctx.
        let c0 = conj (vld_fmla r o o) (ordering o) in
        let cx = hyp_fmla r (ctx_union ctx) in
        let c = conj cx c0 in
        let p2 = related r (e.transformp ctx q0 x) in
        let q2 = related r (e_lift q0) in
        holds c (enforce p2 q2)
      by forall xs. p2 xs -> holds c (enforce ((=) xs) q2)
      by let (xg,xl) = x in
        let q = eh.post xg xl xs in
        let qr = related r (e_lift q) in
        e.transformp ctx q0 x xs
      so enf_transf xg eh q0 xl xs
      so (holds c (enforce ((=) xs) qr)
         by let ctx' = gf xg in
           let cx' = hyp_fmla r (ctx_union ctx') in
           let c' = conj cx' c0 in
           holds c c' by holds cx cx')
      so subset qr q2
      by forall ys. qr ys -> q2 ys
      by exists y. q y ys

  predicate proof_obligations (gf:'ig -> context 'a)
                              (t:transformer 'a ('ig,'il) 'o)
                              (eh:enf_hyp 'a 'ig 'il 'o) =
    forall xg. enf_transf_match xg (freeze_context xg (gf xg) t) eh

  (* Combinator itself. *)
  let ghost abstraction (gf:'ig -> context 'a)
                        (eh:enf_hyp 'a 'ig 'il 'o)
                        (e:enforce 'a ('ig,'il) 'o) : enforce 'a ('ig,'il) 'o
    requires { enforce_inv e }
    requires { proof_obligations gf e.transformp eh }
    ensures { result.transformp = abstraction_transformer gf eh }
    ensures { game_sames result e }
    ensures { enforce_inv result }
  = let res = { e with transformp = abstraction_transformer gf eh } in
    assert { abstraction_inv gf eh res
      by forall xg xl xs. let ctx = gf xg in
        let o = e.game_order in
        let r = eqv e.game_valid in
        let c = conj (hyp_fmla r (ctx_union ctx))
                     (conj (vld_fmla r o o) (ordering o)) in
        let q0 = e_lift (eh.post xg xl xs) in
        e.game_valid xs /\ eh.pre xg xl xs ->
        let qr = related r q0 in
        let exs = (=) xs in
        holds c (enforce exs qr)
      by let hd = direct_enf_hyp xg eh in
        let ft = freeze_context xg ctx e.transformp in
        let ht = transf_hyp ft in
        let p0 = inter (eh.pre xg xl) ((=) xs) in
        hd (p0,q0)
      so (subset exs (related r p0) by r xs xs)
      so holds c (enforce (related r p0) qr)
      by holds c (hyp_fmla r hd)
      by let hd = enf_hyp xg eh in
        holds c (hyp_fmla r hd)
      by holds c (hyp_fmla r ht)
      so holds (hyp_fmla r ht) (hyp_fmla r hd)
      by weaker_hypothesis hd ht by enf_transf_match xg ft eh
    };
    res

  (* Second combinator: kontinuation trap. *)
  function empty_post : 'a -> 'b -> 'c -> 'd -> 'e -> bool =
    \_ _ _ _ _. false
  function kontinuation_transformer
    (t:transformer 'a 'i 'o) : transformer 'a 'i 'o =
    \ctx q x xs.
      let eh = { pre = const q; post = empty_post;
                 pre_strct = q_def; post_strct = q_unit } in
      t (Cons (enf_hyp x eh) ctx) q x xs

  let ghost ktrap (e:enforce 'a 'i 'o) : enforce 'a 'i 'o
    requires { enforce_inv e }
    ensures { result.transformp = kontinuation_transformer e.transformp }
    ensures { game_sames result e }
    ensures { enforce_inv result }
  = let res = { e with transformp = kontinuation_transformer e.transformp } in
    assert { forall x q ctx.
      let r = eqv e.game_valid in let o = e.game_order in
      let cv = conj (vld_fmla r o o) (ordering o) in
      let cx = hyp_fmla r (ctx_union ctx) in
      let c = conj cx cv in
      let p = res.transformp ctx q x in
      let p2 = related r p in let q2 = related r (e_lift q) in
      holds c (enforce p2 q2)
      by is_fmla c
      so let k = enforce q2 none in
        holds (conj c k) (enforce p2 q2)
      by let cx' = conj cx k in
        let c' = conj cx' cv in
        holds c' (enforce p2 q2)
      by let eh = { pre = const q; post = empty_post;
                    pre_strct = q_def; post_strct = q_unit } in
        let h0 = enf_hyp x eh in
        let ctx' = Cons h0 ctx in
        let cx'' = hyp_fmla r (ctx_union ctx') in
        (p = e.transformp ctx' q x by sext p (e.transformp ctx' q x))
      so holds cx' cx''
      by holds k (hyp_fmla r h0)
      by let h1 = direct_enf_hyp x eh in
        holds k (hyp_fmla r h1)
      by forall pq. h1 pq -> holds k (pre_post_fmla r pq)
      by let (p',q') = pq in
        exists xl xs. p' = inter (q xl) ((=) xs)
      so let p2' = related r p' in let q2' = related r q' in
        holds k (enforce p2' q2')
      by subset p2' q2 /\ holds k k
    };
    res




  (* Export zone. *)

  (* Expose universal quant_structure definition to considerably
     ease proof of computation rules *)
  let lemma expose_quant_structure_def (s:qstructure 'a) (p:'a -> bool) : unit
    ensures { quant_structure true s p <-> forall y. p y }
  = quant_structure_def p

  (* Redefine a lot of things due to slight differences between bare
     development above and exported notions, mainly because of
     quantification handling. *)
  predicate app_transformer (t:transformer 'a 'i 'o)
    (ctx:context 'a) (q:rel 'o 'a) (x:'i) (xs:'a) = t ctx q x xs
  predicate app_ftransformer (ft:ftransformer 'a 'i 'o)
    (q:rel 'o 'a) (x:'i) (xs:'a) = ft q x xs
  function enf_transf_match_fn (xg:'ig)
                               (ft:ftransformer 'a 'il 'o)
                               (eh:enf_hyp 'a 'ig 'il 'o) : set ('il,'a) =
    \pr. let (xl,xs) = pr in
      eh.pre xg xl xs -> ft (eh.post xg xl xs) xl xs
  predicate enf_transf_match_ex (qstructure 'a)
                                (xg:'ig)
                                (ft:ftransformer 'a 'il 'o)
                                (eh:enf_hyp 'a 'ig 'il 'o) =
    enf_transf_match xg ft eh
  lemma enf_transf_match_other_def :
    forall xg ft,eh:enf_hyp 'a 'ig 'il 'o.
      enf_transf_match xg ft eh <-> forall x. enf_transf_match_fn xg ft eh x
        by let (xl,xs) = x in eh.pre xg xl xs -> ft (eh.post xg xl xs) xl xs
  predicate proof_obligations_ex (qstructure 'a)
                                 (qstructure 'ig)
                                 (gf:'ig -> context 'a)
                                 (t:transformer 'a ('ig,'il) 'o)
                                 (eh:enf_hyp 'a 'ig 'il 'o) =
    proof_obligations gf t eh
  function proof_obligations_fn (qstructure 'a)
                                (gf:'ig -> context 'a)
                                (t:transformer 'a ('ig,'il) 'o)
                                (eh:enf_hyp 'a 'ig 'il 'o) : set 'ig =
    \xg. enf_transf_match xg (freeze_context xg (gf xg) t) eh
  function abstraction_transformer_ex (qstructure 'a)
                                      (gf:'ig -> context 'a)
                                      (eh:enf_hyp 'a 'ig 'il 'o) :
                                      transformer 'a ('ig,'il) 'o =
    abstraction_transformer gf eh
  let ghost abstraction_ex (igs:qstructure 'ig)
                           (gf:'ig -> context 'a)
                           (eh:enf_hyp 'a 'ig 'il 'o)
                           (e:enforce 'a ('ig,'il) 'o) :
                           enforce 'a ('ig,'il) 'o
    requires { enforce_inv e }
    requires { proof_obligations_ex e.game_strct igs gf e.transformp eh }
    ensures { enforce_inv result }
    ensures { result.transformp =
      abstraction_transformer_ex e.game_strct gf eh }
    ensures { game_sames result e }
  = abstraction gf eh e

  function enf_transf_ex (qstructure 'a) (xg:'ig) (eh:enf_hyp 'a 'ig 'il 'o) :
                         ftransformer 'a 'il 'o = enf_transf xg eh
  function post_inclusion (q1 q2:rel 'o 'a) : set ('o,'a) =
    \yp. let (y,ys) = yp in q1 y ys -> q2 y ys
  lemma enf_transf_other_def : forall xg,eh:enf_hyp 'a 'ig 'il 'o,q xl xs.
    (enf_transf xg eh q xl xs
      by eh.pre xg xl xs /\ forall y ys. eh.post xg xl xs y ys -> q y ys
      by post_inclusion (eh.post xg xl xs) q (y,ys))
    <-> eh.pre xg xl xs /\
      forall y. post_inclusion (eh.post xg xl xs) q y
      by let (y,ys) = y in eh.post xg xl xs y ys -> q y ys
  predicate sub_context_ex (qstructure 'a) (c1 c2:context 'a) =
    sub_context c1 c2
  lemma sub_context_nil : forall c:context 'a.
    sub_context Nil c by match c with Nil -> true | _ -> true end
  predicate weaker_hypothesis_ex (qstructure 'a) (h1 h2:hyp 'a) =
    weaker_hypothesis h1 h2
  predicate weaker_hypothesis_prelude (h1 h2:hyp 'a) =
    not weaker_hypothesis h1 h2
  constant ctx_nil : 'ig -> context 'a = \_. Nil
  function ctx_add (qstructure 'a)
                   (eh:enf_hyp 'a 'ig 'il 'o)
                   (ctxf:'ig -> context 'a) : 'ig -> context 'a =
    \xg. Cons (enf_hyp xg eh) (ctxf xg)

  clone Wp with type context = context,
    type enforce = enforce,
    type transformer = transformer,
    function game_order = game_order,
    function game_valid = game_valid,
    function game_strct = game_strct,
    function transformp = transformp,
    predicate enforce_inv = enforce_inv,
    predicate game_sames = game_sames,
    function ctx_nil = ctx_nil,
    function ctx_add = ctx_add,
    predicate proof_obligations = proof_obligations_ex,
    function empty_post = empty_post,
    function abstraction_transformer = abstraction_transformer_ex,
    val abstraction = abstraction_ex,
    function kontinuation_transformer = kontinuation_transformer,
    val ktrap = ktrap,
    predicate LOCAL.app_transformer = app_transformer,
    type LOCAL.hyp = hyp,
    type LOCAL.ftransformer = ftransformer,
    predicate LOCAL.app_ftransformer = app_ftransformer,
    function LOCAL.ctx_empty = Nil,
    function LOCAL.ctx_cons = Cons,
    function LOCAL.ctx_nth = ctx_nth,
    function LOCAL.ctx_len = length,
    goal LOCAL.ctx_nth_rule,
    goal LOCAL.ctx_len_cons,
    goal LOCAL.ctx_len_empty,
    function LOCAL.transf_hyp = transf_hyp,
    function LOCAL.enf_transf_match_fn = enf_transf_match_fn,
    goal LOCAL.enf_transf_match_fn_rule,
    predicate LOCAL.enf_transf_match = enf_transf_match_ex,
    goal LOCAL.enf_transf_match_rule,
    function LOCAL.freeze_context = freeze_context,
    goal LOCAL.freeze_context_rule,
    function LOCAL.proof_obligations_fn = proof_obligations_fn,
    goal LOCAL.proof_obligations_fn_rule,
    goal LOCAL.proof_obligations_rule,
    function LOCAL.post_inclusion = post_inclusion,
    goal LOCAL.post_inclusion_rule,
    function LOCAL.enf_transf = enf_transf_ex,
    goal LOCAL.enf_transf_rule,
    goal LOCAL.ctx_nil_apply,
    goal LOCAL.ctx_add_apply,
    predicate LOCAL.weaker_hypothesis = weaker_hypothesis_ex,
    predicate LOCAL.weaker_hypothesis_prelude = weaker_hypothesis_prelude,
    goal LOCAL.weaker_hypothesis_rule,
    goal LOCAL.weaker_hypothesis_refl,
    predicate LOCAL.sub_context = sub_context_ex,
    goal LOCAL.sub_context_empty,
    goal LOCAL.sub_context_add,
    goal LOCAL.sub_context_refl,
    goal LOCAL.abstraction_transformer_rule,
    goal LOCAL.empty_post_rule,
    function LOCAL.kont_pre = const,
    goal LOCAL.kont_pre_rule,
    goal LOCAL.kontinuation_transformer_rule

end

