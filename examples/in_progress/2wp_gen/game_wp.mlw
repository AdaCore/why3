
(* Common definitions. *)
module WpCommon

  use import ho_set.Set
  use import ho_rel.Rel
  use import ho_rel.Prod
  use import order.Ordered
  use import order.Chain
  use import fn.Fun
  use import fn.Image
  use import compute_elts.Quant

  (* Represent the basic informations about the game structure:
     namely ordering, a 'validity' predicate serving as a global
     invariant, and a structure used for decomposing quantifications. *)
  type game_info 'a = {
    game_order : erel 'a;
    game_valid : set 'a;
    game_strct : qstructure 'a;
  }

  (* Represent the usual structure of hypothesis:
     precondition-postcondition couples, with auxiliary (ghost) parameters
     'ig and 'il, and auxiliary (ghost) return values 'o.
     'ig and 'il represent the distinction between global (shared among
     hypothesis/'goal') and local (parameter of the current hypothesis)
     parameters.
     Finally, the 'input/output structure' will be used internally
     to build quantifications introducting the input/output result(s):
     input/output for inclusion tests, and output only for usage.
   *)
  type enf_hyp 'a 'ig 'il 'o = {
    pre : 'ig -> rel 'il 'a;
    post : 'ig -> 'il -> 'a -> rel 'o 'a;
    pre_strct : qstructure 'il;
    post_strct : qstructure 'o;
  }

  (* Definitions for domain shift. *)
  predicate invalid_sup_witness (r:rel 'a 'd) (o1:erel 'a) (o2:erel 'd) (sp:'d)
                                (ch:set ('a,'d)) (inh:('a,'d)) =
    chain (rprod o1 o2) ch /\ ch inh /\ supremum o2 (image snd ch) sp /\
    (forall x y. ch (x,y) -> r x y) /\
    (forall sp0. supremum o1 (image fst ch) sp0 -> not r sp0 sp)

  (* Lifting of postcondition with auxiliary (ghost) return values *)
  function e_lift (q:rel 'a 'b) : set 'b = \y. exists x. q x y

end

module WpCore "W:non_conservative_extension:N" (* Definitions in WpImpl *)

  use export WpCommon
  use import int.Int
  use import ho_set.Set
  use import ho_rel.Rel
  use import compute_elts.Base
  use import compute_elts.Quant
  use import game.Game
  use import game_fmla.Fmla

  (* Context: represent a sequential set of hypothesis,
     that can be referenced by index.
     Those behave as De Bruijn Indices. *)
  type context 'a
  (* An enforcement record (type enforce 'a 'i 'o) internally
     represent a game formula shaped roughly as

     |- forall (GS:game_info 'a) (Gamma:context 'a) (x:'i) (Q:rel 'o 'a).
         ordering(GS) /\ (Gamma MODULO valid(GS)) =>
         < f(GS,Gamma,Q,x) -> exists y. Q y > (MODULO valid(GS) as well)

     Here, the f(GS,Gamma,Q,x) represent a backward predicate transformer,
     as would be obtained by wp calculus. It is modified to take into
     account context & game basic info (the later being for inference reasons).

     The hypothesis set (Gamma) will contain hypothesis shaped as:
     forall x Q. < f(Q,x) -> exists y. Q y >, e.g regular backward predicate
     transformer. They do not depend on the context as they are part of it.

     'GS', of type game_info 'a, provides some references to the underlying
     game:
     - the underlying game ordering
     - A validity predicate that indicate which states 'make sense'.
       The theorem above takes that predicate into account everywhere,
       as a global invariant.
     - A 'quantification structure' for the games states, that serve
       for decomposing quantification mentionning game states. *)
  type enforce 'a 'i 'o
  (* Transformer fields.
     Fields might be added in the future, so enforce 'a 'i 'o
     is kept abstract. *)
  type ftransformer 'a 'i 'o = rel 'o 'a -> rel 'i 'a
  type transformer 'a 'i 'o =
    game_info 'a -> context 'a -> ftransformer 'a 'i 'o
  function transformp (enforce 'a 'i 'o) : transformer 'a 'i 'o
  (* Invariant *)
  predicate enforce_inv (enforce 'a 'i 'o)

  (* Exposed logical function to create contexts. *)
  function ctx_nil : 'ig -> context 'a
  function ctx_add (qstructure 'a)
                   (enf_hyp 'a 'ig 'il 'o)
                   ('ig -> context 'a) : 'ig -> context 'a

  (* A potentially useful postcondition for abstractions:
     empty postcondition. *)
  function empty_post : 'ig -> 'il -> 'a -> rel 'o 'a

  (* Domain relation combinator: transform the game domain to another
     one through a relation. *)
  function domain_rel_enforce (game_info 'a) (rel 'a 'd) (game_info 'd)
                              (enforce 'a ('i,'d) 'o)
                              (enforce 'd (set ('a,'d),('a,'d)) 'o_any) :
                              enforce 'd ('i,'a) ('o,'a)
  val ghost domain_rel (gia:game_info 'a) (r:rel 'a 'd) (gid:game_info 'd)
                       (ea:enforce 'a ('i,'d) 'o)
                       (ei:enforce 'd (set ('a,'d),('a,'d)) 'o_any) :
                       enforce 'd ('i,'a) ('o,'a)
    requires { enforce_inv ea /\ enforce_inv ei }
    ensures { enforce_inv result }
    ensures { result = domain_rel_enforce gia r gid ea ei }

  (* Abstraction combinator: replace the backward predicate
     transformer by an explicit interface triple
     (context,precondition,postcondition).
     This generates proof obligations corresponding to the transformers. *)
  function abstraction_enforce (game_info 'a)
                               ('ig -> context 'a)
                               (enf_hyp 'a 'ig 'il 'o) :
                               enforce 'a ('ig,'il) 'o
  predicate proof_obligations (game_info 'a)
                              (qstructure 'ig)
                              ('ig -> context 'a)
                              (enforce 'a ('ig,'il) 'o)
                              (enf_hyp 'a 'ig 'il 'o)
  val ghost abstraction (gi:game_info 'a)
                        (igs:qstructure 'ig)
                        (gf:'ig -> context 'a)
                        (eh:enf_hyp 'a 'ig 'il 'o)
                        (e:enforce 'a ('ig,'il) 'o) : enforce 'a ('ig,'il) 'o
    requires { enforce_inv e }
    requires { "expl:to be computed precondition"
      proof_obligations gi igs gf e eh }
    ensures { enforce_inv result }
    ensures { result --> abstraction_enforce gi gf eh }

  (* Invariant exposure combinator: expose a theorem about games
     when the transformer has a certain shape. *)
  function expose_inv (gi:game_info 'a)
                      (gf:'ig -> context 'a)
                      (eh:enf_hyp 'a 'ig 'il 'o) :
                      set (('ig,'il),('a,game 'a))
  val ghost expose (gi:game_info 'a)
                   (igs:qstructure 'ig)
                   (gf:'ig -> context 'a)
                   (eh:enf_hyp 'a 'ig 'il 'o) : unit
    requires { "expl:to be computed precondition"
      quant_structure true gi.game_strct gi.game_valid }
    requires { enforce_inv (abstraction_enforce gi gf eh) }
    ensures {
      let qs = q_pair (q_pair igs eh.pre_strct)
                      (q_pair gi.game_strct q_def) in
      quant_structure true qs (expose_inv gi gf eh) }

  (* Kontinuation combinator: take an enforcement record that
     may use a continuation for the place right there as last
     hypothesis, and send back one which does not need it.
     Programming analogy: this is similar to call/cc. *)
  function kontinuation_enforce (enforce 'a 'i 'o) : enforce 'a 'i 'o
  val ghost ktrap (e:enforce 'a 'i 'o) : enforce 'a 'i 'o
    requires { enforce_inv e }
    ensures { enforce_inv result }
    ensures { result --> kontinuation_enforce e }

  (* Context reference combinator: create an enforcement record that
     corresponds to use the n-th hypothesis. *)
  function ctx_ref_enforce int : enforce 'a ('ig,'il) 'o
  val ghost ctx_ref (n:int) : enforce 'a ('ig,'il) 'o
    ensures { enforce_inv result }
    ensures { result --> ctx_ref_enforce n }

  (* Hide away from main namespace definitions & axioms
     related to computation rules *)
  namespace LOCAL

    (* Context members, functions creating them, and associated rules. *)
    type hyp 'a
    type fz_enforce 'a 'i 'o
    function fz_transformp (fz_enforce 'a 'i 'o) : ftransformer 'a 'i 'o
    function fz_enforce_hyp (fz_enforce 'a 'i 'o) : hyp 'a
    function domain_rel_hyp (qstructure 'd) (rel 'a 'd) (hyp 'd) : hyp 'a
    function enf_hyp_fz (qstructure 'a) (xg:'ig)
                        (eh:enf_hyp 'a 'ig 'il 'o) : fz_enforce 'a 'il 'o
    function freeze_context (game_info 'a) (context 'a) 'ig
                            (enforce 'a ('ig,'il) 'o) : fz_enforce 'a 'il 'o
    function post_inclusion (q1 q2:rel 'o 'a) : set ('o,'a)
    function set_inclusion (s1 s2:set 'a) : set 'a
    function rel_post (r:rel 'a 'd) (q:rel 'o 'a) : rel ('o,'a) 'd

    axiom enf_hyp_fz_rule : forall gs xg q xl xs,eh:enf_hyp 'a 'ig 'il 'o.
      (enf_hyp_fz gs xg eh).fz_transformp q xl xs <->
      ("expl:inner precondition" (eh.pre xg xl xs = true)) &&
      quant_structure true (q_pair eh.post_strct gs)
                           (post_inclusion (eh.post xg xl xs) q)
    meta rewrite prop enf_hyp_fz_rule
    meta remove_prop prop enf_hyp_fz_rule

    axiom freeze_context_transformp_rule :
      forall gi xg ctx q xl xs,e:enforce 'a ('ig,'il) 'o.
        (freeze_context gi ctx xg e).fz_transformp q xl xs <->
        e.transformp gi ctx q (xg,xl) xs
    meta rewrite prop freeze_context_transformp_rule
    meta remove_prop prop freeze_context_transformp_rule

    axiom post_inclusion_rule : forall q1 q2:rel 'o 'a,y ys.
      post_inclusion q1 q2 (y,ys) <->
        (q1 y ys -> "expl:inner postcondition" (q2 y ys = true))
    meta rewrite prop post_inclusion_rule
    meta remove_prop prop post_inclusion_rule

    axiom set_inclusion_rule : forall s1 s2:set 'a,x.
      set_inclusion s1 s2 x <-> (s1 x -> s2 x)
    meta rewrite prop set_inclusion_rule
    meta remove_prop prop set_inclusion_rule

    axiom rel_post_rule : forall r:rel 'a 'd,q:rel 'o 'a,pr xd.
      rel_post r q pr xd <-> let (xo,xa) = pr in
        ("expl:related elements" r xa xd) && q xo xa
    meta rewrite prop rel_post_rule
    meta remove_prop prop rel_post_rule

    (* Matching between a 'context-frozen' enforce and a fully structured
       hypothesis. *)
    function fz_enforce_match_fn 'ig (ftransformer 'a 'il 'o)
                                 (enf_hyp 'a 'ig 'il 'o) : set ('il,'a)
    axiom fz_enforce_match_fn_rule :
      forall xg ft xl xs,eh:enf_hyp 'a 'ig 'il 'o.
        fz_enforce_match_fn xg ft eh (xl,xs) <->
        (eh.pre xg xl xs -> ft (eh.post xg xl xs) xl xs)
    meta rewrite prop fz_enforce_match_fn_rule
    meta remove_prop prop fz_enforce_match_fn_rule

    predicate fz_enforce_match (qstructure 'a) 'ig (fz_enforce 'a 'il 'o)
                               (enf_hyp 'a 'ig 'il 'o)
    axiom fz_enforce_match_rule : forall gs xg fze,eh:enf_hyp 'a 'ig 'il 'o.
      fz_enforce_match gs xg fze eh <->
        let fn = fz_enforce_match_fn xg fze.fz_transformp eh in
        quant_structure true (q_pair eh.pre_strct gs) fn
    meta rewrite prop fz_enforce_match_rule
    meta remove_prop prop fz_enforce_match_rule

    (* Definitions & rules associated to context creation & access *)
    function ctx_empty : context 'a
    function ctx_cons (hyp 'a) (context 'a) : context 'a
    function ctx_nth (context 'a) int : hyp 'a
    function ctx_len (context 'a) : int

    axiom ctx_nth_rule : forall h:hyp 'a,ctx n.
      ctx_nth (ctx_cons h ctx) n = if n = 0 then h else ctx_nth ctx (n-1)
    meta rewrite prop ctx_nth_rule
    meta remove_prop prop ctx_nth_rule

    axiom ctx_len_cons : forall h:hyp 'a,ctx.
      ctx_len (ctx_cons h ctx) = 1 + ctx_len ctx
    meta rewrite prop ctx_len_cons
    meta remove_prop prop ctx_len_cons

    axiom ctx_len_empty : ctx_len (ctx_empty:context 'a) = 0
    meta rewrite prop ctx_len_empty
    meta remove_prop prop ctx_len_empty

    axiom ctx_nil_apply : forall xg:'ig. ctx_nil xg = (ctx_empty:context 'a)
    meta rewrite prop ctx_nil_apply
    meta remove_prop prop ctx_nil_apply

    axiom ctx_add_apply : forall eh:enf_hyp 'a 'ig 'il 'o,gs xg ctx.
      ctx_add gs eh ctx xg =
        ctx_cons (fz_enforce_hyp (enf_hyp_fz gs xg eh)) (ctx xg)
    meta rewrite prop ctx_add_apply
    meta remove_prop prop ctx_add_apply

    (* Rules for dereferencing hypothesis. *)
    function ctx_fz_deref (h:hyp 'a) : fz_enforce 'a 'i 'o
    function ctx_fz_deref_transformer_prelude (h:hyp 'a) :
      ftransformer 'a 'i 'o
    axiom ctx_fz_deref_fz_transformp_rule :
      forall fze:fz_enforce 'a 'i 'o,q x xs.
        (ctx_fz_deref (fz_enforce_hyp fze)).fz_transformp q x xs <->
        (ctx_fz_deref_transformer_prelude (fz_enforce_hyp fze) q x xs ->
          fze.fz_transformp q x xs)
    meta rewrite prop ctx_fz_deref_fz_transformp_rule
    meta remove_prop prop ctx_fz_deref_fz_transformp_rule
    axiom ctx_fz_deref_rel_transformp_rule :
      forall r:rel 'a 'd,qd h,q:rel 'o 'a,x:'i,xa.
      (ctx_fz_deref (domain_rel_hyp qd r h)).fz_transformp q x xa <->
      (ctx_fz_deref_transformer_prelude (domain_rel_hyp qd r h) q x xa ->
        quant_structure true qd
          (set_inclusion (r xa)
            ((ctx_fz_deref h).fz_transformp (rel_post r q) (x,xa))))
    meta rewrite prop ctx_fz_deref_rel_transformp_rule
    meta remove_prop prop ctx_fz_deref_rel_transformp_rule

    (* Rules related to sub-contexts. *)
    predicate sub_context (qstructure 'a) (a b:context 'a)
    (* Note: if this symbol is ever seen in a fully reduced goal,
       it indicates a type mistake. *)
    predicate weaker_hypothesis (qstructure 'a) (h1 h2:hyp 'a)
    predicate weaker_hypothesis_prelude (h1 h2:hyp 'a)

    axiom sub_context_empty : forall gs:qstructure 'a,c.
      sub_context gs ctx_empty c <-> true
    meta rewrite prop sub_context_empty
    meta remove_prop prop sub_context_empty

    axiom sub_context_add : forall gs:qstructure 'a,h1 c1 h2 c2.
      sub_context gs (ctx_cons h1 c1) (ctx_cons h2 c2) <->
        weaker_hypothesis gs h1 h2 /\ sub_context gs c1 c2
    meta rewrite prop sub_context_add
    meta remove_prop prop sub_context_add

    axiom sub_context_refl : forall gs:qstructure 'a,c.
      sub_context gs c c <-> true
    meta rewrite prop sub_context_refl
    meta remove_prop prop sub_context_refl

    axiom weaker_hypothesis_rule :
      forall gs1 gs2 xg h,eh:enf_hyp 'a 'ig 'il 'o.
        weaker_hypothesis gs1 (fz_enforce_hyp (enf_hyp_fz gs2 xg eh)) h
        <-> (weaker_hypothesis_prelude (fz_enforce_hyp (enf_hyp_fz gs2 xg eh))
                                       h ->
             fz_enforce_match gs1 xg (ctx_fz_deref h) eh)
    meta rewrite prop weaker_hypothesis_rule
    meta remove_prop prop weaker_hypothesis_rule

    axiom weaker_hypothesis_refl : forall gs,h:hyp 'a.
      weaker_hypothesis gs h h <-> true
    meta rewrite prop weaker_hypothesis_refl
    meta remove_prop prop weaker_hypothesis_refl

    (* Rules for domain_rel (a lot). *)
    function inv_rel_post (qd:qstructure 'd)
                          (rel 'a 'd) (q:rel ('o,'a) 'd) : rel 'o 'a
    axiom inv_rel_post_rule : forall qd r,q:rel ('o,'a) 'd,xo xa.
      inv_rel_post qd r q xo xa <->
        quant_structure true qd (set_inclusion (r xa) (q (xo,xa)))
    meta rewrite prop inv_rel_post_rule
    meta remove_prop prop inv_rel_post_rule

    function absurd_post : rel 'o 'a
    axiom absurd_post_rule : forall a:'o,b:'a. absurd_post a b <->
      "expl:unreachable point" false
    meta rewrite prop absurd_post_rule
    meta remove_prop prop absurd_post_rule

    function domain_rel_ctx (qstructure 'd)
                            (rel 'a 'd) (context 'd) : context 'a
    axiom domain_rel_ctx_empty_rule : forall qd,r:rel 'a 'd.
      domain_rel_ctx qd r ctx_empty = ctx_empty
    meta rewrite prop domain_rel_ctx_empty_rule
    meta remove_prop prop domain_rel_ctx_empty_rule
    axiom domain_rel_ctx_cons_rule : forall r:rel 'a 'd,qd h ctx.
      domain_rel_ctx qd r (ctx_cons h ctx) =
        ctx_cons (domain_rel_hyp qd r h) (domain_rel_ctx qd r ctx)
    meta rewrite prop domain_rel_ctx_cons_rule
    meta remove_prop prop domain_rel_ctx_cons_rule

    function rel_valids (rel 'a 'd) (set 'a) (set 'd) : set ('a,'d)
    axiom rel_valids_rule : forall r:rel 'a 'd,s1 s2 xa xd.
      rel_valids r s1 s2 (xa,xd) <-> (r xa xd -> s1 xa /\ s2 xd)
    meta rewrite prop rel_valids_rule
    meta remove_prop prop rel_valids_rule

    function rel_b_mono (r:rel 'a 'd) (o1:erel 'a)
                         (o2:erel 'd) : set (('a,'d),('a,'d))
    axiom rel_b_mono_rule : forall r:rel 'a 'd,o1 o2 x y u v.
      rel_b_mono r o1 o2 ((x,y),(u,v)) <->
      (r x y /\ r u v /\ o2 y v -> o1 x u)
    meta rewrite prop rel_b_mono_rule
    meta remove_prop prop rel_b_mono_rule

    function invalid_sup_to_rel (r:rel 'a 'd) (oa:erel 'a) (od:erel 'd) :
      rel (set ('a,'d),('a,'d)) 'd
    axiom invalid_sup_to_rel_rule : forall r:rel 'a 'd,oa od ch inh sp.
      invalid_sup_to_rel r oa od (ch,inh) sp <->
      invalid_sup_witness r oa od sp ch inh
    meta rewrite prop invalid_sup_to_rel_rule
    meta remove_prop prop invalid_sup_to_rel_rule

    axiom domain_rel_enforce_transformp_rule :
      forall gia r gid,ea:enforce 'a ('i,'d) 'o,
                       ei:enforce 'd (set ('a,'d),('a,'d)) 'o_any,
                       gi ctx q x xd.
        (domain_rel_enforce gia r gid ea ei).transformp gi ctx q x xd <->
        (gi.game_order = gid.game_order /\
         gi.game_valid = gid.game_valid /\
         ("expl:ordering expected" order gia.game_order) /\
         let qs = q_pair gia.game_strct gid.game_strct in
         let oa = gia.game_order in let od = gid.game_order in
         ("expl:relation imply validity"
          quant_structure true qs
                         (rel_valids r gia.game_valid gid.game_valid)) /\
         ("expl:backward relation monotonicity"
          quant_structure true (q_pair qs qs) (rel_b_mono r oa od)) /\
         ("expl:limit relation condition"
         quant_structure true (q_pair (q_pair q_def qs) gid.game_strct)
                      (post_inclusion (invalid_sup_to_rel r oa od)
                                      (ei.transformp gid ctx absurd_post))) /\
         let (xi,xa) = x in
         ("expl:related elements" r xa xd) &&
         ea.transformp gia (domain_rel_ctx gid.game_strct r ctx)
                           (inv_rel_post gid.game_strct r q) (xi,xd) xa)
    meta rewrite prop domain_rel_enforce_transformp_rule
    meta remove_prop prop domain_rel_enforce_transformp_rule

    (* Rules for abstraction. *)
    function proof_obligations_fn (game_info 'a)
                                  ('ig -> context 'a)
                                  (enforce 'a ('ig,'il) 'o)
                                  (enf_hyp 'a 'ig 'il 'o) : set 'ig
    axiom proof_obligations_fn_rule :
      forall gi gf e xg,eh:enf_hyp 'a 'ig 'il 'o.
        proof_obligations_fn gi gf e eh xg <->
        fz_enforce_match gi.game_strct xg (freeze_context gi (gf xg) xg e) eh
    meta rewrite prop proof_obligations_fn_rule
    meta remove_prop prop proof_obligations_fn_rule

    axiom proof_obligations_rule :
      forall gi igs gf e,eh:enf_hyp 'a 'ig 'il 'o.
      proof_obligations gi igs gf e eh <->
      quant_structure true igs (proof_obligations_fn gi gf e eh)
    meta rewrite prop proof_obligations_rule
    meta remove_prop prop proof_obligations_rule

    axiom abstraction_enforce_transformp_rule :
      forall gi1 gi2 gf ctx q xg xl xs,eh:enf_hyp 'a 'ig 'il 'o.
      (abstraction_enforce gi1 gf eh).transformp gi2 ctx q (xg,xl) xs <->
        gi2.game_order = gi1.game_order /\ gi2.game_valid = gi1.game_valid /\
        sub_context gi2.game_strct (gf xg) ctx /\
        (enf_hyp_fz gi2.game_strct xg eh).fz_transformp q xl xs
    meta rewrite prop abstraction_enforce_transformp_rule
    meta remove_prop prop abstraction_enforce_transformp_rule

    (* Rules for ktrap *)
    axiom empty_post_rule :
      forall xg:'ig,xl:'il,xs:'a,y:'o,ys.
        empty_post xg xl xs y ys <-> false
    meta rewrite prop empty_post_rule
    meta remove_prop prop empty_post_rule

    function kont_pre (q:rel 'o 'a) : 'i -> rel 'o 'a
    axiom kont_pre_rule : forall q,xl:'i,y:'o,ys:'a.
      kont_pre q xl y ys <-> q y ys
    meta rewrite prop kont_pre_rule
    meta remove_prop prop kont_pre_rule

    axiom kontinuation_enforce_transformp_rule :
      forall e:enforce 'a 'i 'o,gi ctx q x xs.
        (kontinuation_enforce e).transformp gi ctx q x xs <->
        let eh = { pre = kont_pre q; post = empty_post;
                   pre_strct = q_def; post_strct = q_unit } in
        let ctx' = ctx_cons (fz_enforce_hyp (enf_hyp_fz q_def x eh)) ctx in
        e.transformp gi ctx' q x xs
    meta rewrite prop kontinuation_enforce_transformp_rule
    meta remove_prop prop kontinuation_enforce_transformp_rule

    (* Rule for context access *)
    axiom ctx_ref_enforce_transformp_rule :
      forall n:int,xg:'ig,gi ctx,q:rel 'o 'a,xl:'il,xs.
        (ctx_ref_enforce n).transformp gi ctx q (xg,xl) xs <->
        0 <= n < ctx_len ctx /\
        (ctx_fz_deref (ctx_nth ctx n)).fz_transformp q xl xs
    meta rewrite prop ctx_ref_enforce_transformp_rule
    meta remove_prop prop ctx_ref_enforce_transformp_rule

    (* Rules for invariant exposure *)
    predicate expose_hyp (hyp 'a) (game 'a)
    predicate expose_context (context 'a) (game 'a)
    axiom expose_inv_rule :
      forall gi gf,eh:enf_hyp 'a 'ig 'il 'o,xg xl xs gm.
        expose_inv gi gf eh ((xg,xl),(xs,gm)) <->
          eh.pre xg xl xs /\ gm.progress = gi.game_order /\ game_wf gm /\
          expose_context (gf xg) gm ->
          enforce ((=) xs) (e_lift (eh.post xg xl xs)) gm
    meta rewrite prop expose_inv_rule
    meta remove_prop prop expose_inv_rule

    axiom expose_context_empty :
      forall gm:game 'a. expose_context ctx_empty gm <-> true
    meta rewrite prop expose_context_empty
    meta remove_prop prop expose_context_empty

    axiom expose_context_add :
      forall h q,gm:game 'a. expose_context (ctx_cons h q) gm <->
        expose_hyp h gm /\ expose_context q gm
    meta rewrite prop expose_context_add
    meta remove_prop prop expose_context_add

    axiom expose_hyp_rule :
      forall qs xg,eh:enf_hyp 'a 'ig 'il 'o,gm.
        expose_hyp (fz_enforce_hyp (enf_hyp_fz qs xg eh)) gm <->
        game_wf gm /\ forall xl xs. eh.pre xg xl xs ->
          enforce ((=) xs) (e_lift (eh.post xg xl xs)) gm
    meta rewrite prop expose_hyp_rule
    meta remove_prop prop expose_hyp_rule

  end

  (* TODO: erase those, they are harnesses. *)

  function h_eh (p:'i -> bool) (q:'i -> 'o -> bool) :
    enf_hyp 'a 'g 'i 'o = {
    pre = \_ x _. p x;
    post = \_ x _ y _. q x y;
    pre_strct = q_def;
    post_strct = q_def;
  }
  meta rewrite_def function h_eh

  function gu : game_info unit = {
    game_order = \_ _. true;
    game_valid = \_. true;
    game_strct = q_unit;
  }
  meta rewrite_def function gu
  function go : erel 'a
  function gv : set 'a
  function gd : game_info 'a = {
    game_order = go;
    game_valid = gv;
    game_strct = q_def;
  }
  meta rewrite_def function gd

  function h_skip : enf_hyp 'a 'g 'i 'o =
    { pre = \_ _ _. true;
      post = \_ _ xs _ ys. xs = ys;
      pre_strct = q_def;
      post_strct = q_def;
    }
  meta rewrite_def function h_skip

  let ghost test (e:enforce unit ('g,'i) 'o)
                 (pc1 pc2:set 'ic) (qc1 qc2:rel 'ic 'oc)
                 (p1 p2:set 'i) (q1 q2:rel 'i 'o) : enforce unit ('g,'i) 'o
    requires { enforce_inv e }
    requires { e -->
      abstraction_enforce gu
      (ctx_add q_unit (h_eh pc1 qc1) ctx_nil)
      (h_eh p1 q1) }
    requires { subset p2 p1 }
    requires { forall x y. p2 x /\ q1 x y -> q2 x y }
    requires { subset pc1 pc2 }
    requires { forall x y. pc1 x /\ qc2 x y -> qc1 x y }
    ensures { enforce_inv result }
    ensures { result -->
      abstraction_enforce gu
      (ctx_add q_unit (h_eh pc2 qc2) ctx_nil)
      (h_eh p2 q2) }
  = let c = ctx_add q_unit (h_eh pc2 qc2) ctx_nil in
    abstraction gu q_def c (h_eh p2 q2) e

  let ghost skip (gi:game_info 'a) : enforce 'a ('g,unit) unit
    requires { gi.game_strct --> q_def }
    ensures { enforce_inv result }
    ensures { result --> abstraction_enforce gi ctx_nil h_skip }
  = abstraction gi q_def ctx_nil h_skip (ktrap (ktrap (ktrap (ctx_ref 2))))

  function eq : erel 'a = (=)
  meta rewrite_def function eq

  function adda (q:rel 'a 'o) : rel 'a ('o,'a) =
    \x y. let (y,z) = y in q x y /\ z = x
  meta rewrite_def function adda

  let ghost rtest (e:enforce 'a ('g,'a) 'o)
                  (ehi:enf_hyp 'a 'g 'i 'o)
                  (eho:enf_hyp 'a 'g ('i,'a) ('o,'a))
                  (p:set 'a) (q:rel 'a 'o)
    : enforce 'a ('g,'a) ('o,'a)
    requires { enforce_inv e }
    requires { ehi.pre_strct --> q_def }
    requires { eho.pre_strct --> q_pair q_def q_def }
    requires { ehi.post_strct --> q_def }
    requires { eho.post_strct --> q_pair q_def q_def }
    requires { e -->
      abstraction_enforce gd (ctx_add q_def ehi ctx_nil) (h_eh p q) }
    ensures { result -->
      abstraction_enforce gd (ctx_add q_def eho ctx_nil)
                             (h_eh p (adda q)) }
    ensures { enforce_inv result }
  = let eany = any enforce 'a (set ('a,'a),('a,'a)) unit
      ensures { enforce_inv result } in
    let er = domain_rel gd eq gd e eany in
    let ctx = ctx_add q_def eho ctx_nil in
    abstraction gd q_def ctx (h_eh p (adda q)) er

end

module WpImpl

  use import WpCommon
  use import int.Int
  use import choice.Choice
  use import list.List
  use import list.Length
  use import ho_set.Set
  use import ho_rel.Rel
  use import ho_rel.Prod
  use import ho_rel.RelSet
  use import order.Ordered
  use import order.Chain
  use import order.ProductChain
  use import fn.Fun
  use import fn.Image
  use import game.Game
  use import game.StratProps
  use import game_fmla.Fmla
  use import game_fmla.FmlaRules
  use import compute_elts.Quant

  (* Context definitions & a few lemmas about it. *)

  (* Context-independent predicate transformers. *)
  type ftransformer 'a 'i 'o = rel 'o 'a -> rel 'i 'a

  (* (flat) Hypothesis are set of pairs (precondition,postcondition)  *)
  type hyp 'a = set (set 'a,set 'a)
  (* Contexts are merely lists, hypothesis being referenced to by nth.
     (this is reminiscent to De Bruijn Indices) *)
  type context 'a = list (hyp 'a)
  (* Fusion of all hypothesis into one. *)
  predicate ctx_union (ctx:context 'a) (h:(set 'a,set 'a)) = match ctx with
    | Nil -> false
    | Cons x q -> x h \/ ctx_union q h
    end
  (* Hypothesis access. *)
  function ctx_nth (ctx:context 'a) (n:int) : hyp 'a = match ctx with
    | Nil -> witness
    | Cons x q -> if n = 0 then x else ctx_nth q (n-1)
    end
  (* Interpretation of a pre/post-condition tandem
     + relation to effective game as a game formula. *)
  function pre_post_fmla (r:rel 'a 'd) (pq:(set 'a,set 'a)) : fmla 'd =
    let (p,q) = pq in enforce (related r p) (related r q)
  (* Transform an hypothesis into a universal formula (quantification
     over all pre/post-condition tandems) *)
  function hyp_fmla (r:rel 'a 'd) (h:hyp 'a) : fmla 'd =
    b_universal h (pre_post_fmla r)
  (* A natural lemma about context update. *)
  lemma ctx_hyp_add_fmla : forall r:rel 'a 'd,h q g.
    game_wf g ->
    (hyp_fmla r h g /\ hyp_fmla r (ctx_union q) g <->
      hyp_fmla r (ctx_union (Cons h q)) g)
  (* Transform a regular backward predicate transformer into an hypothesis. *)
  function transf_hyp (t:ftransformer 'a 'i 'o) : hyp 'a =
    \pr. let (p,q) = pr in exists x q'. q = e_lift q' /\ p = t q' x
  (* Directly transform a structured hypothesis into a flat one.
     Even though we will store all hypothesis in transformer form,
     this temporary form is useful when adding structured ones in context. *)
  function direct_enf_hyp
    (xg:'ig) (eh:enf_hyp 'a 'ig 'il 'o) : hyp 'a =
    \pr. let (p,q) = pr in
      exists xl xs. p = inter (eh.pre xg xl) ((=) xs) /\
                    q = e_lift (eh.post xg xl xs)
  (* Transform a structured hypothesis into a regular backward predicate
     transformer. *)
  function enf_transf (xg:'ig) (eh:enf_hyp 'a 'ig 'il 'o) :
                      ftransformer 'a 'il 'o =
    \q xl xs. eh.pre xg xl xs && forall y ys. eh.post xg xl xs y ys -> q y ys
  function enf_hyp (xg:'ig) (eh:enf_hyp 'a 'ig 'il 'o) : hyp 'a =
    transf_hyp (enf_transf xg eh)
  (* Lemma: both ways of creating a flat hypothesis from a structured
     one are equivalent. *)
  lemma enf_transf_identical :
    forall r:rel 'a 'd,xg,eh:enf_hyp 'a 'ig 'il 'o,g. game_wf g ->
    let hd = direct_enf_hyp xg eh in
    let ht = enf_hyp xg eh in
    (hyp_fmla r hd g -> hyp_fmla r ht g
      by let et = enf_transf xg eh in
        forall p q. ht (p,q) -> pre_post_fmla r (p,q) g
      by let pr = related r p in let qr = related r q in
        holds (hyp_fmla r hd) (enforce pr qr)
      by exists xl q'. q = e_lift q' /\ p = et q' xl
      so forall xd. pr xd -> holds (hyp_fmla r hd) (enforce ((=) xd) qr)
      by exists xs. r xs xd /\ p xs
      so let p0 = inter (eh.pre xg xl) ((=) xs) in
        let q0 = e_lift (eh.post xg xl xs) in
        hd (p0,q0)
      so holds (hyp_fmla r hd) (pre_post_fmla r (p0,q0))
      so subset ((=) xd) (related r p0)
      so subset (related r q0) qr
    ) /\ (hyp_fmla r ht g -> hyp_fmla r hd g
      by let et = enf_transf xg eh in
        forall p q. hd (p,q) -> pre_post_fmla r (p,q) g
      by let pr = related r p in let qr = related r q in
        holds (hyp_fmla r ht) (enforce pr qr)
      by exists xl xs. p = inter (eh.pre xg xl) ((=) xs) /\
                       q = e_lift (eh.post xg xl xs)
      so let p1 = et (eh.post xg xl xs) xl in ht (p1,q)
      so holds (hyp_fmla r ht) (pre_post_fmla r (p1,q))
      so subset pr (related r p1)
    )

  (* Hypothesis access. Must handle the fact that hypothesis may be flat. *)
  predicate hyp_deduce (h:hyp 'a) (x:'a) (q:set 'a) =
    exists p' q'. h (p',q') /\ p' x /\ subset q' q
  function ctx_t_deref (h:hyp 'a) : ftransformer 'a 'i 'o =
    \q _ xs. hyp_deduce h xs (e_lift q)
  function ctx_fz_deref_transformer_prelude (h:hyp 'a) : ftransformer 'a 'i 'o =
    \q x xs. not ctx_t_deref h q x xs

  (* Notions related to pointwise context inclusion *)
  predicate weaker_hypothesis (h1 h2:hyp 'a) =
    forall p q x. h1 (p,q) /\ p x -> hyp_deduce h2 x q
  predicate sub_context (g1 g2:context 'a) = match g1, g2 with
    | Nil, _ -> true
    | _, Nil -> false
    | Cons h1 q1, Cons h2 q2 -> weaker_hypothesis h1 h2 /\ sub_context q1 q2
    end
  lemma weaker_hypothesis_correct : forall r:rel 'a 'd,h1 h2.
    weaker_hypothesis h1 h2 ->
    holds (hyp_fmla r h2) (hyp_fmla r h1)
      by forall pq. h1 pq -> holds (hyp_fmla r h2) (pre_post_fmla r pq)
      by let (p,q) = pq in
        let pr = related r p in
        let qr = related r q in
        forall xd. pr xd -> holds (hyp_fmla r h2) (enforce ((=) xd) qr)
          by exists x. p x /\ r x xd
          so exists p' q'. h2 (p',q') /\ p' x /\ subset q' q
          so holds (hyp_fmla r h2) (pre_post_fmla r (p',q'))
          so subset ((=) xd) (related r p') /\ subset (related r q') qr
  (* if g1 sub g2, then g1 holds under g2. *)
  let rec lemma sub_context_correct (r:rel 'a 'd) (g1 g2:context 'a) : unit
    requires { sub_context g1 g2 }
    ensures { holds (hyp_fmla r (ctx_union g2)) (hyp_fmla r (ctx_union g1)) }
    variant { g1 }
  = match g1, g2 with
    | Nil, _ -> ()
    | _, Nil -> absurd
    | Cons h1 q1, Cons h2 q2 ->
      assert { holds (hyp_fmla r h2) (hyp_fmla r h1) };
      sub_context_correct r q1 q2
    end
  (* Obviously, reflexive. *)
  let rec lemma sub_context_refl (g:context 'a) : unit
    ensures { sub_context g g }
    variant { g }
  = match g with Nil -> () | Cons _ q -> sub_context_refl q end
  (* Useful lemma for actual computation-started resolution:
     a sufficient condition for hypothesis inclusion (which we will
     require in practice) is that one is transformer-based, the other
     is structurally-based, and that they match out *)
  predicate enf_transf_match (xg:'ig) (t:rel 'o 'a -> rel 'il 'a)
                             (eh:enf_hyp 'a 'ig 'il 'o) =
    forall xl xs. eh.pre xg xl xs -> t (eh.post xg xl xs) xl xs
  lemma weaker_hypothesis_sufficient : forall xg h,eh:enf_hyp 'a 'ig 'il 'o.
    let th = ctx_t_deref h in
    enf_transf_match xg th eh ->
    let he = enf_hyp xg eh in
    weaker_hypothesis he h
    by forall p q xs. he (p,q) /\ p xs ->
      let et = enf_transf xg eh in
      exists xl q'. q = e_lift q' /\ p = et q' xl
    so eh.pre xg xl xs
    so let q2 = eh.post xg xl xs in
      let p2 = th q2 xl in
      let q2' = e_lift q2 in
      p2 xs /\ subset q2' q
    so hyp_deduce h xs q2'




  (* transformer definition, invariant, and a domain shift lemma. *)
  type transformer 'a 'i 'o =
    game_info 'a -> context 'a -> ftransformer 'a 'i 'o
  function sing_kont_fmla (x:'d) : fmla 'd = enforce ((=) x) none
  predicate invalid_sup (r:rel 'a 'd) (o1:erel 'a) (o2:erel 'd) (sp:'d) =
    exists ch inh. invalid_sup_witness r o1 o2 sp ch inh
  function vld_fmla (r:rel 'a 'd) (o1:erel 'a) (o2:erel 'd) : fmla 'd =
    b_universal (invalid_sup r o1 o2) sing_kont_fmla
  predicate eqv (s:set 'a) (x y:'a) = x = y /\ s x
  predicate valid_proj (gi:game_info 'a) (r:rel 'a 'd) (o:erel 'd) =
    order gi.game_order /\
    (forall x y. r x y -> gi.game_valid x) /\
    (forall x y u v. r x y /\ r u v /\ o y v -> gi.game_order x u)
  predicate transform_inv (t:transformer 'a 'i 'o) =
    forall gi ctx q x.
      let o = gi.game_order in
      let r = eqv gi.game_valid in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let p2 = related r (t gi ctx q x) in
      let q2 = related r (e_lift q) in
      holds c (enforce p2 q2)

  (* Very important lemma: in the invariant, we fixed the game support type
     to be 'd = 'a, as well as we fixed the order and the relation.
     However, this will still holds for ANY support type 'd and order
     with a validity-compatible relation that maps ordering relation backward.
     This allows to port theorems to different domains.
     Note: monotonicity condition come from the fact that if
       (x -> Q) is in context, what is truly implied is
       (x -> \y. Q y /\ y >= x). However, related (\y. Q y /\ y >= x) is
       a priori not a superset of \y'. related(Q) y' /\ y' >= x'.
       The condition on the ordering relation is the simplest way to guarantee
       this.
     Method:
     1) build a canonical game satisfying the context
     2) Show the relation induce simulation from the canonical game
        to the 'd-one.
     This lemma will be used to switch between game supports. *)

  lemma transform_inv_reinforced : forall t:transformer 'a 'i 'o.
    transform_inv t ->
    forall gi ctx q x rd,od:erel 'd. valid_proj gi rd od ->
      let oe = gi.game_order in
      let c = conj (hyp_fmla rd (ctx_union ctx))
                   (conj (vld_fmla rd oe od) (ordering od)) in
      let p0 = t gi ctx q x in let q0 = e_lift q in
      let pd = related rd p0 in let qd = related rd q0 in
      holds c (enforce pd qd)
      by forall gd. game_wf gd /\ c gd -> have_uniform_winning_strat gd pd qd
      by let re = eqv gi.game_valid in
        let ctx0 = \p q. (exists p0 q0. ctx_union ctx (p0,q0) /\
                          p = related re p0 /\ q = related re q0) \/
                         (exists sp. invalid_sup re oe oe sp /\
                          p = (=) sp /\ q = none)
        in
        let tr = \x s. exists p q. ctx0 p q /\ p x /\ s = inter q (oe x) in
        let ge = { progress = oe; transition = tr } in
        game_wf ge
      (* Preliminary: related by re then rd is equivalent to relate
           directly by rd *)
      so ("stop_split" forall s. related rd (related re s) = related rd s
        by let rds = related rd s in let res = related re s in
          let rdes = related rd res in
          sext rdes rds
        by (forall x. rdes x -> rds x)
        /\ (forall x. rds x -> rdes x
          by exists y. s y /\ rd y x so res y by re y y)
      )
      (* All pre-post implied by the context are validated by ge
         (the canonical game associated to the theorem) *)
      so ("stop_split" forall p q. ctx0 p q -> enforce p q ge
        by forall x. p x -> have_winning_strat ge x q
        by let s = inter q (oe x) in
          subset s q /\ tr x s)
      (* Hence the context is validated by ge, and so the final
         pre/post holds. *)
      so let ce = conj (hyp_fmla re (ctx_union ctx))
                       (conj (vld_fmla re oe oe) (ordering oe))
        in ("stop_split" ce ge
          by hyp_fmla re (ctx_union ctx) ge
          /\ vld_fmla re oe oe ge
          /\ ordering oe ge
      )
      so let pe = related re p0 in let qe = related re q0 in
        (enforce pe qe ge by holds ce (enforce pe qe))
      (* To conclude, it remains only to notice that rd
         induce a step-by-step simulation from ge to gd. *)
      so step_simulate ge rd gd
      by ("stop_split" limit_compatible oe rd gd
        by gd.progress = od
        so forall ch inh sd. chain (rprod oe od) ch /\ ch inh /\
          (forall a b. ch (a,b) -> rd a b) /\ supremum od (image snd ch) sd ->
          (have_winning_strat gd sd none
          \/ exists se. supremum oe (image fst ch) se /\ rd se sd)
        by if invalid_sup rd oe od sd
        then have_winning_strat gd sd none
          by enforce ((=) sd) none gd
        else not invalid_sup_witness rd oe od sd ch inh
          so exists se. supremum oe (image fst ch) se /\ rd se sd
      )
      /\ "stop_split" forall x y s. tr x s /\ rd x y ->
        (* Out of the two transitions possibility, the invalid
           supremum one is unfeasible as this supremum may not be related. *)
        have_winning_strat gd y (related rd s)
        by exists p q. ctx0 p q /\ p x /\ s = inter q (oe x)
        so (false by exists sp. invalid_sup re oe oe sp /\
          p = (=) sp /\ q = none so exists ch inh.
            invalid_sup_witness re oe oe sp ch inh
          so image fst ch = image snd ch
          by sext (image fst ch) (image snd ch)
          by (forall x. image fst ch x <-> ch (x,x))
          /\ (forall x. image snd ch x <-> ch (x,x))
        )
        \/ (exists p0 q0. ctx_union ctx (p0,q0) /\
          p = related re p0 /\ q = related re q0
          so enforce (related rd p0) (related rd q0) gd
          so let cd = subgame gd in
            holds cd (enforce (related rd p0) (related rd q0))
          so let qr = related rd q in
            (holds cd (enforce ((=) y) qr)
            by subset ((=) y) (related rd p0))
          so holds cd (enforce ((=) y) (inter qr (od y)))
          so (holds cd (enforce ((=) y) (related rd s))
            by subset (inter qr (od y)) (related rd s)
          )
          so have_uniform_winning_strat gd ((=) y) (related rd s)
        )

  (* Another useful lemma: the invariant can be mostly reworded using
     hyp_fmla & transformer hypothesis. *)
  function freeze_context_t (gi:game_info 'a) (g:context 'a) (xg:'ig)
                            (t:transformer 'a ('ig,'il) 'o) :
                            ftransformer 'a 'il 'o = \q xl. t gi g q (xg,xl)
  lemma transform_inv_as_hyp_fmla : forall t:transformer 'a ('ig,'il) 'o.
    transform_inv t -> forall gi ctx xg.
      let r = eqv gi.game_valid in
      let o = gi.game_order in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let ft = freeze_context_t gi ctx xg t in
      let ht = transf_hyp ft in
      holds c (hyp_fmla r ht)
      by forall pq. ht pq -> holds c (pre_post_fmla r pq)
      by let (p,q) = pq in
        let p2 = related r p in
        let q2 = related r q in
        holds c (enforce p2 q2)
      by exists xl q'. q = e_lift q' /\ p = ft q' xl
      so p = t gi ctx q' (xg,xl)




  (* First combinator, unusual but absolutely necessary for applications to
     work: domain relation combinator. This is a consequence of the
     'very important lemma'. *)
  function rel_post (r:rel 'a 'd) (q:rel 'o 'a) : rel ('o,'a) 'd =
    \pr xd. let (xo,xa) = pr in r xa xd && q xo xa
  function inv_rel_post (r:rel 'a 'd) (q:rel ('o,'a) 'd) : rel 'o 'a =
    \xo xa. forall xd. r xa xd -> q (xo,xa) xd
  function domain_rel_hyp (r:rel 'a 'd) (h:hyp 'd) : hyp 'a =
    \pqa. let (pa,qa) = pqa in forall x. related r pa x ->
      hyp_deduce h x (related r qa)
  function domain_rel_ctx (r:rel 'a 'd) (ctx:context 'd) : context 'a =
    match ctx with
    | Nil -> Nil
    | Cons h q -> Cons (domain_rel_hyp r h) (domain_rel_ctx r q)
    end
  function domain_rel_transformer
    (gia:game_info 'a) (r:rel 'a 'd) (gid:game_info 'd)
    (ta:transformer 'a ('i,'d) 'o)
    (ti:transformer 'd (set ('a,'d),('a,'d)) 'o_any) :
    transformer 'd ('i,'a) ('o,'a) =
    \gi ctx q x xd.
      gi.game_order = gid.game_order /\ gi.game_valid = gid.game_valid /\
      (forall x y. r x y -> gia.game_valid x /\ gid.game_valid y) /\
      order gia.game_order /\
      (forall x y u v. r x y /\ r u v /\ gid.game_order y v ->
        gia.game_order x u) /\
      (forall ch inh sp.
        invalid_sup_witness r gia.game_order gid.game_order sp ch inh ->
        ti gid ctx (const none) (ch,inh) sp) /\
      let (xi,xa) = x in
      r xa xd /\ ta gia (domain_rel_ctx r ctx) (inv_rel_post r q) (xi,xd) xa

  let rec lemma domain_rel_ctx_ok (r:rel 'a 'd) (s:set 'd)
                                  (ctx:context 'd) : unit
    requires { forall x y. r x y -> s y }
    ensures { holds (hyp_fmla (eqv s) (ctx_union ctx))
                    (hyp_fmla r (ctx_union (domain_rel_ctx r ctx))) }
    variant { ctx }
  = match ctx with
    | Nil -> ()
    | Cons h q ->
        assert { let rs = eqv s in
          let hr = domain_rel_hyp r h in
          let ch = hyp_fmla rs h in
          holds ch (hyp_fmla r hr)
          by forall pqa. hr pqa -> holds ch (pre_post_fmla r pqa)
          by let (pa,qa) = pqa in
            forall x. related r pa x ->
              holds ch (enforce ((=) x) (related r qa))
            by hyp_deduce h x (related r qa)
            so exists pd qd. h (pd,qd) /\ pd x /\ subset qd (related r qa)
          so holds ch (pre_post_fmla rs (pd,qd))
          so subset ((=) x) (related rs pd)
          by related rs pd x by rs x x
        };
        domain_rel_ctx_ok r s q
    end
  (* TODO/FIXME: ugly way around eval_match that inlines fst/snd under
     epsilon... *)
  lemma domain_rel_t : forall gia r gid,ta:transformer 'a ('i,'d) 'o,
                              ti:transformer 'd (set ('a,'d),('a,'d)) 'o_any.
    transform_inv ta /\ transform_inv ti ->
    let res = domain_rel_transformer gia r gid ta ti in
    transform_inv res
    by forall gi ctxd q x.
      let od = gi.game_order in let rd = eqv gi.game_valid in
      let cd = hyp_fmla rd (ctx_union ctxd) in
      let vd = vld_fmla rd od od in
      let ctd = conj cd (conj vd (ordering od)) in
      let p0 = res gi ctxd q x in
      let pd = related rd p0 in
      let qd = related rd (e_lift q) in
      holds ctd (enforce pd qd)
      by forall xd. pd xd -> holds ctd (enforce ((=) xd) qd)
      by od = gid.game_order /\ gi.game_valid = gid.game_valid
      so let (xi,xa) = x in
        let oa = gia.game_order in
        p0 xd
      so valid_proj gia r od
      so let ctxa = domain_rel_ctx r ctxd in
        let ca = hyp_fmla r (ctx_union ctxa) in
        let va = vld_fmla r oa od in
        let cta = conj ca (conj va (ordering od)) in
        let qir = inv_rel_post r q in
        let pa = related r (ta gia ctxa qir (xi,xd)) in
        let qa = related r (e_lift qir) in
        (holds cta (enforce ((=) xd) qd)
         by holds cta (enforce pa qa)
         so (pa xd by r xa xd /\ ta gia ctxa qir (xi,xd) xa)
         so subset qa qd
         by forall yd. qa yd -> qd yd
         by exists ya. e_lift qir ya /\ r ya yd so rd yd yd
         so exists yo. qir yo ya so q (yo,ya) yd
        )
      so holds ctd cta
      by holds cd ca
      /\ (holds ctd va
        by forall g. ctd g /\ game_wf g -> va g
        by forall sp. invalid_sup r oa od sp ->
          let sk = sing_kont_fmla sp in sk g
        by holds ctd sk
        by exists ch inh. invalid_sup_witness r oa od sp ch inh
        so order oa /\ order od
        so let (_,inhd) = inh in
          let ch2 = image snd ch in
          if gid.game_valid sp
          then let q0 = (const none:rel 'o_any 'd) in
            let qr = related rd (e_lift q0) in
            let p0 = ti gid ctxd (const none) (ch,inh) in
            let pr = related rd p0 in
            (pr sp by rd sp sp) /\ sext qr none
            so holds ctd (enforce pr none)
          else holds vd sk
            by let ch0 = \x. let (a,b) = x in a = b /\ ch2 b in
              invalid_sup rd od od sp
            by invalid_sup_witness rd od od sp ch0 (inhd,inhd)
            by (forall x y. ch0 (x,y) -> rd x y
              by x = y so ch2 y so exists x. ch (x,y) so r x y
              so gid.game_valid y)
            so (forall x. image snd ch0 x \/ image fst ch0 x -> ch2 x
              by exists a. ch0 a /\ (snd a = x \/ fst a = x)
              so let (_,b) = a in b = x /\ ch2 b)
            so (forall x. ch2 x -> (image fst ch0 x by fst (x,x) = x)
                                   /\ (image snd ch0 x by snd (x,x) = x))
            so (image fst ch0 = ch2 by sext (image fst ch0) ch2)
            /\ (image snd ch0 = ch2 by sext (image snd ch0) ch2)
            so (chain (rprod od od) ch0 by chain od ch2)
            so supremum od ch2 sp
      )
  let ghost domain_rel_t (gia:game_info 'a) (r:rel 'a 'd) (gid:game_info 'd)
                         (ta:transformer 'a ('i,'d) 'o)
                         (ti:transformer 'd (set ('a,'d),('a,'d)) 'o_any) :
                         transformer 'd ('i,'a) ('o,'a)
    requires { transform_inv ta /\ transform_inv ti }
    ensures { transform_inv result }
    ensures { result = domain_rel_transformer gia r gid ta ti }
  = domain_rel_transformer gia r gid ta ti
  meta remove_prop prop domain_rel_t




  (* Second combinator:
     abstract away internal transformer by a given interface. *)
  function abstraction_transformer (gi:game_info 'a)
                                   (gf:'ig -> context 'a)
                                   (eh:enf_hyp 'a 'ig 'il 'o) :
                                   transformer 'a ('ig,'il) 'o =
    \gi2 ctx q x xs. let (xg,xl) = x in
      gi2.game_order = gi.game_order /\ gi2.game_valid = gi.game_valid /\
      sub_context (gf xg) ctx /\ enf_transf xg eh q xl xs

  (* Alternative (equivalent) invariant for enforcements that have
     an abstraction for transformer. *)
  predicate abstraction_inv (gi:game_info 'a)
                            (gf:'ig -> context 'a)
                            (eh:enf_hyp 'a 'ig 'il 'o) =
    let o = gi.game_order in
    let r = eqv gi.game_valid in
    forall xg xl xs. let ctx = gf xg in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      gi.game_valid xs /\ eh.pre xg xl xs ->
      let qr = related r (e_lift (eh.post xg xl xs)) in
      holds c (enforce ((=) xs) qr)

  lemma transform_inv_implies_abstraction_inv :
    forall gi gf,eh:enf_hyp 'a 'ig 'il 'o.
      let t = abstraction_transformer gi gf eh in
      transform_inv t -> abstraction_inv gi gf eh
      by forall xg xl xs. let ctx = gf xg in
        let r = eqv gi.game_valid in let o = gi.game_order in
        let c = conj (hyp_fmla r (ctx_union ctx))
                     (conj (vld_fmla r o o) (ordering o)) in
        gi.game_valid xs /\ eh.pre xg xl xs ->
        let q = eh.post xg xl xs in
        let qr = related r (e_lift q) in
        holds c (enforce ((=) xs) qr)
      by let p1 = t gi ctx q (xg,xl) in
        let p2 = related r p1 in
        holds c (enforce p2 qr)
      so subset ((=) xs) p2
      by r xs xs /\ p1 xs

  lemma abstraction_inv_implies_transform_inv :
    forall gi gf,eh:enf_hyp 'a 'ig 'il 'o.
      let t = abstraction_transformer gi gf eh in
      abstraction_inv gi gf eh -> transform_inv t
    by forall gi2 ctx q0 x.
        let o = gi2.game_order in let r = eqv gi2.game_valid in
        let c0 = conj (vld_fmla r o o) (ordering o) in
        let cx = hyp_fmla r (ctx_union ctx) in
        let c = conj cx c0 in
        let p2 = related r (t gi2 ctx q0 x) in
        let q2 = related r (e_lift q0) in
        holds c (enforce p2 q2)
      by forall xs. p2 xs -> holds c (enforce ((=) xs) q2)
      by r = eqv gi.game_valid /\ o = gi.game_order
      so let (xg,xl) = x in
        let q = eh.post xg xl xs in
        let qr = related r (e_lift q) in
        t gi2 ctx q0 x xs
      so enf_transf xg eh q0 xl xs
      so (holds c (enforce ((=) xs) qr)
         by let ctx' = gf xg in
           let cx' = hyp_fmla r (ctx_union ctx') in
           let c' = conj cx' c0 in
           holds c c' by holds cx cx')
      so subset qr q2
      by forall ys. qr ys -> q2 ys
      by exists y. q y ys

  predicate proof_obligations_t (gi:game_info 'a)
                                (gf:'ig -> context 'a)
                                (t:transformer 'a ('ig,'il) 'o)
                                (eh:enf_hyp 'a 'ig 'il 'o) =
    forall xg. enf_transf_match xg (freeze_context_t gi (gf xg) xg t) eh

  (* Combinator itself. *)
  let ghost abstraction_t (gi:game_info 'a)
                          (gf:'ig -> context 'a)
                          (eh:enf_hyp 'a 'ig 'il 'o)
                          (t:transformer 'a ('ig,'il) 'o) :
                          transformer 'a ('ig,'il) 'o
    requires { transform_inv t }
    requires { proof_obligations_t gi gf t eh }
    ensures { result = abstraction_transformer gi gf eh }
    ensures { transform_inv result }
  = assert { abstraction_inv gi gf eh
      by forall xg xl xs. let ctx = gf xg in
        let o = gi.game_order in
        let r = eqv gi.game_valid in
        let c = conj (hyp_fmla r (ctx_union ctx))
                     (conj (vld_fmla r o o) (ordering o)) in
        let q0 = e_lift (eh.post xg xl xs) in
        gi.game_valid xs /\ eh.pre xg xl xs ->
        let qr = related r q0 in
        let exs = (=) xs in
        holds c (enforce exs qr)
      by let hd = direct_enf_hyp xg eh in
        let ft = freeze_context_t gi ctx xg t in
        let ht = transf_hyp ft in
        let p0 = inter (eh.pre xg xl) ((=) xs) in
        hd (p0,q0)
      so (subset exs (related r p0) by r xs xs)
      so holds c (enforce (related r p0) qr)
      by holds c (hyp_fmla r hd)
      by holds c (hyp_fmla r ht)
      so holds (hyp_fmla r ht) (hyp_fmla r hd)
      by weaker_hypothesis hd ht
      by forall p q xs. hd (p,q) /\ p xs -> hyp_deduce ht xs q
        by exists xl xs. p = inter (eh.pre xg xl) ((=) xs) /\
                         q = e_lift (eh.post xg xl xs)
        so let p0 = ft (eh.post xg xl xs) xl in ht (p0,q) /\ p0 xs
    };
    abstraction_transformer gi gf eh



  (* TODO: export. *)
  (* Third combinator: if the transformer is in abstraction form,
     and the validity predicate is trivial,
     then one may expose the invariant. *)
  predicate expose_hyp (h:hyp 'a) (gm:game 'a) =
    game_wf gm (* technicality for computation rules to go through. *)
    /\ forall p q. h (p,q) -> enforce p q gm
  predicate expose_context (ctx:context 'a) (gm:game 'a) = match ctx with
    | Nil -> true
    | Cons h q -> expose_hyp h gm /\ expose_context q gm
    end
  let rec lemma trivial_rel_expose_context
    (r:erel 'a) (ctx:context 'a) (gm:game 'a) : unit
    requires { forall x y. r x y <-> x = y }
    requires { expose_context ctx gm }
    ensures { hyp_fmla r (ctx_union ctx) gm }
    variant { ctx }
  = match ctx with
    | Nil -> ()
    | Cons _ q ->
      assert { forall p. let pr = related r p in pr = p by sext pr p
        by forall x. p x -> pr x by r x x };
      trivial_rel_expose_context r q gm
    end
  (* TODO/FIXME: eval_match is really annoying,
     it inlines fst/snd under lambdas. *)
  lemma expose : forall gi gf,eh:enf_hyp 'a 'ig 'il 'o.
    (forall x. gi.game_valid x) /\
    transform_inv (abstraction_transformer gi gf eh) ->
    forall xg xl xs gm. let ctx = gf xg in
      eh.pre xg xl xs /\ gm.progress = gi.game_order /\ game_wf gm /\
      expose_context ctx gm ->
      let q0 = e_lift (eh.post xg xl xs) in
      let exs = ((=) xs) in
      enforce exs q0 gm
    by abstraction_inv gi gf eh
    so let r = eqv gi.game_valid in let o = gi.game_order in
      let cx = hyp_fmla r (ctx_union ctx) in
      let cv = vld_fmla r o o in
      let c = conj cx (conj cv (ordering o)) in
      let qr = related r q0 in
      holds c (enforce exs qr)
    so (c gm by cv gm by forall sp. invalid_sup r o o sp -> false
      by exists ch inh. invalid_sup_witness r o o sp ch inh
      so (sext (image fst ch) (image snd ch)
        by forall x. ((image fst ch x <-> ch (x,x)) /\
                     (image snd ch x <-> ch (x,x))) by r x x /\
                     fst (x,x) = x /\ snd (x,x) = x)
      so r sp sp)
    so enforce exs qr gm
    so (sext qr q0 by forall x. q0 x -> qr x by r x x)

  let ghost expose (gi:game_info 'a)
                   (gf:'ig -> context 'a)
                   (eh:enf_hyp 'a 'ig 'il 'o) : unit
    requires { forall x. gi.game_valid x }
    requires { transform_inv (abstraction_transformer gi gf eh) }
    ensures { forall xg xl xs gm. let ctx = gf xg in
      eh.pre xg xl xs /\ gm.progress = gi.game_order /\ game_wf gm /\
      expose_context ctx gm ->
      enforce ((=) xs) (e_lift (eh.post xg xl xs)) gm }
  = ()
  meta remove_prop prop expose

  (* TODO: rework comments from there. *)



















  (* Second combinator: kontinuation trap. *)
  function empty_post : 'a -> 'b -> 'c -> 'd -> 'e -> bool =
    \_ _ _ _ _. false
  function kontinuation_transformer
    (t:transformer 'a 'i 'o) : transformer 'a 'i 'o =
    \gi ctx q x.
      let eh = { pre = const q; post = empty_post;
                 pre_strct = q_def; post_strct = q_unit } in
      t gi (Cons (enf_hyp x eh) ctx) q x

  let ghost ktrap_t (t:transformer 'a 'i 'o) : transformer 'a 'i 'o
    requires { transform_inv t }
    ensures { result = kontinuation_transformer t }
    ensures { transform_inv result }
  = let res = kontinuation_transformer t in
    assert { forall gi ctx q x.
      let r = eqv gi.game_valid in let o = gi.game_order in
      let cv = conj (vld_fmla r o o) (ordering o) in
      let cx = hyp_fmla r (ctx_union ctx) in
      let c = conj cx cv in
      let p = res gi ctx q x in
      let p2 = related r p in let q2 = related r (e_lift q) in
      holds c (enforce p2 q2)
      by is_fmla c
      so let k = enforce q2 none in
        holds (conj c k) (enforce p2 q2)
      by let cx' = conj cx k in
        let c' = conj cx' cv in
        holds c' (enforce p2 q2)
      by let eh = { pre = const q; post = empty_post;
                    pre_strct = q_def; post_strct = q_unit } in
        let h0 = enf_hyp x eh in
        let ctx' = Cons h0 ctx in
        let cx'' = hyp_fmla r (ctx_union ctx') in
        p = t gi ctx' q x
      so holds cx' cx''
      by holds k (hyp_fmla r h0)
      by let h1 = direct_enf_hyp x eh in
        holds k (hyp_fmla r h1)
      by forall pq. h1 pq -> holds k (pre_post_fmla r pq)
      by let (p',q') = pq in
        exists xl xs. p' = inter (q xl) ((=) xs)
      so let p2' = related r p' in let q2' = related r q' in
        holds k (enforce p2' q2')
      by subset p2' q2 /\ holds k k
    };
    res

  (* Third combinator: context reference. *)
  function ctx_ref_transformer (n:int) : transformer 'a 'i 'o =
    \_ ctx q _ xs. 0 <= n < length ctx /\
      hyp_deduce (ctx_nth ctx n) xs (e_lift q)
  let rec lemma ctx_nth_hyp (r:rel 'a 'd) (ctx:context 'a) (n:int) : unit
    requires { 0 <= n < length ctx }
    ensures { holds (hyp_fmla r (ctx_union ctx)) (hyp_fmla r (ctx_nth ctx n)) }
    variant { ctx }
  = match ctx with
    | Nil -> absurd
    | Cons _ q -> if n > 0 then ctx_nth_hyp r q (n-1)
    end

  let ghost ctx_ref_t (n:int) : transformer 'a 'i 'o
    ensures { result = ctx_ref_transformer n }
    ensures { transform_inv result }
  = let t = ctx_ref_transformer n in
    assert { forall gi ctx q x.
      let o = gi.game_order in
      let r = eqv gi.game_valid in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let p = t gi ctx q x in
      let qe = e_lift q in
      let p2 = related r p in
      let q2 = related r qe in
      holds c (enforce p2 q2)
      by forall xs. p2 xs -> holds c (enforce ((=) xs) q2)
      by let h = ctx_nth ctx n in
        holds c (hyp_fmla r h)
      so exists p' q'. h (p',q') /\ p' xs /\ subset q' qe
      so holds c (enforce (related r p') (related r q'))
      so subset (related r q') q2
    };
    t

  (* Lemmas that allows to unroll hypothesis back to transformers. *)
  lemma hyp_deduce_sufficient :
    forall ft:ftransformer 'a 'il 'o,q xl xs.
      ft q xl xs -> hyp_deduce (transf_hyp ft) xs (e_lift q)
      by transf_hyp ft (ft q xl,e_lift q)

  lemma domain_rel_hyp_sufficient :
    forall r:rel 'a 'd,h xa,q:rel 'o 'a.
      let qr = rel_post r q in
      let eqr = e_lift qr in
      (forall xd. r xa xd -> hyp_deduce h xd eqr) ->
      let hr = domain_rel_hyp r h in
      let eq = e_lift q in
      hyp_deduce hr xa eq
      by let exa = (=) xa in
        hr (exa,eq)
      by forall xd. related r exa xd ->
        hyp_deduce h xd (related r eq)
      by hyp_deduce h xd eqr
      so subset eqr (related r eq)
      by forall yd. eqr yd -> related r eq yd
      by exists oa. qr oa yd so let (_,ya) = oa in r ya yd /\ eq ya

  (* Fourth combinator: sequence. *)
  function seq_transformer (t1:transformer 'a 'i 'm)
                           (t2:transformer 'a ('i,'m) 'o) :
                           transformer 'a 'i 'o =
    \gi ctx q xi. t1 gi ctx (freeze_context_t gi ctx xi t2 q) xi

  let ghost seq_t (t1:transformer 'a 'i 'm)
                  (t2:transformer 'a ('i,'m) 'o) :
                  transformer 'a 'i 'o
    requires { transform_inv t1 /\ transform_inv t2 }
    ensures { transform_inv result }
    ensures { result = seq_transformer t1 t2 }
  = let t = seq_transformer t1 t2 in
    assert { forall gi ctx q xi.
      let o = gi.game_order in let r = eqv gi.game_valid in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let p = t gi ctx q xi in
      let p2 = related r p in let q2 = related r (e_lift q) in
      holds c (enforce p2 q2)
      by let qi = freeze_context_t gi ctx xi t2 q in
        let qi2 = related r (e_lift qi) in
        holds c (enforce p2 qi2)
      so holds c (enforce qi2 q2)
      by forall ys. qi2 ys -> holds c (enforce ((=) ys) q2)
      by exists xm. qi xm ys
      so let pi = t2 gi ctx q (xi,xm) in
        holds c (enforce (related r pi) q2)
    };
    t

  (* Fifth combinator: camera (snapshot initial state in parameters) *)
  function camera_transformer
    (t:transformer 'a ('i,'a) 'o) : transformer 'a 'i 'o =
    \gi ctx q xi xs. t gi ctx q (xi,xs) xs
  let ghost camera_t (t:transformer 'a ('i,'a) 'o) : transformer 'a 'i 'o
    requires { transform_inv t }
    ensures { transform_inv result }
    ensures { result = camera_transformer t }
  = let t2 = camera_transformer t in
    assert { forall gi ctx q xi.
      let o = gi.game_order in let r = eqv gi.game_valid in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let p = t2 gi ctx q xi in
      let p2 = related r p in let q2 = related r (e_lift q) in
      holds c (enforce p2 q2)
      by forall xs. p2 xs -> holds c (enforce ((=) xs) q2)
      by holds c (enforce (related r (t gi ctx q (xi,xs))) q2)
    };
    t2

  (* Sixth (trivial) combinator: parameter management. *)
  function reorder_transformer (f:'i1 -> 'i2)
    (t:transformer 'a 'i2 'o) : transformer 'a 'i1 'o =
    \gi ctx q xi. t gi ctx q (f xi)
  let ghost reorder_t (f:'i1 -> 'i2)
                      (t:transformer 'a 'i2 'o) : transformer 'a 'i1 'o
    requires { transform_inv t }
    ensures { transform_inv result }
    ensures { result = reorder_transformer f t }
  = reorder_transformer f t

  (* Seventh combinator: angelic decision.
     Note that this is a complete rupture with usual wp calculus, as it
     introduce an existential/disjunction in the formula instead
     of the regular conjunction/implications/quantifications. *)
  function ex_transformer (t:transformer 'a ('i,'e) 'o) : transformer 'a 'i 'o =
    \gi ctx q xi xs. exists a. t gi ctx q (xi,a) xs

  let ghost ex_t (t:transformer 'a ('i,'e) 'o) : transformer 'a 'i 'o
    requires { transform_inv t }
    ensures { transform_inv result }
    ensures { result = ex_transformer t }
  = let t2 = ex_transformer t in
    assert { forall gi ctx q xi.
      let o = gi.game_order in let r = eqv gi.game_valid in
      let c = conj (hyp_fmla r (ctx_union ctx))
                   (conj (vld_fmla r o o) (ordering o)) in
      let p = t2 gi ctx q xi in
      let pr = related r p in let qr = related r (e_lift q) in
      holds c (enforce pr qr)
      by forall xs. pr xs -> holds c (enforce ((=) xs) qr)
      by exists a. let p = t gi ctx q (xi,a) in p xs
      so holds c (enforce (related r p) qr)
    };
    t2

  (* Eighth combinator: explicit weakening.
     Mostly intended so that one may write new combinators naturally. *)
  let ghost weaken (t1 t2:transformer 'a 'i 'o) : unit
    requires { transform_inv t2 }
    requires { forall gi ctx q xi xs. t1 gi ctx q xi xs -> t2 gi ctx q xi xs }
    ensures { transform_inv t1 }
  = assert { forall gi ctx q xi c.
      let r = eqv gi.game_valid in
      let p1r = related r (t1 gi ctx q xi) in
      let p2r = related r (t2 gi ctx q xi) in
      let qr = related r (e_lift q) in
      holds c (enforce p2r qr) -> holds c (enforce p1r qr) }








  (* Export zone: define exported types & values.
     TODO(in late future): maybe modify enforce/fz_enforce to allow other
     (equivalent) wp calculus to be used, such as fast-wp ? *)

  (* Expose universal quant_structure definition to considerably
     ease proof of computation rules *)
  let lemma expose_quant_structure_def (s:qstructure 'a) (p:'a -> bool) : unit
    ensures { quant_structure true s p <-> forall y. p y }
  = quant_structure_def p

  (* Proxy type for predicate transformers. *)
  type enforce 'a 'i 'o = {
    transformp : transformer 'a 'i 'o;
  }
  predicate enforce_inv (e:enforce 'a 'i 'o) = transform_inv e.transformp
  (* Proxy type for context-frozen predicate transformers. *)
  type fz_enforce 'a 'i 'o = {
    fz_transformp : ftransformer 'a 'i 'o;
  }
  function fz_enforce_hyp (fze:fz_enforce 'a 'i 'o) : hyp 'a =
    transf_hyp fze.fz_transformp
  function enf_hyp_fz (qstructure 'a) (xg:'ig)
                      (eh:enf_hyp 'a 'ig 'il 'o) : fz_enforce 'a 'il 'o =
    { fz_transformp = enf_transf xg eh }
  function freeze_context (gi:game_info 'a) (ctx:context 'a) (xg:'ig)
                          (e:enforce 'a ('ig,'il) 'o) : fz_enforce 'a 'il 'o =
    { fz_transformp = freeze_context_t gi ctx xg e.transformp }

  function fz_enforce_match_fn (xg:'ig)
                               (ft:ftransformer 'a 'il 'o)
                               (eh:enf_hyp 'a 'ig 'il 'o) : set ('il,'a) =
    \pr. let (xl,xs) = pr in
      eh.pre xg xl xs -> ft (eh.post xg xl xs) xl xs
  predicate fz_enforce_match (qstructure 'a)
                             (xg:'ig)
                             (fze:fz_enforce 'a 'il 'o)
                             (eh:enf_hyp 'a 'ig 'il 'o) =
    enf_transf_match xg fze.fz_transformp eh
  lemma enf_transf_match_other_def :
    forall xg ft,eh:enf_hyp 'a 'ig 'il 'o.
      enf_transf_match xg ft eh <-> forall x. fz_enforce_match_fn xg ft eh x
        by let (xl,xs) = x in eh.pre xg xl xs -> ft (eh.post xg xl xs) xl xs

  function post_inclusion (q1 q2:rel 'o 'a) : set ('o,'a) =
    \yp. let (y,ys) = yp in q1 y ys -> q2 y ys
  lemma enf_transf_other_def : forall xg,eh:enf_hyp 'a 'ig 'il 'o,q xl xs.
    (enf_transf xg eh q xl xs
      by eh.pre xg xl xs /\ forall y ys. eh.post xg xl xs y ys -> q y ys
      by post_inclusion (eh.post xg xl xs) q (y,ys))
    <-> eh.pre xg xl xs /\
      forall y. post_inclusion (eh.post xg xl xs) q y
      by let (y,ys) = y in eh.post xg xl xs y ys -> q y ys

  function set_inclusion (s1 s2:set 'a) : set 'a = \x. s1 x -> s2 x
  lemma inv_rel_post_other_def : forall r,q:rel ('o,'a) 'd,xo xa.
    (inv_rel_post r q xo xa by forall xd. r xa xd -> q (xo,xa) xd
      by set_inclusion (r xa) (q (xo,xa)) xd)
     <-> forall xd. set_inclusion (r xa) (q (xo,xa)) xd

  function ctx_nil : 'ig -> context 'a = \_. Nil
  function ctx_add (qstructure 'a)
                   (eh:enf_hyp 'a 'ig 'il 'o)
                   (ctxf:'ig -> context 'a) : 'ig -> context 'a =
    \xg. Cons (enf_hyp xg eh) (ctxf xg)

  function ctx_fz_deref (h:hyp 'a) : fz_enforce 'a 'i 'o =
    { fz_transformp = ctx_t_deref h }
  predicate sub_context_ex (qstructure 'a) (ctx1 ctx2:context 'a) =
    sub_context ctx1 ctx2
  predicate weaker_hypothesis_ex (qstructure 'a) (h1 h2:hyp 'a) =
    weaker_hypothesis h1 h2
  predicate weaker_hypothesis_prelude (h1 h2:hyp 'a) =
    not weaker_hypothesis h1 h2
  lemma sub_context_nil : forall c:context 'a.
    sub_context Nil c by match c with Nil -> true | _ -> true end

  lemma ctx_fz_deref_rel_sufficient :
    forall r:rel 'a 'd,qd h,q:rel 'o 'a,x:'i,xa.
      let fz = ctx_fz_deref h in
      let ft = fz.fz_transformp (rel_post r q) (x,xa) in
      quant_structure true qd (set_inclusion (r xa) ft) ->
      (ctx_fz_deref (domain_rel_hyp r h)).fz_transformp q x xa
      by forall xd. r xa xd -> hyp_deduce h xd (e_lift (rel_post r q))
      by set_inclusion (r xa) ft xd

  function inv_rel_post_ex
    (_:'an) (r:rel 'a 'd) (q:rel ('o,'a) 'd) : rel 'o 'a =
    inv_rel_post r q

  function domain_rel_hyp_ex (_:'b) (r:rel 'a 'd) (h:hyp 'd) : hyp 'a =
    domain_rel_hyp r h
  function domain_rel_ctx_ex (_:'b) (r:rel 'a 'd)
                             (ctx:context 'd) : context 'a =
    domain_rel_ctx r ctx

  function absurd_post : rel 'a 'b = const none
  function rel_valids (r:rel 'a 'd) (s1:set 'a) (s2:set 'd) : set ('a,'d) =
    \pr. let (x,y) = pr in r x y -> s1 x /\ s2 y
  lemma rel_valids_cond : forall r:rel 'a 'd,qs s1 s2.
    let rv = rel_valids r s1 s2 in
    (quant_structure true qs rv by forall x. rv x by let (_,_) = x in rv x
    ) <-> forall x y. r x y -> s1 x /\ s2 y by rv (x,y)
  function rel_b_mono (r:rel 'a 'd) (o1:erel 'a) (o2:erel 'd) :
                      set (('a,'d),('a,'d)) =
    \qr. let ((x,y),(u,v)) = qr in r x y /\ r u v /\ o2 y v -> o1 x u
  lemma rel_b_mono_cond : forall r:rel 'a 'd,qs o1 o2.
    let rb = rel_b_mono r o1 o2 in
    (quant_structure true qs rb
      by forall x. rb x by let ((_,_),(_,_)) = x in rb x
    ) <-> forall x y u v. r x y /\ r u v /\ o2 y v -> o1 x u by rb ((x,y),(u,v))
  function invalid_sup_to_rel (r:rel 'a 'd) (oa:erel 'a) (od:erel 'd) :
    rel (set ('a,'d),('a,'d)) 'd =
    \pr sp. let (ch,inh) = pr in invalid_sup_witness r oa od sp ch inh
  lemma invalid_sup_to_rel_cond : forall r:rel 'a 'd,qs oa od q.
    let ps = post_inclusion (invalid_sup_to_rel r oa od) q in
    (quant_structure true qs ps by forall x. ps x by let ((_,_),_) = x in ps x
    ) <-> forall ch inh sp. invalid_sup_witness r oa od sp ch inh ->
      q (ch,inh) sp by ps ((ch,inh),sp)

  function domain_rel_enforce
    (gia:game_info 'a) (r:rel 'a 'd) (gid:game_info 'd)
    (ea:enforce 'a ('i,'d) 'o) (ed:enforce 'd  (set ('a,'d),('a,'d)) 'o_any) :
    enforce 'd ('i,'a) ('o,'a) =
    { transformp =
      domain_rel_transformer gia r gid ea.transformp ed.transformp }
  let ghost domain_rel (gia:game_info 'a) (r:rel 'a 'd) (gid:game_info 'd)
                       (ea:enforce 'a ('i,'d) 'o)
                       (ei:enforce 'd (set ('a,'d),('a,'d)) 'o_any) :
                       enforce 'd ('i,'a) ('o,'a)
    requires { enforce_inv ea /\ enforce_inv ei }
    ensures { enforce_inv result }
    ensures { result = domain_rel_enforce gia r gid ea ei }
  = { transformp = domain_rel_t gia r gid ea.transformp ei.transformp }

  function abstraction_enforce (gi:game_info 'a)
                               (gf:'ig -> context 'a)
                               (eh:enf_hyp 'a 'ig 'il 'o) :
                               enforce 'a ('ig,'il) 'o =
  { transformp = abstraction_transformer gi gf eh }

  predicate proof_obligations (gi:game_info 'a)
                              (igs:qstructure 'ig)
                              (gf:'ig -> context 'a)
                              (e:enforce 'a ('ig,'il) 'o)
                              (eh:enf_hyp 'a 'ig 'il 'o) =
    proof_obligations_t gi gf e.transformp eh
  function proof_obligations_fn (gi:game_info 'a)
                                (gf:'ig -> context 'a)
                                (e:enforce 'a ('ig,'il) 'o)
                                (eh:enf_hyp 'a 'ig 'il 'o) : set 'ig =
    \xg. enf_transf_match xg (freeze_context_t gi (gf xg) xg e.transformp) eh

  let ghost abstraction (gi:game_info 'a)
                        (igs:qstructure 'ig)
                        (gf:'ig -> context 'a)
                        (eh:enf_hyp 'a 'ig 'il 'o)
                        (e:enforce 'a ('ig,'il) 'o) :
                        enforce 'a ('ig,'il) 'o
    requires { enforce_inv e }
    requires { proof_obligations gi igs gf e eh }
    ensures { enforce_inv result }
    ensures { result = abstraction_enforce gi gf eh }
  = { transformp = abstraction_t gi gf eh e.transformp }

  function expose_inv (gi:game_info 'a)
                      (gf:'ig -> context 'a)
                      (eh:enf_hyp 'a 'ig 'il 'o) :
                      set (('ig,'il),('a,game 'a)) =
    \x. let ((xg,xl),(xs,gm)) = x in
        eh.pre xg xl xs /\ gm.progress = gi.game_order /\ game_wf gm /\
          expose_context (gf xg) gm ->
          enforce ((=) xs) (e_lift (eh.post xg xl xs)) gm

  let ghost expose_ex (gi:game_info 'a)
                      (igs:qstructure 'ig)
                      (gf:'ig -> context 'a)
                      (eh:enf_hyp 'a 'ig 'il 'o) : unit
    requires { quant_structure true gi.game_strct gi.game_valid }
    requires { enforce_inv (abstraction_enforce gi gf eh) }
    ensures { forall qs. quant_structure true qs (expose_inv gi gf eh) }
  = expose gi gf eh;
    assert { forall x. expose_inv gi gf eh x by
      let ((_,_),(_,_)) = x in expose_inv gi gf eh x }

  lemma expose_hyp_rule_1 : forall qs xg,eh:enf_hyp 'a 'ig 'il 'o,gm.
    let h = fz_enforce_hyp (enf_hyp_fz qs xg eh) in
    expose_hyp (fz_enforce_hyp (enf_hyp_fz qs xg eh)) gm ->
    game_wf gm && forall xl xs. eh.pre xg xl xs ->
      let q = eh.post xg xl xs in
      let q' = e_lift q in
      enforce ((=) xs) q' gm
      by let t = enf_transf xg eh in
        let p = t q xl in let c = (=) gm in
        h (p,q')
      so enforce p q' gm so holds c (enforce p q')
      so subset ((=) xs) p
      so holds c (enforce ((=) xs) q') /\ c gm
  lemma expose_hyp_rule_2 : forall qs xg,eh:enf_hyp 'a 'ig 'il 'o,gm.
    game_wf gm /\ (forall xl xs. eh.pre xg xl xs ->
      enforce ((=) xs) (e_lift (eh.post xg xl xs)) gm) ->
     let h = fz_enforce_hyp (enf_hyp_fz qs xg eh) in
     expose_hyp h gm
     by let t = enf_transf xg eh in
       forall p q. h (p,q) -> enforce p q gm
     by exists xl q'. q = e_lift q' /\ p = t q' xl
     so let c = (=) gm in holds c (enforce p q) /\ c gm
     by forall xs. p xs -> holds c (enforce ((=) xs) q)
     by let q0 = eh.post xg xl xs in let q1 = e_lift q0 in
       holds c (enforce ((=) xs) q1) /\ subset q1 q

  function kontinuation_enforce (e:enforce 'a 'i 'o) : enforce 'a 'i 'o =
    { transformp = kontinuation_transformer e.transformp }

  let ghost ktrap (e:enforce 'a 'i 'o) : enforce 'a 'i 'o
    requires { enforce_inv e }
    ensures { enforce_inv result }
    ensures { result = kontinuation_enforce e }
  = { transformp = ktrap_t e.transformp }

  function ctx_ref_enforce (n:int) : enforce 'a 'i 'o =
    { transformp = ctx_ref_transformer n }
  let ghost ctx_ref (n:int) : enforce 'a 'i 'o
    ensures { result = ctx_ref_enforce n }
    ensures { enforce_inv result }
  = { transformp = ctx_ref_t n }




  clone WpCore with type context = context,
    type enforce = enforce,
    function transformp = transformp,
    predicate enforce_inv = enforce_inv,
    function ctx_nil = ctx_nil,
    function ctx_add = ctx_add,
    function empty_post = empty_post,
    function domain_rel_enforce = domain_rel_enforce,
    val domain_rel = domain_rel,
    function abstraction_enforce = abstraction_enforce,
    predicate proof_obligations = proof_obligations,
    val abstraction = abstraction,
    function expose_inv = expose_inv,
    val expose = expose_ex,
    function kontinuation_enforce = kontinuation_enforce,
    val ktrap = ktrap,
    function ctx_ref_enforce = ctx_ref_enforce,
    val ctx_ref = ctx_ref,

    type LOCAL.hyp = hyp,
    type LOCAL.fz_enforce = fz_enforce,
    function LOCAL.fz_transformp = fz_transformp,
    function LOCAL.fz_enforce_hyp = fz_enforce_hyp,
    function LOCAL.domain_rel_hyp = domain_rel_hyp_ex,
    function LOCAL.enf_hyp_fz = enf_hyp_fz,
    function LOCAL.freeze_context = freeze_context,
    function LOCAL.post_inclusion = post_inclusion,
    function LOCAL.set_inclusion = set_inclusion,
    function LOCAL.rel_post = rel_post,
    goal LOCAL.enf_hyp_fz_rule,
    goal LOCAL.freeze_context_transformp_rule,
    goal LOCAL.post_inclusion_rule,
    goal LOCAL.set_inclusion_rule,
    goal LOCAL.rel_post_rule,

    function LOCAL.fz_enforce_match_fn = fz_enforce_match_fn,
    goal LOCAL.fz_enforce_match_fn_rule,
    predicate LOCAL.fz_enforce_match = fz_enforce_match,
    goal LOCAL.fz_enforce_match_rule,

    function LOCAL.ctx_empty = Nil,
    function LOCAL.ctx_cons = Cons,
    function LOCAL.ctx_nth = ctx_nth,
    function LOCAL.ctx_len = length,
    goal LOCAL.ctx_nth_rule,
    goal LOCAL.ctx_len_cons,
    goal LOCAL.ctx_len_empty,
    goal LOCAL.ctx_nil_apply,
    goal LOCAL.ctx_add_apply,

    function LOCAL.ctx_fz_deref = ctx_fz_deref,
    function LOCAL.ctx_fz_deref_transformer_prelude =
      ctx_fz_deref_transformer_prelude,
    goal LOCAL.ctx_fz_deref_fz_transformp_rule,
    goal LOCAL.ctx_fz_deref_rel_transformp_rule,

    predicate LOCAL.sub_context = sub_context_ex,
    predicate LOCAL.weaker_hypothesis = weaker_hypothesis_ex,
    predicate LOCAL.weaker_hypothesis_prelude = weaker_hypothesis_prelude,
    goal LOCAL.sub_context_empty,
    goal LOCAL.sub_context_add,
    goal LOCAL.sub_context_refl,
    goal LOCAL.weaker_hypothesis_rule,
    goal LOCAL.weaker_hypothesis_refl,

    function LOCAL.inv_rel_post = inv_rel_post_ex,
    goal LOCAL.inv_rel_post_rule,
    function LOCAL.absurd_post = absurd_post,
    goal LOCAL.absurd_post_rule,
    function LOCAL.domain_rel_ctx = domain_rel_ctx_ex,
    goal LOCAL.domain_rel_ctx_empty_rule,
    goal LOCAL.domain_rel_ctx_cons_rule,
    function LOCAL.rel_valids = rel_valids,
    goal LOCAL.rel_valids_rule,
    function LOCAL.rel_b_mono = rel_b_mono,
    goal LOCAL.rel_b_mono_rule,
    function LOCAL.invalid_sup_to_rel = invalid_sup_to_rel,
    goal LOCAL.invalid_sup_to_rel_rule,
    goal LOCAL.domain_rel_enforce_transformp_rule,

    function LOCAL.proof_obligations_fn = proof_obligations_fn,
    goal LOCAL.proof_obligations_fn_rule,
    goal LOCAL.proof_obligations_rule,
    goal LOCAL.abstraction_enforce_transformp_rule,
    goal LOCAL.empty_post_rule,
    function LOCAL.kont_pre = const,
    goal LOCAL.kont_pre_rule,
    goal LOCAL.kontinuation_enforce_transformp_rule,

    goal LOCAL.ctx_ref_enforce_transformp_rule,

    predicate LOCAL.expose_context = expose_context,
    predicate LOCAL.expose_hyp = expose_hyp,
    goal LOCAL.expose_inv_rule,
    goal LOCAL.expose_context_empty,
    goal LOCAL.expose_context_add,
    goal LOCAL.expose_hyp_rule

end

