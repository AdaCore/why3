(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require list.List.
Require list.Length.
Require list.Mem.
Require list.Append.
Require list.NumOcc.
Require list.Permut.

(* Why3 assumption *)
Definition unit := unit.

Axiom qtmark : Type.
Parameter qtmark_WhyType : WhyType qtmark.
Existing Instance qtmark_WhyType.

(* Why3 assumption *)
Inductive sorted: (list Z) -> Prop :=
  | Sorted_Nil : (sorted Init.Datatypes.nil)
  | Sorted_One : forall (x:Z), (sorted
      (Init.Datatypes.cons x Init.Datatypes.nil))
  | Sorted_Two : forall (x:Z) (y:Z) (l:(list Z)), (x <= y)%Z -> ((sorted
      (Init.Datatypes.cons y l)) -> (sorted
      (Init.Datatypes.cons x (Init.Datatypes.cons y l)))).

Axiom sorted_mem : forall (x:Z) (l:(list Z)), ((forall (y:Z), (list.Mem.mem y
  l) -> (x <= y)%Z) /\ (sorted l)) <-> (sorted (Init.Datatypes.cons x l)).

Import Permut.

(* Why3 goal *)
Theorem WP_parameter_mergesort : forall (l:(list Z)),
  match l with
  | (Init.Datatypes.nil|(Init.Datatypes.cons _ Init.Datatypes.nil)) => True
  | _ => (2%Z <= (list.Length.length l))%Z -> forall (result:(list Z))
      (result1:(list Z)), ((1%Z <= (list.Length.length result))%Z /\
      ((1%Z <= (list.Length.length result1))%Z /\ (list.Permut.permut l
      (Init.Datatypes.app result result1)))) -> forall (o:(list Z)), ((sorted
      o) /\ (list.Permut.permut o result1)) -> forall (o1:(list Z)), ((sorted
      o1) /\ (list.Permut.permut o1 result)) -> (((sorted o1) /\ (sorted
      o)) -> forall (result2:(list Z)), ((sorted result2) /\
      (list.Permut.permut result2 (Init.Datatypes.app o1 o))) ->
      (list.Permut.permut result2 l))
  end.
(* Why3 intros l. *)
Proof.
destruct l; try trivial.
destruct l; try trivial.
intuition.
apply Permut_trans with (app o1 o); auto.
apply Permut_trans with (app result result1); auto.
apply Permut_append; auto.
apply Permut_sym; auto.
Qed.

