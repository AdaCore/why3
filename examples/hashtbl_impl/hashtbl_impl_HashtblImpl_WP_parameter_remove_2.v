(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require map.Const.
Require list.List.
Require list.Mem.
Require option.Option.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType : forall (a:Type) {a_WT:WhyType a},
  WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, (array a) -> (Z -> a).

Parameter length: forall {a:Type} {a_WT:WhyType a}, (array a) -> Z.

Axiom array'invariant : forall {a:Type} {a_WT:WhyType a}, forall (self:(array
  a)), (0%Z <= (length self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z): a :=
  ((elts a1) i).

Parameter mixfix_lblsmnrb: forall {a:Type} {a_WT:WhyType a}, (array a) ->
  Z -> a -> (array a).

Axiom mixfix_lblsmnrb_spec : forall {a:Type} {a_WT:WhyType a},
  forall (a1:(array a)) (i:Z) (v:a), ((length (mixfix_lblsmnrb a1 i
  v)) = (length a1)) /\ ((elts (mixfix_lblsmnrb a1 i
  v)) = (map.Map.set (elts a1) i v)).

Axiom key : Type.
Parameter key_WhyType : WhyType key.
Existing Instance key_WhyType.

Parameter hash: key -> Z.

Axiom hash_spec : forall (us:key), (0%Z <= (hash us))%Z.

Parameter bucket: key -> Z -> Z.

Axiom bucket_def : forall (k:key) (n:Z), (0%Z < n)%Z -> ((bucket k
  n) = (ZArith.BinInt.Z.rem (hash k) n)).

Axiom bucket_spec : forall (k:key) (n:Z), (0%Z < n)%Z -> ((0%Z <= (bucket k
  n))%Z /\ ((bucket k n) < n)%Z).

Axiom bucket_bounds : forall (n:Z), (0%Z < n)%Z -> forall (k:key),
  (0%Z <= (bucket k n))%Z /\ ((bucket k n) < n)%Z.

(* Why3 assumption *)
Definition in_data {a:Type} {a_WT:WhyType a} (k:key) (v:a) (d:(array
  (list (key* a)%type))): Prop := (list.Mem.mem (k, v) (mixfix_lbrb d
  (bucket k (length d)))).

(* Why3 assumption *)
Definition good_data {a:Type} {a_WT:WhyType a} (k:key) (v:a) (m:(key ->
  (option a))) (d:(array (list (key* a)%type))): Prop := ((m
  k) = (Init.Datatypes.Some v)) <-> (in_data k v d).

(* Why3 assumption *)
Definition good_hash {a:Type} {a_WT:WhyType a} (d:(array (list (key*
  a)%type))) (i:Z): Prop := forall (k:key) (v:a), (list.Mem.mem (k, v)
  (mixfix_lbrb d i)) -> ((bucket k (length d)) = i).

Axiom t : forall (a:Type), Type.
Parameter t_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t a).
Existing Instance t_WhyType.

Parameter size: forall {a:Type} {a_WT:WhyType a}, (t a) -> Z.

Parameter data: forall {a:Type} {a_WT:WhyType a}, (t a) -> (array (list (key*
  a)%type)).

Parameter view: forall {a:Type} {a_WT:WhyType a}, (t a) -> (key ->
  (option a)).

Axiom t'invariant : forall {a:Type} {a_WT:WhyType a}, forall (self:(t a)),
  (0%Z < (length (data self)))%Z /\ ((forall (i:Z), ((0%Z <= i)%Z /\
  (i < (length (data self)))%Z) -> (good_hash (data self) i)) /\
  forall (k:key) (v:a), (good_data k v (view self) (data self))).

(* Why3 goal *)
Theorem VC_remove : forall {a:Type} {a_WT:WhyType a}, forall (h:(t a))
  (h_view:(key -> (option a))) (h_data:(array (list (key* a)%type)))
  (h_size:Z) (k:key), ((h_view = (view h)) /\ ((h_data = (data h)) /\
  (h_size = (size h)))) -> let o := (length (data h)) in let i := (bucket k
  o) in (((0%Z <= i)%Z /\ (i < o)%Z) -> let l := (mixfix_lbrb (data h) i) in
  forall (o1:(option a)),
  match o1 with
  | Init.Datatypes.None => forall (v:a), ~ (list.Mem.mem (k, v) l)
  | (Init.Datatypes.Some v) => (list.Mem.mem (k, v) l)
  end -> ((o1 = Init.Datatypes.None) -> (((view h)
  k) = Init.Datatypes.None))).
(* Why3 intros a a_WT h h_view h_data h_size k (h1,(h2,h3)) o i (h4,h5) l o1
        h6 h7. *)
Proof.
intros a a_WT h h_view h_data h_size k (h1,(h2,h3)) o i (h4,h5) l o1 h6 h7.
subst i.
rewrite h7 in h6.
subst l.
destruct (t'invariant h) as [_ [_ h8]].
unfold good_data in h8.
specialize (h8 k).
destruct (view h k); intuition.
elim (h6 a0).
now apply h8.
Qed.

