
(* Simple priority queue implementation
   (inspired by Tinelli's lecture http://www.divms.uiowa.edu/~tinelli/181/) *)

module SimplePrioriyQueue

  use import int.Int
  use import ref.Ref
  use import array.Array

  type elt
  function priority elt : int

  type t = {
    elems: array elt;
    mutable size : int; (* size elements, stored in elems[0..size[ *)
    mutable h    : int; (* index of the highest prioiry element, if any *)
  }
  invariant { 0 <= self.size <= self.elems.length }
  invariant { self.size = 0 \/ 0 <= self.h < self.size }

  let create (n: int) (dummy: elt) : t
    requires { 0 <= n }
    ensures  {result. size = 0 }
  = { elems = Array.make n dummy; size = 0; h = 0; }

  predicate is_empty (q: t) = q.size = 0

  predicate is_full (q: t) = q.size = length q.elems

  let add (q: t) (x: elt) : unit
    requires { not (is_full q) }
    writes   { q.elems.elts, q.h, q.size }
  = q.elems[q.size] <- x;
    if q.size = 0 then
      q.h <- 0
    else if priority x > priority q.elems[q.h] then
      q.h <- q.size;
    q.size <- q.size + 1

  let highest (q: t) : elt
    requires { not (is_empty q) }
  = q.elems[q.h]

  let remove (q: t) : elt
    requires { not (is_empty q) }
  = q.size <- q.size - 1;
    let r = q.elems[q.h] in
    q.elems[q.h] <- q.elems[q.size];
    if q.size > 0 then begin
      let m = ref (priority q.elems[0]) in
      q.h <- 0;
      for i = 1 to q.size - 1 do
        invariant { 0 <= q.h < q.size }
        let p = priority q.elems[i] in
        if p > !m then begin q.h <- i; m := p end
      done
    end;
    r

end

