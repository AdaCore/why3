(* Euler Project, problem 2

Each new term in the Fibonacci sequence is generated by adding the
previous two terms. By starting with 1 and 2, the first 10 terms will
be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms. *)

theory Fib "Definition of Fibonacci sequence"

  use import int.Int

  function fib int : int

  axiom fib0: fib 0 = 1

  axiom fib1: fib 1 = 2

  axiom fibn: forall n:int [fib n].
     n >= 2 -> fib n = fib (n-1) + fib (n-2)

end

theory FibSumEven "sum of even-valued Fibonacci numbers"

  use import int.Int
  use import Fib
  use import int.ComputerDivision

  (* [fib_sum_even m n] is the sum of even-valued terms of the
      Fibonacci sequence from index 0 to n-1, that do not exceed m *)
  function fib_sum_even int int : int

  axiom SumZero: forall m:int. fib_sum_even m 0 = 0

  axiom SumEvenLe: forall n m:int.
     n >= 0 /\ (fib n) <= m /\ mod (fib n) 2 = 0 ->
       fib_sum_even m (n+1) = fib_sum_even m n + fib n

  axiom SumEvenGt: forall n m:int.
     n >= 0 /\ (fib n) > m /\ mod (fib n) 2 = 0 ->
       fib_sum_even m (n+1) = fib_sum_even m n

  axiom SumOdd: forall n m:int.
     n >= 0 /\ mod (fib n) 2 <> 0 ->
       fib_sum_even m (n+1) = fib_sum_even m n

  predicate is_fib_sum_even (m:int) (sum:int) = 
    exists n:int. 
      sum = fib_sum_even m n /\ fib n > m
   (* Note: we take for granted that [fib] is an
        increasing sequence *)

end

(*
theory FibSumEven "sum of even-valued Fibonacci numbers"

  use import int.Int
  use import Fib
  use import int.ComputerDivision

  (* [fib_sum_even_lt m] is the sum of even-valued terms
      of the Fibonacci sequence that are less than m

     [fib_sum_even_lt_from m n] is the sum of even-valued terms
      of the Fibonacci sequence that are less than m, starting from n


  *)

  function fib_sum_even_lt_from int int : int

  axiom SumTooLarge: forall m n:int.
     n >= 0 -> (fib n) >= m -> fib_sum_even_lt_from m n = 0
     (* Note: we take for granted that [fib] is an
        increasing sequence *)

  axiom SumYes: forall n m:int.
     n >= 0 -> (fib n) < m -> mod (fib n) 2 = 0 ->
       fib_sum_even_lt_from m n = fib_sum_even_lt_from m (n+1) + (fib n)

  axiom SumOdd: forall n m:int.
     n >= 0 -> mod (fib n) 2 <> 0 ->
       fib_sum_even_lt_from m n = fib_sum_even_lt_from m (n+1)

  function fib_sum_even_lt (m:int) : int = fib_sum_even_lt_from m 0

end
*)
theory FibOnlyEven

  use import int.Int
  use import int.ComputerDivision
  use import Fib

  lemma fib_even : forall n:int. n >= 0 ->
      (mod (fib n) 2 = 0 <-> mod n 3 = 1)

  (* we pose xn = f(3n+1), that is
     x_0 = 2, x_1 = 8, x_{n+2} = 4 x_{n+1} + x_n
  *)

  function fib_even int : int

  axiom fib_even0: fib_even 0 = 2
  axiom fib_even1: fib_even 1 = 8
  axiom fib_evenn: forall n:int [fib_even n].
     n >= 2 -> fib_even n = 4 * fib_even (n-1) + fib_even (n-2)

  lemma fib_even_correct :
     forall n:int. n >= 0 -> fib_even n = fib (3*n+1)

end

module Solve

  use import int.Int
  use import ref.Ref
  use import Fib
  use import FibSumEven
  use import FibOnlyEven

  let f m : int
    requires { m >= 0 }
    ensures  { is_fib_sum_even m result }
  = let x = ref 2 in
    let y = ref 8 in
    let sum = ref 0 in
    let ghost n = ref 0 in
    let ghost k = ref 1 in
    assert { !k = 0 + 1 };
    while !x <= m do
      invariant { !n >= 0 }
      invariant { !k >= 1 }
      invariant { !x = fib_even !n }
      invariant { !x = fib !k }
      invariant { !y = fib_even (!n+1) }
      invariant { !y = fib (!k+3) }
      invariant { !sum = fib_sum_even m !k }
      let tmp = !x in
      x := !y;
      y := 4 * !y + tmp;
      sum := !sum + tmp;
      n := !n + 1;
      k := !k + 3
    done;
    !sum

  let run () = f 4000000 (* should be 4613732 *)

end
