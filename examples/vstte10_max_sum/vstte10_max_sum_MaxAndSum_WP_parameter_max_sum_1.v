(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require map.Map.

(* Why3 assumption *)
Definition unit := unit.

(* Why3 assumption *)
Inductive ref (a:Type) {a_WT:WhyType a} :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Implicit Arguments mk_ref [[a] [a_WT]].

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:(ref a)): a :=
  match v with
  | (mk_ref x) => x
  end.

(* Why3 assumption *)
Inductive array
  (a:Type) {a_WT:WhyType a} :=
  | mk_array : Z -> (map.Map.map Z a) -> array a.
Axiom array_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.
Implicit Arguments mk_array [[a] [a_WT]].

(* Why3 assumption *)
Definition elts {a:Type} {a_WT:WhyType a} (v:(array a)): (map.Map.map Z a) :=
  match v with
  | (mk_array x x1) => x1
  end.

(* Why3 assumption *)
Definition length {a:Type} {a_WT:WhyType a} (v:(array a)): Z :=
  match v with
  | (mk_array x x1) => x
  end.

(* Why3 assumption *)
Definition get {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z): a :=
  (map.Map.get (elts a1) i).

(* Why3 assumption *)
Definition set {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z) (v:a): (array
  a) := (mk_array (length a1) (map.Map.set (elts a1) i v)).

(* Why3 assumption *)
Definition make {a:Type} {a_WT:WhyType a} (n:Z) (v:a): (array a) :=
  (mk_array n (map.Map.const v:(map.Map.map Z a))).


(* Why3 goal *)
Theorem WP_parameter_max_sum : forall (a:Z) (n:Z), forall (a1:(map.Map.map Z
  Z)), ((0%Z <= a)%Z /\ ((n = a) /\ forall (i:Z), ((0%Z <= i)%Z /\
  (i < n)%Z) -> (0%Z <= (map.Map.get a1 i))%Z)) -> let o := (n - 1%Z)%Z in
  ((0%Z <= o)%Z -> forall (max:Z) (sum:Z), forall (i:Z), ((0%Z <= i)%Z /\
  (i <= o)%Z) -> ((sum <= (i * max)%Z)%Z -> (((0%Z <= i)%Z /\ (i < a)%Z) ->
  ((max < (map.Map.get a1 i))%Z -> (((0%Z <= i)%Z /\ (i < a)%Z) ->
  forall (max1:Z), (max1 = (map.Map.get a1 i)) -> (((0%Z <= i)%Z /\
  (i < a)%Z) -> forall (sum1:Z), (sum1 = (sum + (map.Map.get a1 i))%Z) ->
  (sum1 <= ((i + 1%Z)%Z * max1)%Z)%Z)))))).
intros a n a1 (h1,(h2,h3)) o h4 max sum i (h5,h6) h7 (h8,h9) h10
        (h11,h12) max1 h13 (h14,h15) sum1 h16.
subst o.
ring_simplify.
subst.
apply Zplus_le_compat_r.
apply Zle_trans with (i * max)%Z; auto.
auto with *.
Qed.


