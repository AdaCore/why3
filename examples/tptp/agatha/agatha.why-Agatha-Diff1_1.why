(* this is a prelude for Alt-Ergo*)
type person

logic Agatha : person


logic Butler : person


logic Charles : person


logic match_person : person, 'a, 'a, 'a -> 'a


axiom match_person_Agatha :
  (forall z:'a. forall z1:'a. forall z2:'a [match_person(Agatha, z, z1, z2)].
  (match_person(Agatha, z, z1, z2) = z))


axiom match_person_Butler :
  (forall z:'a. forall z1:'a. forall z2:'a [match_person(Butler, z, z1, z2)].
  (match_person(Butler, z, z1, z2) = z1))


axiom match_person_Charles :
  (forall z:'a. forall z1:'a. forall z2:'a [match_person(Charles, z, z1,
  z2)]. (match_person(Charles, z, z1, z2) = z2))


axiom person_inversion :
  (forall u:person. forall z:'a. forall z1:'a. forall z2:'a [match_person(u,
  z2, z1, z)]. (((u = Agatha) or (u = Butler)) or (u = Charles)))


logic hates : person, person -> prop


logic richer : person, person -> prop


logic lives : person -> prop


logic killed : person, person -> prop


axiom Lives1 : lives(Agatha)


axiom Lives2 : lives(Charles)


axiom Lives3 : lives(Butler)


axiom NoOneLivesForever :
  (forall x:person. (lives(x) -> ((x = Agatha) or ((x = Charles) or
  (x = Butler)))))


axiom MURDER : (exists x:person. (lives(x) and killed(x, Agatha)))


axiom Hate_and_killed :
  (forall p1:person. forall p2:person. (killed(p1, p2) -> hates(p1, p2)))


axiom Killed_and_wealth :
  (forall p1:person. forall p2:person. (killed(p1, p2) -> (not richer(p1,
  p2))))


goal Diff1 : (not (Agatha = Butler))
