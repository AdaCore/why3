;; produced by cvc4_15.drv ;;
(set-logic AUFBVDTNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

;; "sort"
(declare-fun sort (ty
  uni) Bool)

;; "witness"
(declare-fun witness (ty) uni)

;; "witness_sort"
(assert (forall ((a ty)) (sort a (witness a))))

;; "int"
(declare-fun int () ty)

;; "real"
(declare-fun real () ty)

;; "string"
(declare-fun string () ty)

;; "bool"
(declare-fun bool () ty)

(declare-sort tuple0 0)

;; "tuple0"
(declare-fun tuple01 () ty)

;; "ref"
(declare-fun ref (ty) ty)

;; "t"
(declare-fun t () ty)

;; "infix ->"
(declare-fun infix_mngt (ty
  ty) ty)

;; "Tuple0"
(declare-fun Tuple0 () tuple0)

;; "tuple0_inversion"
(assert (forall ((u tuple0)) (= u Tuple0)))

;; "CompatOrderMult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; "ref'mk"
(declare-fun refqtmk (ty
  uni) uni)

;; "ref'mk_sort"
(assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (refqtmk a x)))))

;; "contents"
(declare-fun contents (ty
  uni) uni)

;; "contents_sort"
(assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; "contents'def"
(assert
  (forall ((a ty))
    (forall ((u uni)) (=> (sort a u) (= (contents a (refqtmk a u)) u)))))

;; "ref_inversion"
(assert
  (forall ((a ty))
    (forall ((u uni)) (=> (sort (ref a) u) (= u (refqtmk a (contents a u)))))))

;; "t'eq"
(declare-fun tqteq ((_ BitVec 64)
  (_ BitVec 64)) Bool)

;; "t'eq'def"
(assert
  (forall ((a (_ BitVec 64)) (b (_ BitVec 64)))
    (= (tqteq a b) (= (bv2nat a) (bv2nat b)))))

;; "t'inj"
(assert
  (forall ((a (_ BitVec 64)) (b (_ BitVec 64))) (=> (tqteq a b) (= a b))))

;; "nth"
(declare-fun nth ((_ BitVec 64)
  Int) Bool)

;; "lsr"
(declare-fun lsr ((_ BitVec 64)
  Int) (_ BitVec 64))

;; "asr"
(declare-fun asr ((_ BitVec 64)
  Int) (_ BitVec 64))

;; "lsl"
(declare-fun lsl ((_ BitVec 64)
  Int) (_ BitVec 64))

;; "abs"
(declare-fun abs1 (Int) Int)

;; "abs'def"
(assert (forall ((x Int)) (ite (<= 0 x) (= (abs1 x) x) (= (abs1 x) (- x)))))

;; "Abs_le"
(assert
  (forall ((x Int) (y Int)) (= (<= (abs1 x) y) (and (<= (- y) x) (<= x y)))))

;; "Abs_pos"
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; "Div_unique"
(assert
  (forall ((x Int) (y Int) (q Int))
    (=>
      (< 0 y)
      (=> (and (<= (* q y) x) (< x (+ (* q y) y))) (= (div x y) q)))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (div x y)) (<= (div x y) x)))))

;; "Div_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div x y) 0))))

;; "Div_inf_neg"
(assert
  (forall ((x Int) (y Int))
    (=> (and (< 0 x) (<= x y)) (= (div (- x) y) (- 1)))))

;; "Mod_0"
(assert (forall ((y Int)) (=> (not (= y 0)) (= (mod 0 y) 0))))

;; "Div_1_left"
(assert (forall ((y Int)) (=> (< 1 y) (= (div 1 y) 0))))

;; "Div_minus1_left"
(assert (forall ((y Int)) (=> (< 1 y) (= (div (- 1) y) (- 1)))))

;; "Mod_1_left"
(assert (forall ((y Int)) (=> (< 1 y) (= (mod 1 y) 1))))

;; "Mod_minus1_left"
(assert (forall ((y Int)) (=> (< 1 y) (= (mod (- 1) y) (- y 1)))))

;; "Div_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=> (< 0 x) (= (div (+ (* x y) z) x) (+ y (div z x)))) :pattern ((div (+ (* x y) z) x)) )))

;; "Mod_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=> (< 0 x) (= (mod (+ (* x y) z) x) (mod z x))) :pattern ((mod (+ (* x y) z) x)) )))

;; "rotate_right"
(declare-fun rotate_right1 ((_ BitVec 64)
  Int) (_ BitVec 64))

;; "rotate_left"
(declare-fun rotate_left1 ((_ BitVec 64)
  Int) (_ BitVec 64))

;; "pow2"
(declare-fun pow2 (Int) Int)

;; "Power_0"
(assert (= (pow2 0) 1))

;; "Power_s"
(assert (forall ((n Int)) (=> (<= 0 n) (= (pow2 (+ n 1)) (* 2 (pow2 n))))))

;; "Power_1"
(assert (= (pow2 1) 2))

;; "Power_sum"
(assert
  (forall ((n Int) (m Int))
    (=> (and (<= 0 n) (<= 0 m)) (= (pow2 (+ n m)) (* (pow2 n) (pow2 m))))))

;; "pow2pos"
(assert (forall ((i Int)) (=> (<= 0 i) (< 0 (pow2 i)))))

;; "pow2_0"
(assert (= (pow2 0) 1))

;; "pow2_1"
(assert (= (pow2 1) 2))

;; "pow2_2"
(assert (= (pow2 2) 4))

;; "pow2_3"
(assert (= (pow2 3) 8))

;; "pow2_4"
(assert (= (pow2 4) 16))

;; "pow2_5"
(assert (= (pow2 5) 32))

;; "pow2_6"
(assert (= (pow2 6) 64))

;; "pow2_7"
(assert (= (pow2 7) 128))

;; "pow2_8"
(assert (= (pow2 8) 256))

;; "pow2_9"
(assert (= (pow2 9) 512))

;; "pow2_10"
(assert (= (pow2 10) 1024))

;; "pow2_11"
(assert (= (pow2 11) 2048))

;; "pow2_12"
(assert (= (pow2 12) 4096))

;; "pow2_13"
(assert (= (pow2 13) 8192))

;; "pow2_14"
(assert (= (pow2 14) 16384))

;; "pow2_15"
(assert (= (pow2 15) 32768))

;; "pow2_16"
(assert (= (pow2 16) 65536))

;; "pow2_17"
(assert (= (pow2 17) 131072))

;; "pow2_18"
(assert (= (pow2 18) 262144))

;; "pow2_19"
(assert (= (pow2 19) 524288))

;; "pow2_20"
(assert (= (pow2 20) 1048576))

;; "pow2_21"
(assert (= (pow2 21) 2097152))

;; "pow2_22"
(assert (= (pow2 22) 4194304))

;; "pow2_23"
(assert (= (pow2 23) 8388608))

;; "pow2_24"
(assert (= (pow2 24) 16777216))

;; "pow2_25"
(assert (= (pow2 25) 33554432))

;; "pow2_26"
(assert (= (pow2 26) 67108864))

;; "pow2_27"
(assert (= (pow2 27) 134217728))

;; "pow2_28"
(assert (= (pow2 28) 268435456))

;; "pow2_29"
(assert (= (pow2 29) 536870912))

;; "pow2_30"
(assert (= (pow2 30) 1073741824))

;; "pow2_31"
(assert (= (pow2 31) 2147483648))

;; "pow2_32"
(assert (= (pow2 32) 4294967296))

;; "pow2_33"
(assert (= (pow2 33) 8589934592))

;; "pow2_34"
(assert (= (pow2 34) 17179869184))

;; "pow2_35"
(assert (= (pow2 35) 34359738368))

;; "pow2_36"
(assert (= (pow2 36) 68719476736))

;; "pow2_37"
(assert (= (pow2 37) 137438953472))

;; "pow2_38"
(assert (= (pow2 38) 274877906944))

;; "pow2_39"
(assert (= (pow2 39) 549755813888))

;; "pow2_40"
(assert (= (pow2 40) 1099511627776))

;; "pow2_41"
(assert (= (pow2 41) 2199023255552))

;; "pow2_42"
(assert (= (pow2 42) 4398046511104))

;; "pow2_43"
(assert (= (pow2 43) 8796093022208))

;; "pow2_44"
(assert (= (pow2 44) 17592186044416))

;; "pow2_45"
(assert (= (pow2 45) 35184372088832))

;; "pow2_46"
(assert (= (pow2 46) 70368744177664))

;; "pow2_47"
(assert (= (pow2 47) 140737488355328))

;; "pow2_48"
(assert (= (pow2 48) 281474976710656))

;; "pow2_49"
(assert (= (pow2 49) 562949953421312))

;; "pow2_50"
(assert (= (pow2 50) 1125899906842624))

;; "pow2_51"
(assert (= (pow2 51) 2251799813685248))

;; "pow2_52"
(assert (= (pow2 52) 4503599627370496))

;; "pow2_53"
(assert (= (pow2 53) 9007199254740992))

;; "pow2_54"
(assert (= (pow2 54) 18014398509481984))

;; "pow2_55"
(assert (= (pow2 55) 36028797018963968))

;; "pow2_56"
(assert (= (pow2 56) 72057594037927936))

;; "pow2_57"
(assert (= (pow2 57) 144115188075855872))

;; "pow2_58"
(assert (= (pow2 58) 288230376151711744))

;; "pow2_59"
(assert (= (pow2 59) 576460752303423488))

;; "pow2_60"
(assert (= (pow2 60) 1152921504606846976))

;; "pow2_61"
(assert (= (pow2 61) 2305843009213693952))

;; "pow2_62"
(assert (= (pow2 62) 4611686018427387904))

;; "pow2_63"
(assert (= (pow2 63) 9223372036854775808))

;; "pow2_64"
(assert (= (pow2 64) 18446744073709551616))

;; "of_int"
(declare-fun of_int (Int) (_ BitVec 64))

;; "to_int"
(declare-fun to_int1 ((_ BitVec 64)) Int)

;; "to_int'def"
(assert
  (forall ((x (_ BitVec 64)))
    (ite (bvsge x (_ bv0 64))
      (= (to_int1 x) (bv2nat x))
      (= (to_int1 x) (- (- 18446744073709551616 (bv2nat x)))))))

;; "uint_in_range"
(declare-fun uint_in_range (Int) Bool)

;; "uint_in_range'def"
(assert
  (forall ((i Int))
    (= (uint_in_range i) (and (<= 0 i) (<= i 18446744073709551615)))))

;; "to_uint_of_int"
(assert
  (forall ((i Int))
    (=> (and (<= 0 i) (< i 18446744073709551616)) (= (bv2nat (of_int i)) i))))

;; "infix @"
(declare-fun infix_at (ty
  ty
  uni
  uni) uni)

;; "infix @_sort"
(assert
  (forall ((a ty) (b ty))
    (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

;; "acc"
(declare-fun acc (ty
  uni
  uni) Bool)

;; "t2tb"
(declare-fun t2tb (Bool) uni)

;; "t2tb_sort"
(assert (forall ((x Bool)) (sort bool (t2tb x))))

;; "tb2t"
(declare-fun tb2t (uni) Bool)

;; "BridgeL"
(assert (forall ((i Bool)) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (=> (sort bool j) (= (t2tb (tb2t j)) j)) :pattern ((t2tb (tb2t j))) )))

;; "acc_x"
(assert
  (forall ((a ty))
    (forall ((r uni) (x uni))
      (=>
        (forall ((y uni))
          (=>
            (sort a y)
            (=>
              (= (tb2t
                   (infix_at bool a (infix_at (infix_mngt a bool) a r y) x)) true)
              (acc a r y))))
        (acc a r x)))))

;; "acc_inversion"
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni))
      (=>
        (acc a z z1)
        (forall ((y uni))
          (=>
            (= (tb2t
                 (infix_at bool a (infix_at (infix_mngt a bool) a z y) z1)) true)
            (acc a z y)))))))

;; "well_founded"
(declare-fun well_founded (ty
  uni) Bool)

;; "well_founded'def"
(assert
  (forall ((a ty))
    (forall ((r uni))
      (and
        (=> (well_founded a r) (forall ((x uni)) (acc a r x)))
        (=>
          (forall ((x uni)) (=> (sort a x) (acc a r x)))
          (well_founded a r))))))

;; "positive_is_ge_zeros"
(assert
  (forall ((x (_ BitVec 64)))
    (= (bvsge x (_ bv0 64)) (bvsge x #x0000000000000000))))

;; "lsr_bv_is_lsr"
(assert
  (forall ((x (_ BitVec 64)) (n (_ BitVec 64)))
    (= (bvlshr x n) (lsr x (bv2nat n)))))

;; "asr_bv_is_asr"
(assert
  (forall ((x (_ BitVec 64)) (n (_ BitVec 64)))
    (= (bvashr x n) (asr x (bv2nat n)))))

;; "lsl_bv_is_lsl"
(assert
  (forall ((x (_ BitVec 64)) (n (_ BitVec 64)))
    (= (bvshl x n) (lsl x (bv2nat n)))))

;; "rotate_left_bv_is_rotate_left"
(assert
  (forall ((v (_ BitVec 64)) (n (_ BitVec 64)))
    (= (bvor (bvshl v (bvurem n (_ bv64 64))) (bvlshr v (bvsub (_ bv64 64) (bvurem n (_ bv64 64))))) 
    (rotate_left1
      v
      (bv2nat n)))))

;; "rotate_right_bv_is_rotate_right"
(assert
  (forall ((v (_ BitVec 64)) (n (_ BitVec 64)))
    (= (bvor (bvlshr v (bvurem n (_ bv64 64))) (bvshl v (bvsub (_ bv64 64) (bvurem n (_ bv64 64))))) 
    (rotate_right1
      v
      (bv2nat n)))))

;; "nth_bv"
(declare-fun nth_bv ((_ BitVec 64)
  (_ BitVec 64)) Bool)

;; "nth_bv_def"
(assert
  (forall ((x (_ BitVec 64)) (i (_ BitVec 64)))
    (=
      (= (nth_bv x i) true)
      (not (= (bvand (bvlshr x i) #x0000000000000001) #x0000000000000000)))))

;; "Nth_bv_is_nth"
(assert
  (forall ((x (_ BitVec 64)) (i (_ BitVec 64)))
    (= (nth x (bv2nat i)) (nth_bv x i))))

;; "Nth_bv_is_nth2"
(assert
  (forall ((x (_ BitVec 64)) (i Int))
    (=>
      (and (<= 0 i) (< i 18446744073709551616))
      (= (nth_bv x (of_int i)) (nth x i)))))

;; "eq_sub_bv"
(declare-fun eq_sub_bv ((_ BitVec 64)
  (_ BitVec 64)
  (_ BitVec 64)
  (_ BitVec 64)) Bool)

;; "eq_sub_bv_def"
(assert
  (forall ((a (_ BitVec 64)) (b (_ BitVec 64)) (i (_ BitVec 64)) (n (_ BitVec 64)))
    (let ((mask (bvshl (bvsub (bvshl #x0000000000000001 n) #x0000000000000001) i)))
      (= (eq_sub_bv a b i n) (= (bvand b mask) (bvand a mask))))))

;; "eq_sub"
(declare-fun eq_sub ((_ BitVec 64)
  (_ BitVec 64)
  Int
  Int) Bool)

;; "eq_sub'def"
(assert
  (forall ((a (_ BitVec 64)) (b (_ BitVec 64)) (i Int) (n Int))
    (=
      (eq_sub a b i n)
      (forall ((j Int))
        (=> (and (<= i j) (< j (+ i n))) (= (nth a j) (nth b j)))))))

;; "eq_sub_equiv"
(assert
  (forall ((a (_ BitVec 64)) (b (_ BitVec 64)) (i (_ BitVec 64)) (n (_ BitVec 64)))
    (= (eq_sub a b (bv2nat i) (bv2nat n)) (eq_sub_bv a b i n))))

;; Goal "rightmost_bit_trick'vc"
;; File "/home/marche/why3/examples/rightmostbittrick.mlw", line 20, characters 6-25
(assert
  (not
  (forall ((x (_ BitVec 64)))
    (=>
      (not (= x #x0000000000000000))
      (forall ((p_bv (_ BitVec 64)))
        (=>
          (and
            (bvult p_bv #x0000000000000040)
            (and
              (eq_sub_bv x #x0000000000000000 #x0000000000000000 p_bv)
              (= (nth_bv x p_bv) true)))
          (forall ((p Int))
            (=>
              (= p (bv2nat p_bv))
              (=>
                (= (nth_bv (bvneg x) p_bv) true)
                (let ((result (bvand x (bvneg x))))
                  (=>
                    (and (<= 0 p) (< p 64))
                    (=>
                      (eq_sub x #x0000000000000000 0 p)
                      (=>
                        (= (nth x p) true)
                        (=>
                          (eq_sub result #x0000000000000000 0 p)
                          (eq_sub result #x0000000000000000 (+ p 1) (- 63 p))))))))))))))))

(check-sat)
