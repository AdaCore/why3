use coma.Regexp
use int.Int

let halt = (? any)
let fail = { false } any

let if (b: bool) (then {b}) (else {not b}) = any

let unRe (r: regexp)
    (empty { r = Empty })
    (eps { r = Epsilon })
    (char (c: char) { r = Char c })
    (alt (r1 r2: regexp) { r = Alt r1 r2 })
    (cat (r1 r2: regexp) { r = Concat r1 r2 })
    (star (r1: regexp) { r = Star r1 })
= any

let accept (r: regexp) (w: word) {} (ret (b: bool) { b <-> mem w r })
 = a {r} {0} {Epsilon} (fun (i: int) (h (b: bool)) -> h {i=n}) ret
   [ a (r: regexp) (i : int) (rk: regexp) {0 <= i <= n}
       (k (j: int) { mem w[i..j] r } { i <= j <= n }
          (h (b: bool) { b <-> mem w[j..] rk }))
       (o (b: bool) { b <-> mem w[i..] (Concat r rk) })
     = unRe {r} empty eps char alt cat star
         [ empty -> o {false}
         | eps   -> { mem empty r } k {i} o
         | char (c: char) ->
             if {i < n}
                (-> if { w[i] = c } (-> k {i+1} o) (o {false}))
                (o {false})
         | alt (r1 r2: regexp) ->
             a {r1} {i} {rk} k
               (fun (b: bool) ->
                  if {b} (o {true})
                     (-> a {r2} {i} {rk} k o))
         | cat (r1 r2: regexp) ->
             a {r1} {i} {Concat r2 rk}
               (fun (j: int) (h (b: bool)) -> a {r2} {j} {rk} k h)
               o
         | star (r1: regexp) ->
             k {i} (fun (b: bool) ->
               a {r1} {i} {Concat r rk}
                 (fun (j: int) (ho (b: bool)) ->
                   (! if {i < j} (-> a {r} {j} {rk} k ho) (ho {false})))
                 o) ]
   ]
   [ n: int = length w ]
