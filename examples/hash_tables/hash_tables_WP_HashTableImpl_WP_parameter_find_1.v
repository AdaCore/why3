(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Import ZOdiv.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.

(* Why3 assumption *)
Definition unit  := unit.

(* Why3 assumption *)
Inductive option (a:Type) {a_WT:WhyType a} :=
  | None : option a
  | Some : a -> option a.
Axiom option_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (option a).
Existing Instance option_WhyType.
Implicit Arguments None [[a] [a_WT]].
Implicit Arguments Some [[a] [a_WT]].

(* Why3 assumption *)
Inductive list (a:Type) {a_WT:WhyType a} :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Axiom list_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (list a).
Existing Instance list_WhyType.
Implicit Arguments Nil [[a] [a_WT]].
Implicit Arguments Cons [[a] [a_WT]].

(* Why3 assumption *)
Fixpoint mem {a:Type} {a_WT:WhyType a}(x:a) (l:(list a)) {struct l}: Prop :=
  match l with
  | Nil => False
  | (Cons y r) => (x = y) \/ (mem x r)
  end.

(* Why3 assumption *)
Inductive array (a:Type) {a_WT:WhyType a} :=
  | mk_array : Z -> (map.Map.map Z a) -> array a.
Axiom array_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.
Implicit Arguments mk_array [[a] [a_WT]].

(* Why3 assumption *)
Definition elts {a:Type} {a_WT:WhyType a}(v:(array a)): (map.Map.map Z a) :=
  match v with
  | (mk_array x x1) => x1
  end.

(* Why3 assumption *)
Definition length {a:Type} {a_WT:WhyType a}(v:(array a)): Z :=
  match v with
  | (mk_array x x1) => x
  end.

(* Why3 assumption *)
Definition get {a:Type} {a_WT:WhyType a}(a1:(array a)) (i:Z): a :=
  (map.Map.get (elts a1) i).

(* Why3 assumption *)
Definition set {a:Type} {a_WT:WhyType a}(a1:(array a)) (i:Z) (v:a): (array
  a) := (mk_array (length a1) (map.Map.set (elts a1) i v)).

(* Why3 assumption *)
Definition make {a:Type} {a_WT:WhyType a}(n:Z) (v:a): (array a) :=
  (mk_array n (map.Map.const v:(map.Map.map Z a))).

(* Why3 assumption *)
Inductive t (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b} :=
  | mk_t : (map.Map.map a (option b)) -> (array (list (a* b)%type)) -> t a b.
Axiom t_WhyType : forall (a:Type) {a_WT:WhyType a} (b:Type) {b_WT:WhyType b},
  WhyType (t a b).
Existing Instance t_WhyType.
Implicit Arguments mk_t [[a] [a_WT] [b] [b_WT]].

(* Why3 assumption *)
Definition data {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}(v:(t a
  b)): (array (list (a* b)%type)) := match v with
  | (mk_t x x1) => x1
  end.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}(v:(t
  a b)): (map.Map.map a (option b)) := match v with
  | (mk_t x x1) => x
  end.

(* Why3 assumption *)
Definition get1 {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}(h:(t a
  b)) (k:a): (option b) := (map.Map.get (contents h) k).

Parameter hash: forall {a:Type} {a_WT:WhyType a}, a -> Z.

(* Why3 assumption *)
Definition idx {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}(h:(t a b))
  (k:a): Z := (ZOmod (Zabs (hash k)) (length (data h))).

Axiom idx_bounds : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (h:(t a b)) (k:a),
  (0%Z < (length (data h)))%Z -> ((0%Z <= (idx h k))%Z /\ ((idx h
  k) < (length (data h)))%Z).

(* Why3 assumption *)
Fixpoint occurs_first {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}(k:a) (v:b) (l:(list (a*
  b)%type)) {struct l}: Prop :=
  match l with
  | Nil => False
  | (Cons (k', v') r) => ((k = k') /\ (v = v')) \/ ((~ (k = k')) /\
      (occurs_first k v r))
  end.

Axiom mem_occurs_first : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (k:a) (v:b) (l:(list (a* b)%type)),
  (occurs_first k v l) -> (mem (k, v) l).

Axiom cons_occurs_first : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (k1:a) (v1:b) (l:(list (a* b)%type)),
  (occurs_first k1 v1 l) -> forall (k:a) (v:b), (~ (k = k1)) ->
  (occurs_first k1 v1 (Cons (k, v) l)).

(* Why3 goal *)
Theorem WP_parameter_find : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (h:Z) (k:a), forall (rho:(map.Map.map Z
  (list (a* b)%type))) (rho1:(map.Map.map a (option b))), (((0%Z < h)%Z /\
  ((forall (k1:a) (v:b), ((map.Map.get rho1 k1) = (Some v)) <->
  (occurs_first k1 v (map.Map.get rho (ZOmod (Zabs (hash k1)) h)))) /\
  forall (k1:a) (v:b), forall (i:Z), ((0%Z <= i)%Z /\ (i < h)%Z) -> ((mem (
  k1, v) (map.Map.get rho i)) -> (i = (ZOmod (Zabs (hash k1)) h))))) /\
  (0%Z <= h)%Z) -> let i := (ZOmod (Zabs (hash k)) h) in (((0%Z <= i)%Z /\
  (i < h)%Z) -> ((forall (v:b), ~ (mem (k, v) (map.Map.get rho i))) ->
  ((map.Map.get rho1 k) = (None :(option b))))).
intros a _a b _b h k rho rho1.
pose (i := (Zabs (hash k) mod h)).
unfold get1; simpl.
intuition.
generalize (H2 k); clear H2.
generalize (H6 k); clear H6.
unfold get1; simpl; intuition.
destruct (Map.get rho1 k); auto.
elim (H1 b0); clear H1.
generalize (H5 b0); clear H3.
intuition.
apply mem_occurs_first; auto.
Qed.


