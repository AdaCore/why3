(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Definition unit  := unit.

Parameter ignore: forall (a:Type), a  -> unit.

Implicit Arguments ignore.

Parameter label_ : Type.

Parameter at1: forall (a:Type), a -> label_  -> a.

Implicit Arguments at1.

Parameter old: forall (a:Type), a  -> a.

Implicit Arguments old.

Inductive list (a:Type) :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.
Implicit Arguments Cons.

Parameter infix_plpl: forall (a:Type), (list a) -> (list a)  -> (list a).

Implicit Arguments infix_plpl.

Axiom infix_plpl_def : forall (a:Type), forall (l1:(list a)) (l2:(list a)),
  match l1 with
  | Nil  => ((infix_plpl l1 l2) = l2)
  | Cons x1 r1 => ((infix_plpl l1 l2) = (Cons x1 (infix_plpl r1 l2)))
  end.

Axiom Append_assoc : forall (a:Type), forall (l1:(list a)) (l2:(list a))
  (l3:(list a)), ((infix_plpl l1 (infix_plpl l2
  l3)) = (infix_plpl (infix_plpl l1 l2) l3)).

Axiom Append_l_nil : forall (a:Type), forall (l:(list a)), ((infix_plpl l
  (Nil:(list a))) = l).

Parameter length: forall (a:Type), (list a)  -> Z.

Implicit Arguments length.

Axiom length_def : forall (a:Type), forall (l:(list a)),
  match l with
  | Nil  => ((length l) = 0%Z)
  | Cons _ r => ((length l) = (1%Z + (length r))%Z)
  end.

Axiom Length_nonnegative : forall (a:Type), forall (l:(list a)),
  (0%Z <= (length l))%Z.

Axiom Length_nil : forall (a:Type), forall (l:(list a)),
  ((length l) = 0%Z) <-> (l = (Nil:(list a))).

Axiom Append_length : forall (a:Type), forall (l1:(list a)) (l2:(list a)),
  ((length (infix_plpl l1 l2)) = ((length l1) + (length l2))%Z).

Parameter mem: forall (a:Type), a -> (list a)  -> Prop.

Implicit Arguments mem.

Axiom mem_def : forall (a:Type), forall (x:a) (l:(list a)),
  match l with
  | Nil  => ~ (mem x l)
  | Cons y r => (mem x l) <-> ((x = y) \/ (mem x r))
  end.

Axiom mem_append : forall (a:Type), forall (x:a) (l1:(list a)) (l2:(list a)),
  (mem x (infix_plpl l1 l2)) <-> ((mem x l1) \/ (mem x l2)).

Parameter elt : Type.

Inductive tree  :=
  | Empty : tree 
  | Node : tree -> elt -> tree -> tree .

Parameter elements: tree  -> (list elt).


Axiom elements_def : forall (t:tree),
  match t with
  | Empty  => ((elements t) = (Nil:(list elt)))
  | Node l x r => ((elements t) = (infix_plpl (elements l) (Cons x
      (elements r))))
  end.

Inductive enum  :=
  | Done : enum 
  | Next : elt -> tree -> enum -> enum .

Parameter enum_elements: enum  -> (list elt).


Axiom enum_elements_def : forall (e:enum),
  match e with
  | Done  => ((enum_elements e) = (Nil:(list elt)))
  | Next x r e1 => ((enum_elements e) = (Cons x (infix_plpl (elements r)
      (enum_elements e1))))
  end.

Parameter leftlen: tree  -> Z.


Axiom leftlen_def : forall (t:tree),
  match t with
  | Empty  => ((leftlen t) = 0%Z)
  | Node l _ _ => ((leftlen t) = (1%Z + (leftlen l))%Z)
  end.

Theorem leftlen_nonneg : forall (t:tree), (0%Z <= (leftlen t))%Z.
(* YOU MAY EDIT THE PROOF BELOW *)
induction t; 
intuition.
rewrite (leftlen_def Empty).
omega.
rewrite (leftlen_def (Node t1 e t2)).
omega.
Qed.
(* DO NOT EDIT BELOW *)


