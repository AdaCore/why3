
{

  use array.ArrayLength as A

  type array 'a = A.t int 'a

  logic (#) (a : array 'a) (i : int) : 'a = A.get a i

  type uf = UF (link : array int)
               (dist : array int) (* distance to representative *)
               (size : int)       (* elements are 0..size-1 *)
               (num  : int)       (* number of classes *)

  logic inv (u : uf) =
    let UF l d s n = u in
    (forall i:int. 0 <= i < s -> 0 <= l#i < s) and
    (forall i:int. 0 <= i < s -> 
       ((d#i = 0 and l#i = i) or (d#i > 0 and d#(l#i) < d#i)))

  inductive repr (u:uf) (x:int) (r:int) = 
  | Repr_root: forall u:uf. inv u -> 
               forall x:int. 0 <= x < size u -> 
               link u #x = x -> repr u x x
  | Repr_link: forall u:uf. inv u -> 
               forall x:int. 0 <= x < size u -> 
               forall r:int. repr u (link u # x) r -> repr u x r

(*
  lemma Repr_inv:
    forall u:uf, x y:int. repr u x y -> inv u
  lemma Repr_bounds_1:
    forall u:uf, x y:int. repr u x y -> 0 <= x < size u
*)
  lemma Repr_bounds_2:
    forall u:uf, x y:int. repr u x y -> 0 <= y < size u
  lemma Repr_dist_1:
    forall u:uf, x y:int. repr u x y -> dist u # y = 0
(*
  lemma Repr_dist_2:
    forall u:uf. inv u -> 
    forall x:int. 0 <= x < size u -> dist u # x = 0 -> repr u x x
  lemma Repr_dist_3:
    forall u:uf. inv u -> 
    forall x:int. 0 <= x < size u -> dist u # x = 1 -> repr u x (link u # x)
*)

  logic same (u:uf) (x y:int) = 
    forall r:int. repr u x r <-> repr u y r

  logic same_reprs (u1 u2 : uf) = 
    forall x r:int. repr u1 x r <-> repr u2 x r

  axiom OneClass :
    forall u:uf. num u = 1 -> 
    forall x y:int. 0 <= x < size u -> 0 <= y < size u -> same u x y

}

let get_num_classes (u:ref uf) =
  {} num !u { result = num !u }

let create (n:int) =
  { 0 <= n } 
  let l = ref (A.create_const_length 0 n) in
  let i = ref 0 in
  while !i < n do
    invariant { 0 <= !i <= n and
                forall j:int. 0 <= j < !i -> !l#j = j } 
    variant { n - !i }
    l := A.set !l !i !i;
    i := !i + 1
  done;
  ref (UF !l (A.create_const_length 0 n) n n)
  { inv !result and
    num !result = n and size !result = n and
    forall x:int. 0 <= x < n -> repr !result x x }

let path_compression u x r =
  { inv !u and 0 <= x < size !u and dist !u # x > 0 and repr !u x r }
  let UF l d s n = !u in
  let l = A.set l x r in
  let d = A.set d x 1 in
  u := UF l d s n
  { inv !u and size !u = size (old !u) and 
    num !u = num (old !u) and same_reprs (old !u) !u }
 
let rec find (u:ref uf) (x:int) variant { dist !u # x } =
  { inv !u and 0 <= x < size !u } 
  let y = A.get (link !u) x in
  if y <> x then begin
    let r = find u y in
    path_compression u x r;
    r
  end else
    x
  { inv !u and
    repr !u x result and 
    size !u = size (old !u) and num !u = num (old !u) and
    same_reprs !u (old !u) } 

(***

parameter ghost_find : u:ref uf -> x:int ->
  { inv !u and 0 <= x < size !u }
  int reads u
  { repr !u x result }

let increment (u : ref uf) (r : int) =
  { inv !u and 0 <= r < size !u }
  let i = ref 0 in
  let d = ref (dist !u) in
  while !i < size !u do
    invariant { 0 <= !i <= size !u and
                forall j:int. 0 <= j < size !u ->
                !d#j = dist(!u)#j + 
                       if repr !u j r and j < !i then 1 else 0 }
    variant { size !u - !i }
    if ghost_find u !i = r then
      d := A.set !d !i (A.get !d !i + 1)
  done;
  !d
  { forall i:int. 0 <= i < size !u ->
      result#i = (dist !u)#i + if repr !u i r then 1 else 0 }

let union (u:ref uf) (a b:int) =
  { inv !u and 
    0 <= a < size !u and 0 <= b < size !u and not same !u a b }
  let ra = find u a in
  let rb = find u b in
  let l = link !u in
  let d = increment u ra in
  u := UF (A.set l ra rb) d (size !u) (num !u - 1)
  { inv !u and 
    same !u a b and
    size !u = size (old !u) and num !u = num (old !u) - 1 and 
    forall x y:int. 0 <= x < size !u -> 0 <= y < size !u -> 
      same !u x y <->
      same (old !u) x y or
      same (old !u) x a and same (old !u) b y or
      same (old !u) x b and same (old !u) a y }

***)

(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/vacid_0_union_find"
End: 
*)
