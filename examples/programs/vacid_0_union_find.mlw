
{

  use array.ArrayLength as A

  type array 'a = A.t 'a

  logic (#) (a : array 'a) (i : int) : 'a = A.get a i

  type uf = UF (link : array int)
               (dist : array int) (* distance to representative *)
               (size : int)       (* elements are 0..size-1 *)
               (num  : int)       (* number of classes *)

  logic inv (u : uf) =
    let (UF l d s n) = u in
    (forall i:int. 0 <= i < s -> 0 <= l#i < s) and
    (forall i:int. 0 <= i < s -> 
       (d#i = 0 and l#i = i or d#i > 0 and d#(l#i) = d#i - 1))

  logic repr (u:uf) (x:int) : int = 
    let l = link(u) in 
    let y = l#x in
    if y = x then y else repr u y  

  logic same (u:uf) (x y:int) = repr u x = repr u y

  axiom OneClass :
    forall u:uf. num u = 1 -> 
    forall x y:int. 0 <= x < size u -> 0 <= y < size u -> same u x y

}

let get_num_classes (u:ref uf) =
  {} num !u { result = num !u }

let create (n:int) =
  { 0 <= n } 
  let l = ref (A.const_length 0 n) in
  let i = ref 0 in
  while !i < n do
    invariant { 0 <= !i <= n and
                forall j:int. 0 <= j < !i -> !l#j = j } 
    variant { n - !i }
    l := A.set !l !i !i;
    i := !i + 1
  done;
  ref (UF !l (A.const_length 0 n) n n)
  { inv !result and
    num !result = n and size !result = n and
    forall x:int. 0 <= x < n -> repr !result x = x }

let rec find (u:ref uf) (x:int) variant { dist !u # x } =
  { inv !u and 0 <= x < size !u } 
  let y = A.get (link !u) x in
  if y <> x then begin
    let r = find u y in
    let l = A.set (link !u) x r in
    let d = A.set (dist !u) x 1 in
    u := UF l d (size !u) (num !u);
    r
  end else
    x
  { inv !u and
    result = repr !u x and 
    size !u = size (old !u) and num !u = num (old !u) and 
    forall x:int. 0 <= x < size !u -> repr !u x = repr (old !u) x } 

parameter ghost_find : u:ref uf -> x:int ->
  { inv !u and 0 <= x < size !u }
  int reads u
  { result = repr !u x }

let increment (u : ref uf) (r : int) =
  { inv !u and 0 <= r < size !u }
  let i = ref 0 in
  let d = ref (dist !u) in
  while !i < size !u do
    invariant { 0 <= !i <= size !u and
                forall j:int. 0 <= j < size !u ->
                !d#j = dist(!u)#j + 
                       if repr !u j = r and j < !i then 1 else 0 }
    variant { size !u - !i }
    if ghost_find u !i = r then
      d := A.set !d !i (A.get !d !i + 1)
  done;
  !d
  { forall i:int. 0 <= i < size !u ->
      result#i = (dist !u)#i + if repr !u i = r then 1 else 0 }

let union (u:ref uf) (a b:int) =
  { inv !u and 
    0 <= a < size !u and 0 <= b < size !u and not same !u a b }
  let ra = find u a in
  let rb = find u b in
  let l = link !u in
  let d = increment u ra in
  u := UF (A.set l ra rb) d (size !u) (num !u - 1)
  { inv !u and 
    same !u a b and
    size !u = size (old !u) and num !u = num (old !u) - 1 and 
    forall x y:int. 0 <= x < size !u -> 0 <= y < size !u -> 
      same !u x y <->
      same (old !u) x y or
      same (old !u) x a and same (old !u) b y or
      same (old !u) x b and same (old !u) a y }



(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/vacid_0_union_find"
End: 
*)
