
(* The 2nd Verified Software Competition (VSTTE 2012) 
   https://sites.google.com/site/vstte2012/compet

   Problem 4: Tree Reconstruction
   Build a binary tree from a list of leaf depths, if any

   This is a purely applicative implementation, using immutable
   lists from Why3's standard library.
*)

module TreeReconstruction

  use import int.Int
  use import list.List
  use import list.Length
  use import list.Append

  type tree = Leaf | Node tree tree

  (* the list of leaf depths for tree t, if root is at depth d *)
  function depths (d: int) (t: tree) : list int = match t with
    | Leaf -> Cons d Nil
    | Node l r -> depths (d+1) l ++ depths (d+1) r
  end

  (* two lemmas on depths *)
  lemma depths_head:
    forall t: tree, d: int.
    match depths d t with Cons x _ -> x >= d | Nil -> false end

  lemma depths_unique:
    forall t1 t2: tree, d: int, s1 s2: list int.
    depths d t1 ++ s1 = depths d t2 ++ s2 -> t1 = t2 && s1 = s2

  (* termination of build_rec (below) requires a lexicographic order *)
  predicate lex (x1 x2: (list int, int)) =
    let s1, d1 = x1 in
    let s2, d2 = x2 in
    length s1 < length s2 ||
    length s1 = length s2 &&
      match s1, s2 with
      | Cons h1 _, Cons h2 _ -> d2 < d1 <= h1 = h2
      | _ -> false
      end

  exception Failure
    (* used to signal the algorithm's failure i.e. there is no tree *)

  let rec build_rec (d: int) (s: list int) : (tree, list int)
    variant { (s, d) } with lex =
    { }
    match s with
    | Nil ->
        raise Failure
    | Cons h t ->
        if h < d then raise Failure;
        if h = d then
          (Leaf, t)
        else
          let l, s = build_rec (d+1) s in
          let r, s = build_rec (d+1) s in
          (Node l r, s)
    end
    { let t, s' = result in s = depths d t ++ s' }
    | Failure -> { forall t: tree, s' : list int. depths d t ++ s' <> s }

  let build (s: list int) : tree =
    { }
    let t, s = build_rec 0 s in
    match s with
    | Nil -> t
    | _ -> raise Failure
    end
    { depths 0 result = s }
    | Failure -> { forall t: tree. depths 0 t <> s }

end

module Harness

  use import list.List
  use import module TreeReconstruction

  let harness () =
    {}
    build (Cons 1 (Cons 3 (Cons 3 (Cons 2 Nil))))
    { result = Node Leaf (Node (Node Leaf Leaf) Leaf) } | Failure -> { false }

  let harness2 () =
    {}
    build (Cons 1 (Cons 3 (Cons 2 (Cons 2 Nil))))
    { false } | Failure -> { true }

end

(*
Local Variables:
compile-command: "why3ide vstte12_tree_reconstruction.mlw"
End:
*)
