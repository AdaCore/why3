
(* The 2nd Verified Software Competition (VSTTE 2012)
   https://sites.google.com/site/vstte2012/compet

   Problem 4: Tree Reconstruction
   Build a binary tree from a list of leaf depths, if any

   This is a purely applicative implementation, using immutable
   lists from Why3's standard library.
*)

theory Tree

  use export int.Int
  use export list.List
  use export list.Append

  type tree = Leaf | Node tree tree

  (* the list of leaf depths for tree t, if root is at depth d *)
  function depths (d: int) (t: tree) : list int = match t with
    | Leaf -> Cons d Nil
    | Node l r -> depths (d+1) l ++ depths (d+1) r
  end

  (* two lemmas on depths *)
  lemma depths_head:
    forall t: tree, d: int.
    match depths d t with Cons x _ -> x >= d | Nil -> false end

  lemma depths_unique:
    forall t1 t2: tree, d: int, s1 s2: list int.
    depths d t1 ++ s1 = depths d t2 ++ s2 -> t1 = t2 && s1 = s2

  lemma depths_unique2:
    forall t1 t2: tree, d1 d2: int.
    depths d1 t1 = depths d2 t2 -> d1 = d2 && t1 = t2

end

module TreeReconstruction

  use export Tree
  use import list.Length

  (* termination of build_rec (below) requires a lexicographic order *)
  predicate lex (x1 x2: (list int, int)) =
    let s1, d1 = x1 in
    let s2, d2 = x2 in
    length s1 < length s2 ||
    length s1 = length s2 &&
      match s1, s2 with
      | Cons h1 _, Cons h2 _ -> d2 < d1 <= h1 = h2
      | _ -> false
      end

  exception Failure
    (* used to signal the algorithm's failure i.e. there is no tree *)

  let rec build_rec (d: int) (s: list int) : (tree, list int)
    variant { (s, d) } with lex =
    { }
    match s with
    | Nil ->
        raise Failure
    | Cons h t ->
        if h < d then raise Failure;
        if h = d then
          (Leaf, t)
        else
          let l, s = build_rec (d+1) s in
          let r, s = build_rec (d+1) s in
          (Node l r, s)
    end
    { let t, s' = result in s = depths d t ++ s' }
    | Failure -> { forall t: tree, s' : list int. depths d t ++ s' <> s }

  let build (s: list int) : tree =
    { }
    let t, s = build_rec 0 s in
    match s with
    | Nil -> t
    | _ -> raise Failure
    end
    { depths 0 result = s }
    | Failure -> { forall t: tree. depths 0 t <> s }

end

module Harness

  use import module TreeReconstruction

  let harness () =
    {}
    build (Cons 1 (Cons 3 (Cons 3 (Cons 2 Nil))))
    { result = Node Leaf (Node (Node Leaf Leaf) Leaf) } | Failure -> { false }

  let harness2 () =
    {}
    build (Cons 1 (Cons 3 (Cons 2 (Cons 2 Nil))))
    { false } | Failure -> { true }

end

(*
  A variant implementation proposed by Jayadev Misra
  (and proved correct by Natarajan Shankar using PVS).

  Given the input list [x1; x2; ...; xn], we first turn it into the
  list of pairs [(x1, Leaf); (x2, Leaf); ...; (xn, Leaf)].  Then,
  repeatedly, we scan this list from left to right, looking for two
  consecutive pairs (v1, t1) and (v2, t2) with v1 = v2.  Then we
  replace them with the pair (v1-1, Node t1 t2) and we start again.
  We stop when there is only one pair left (v,t). Then we must have v=0.

  The implementation below achieves linear complexity using a zipper
  data structure to traverse the list of pairs. The left list contains
  the elements already traversed (thus on the left), in reverse order,
  and the right list contains the elements yet to be traversed.

*)

module ZipperBased

  use import Tree
  use import int.Lex2
  use import list.Length
  use import list.Reverse

  function forest_depths (f: list (int, tree)) : list int = match f with
  | Nil -> Nil
  | Cons (d, t) r -> depths d t ++ forest_depths r
  end

  lemma forest_depths_append:
    forall f1 f2: list (int, tree).
    forest_depths (f1 ++ f2) = forest_depths f1 ++ forest_depths f2

  exception Failure

(*
  predicate inv (left: list (int, tree)) = match left with
  | Nil -> true
  | Cons (d, _) Nil -> d <> 0
  | Cons (d1, _) ((Cons (d2, _) _) as left') -> d1 <> d2 /\ inv left'
  end
*)

  let rec tc (left: list (int, tree)) (right: list (int, tree)) : tree
    variant { (length left + length right, length right) } with lex =
    { (* inv left *) }
    match left, right with
    | _, Nil ->
        raise Failure
    | Nil, Cons (v, t) Nil ->
        if v = 0 then t else raise Failure
    | Nil, Cons (v, t) right' ->
        tc (Cons (v, t) Nil) right'
    | Cons (v1, t1) left', Cons (v2, t2) right' ->
        if v1 = v2 then tc left' (Cons (v1 - 1, Node t1 t2) right')
        else tc (Cons (v2, t2) left) right'
    end
    { depths 0 result = forest_depths (reverse left ++ right) }
    | Failure ->
    { forall t: tree. depths 0 t <> forest_depths (reverse left ++ right) }

  function map_leaf (l: list int) : list (int, tree) = match l with
  | Nil -> Nil
  | Cons d r -> Cons (d, Leaf) (map_leaf r)
  end

  lemma map_leaf_depths:
    forall l: list int. forest_depths (map_leaf l) = l

  let build (s: list int) =
    {}
    tc Nil (map_leaf s)
    { depths 0 result = s }
    | Failure -> { forall t: tree. depths 0 t <> s }

end


(*
Local Variables:
compile-command: "why3ide vstte12_tree_reconstruction.mlw"
End:
*)
