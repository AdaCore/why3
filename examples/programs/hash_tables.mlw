
(* Hash table implementation.

   These are minimal hash tables, without [remove] operation.

   This is suitable to implement memo tables for instance.
   One example of such a use is in max_matrix.mlw *)

(* The signature *)
module HashTable

  use import option.Option
  use import int.Int
  use import map.Map

  type t 'a 'b model {| mutable contents: map 'a (option 'b) |}

  function ([]) (h: t 'a 'b) (k: 'a) : option 'b = Map.get h.contents k

  val create (n:int) :
    { 0 < n } t 'a 'b { forall k: 'a. result[k] = None }

  val clear (h: t 'a 'b) :
    {} unit writes h { forall k: 'a. h[k] = None }

  val add (h: t 'a 'b) (k: 'a) (v: 'b) :
    {}
    unit writes h
    { h[k] = Some v /\ forall k': 'a. k' <> k -> h[k'] = (old h)[k'] }

  exception Not_found

  val find (h: t 'a 'b) (k: 'a) :
    {}
    'b reads h raises Not_found
    { h[k] = Some result } | Not_found -> { h[k] = None }

end

(* the implementation *)
module HashTableImpl

  use import option.Option
  use import int.Int
  use import int.Abs
  use import int.ComputerDivision
  use import map.Map
  use import list.List
  use import list.Mem
  use import module array.Array

  type t 'a 'b = {| mutable contents: map 'a (option 'b);
                    data: array (list ('a, 'b)) |}

  function get (h: t 'a 'b) (k: 'a) : option 'b = Map.get h.contents k

  function hash 'a : int

  function idx (h: t 'a 'b) (k: 'a) : int =
    mod (abs (hash k)) (length h.data)

  (* [(k,v)] is the first pair in [l] with key [k] *)
  predicate occurs_first (k: 'a) (v: 'b) (l: list ('a, 'b)) = match l with
    | Nil            -> false
    | Cons (k',v') r -> (k = k' /\ v = v') \/ (k <> k' /\ occurs_first k v r)
  end

  lemma mem_occurs_first:
    forall k: 'a, v: 'b, l: list ('a, 'b).
    occurs_first k v l -> mem (k, v) l

  lemma cons_occurs_first:
    forall k1: 'a, v1: 'b, l: list ('a, 'b). occurs_first k1 v1 l ->
    forall k: 'a, v: 'b. k <> k1 -> occurs_first k1 v1 (Cons (k,v) l)

  predicate valid (h: t 'a 'b) =
    length h.data > 0 /\
    (* h[k]=v iff (k,v) is the first pair for k in the bucket for k *)
    (forall k: 'a, v: 'b.
       get h k = Some v <-> occurs_first k v h.data[idx h k]) /\
    (* a pair (k,v) is always stored in the right bucket *)
    (forall k: 'a, v: 'b.
     forall i: int. 0 <= i < length h.data ->
       mem (k,v) h.data[i] -> i = idx h k)

  lemma idx_bounds:
    forall h: t 'a 'b. valid h -> forall k: 'a. 0 <= idx h k < length h.data

  let create (n:int) =
    { 0 < n }
    {| contents = const None;
       data = make n (Nil: list ('a, 'b)) |}
    { valid result /\ forall k: 'a. get result k = None }

  let clear (h: t 'a 'b) =
    { valid h }
    fill h.data 0 (length h.data) Nil;
    h.contents <- const None
    { valid h /\ forall k: 'a. get h k = None }

  let add (h: t 'a 'b) (k: 'a) (v: 'b) =
    { valid h }
    let i = idx h k in
    h.data[i] <- Cons (k,v) h.data[i];
    h.contents <- Map.set h.contents k (Some v)
    { valid h &&
      get h k = Some v /\ forall k': 'a. k' <> k -> get h k' = get (old h) k' }

  exception Not_found

  let rec lookup (k: 'a) (l: list ('a, 'b)) : 'b =
    {}
    match l with
    | Nil -> raise Not_found
    | Cons (k', v) r -> if k = k' then v else lookup k r
    end
    { occurs_first k result l }
    | Not_found -> { forall v: 'b. not (mem (k, v) l) }

  let find (h: t 'a 'b) (k: 'a) =
    { valid h }
    let i = idx h k in
    lookup k h.data[i]
    { get h k = Some result } | Not_found -> { get h k = None }

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/hash_tables.gui"
End:
*)
