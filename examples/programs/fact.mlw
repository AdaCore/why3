
(* Various programs computing the factorial. *)

theory Fact "Factorial"

  use export int.Int

  function fact int : int

  axiom fact0: fact 0 = 1
  axiom factn: forall n:int. n >= 1 -> fact n = fact (n-1) * n

end

module FactRecursive

  use import Fact
  use import int.Int

  let rec fact_rec (x:int) : int variant {x} =
    { x >= 0 }
    if x = 0 then 1 else x * fact_rec (x-1)
    { result = fact x }

end

module FactImperative

  use import Fact
  use import int.Int
  use import module ref.Ref

  let fact_imp (x:int) : int =
    { x >= 0 }
    let y = ref 0 in
    let r = ref 1 in
    while !y < x do
      invariant { 0 <= !y <= x /\ !r = fact !y }
      y := !y + 1;
      r := !r * !y
    done;
    !r
    { result = fact x }

end

(* ‘Checking a large routine’ Alan Mathison Turing, 1949

   One of the earliest proof of program.
   The routine computes n! using only additions, using two nested loops.
*)

module CheckingALargRoutine

  use import Fact
  use import int.Int
  use import module ref.Ref

  let routine (n: int) =
    { n >= 0 }
    let r = ref 0 in
    let u = ref 1 in
    while !r < n do
      invariant { 0 <= !r <= n /\ !u = fact !r }
      variant   { n - !r }
      let s = ref 1 in
      let v = !u in
      while !s <= !r do
        invariant { 1 <= !s <= !r + 1 /\ !u = !s * fact !r }
        variant   { !r - !s }
        u := !u + v;
        s := !s + 1
      done;
      r := !r + 1
    done;
    !u
    { result = fact n }

end


(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/fact.gui"
End:
*)

