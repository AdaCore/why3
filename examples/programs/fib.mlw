
(* Fibonacci function with memoisation *)

{ 
  logic fib (n:int) : int =  
     if n <= 1 then 1 else fib (n-1) + fib (n-2)

  type option 'a = None | Some 'a

  use array.Array as A

  type table = A.t int (option int)

  logic inv (t : table) =
    forall x y : int. A.select t x = Some y -> y = fib x
}

parameter table : ref table

parameter add : 
  x:int -> y:int -> 
    {} unit writes table { !table = A.store (old !table) x (Some y) }

exception Not_found

parameter find :
  x:int -> 
   {} 
   int reads table raises Not_found 
   { A.select !table x = Some result } 
   | Not_found -> { A.select !table x = None }
  
let rec fibo n =
  { 0 <= n and inv !table }
  if n <= 1 then
    1
  else 
    memo_fibo (n-1) + memo_fibo (n-2)
  { result = fib n and inv !table }

and memo_fibo n =
  { 0 <= n and inv !table }
  try  find n
  with Not_found -> let fn = fibo n in add n fn; fn end
  { result = fib n and inv !table }

(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/fib"
End: 
*)
