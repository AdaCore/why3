
theory TwoPlayerGame

  use import int.Int
  use import list.List


  (** type describing a position in the game. It must include every
     needed info, in particular in general it will include whose
     turn it is. *)
  type position

  (** type describing a move *)
  type move

  (** the initial_position of the game *)
  constant initial_position : position

  (** gives the list of legal moves in the given position *)
  function legal_moves position : list move

  (** [do_move p m] returns the position obtained by doing the move [m]
     on position [p]. 
  *)
  function do_move position move : position

  (** [position_value p] returns an evaluation of position [p], an
     integer [v] between [-infinity] and [+infinity] which is supposed
     to be as higher as the position is good FOR THE PLAYER WHO HAS
     THE TURN. [v] must be 0 for a position where nobody can win
     anymore (draw game). For a position where the player who has the
     turn wins, [v] must be between [winning_value] and [infinity],
     and if the other player wins, [v] must be between [-infinity] and
     [-winning_value].
  *)
  constant winning_value : int
  constant infinity : int
  function position_value position : int

  (*

    [minmax p d] returns the min-max evaluation of position [p] at depth [d].
    As for [position_value], the value is for the player who has the turn.

  *)
  function minmax position int : int

  axiom minmax_depth_0 :
    forall p:position. minmax p 0 = position_value p

  type param = (position,int)
  function cost (p:param) (m:move) : int =
    match p with (p,n) -> minmax (do_move p m) n
    end

  clone import set.Min as MinMaxRec with 
    type param = param,
    type elt = move,
    function cost = cost

  use list.Elements
  use set.Fset

  axiom minmax_depth_non_zero:
    forall p:position, n:int. n >= 0 ->
     minmax p (n+1) = 
        let moves = Elements.elements (legal_moves p) in
        if Fset.is_empty moves then position_value p else
          - MinMaxRec.min (p,n) moves

  use list.Mem

  goal Test:
    forall p:position, m:move.
      let moves = legal_moves p in
      Mem.mem m moves -> - (position_value (do_move p m)) <= minmax p 1

end


(*

   alpha-beta

*)

module AlphaBeta

  use import int.Int
  use import int.MinMax

  use TwoPlayerGame as G
  use import list.List

  let rec move_value_alpha_beta alpha beta pos max_prof prof move =
    let pos' = G.do_move pos move in
    let s =
      if prof = max_prof
      then G.position_value pos'
      else
	negabeta (-beta) (-alpha) pos' max_prof (prof+1)
    in -s

  with negabeta alpha beta pos max_prof prof =
    { }
    let l = G.legal_moves pos in
    match l with
      | Nil -> G.position_value pos
      | Cons c l ->
	  let best =
	    move_value_alpha_beta alpha beta pos max_prof prof c
	  in
	  if best >= beta then best else
	    negabeta_rec (max best alpha) beta pos max_prof prof best l
    end
    { result = G.minmax pos (max_prof - prof + 1) }

  with negabeta_rec alpha beta pos max_prof prof best l =
    match l with
      |	Nil -> best
      | Cons c l ->
	  let s =
            move_value_alpha_beta alpha beta pos max_prof prof c
          in
	  let new_best  = max s best in
	  if new_best >= beta then new_best else
   	    negabeta_rec (max new_best alpha) beta pos max_prof prof new_best l
    end

(* alpha-beta at a given depth *)

let alpha_beta pos depth = 
  { }
  negabeta (-G.infinity) G.infinity pos depth 1
  { result = G.minmax pos depth }

(* iterative deepening *)

(*
  let best_move_alpha_beta pos =
    let l =
      List.map
	(fun c ->
	   (move_value_alpha_beta (-G.infinity) G.infinity pos 2 0 c,c))
	(G.legal_moves pos)
    in
    if List.length l < 2 then l else
      let current_best_moves =
	ref
	  (List.sort (fun (x,_) (y,_) -> compare y x) l)
      in
      try
	for max_prof = 3 to 1000 do
	  begin
	    match !current_best_moves with
	      | (v1,_)::(v2,_)::_ ->
		  if v1 >= G.winning_value or v2 <= - G.winning_value
		  then raise Timeout
	      | _ -> assert false
	  end;
	  let l =
	    List.map
	      (fun c ->
		 (move_value_alpha_beta (-G.infinity) G.infinity
		    pos max_prof 0 c,c))
	      (G.legal_moves pos)
	  in
	  current_best_moves :=
	  (List.sort (fun (x,_) (y,_) -> compare y x) l)
	done;
	!current_best_moves
      with
	| Timeout -> !current_best_moves

*)

end

