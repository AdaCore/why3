
theory Power

  use import int.Int

  function power int int : int

  axiom Power_0 : forall x : int. power x 0 = 1

  axiom Power_s : forall x n : int. 0 < n -> power x n = x * power x (n-1)

  lemma Power_1 : forall x : int. power x 1 = x

  lemma Power_sum : forall x n m : int. 0 <= n -> 0 <= m ->
    power x (n + m) = power x n * power x m

  lemma Power_mult : forall x n m : int. 0 <= n -> 0 <= m ->
    power x (n * m) = power (power x n) m

  lemma Power_mult2 : forall x y n : int. 0 <= n ->
    power (x * y) n = power x n * power y n

end

module M

  use import int.Int
  use import int.ComputerDivision
  use import Power

  (* recursive implementation *)

  let rec fast_exp x n variant { n } =
    { 0 <= n }
    if n = 0 then
      1
    else begin
      let r = fast_exp x (div n 2) in
      if mod n 2 = 0 then r * r else r * r * x
    end
    { result = power x n }

  (* non-recursive implementation using a while loop *)

  use import module ref.Ref

  let fast_exp_imperative x n =
    { 0 <= n }
    let r = ref 1 in
    let p = ref x in
    let e = ref n in
    while !e > 0 do
      invariant { 0 <= !e /\ !r * power !p !e = power x n }
      variant   { !e }
      if mod !e 2 = 1 then r := !r * !p;
      p := !p * !p;
      e := div !e 2
    done;
    !r
    { result = power x n }

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/power"
End:
*)
