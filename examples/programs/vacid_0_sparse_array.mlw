module M

(*
      If the sparse array contains three elements x y z, at index
      a b c respectively, then the three arrays look like this:

             b     a      c
val   +-----+-+---+-+----+-+----+
      |     |y|   |x|    |z|    |
      +-----+-+---+-+----+-+----+

idx   +-----+-+---+-+----+-+----+
      |     |1|   |0|    |2|    |
      +-----+-+---+-+----+-+----+

       0 1 2  n=3
back  +-+-+-+-------------------+
      |a|b|c|                   |
      +-+-+-+-------------------+

*)

  use array.ArrayLength as A

  logic maxlen : int = 1000

  type elt
  logic default : elt
  logic c1 : elt
  logic c2 : elt

  type array 'a = A.t int 'a

  logic (#) (a : array 'a) (i : int) : 'a = A.get a i

  type sparse_array = SA (sa_val  : array elt)
                         (sa_idx  : array int)
                         (sa_back : array int)
                         (sa_sz   : int)
                         (sa_n    : int)

  logic is_elt (a : sparse_array) (i : int) =
    let (SA val idx back _ n) = a in
    0 <= idx#i < n and back#(idx#i) = i

  logic model (a : sparse_array) (i : int) : elt =
    if is_elt a i then
      (sa_val a)#i
    else
      default

  logic invariant_ (a : sparse_array) =
    let (SA val idx back sz n) = a in
    0 <= n <= sz <= maxlen and
    A.length val = sz and A.length idx = sz and A.length back = sz and
    forall i : int. 0 <= i < n -> 0 <= back#i < sz and idx#(back#i) = i

  (*
    The following definitions and the axiom Dirichlet
    (provable by natural induction) are necessary to
    prove the lemma Inter6, which is sufficient for
    the proof of WPs for the function [set] below.
  *)

  logic permutation (n : int) (a : array int) =
    (forall i : int. 0 <= i < n -> 0 <= a#i < n) and
    (forall i j : int. 0 <= i < j < n -> a#i <> a#j)

  logic dirichlet (n : int) (a : array int) (i : int) : int

  axiom Dirichlet :
    forall n : int.
    forall a : array int.
        permutation n a ->
        (forall i : int. 0 <= i < n ->
            0 <= dirichlet n a i < n and
            a # dirichlet n a i = i)

  lemma Inter6 :
    forall a : sparse_array . invariant_ a ->
        let (SA val idx back sz n) = a in
        n = sz ->
            permutation sz back &&
            forall i : int. 0 <= i < sz ->
                idx#i = dirichlet sz back i && is_elt a i

(*
parameter create :
  sz:int ->
  { 0 <= sz <= maxlen }
  ref sparse_array
  { sa_sz !result = sz and forall i:int. model !result i = default }
*)

parameter malloc : n:int -> {} array 'a { A.length result = n }

let create sz =
  { 0 <= sz <= maxlen }
  ref (SA (malloc sz) (malloc sz) (malloc sz) sz 0)
  { invariant_ !result and
    sa_sz !result = sz and forall i:int. model !result i = default }

let array_get (a : array 'a) i =
  { 0 <= i < A.length a } A.get a i { result = A.get a i }

let array_set (a : array 'a) i v =
  { 0 <= i < A.length a } A.set a i v { result = A.set a i v }

let test a i =
  { 0 <= i < sa_sz !a and invariant_ !a }
  let idx = sa_idx !a in
  let back = sa_back !a in
  let n = sa_n !a in
  0 <= array_get idx i && array_get idx i < n &&
  array_get back (array_get idx i) = i
  { result=True <-> is_elt !a i }

(*
parameter get :
  a:ref sparse_array -> i:int ->
    { 0 <= i < sa_sz !a }
    elt reads a
    { result = model !a i }
*)
let get a i =
  { 0 <= i < sa_sz !a and invariant_ !a }
  let val = sa_val !a in
  if test a i then
    array_get val i
  else
    default
  { result = model !a i }

(*
parameter set :
  a:ref sparse_array -> i:int -> v:elt ->
    { 0 <= i < sa_sz !a and invariant !a }
    unit writes a
    { invariant !a and
      sa_sz !a = sa_sz (old !a) and
      model !a i = v and
      forall j:int. j <> i -> model !a j = model (old !a) j }
*)
let set a i v =
  { 0 <= i < sa_sz !a and invariant_ !a }
  (* let SA val idx back sz n = !a in *)
  let val = sa_val !a in
  let idx = sa_idx !a in
  let back = sa_back !a in
  let sz= sa_sz !a in
  let n = sa_n !a in
  let val = array_set val i v in
  if test a i then
    a := SA val idx back sz n
  else begin
    assert { n < sz };
    let idx = array_set idx i n in
    let back = array_set back n i in
    a := SA val idx back sz (n+1)
  end
  { invariant_ !a and
    sa_sz !a = sa_sz (old !a) and
    model !a i = v and
    forall j:int. j <> i -> model !a j = model (old !a) j }

let harness () =
  let a = create 10 in
  let b = create 20 in
  let get_a_5 = get a 5 in assert { get_a_5 = default };
  let get_b_7 = get b 7 in assert { get_b_7 = default };
  set a 5 c1;
  set b 7 c2;
  let get_a_5 = get a 5 in assert { get_a_5 = c1 };
  let get_b_7 = get b 7 in assert { get_b_7 = c2 };
  let get_a_7 = get a 7 in assert { get_a_7 = default };
  let get_b_5 = get b 5 in assert { get_b_5 = default };
  let get_a_0 = get a 0 in assert { get_a_0 = default };
  let get_b_0 = get b 0 in assert { get_b_0 = default };
  ()


end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/vacid_0_sparse_array"
End:
*)
