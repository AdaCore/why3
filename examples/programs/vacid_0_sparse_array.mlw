module M

(*
      If the sparse array contains three elements x y z, at index
      a b c respectively, then the three arrays look like this:

             b     a      c
val   +-----+-+---+-+----+-+----+
      |     |y|   |x|    |z|    |
      +-----+-+---+-+----+-+----+

idx   +-----+-+---+-+----+-+----+
      |     |1|   |0|    |2|    |
      +-----+-+---+-+----+-+----+

       0 1 2  n=3
back  +-+-+-+-------------------+
      |a|b|c|                   |
      +-+-+-+-------------------+

*)

  use import int.Int
  use import module ref.Ref
  use import module array.Array as A

  logic maxlen : int = 1000

  type elt
  logic default : elt
  logic c1 : elt
  logic c2 : elt

  type sparse_array = {| val  : array elt;
                         idx  : array int;
                         back : array int;
                 mutable card : int; |}

  logic length (a: sparse_array) : int = A.length a.val

  logic is_elt (a: sparse_array) (i: int) =
    0 <= a.idx[i] < a.card and a.back[a.idx[i]] = i

  logic model (a : sparse_array) (i : int) : elt =
    if is_elt a i then
      a.val[i]
    else
      default

  logic invariant_ (a : sparse_array) =
    0 <= a.card <= length a <= maxlen and
    A.length a.val = A.length a.idx = A.length a.back and
    forall i : int.
      0 <= i < a.card ->
      0 <= a.back[i] < length a and a.idx[a.back[i]] = i

  (*
    The following definitions and the axiom Dirichlet
    (provable by natural induction) are necessary to
    prove the lemma Inter6, which is sufficient for
    the proof of WPs for the function [set] below.
  *)

  logic permutation (n: int) (a: array int) =
    (forall i : int. 0 <= i < n -> 0 <= a[i] < n) and
    (forall i j : int. 0 <= i < j < n -> a[i] <> a[j])

  logic dirichlet (n : int) (a : array int) (i : int) : int

  axiom Dirichlet :
    forall n : int.
    forall a : array int.
        permutation n a ->
        (forall i : int. 0 <= i < n ->
            0 <= dirichlet n a i < n and
            a[dirichlet n a i] = i)

  lemma Inter6 :
    forall a : sparse_array . invariant_ a ->
      a.card = length a ->
            permutation a.card a.back &&
            forall i : int. 0 <= i < a.card ->
                a.idx[i] = dirichlet a.card a.back i && is_elt a i

  parameter malloc : n:int -> {} array 'a { A.length result = n }

  let create sz =
    { 0 <= sz <= maxlen }
    {| val = malloc sz; idx = malloc sz; back = malloc sz; card = 0 |}
    { invariant_ result and
      result.card = 0 and
      length result = sz and forall i:int. model result i = default }

  let test (a: sparse_array) i =
    { 0 <= i < length a and invariant_ a }
    let idx = idx a in
    let back = back a in
    let n = card a in
    0 <= idx[i] && idx[i] < n && back[idx[i]] = i
    { result=True <-> is_elt a i }

  let get (a: sparse_array) i =
    { 0 <= i < length a and invariant_ a }
    if test a i then
      (val a)[i]
    else
      default
    { result = model a i }

  let set (a: sparse_array) i v =
    { 0 <= i < length a and invariant_ a }
    (* let SA val idx back sz n = !a in *)
    let val = val a in
    let idx = idx a in
    let back = back a in
    let n = card a in
    val[i] <- v;
    if not (test a i) then begin
      assert { n < length a };
      idx[i] <- n;
      back[n] <- i;
      () (*TODO a.card <- n+1 *)
    end
    { invariant_ a and
      model a i = v and
      forall j:int. j <> i -> model a j = model (old a) j }

  let harness () =
    let a = create 10 in
    let b = create 20 in
    let get_a_5 = get a 5 in assert { get_a_5 = default };
    let get_b_7 = get b 7 in assert { get_b_7 = default };
    set a 5 c1;
    set b 7 c2;
    let get_a_5 = get a 5 in assert { get_a_5 = c1 };
    let get_b_7 = get b 7 in assert { get_b_7 = c2 };
    let get_a_7 = get a 7 in assert { get_a_7 = default };
    let get_b_5 = get b 5 in assert { get_b_5 = default };
    let get_a_0 = get a 0 in assert { get_a_0 = default };
    let get_b_0 = get b 0 in assert { get_b_0 = default };
    ()

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/vacid_0_sparse_array"
End:
*)
