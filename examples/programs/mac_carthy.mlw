(* McCarthy's ``91'' function. *)

module M

  use import int.Int

  (* traditional recursive implementation *)

  let rec f91 (n:int) : int variant { 101-n } =
    { }
    if n <= 100 then
      f91 (f91 (n + 11))
    else
      n - 10
    { (n <= 100 /\ result = 91) \/ (n >= 101 /\ result = n - 10) }


  (* non-recursive implementation using a while loop *)

  use import module ref.Ref

  function f (x: int) : int =
    if x >= 101 then x-10 else 91

  (* iter_f k x = f^k(x) *)
  function iter_f int int : int

  axiom iter_f_0: forall x: int. iter_f 0 x = x
  axiom iter_f_s: forall k x: int. 0 < k -> iter_f k x = iter_f (k-1) (f x)

  predicate lt_nat (x y: int) = 0 <= y /\ x < y

  clone import relations.Lex with type t1 = int, type t2 = int,
    predicate rel1 = lt_nat, predicate rel2 = lt_nat

  let f91_nonrec (n0: int) =
    { }
    let e = ref 1 in
    let n = ref n0 in
    while !e > 0 do
      invariant { !e >= 0 /\ iter_f !e !n = f n0 }
      variant   { (101 - !n + 10 * !e, !e) } with lex
      if !n > 100 then begin
        n := !n - 10;
        e := !e - 1
      end else begin
        n := !n + 11;
        e := !e + 1
      end
    done;
    !n
    { result = f n0 }

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/mac_carthy"
End:
*)
