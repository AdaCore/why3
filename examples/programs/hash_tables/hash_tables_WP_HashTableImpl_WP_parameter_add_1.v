(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Require Import ZOdiv.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.

(* Why3 assumption *)
Definition unit  := unit.

(* Why3 assumption *)
Inductive option (a:Type) :=
  | None : option a
  | Some : a -> option a.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.
Implicit Arguments Some.

Parameter map : forall (a:Type) (b:Type), Type.

Parameter get: forall (a:Type) (b:Type), (map a b) -> a -> b.
Implicit Arguments get.

Parameter set: forall (a:Type) (b:Type), (map a b) -> a -> b -> (map a b).
Implicit Arguments set.

Axiom Select_eq : forall (a:Type) (b:Type), forall (m:(map a b)),
  forall (a1:a) (a2:a), forall (b1:b), (a1 = a2) -> ((get (set m a1 b1)
  a2) = b1).

Axiom Select_neq : forall (a:Type) (b:Type), forall (m:(map a b)),
  forall (a1:a) (a2:a), forall (b1:b), (~ (a1 = a2)) -> ((get (set m a1 b1)
  a2) = (get m a2)).

Parameter const: forall (a:Type) (b:Type), b -> (map a b).
Set Contextual Implicit.
Implicit Arguments const.
Unset Contextual Implicit.

Axiom Const : forall (a:Type) (b:Type), forall (b1:b) (a1:a),
  ((get (const b1:(map a b)) a1) = b1).

(* Why3 assumption *)
Inductive list (a:Type) :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.
Implicit Arguments Cons.

(* Why3 assumption *)
Set Implicit Arguments.
Fixpoint mem (a:Type)(x:a) (l:(list a)) {struct l}: Prop :=
  match l with
  | Nil => False
  | (Cons y r) => (x = y) \/ (mem x r)
  end.
Unset Implicit Arguments.

(* Why3 assumption *)
Inductive array (a:Type) :=
  | mk_array : Z -> (map Z a) -> array a.
Implicit Arguments mk_array.

(* Why3 assumption *)
Definition elts (a:Type)(v:(array a)): (map Z a) :=
  match v with
  | (mk_array x x1) => x1
  end.
Implicit Arguments elts.

(* Why3 assumption *)
Definition length (a:Type)(v:(array a)): Z :=
  match v with
  | (mk_array x x1) => x
  end.
Implicit Arguments length.

(* Why3 assumption *)
Definition get1 (a:Type)(a1:(array a)) (i:Z): a := (get (elts a1) i).
Implicit Arguments get1.

(* Why3 assumption *)
Definition set1 (a:Type)(a1:(array a)) (i:Z) (v:a): (array a) :=
  (mk_array (length a1) (set (elts a1) i v)).
Implicit Arguments set1.

(* Why3 assumption *)
Inductive t (a:Type)
  (b:Type) :=
  | mk_t : (map a (option b)) -> (array (list (a* b)%type)) -> t a b.
Implicit Arguments mk_t.

(* Why3 assumption *)
Definition data (a:Type) (b:Type)(v:(t a b)): (array (list (a* b)%type)) :=
  match v with
  | (mk_t x x1) => x1
  end.
Implicit Arguments data.

(* Why3 assumption *)
Definition contents (a:Type) (b:Type)(v:(t a b)): (map a (option b)) :=
  match v with
  | (mk_t x x1) => x
  end.
Implicit Arguments contents.

(* Why3 assumption *)
Definition get2 (a:Type) (b:Type)(h:(t a b)) (k:a): (option b) :=
  (get (contents h) k).
Implicit Arguments get2.

Parameter hash: forall (a:Type), a -> Z.
Implicit Arguments hash.

(* Why3 assumption *)
Definition idx (a:Type) (b:Type)(h:(t a b)) (k:a): Z :=
  (ZOmod (Zabs (hash k)) (length (data h))).
Implicit Arguments idx.

(* Why3 assumption *)
Set Implicit Arguments.
Fixpoint occurs_first (a:Type) (b:Type)(k:a) (v:b) (l:(list (a*
  b)%type)) {struct l}: Prop :=
  match l with
  | Nil => False
  | (Cons (k', v') r) => ((k = k') /\ (v = v')) \/ ((~ (k = k')) /\
      (occurs_first k v r))
  end.
Unset Implicit Arguments.

Axiom mem_occurs_first : forall (a:Type) (b:Type), forall (k:a) (v:b)
  (l:(list (a* b)%type)), (occurs_first k v l) -> (mem (k, v) l).

Axiom cons_occurs_first : forall (a:Type) (b:Type), forall (k1:a) (v1:b)
  (l:(list (a* b)%type)), (occurs_first k1 v1 l) -> forall (k:a) (v:b),
  (~ (k = k1)) -> (occurs_first k1 v1 (Cons (k, v) l)).

(* Why3 assumption *)
Definition valid (a:Type) (b:Type)(h:(t a b)): Prop :=
  (0%Z < (length (data h)))%Z /\ ((forall (k:a) (v:b), ((get2 h
  k) = (Some v)) <-> (occurs_first k v (get1 (data h) (idx h k)))) /\
  forall (k:a) (v:b), forall (i:Z), ((0%Z <= i)%Z /\
  (i < (length (data h)))%Z) -> ((mem (k, v) (get1 (data h) i)) ->
  (i = (idx h k)))).
Implicit Arguments valid.

Axiom idx_bounds : forall (a:Type) (b:Type), forall (h:(t a b)), (valid h) ->
  forall (k:a), (0%Z <= (idx h k))%Z /\ ((idx h k) < (length (data h)))%Z.

Require Import Classical.

(* Why3 goal *)
Theorem WP_parameter_add : forall (a:Type) (b:Type), forall (h:Z) (k:a)
  (v:b), forall (rho:(map Z (list (a* b)%type))) (rho1:(map a (option b))),
  ((0%Z < (length (data (mk_t rho1 (mk_array h rho)))))%Z /\ ((forall (k1:a)
  (v1:b), ((get2 (mk_t rho1 (mk_array h rho)) k1) = (Some v1)) <->
  (occurs_first k1 v1 (get1 (data (mk_t rho1 (mk_array h rho)))
  (idx (mk_t rho1 (mk_array h rho)) k1)))) /\ forall (k1:a) (v1:b),
  forall (i:Z), ((0%Z <= i)%Z /\ (i < (length (data (mk_t rho1 (mk_array h
  rho)))))%Z) -> ((mem (k1, v1) (get1 (data (mk_t rho1 (mk_array h rho)))
  i)) -> (i = (idx (mk_t rho1 (mk_array h rho)) k1))))) -> let i :=
  (ZOmod (Zabs (hash k)) h) in ((((0%Z < i)%Z \/ (0%Z = i)) /\ (i < h)%Z) ->
  ((((0%Z < i)%Z \/ (0%Z = i)) /\ (i < h)%Z) -> forall (o:(map Z (list (a*
  b)%type))), (o = (set rho i (Cons (k, v) (get rho i)))) ->
  forall (rho2:(map a (option b))), (rho2 = (set rho1 k (Some v))) ->
  forall (k1:a) (v1:b), ((get2 (mk_t rho2 (mk_array h o)) k1) = (Some v1)) ->
  (occurs_first k1 v1 (get1 (data (mk_t rho2 (mk_array h o))) (idx (mk_t rho2
  (mk_array h o)) k1))))).
unfold get1; simpl; intros.
assert (case: (k1=k \/ k1<>k)) by apply classic; destruct case.
(* k1 = k *)
subst k1.
subst rho2.
unfold get2 in H4; simpl in H4.
rewrite Select_eq in H4; auto.
injection H4; intro; subst v1; clear H4.
unfold idx; simpl.
subst o; rewrite Select_eq.
red; intuition.
auto.
(* k1 <> k *)
subst rho2.
unfold idx; simpl.
unfold get2 in H4; simpl in H4.
rewrite Select_neq in H4; auto.
subst o.
set (i := (Zabs (hash k) mod h)).
set (i1 := (Zabs (hash k1) mod h)).
assert (case: (i1=i \/ i1<>i)) by omega; destruct case.
(* i1 = i *)
subst i1.
rewrite Select_eq; auto.
simpl.
right; split; auto.
destruct H.
destruct H3.
rewrite <- H2.
destruct (H3 k1 v1); clear H3.
unfold idx in H7; simpl in H7.
subst i.
apply H7.
unfold get2; simpl.
auto.
(* i1 <> i *)
rewrite Select_neq; auto.
destruct H.
destruct H3.
destruct (H3 k1 v1); clear H3.
unfold idx in H7; simpl in H7.
subst i1.
apply H7.
unfold get2; simpl.
auto.
Qed.


