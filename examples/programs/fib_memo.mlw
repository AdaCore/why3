(* Fibonacci function with memoisation *)

module M

  use import int.Int
  use import module ref.Ref

  logic fib int : int

  axiom Fib_def : forall n:int. fib n =
     if n <= 1 then 1 else fib (n-1) + fib (n-2)

  type option 'a = None | Some 'a

  use map.Map as M

  type table = M.map int (option int)

  logic inv (t : table) =
    forall x y : int. M.get t x = Some y -> y = fib x

  parameter table : ref table

  parameter add :
    x:int -> y:int ->
      {} unit writes table { !table = M.set (old !table) x (Some y) }

  exception Not_found

  parameter find :
    x:int ->
     {}
     int reads table raises Not_found
     { M.get !table x = Some result }
     | Not_found -> { M.get !table x = None }

  let rec fibo n =
    { 0 <= n and inv !table }
    if n <= 1 then
      1
    else
      memo_fibo (n-1) + memo_fibo (n-2)
    { result = fib n and inv !table }

  with memo_fibo n =
    { 0 <= n and inv !table }
    try  find n
    with Not_found -> let fn = fibo n in add n fn; fn end
    { result = fib n and inv !table }

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/fib_memo"
End:
*)
