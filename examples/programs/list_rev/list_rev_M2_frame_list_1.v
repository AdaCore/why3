(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Definition unit  := unit.

Parameter ignore: forall (a:Type), a  -> unit.

Implicit Arguments ignore.

Parameter label_ : Type.

Parameter at1: forall (a:Type), a -> label_  -> a.

Implicit Arguments at1.

Parameter old: forall (a:Type), a  -> a.

Implicit Arguments old.

Parameter ref : forall (a:Type), Type.

Parameter t : forall (a:Type) (b:Type), Type.

Parameter get: forall (a:Type) (b:Type), (t a b) -> a  -> b.

Implicit Arguments get.

Parameter set: forall (a:Type) (b:Type), (t a b) -> a -> b  -> (t a b).

Implicit Arguments set.

Axiom Select_eq : forall (a:Type) (b:Type), forall (m:(t a b)), forall (a1:a)
  (a2:a), forall (b1:b), (a1 = a2) -> ((get (set m a1 b1) a2) = b1).

Axiom Select_neq : forall (a:Type) (b:Type), forall (m:(t a b)),
  forall (a1:a) (a2:a), forall (b1:b), (~ (a1 = a2)) -> ((get (set m a1 b1)
  a2) = (get m a2)).

Parameter create_const: forall (b:Type) (a:Type), b  -> (t a b).

Set Contextual Implicit.
Implicit Arguments create_const.
Unset Contextual Implicit.

Axiom Const : forall (b:Type) (a:Type), forall (b1:b) (a1:a),
  ((get (create_const(b1):(t a b)) a1) = b1).

Parameter pointer : Type.

Definition next  := (t pointer pointer).

Parameter null:  pointer.


Parameter value:  (t pointer Z).


Parameter next1:  (t pointer pointer).


Inductive is_list : (t pointer pointer) -> pointer -> Prop :=
  | is_list_null : forall (next2:(t pointer pointer)) (p:pointer),
      (p = (null )) -> (is_list next2 p)
  | is_list_next : forall (next3:(t pointer pointer)) (p:pointer),
      (~ (p = (null ))) -> ((is_list next3 (get next3 p)) -> (is_list next3
      p)).

Parameter ft : forall (a:Type), Type.

Parameter in_ft: pointer -> (ft pointer)  -> Prop.


Parameter list_ft: (t pointer pointer) -> pointer  -> (ft pointer).


Axiom list_ft_node_null_cor : forall (next4:(t pointer pointer)) (q:pointer)
  (p:pointer), (q = (null )) -> ~ (in_ft p (list_ft next4 q)).

Axiom list_ft_node_next1 : forall (next5:(t pointer pointer)) (q:pointer)
  (p:pointer), (~ (q = (null ))) -> ((is_list next5 (get next5 q)) ->
  ((in_ft p (list_ft next5 (get next5 q))) -> (in_ft p (list_ft next5 q)))).

Axiom list_ft_node_next2 : forall (next6:(t pointer pointer)) (q:pointer),
  (~ (q = (null ))) -> ((is_list next6 (get next6 q)) -> (in_ft q
  (list_ft next6 q))).

Axiom list_ft_node_next_inv : forall (next7:(t pointer pointer)) (q:pointer)
  (p:pointer), (~ (q = (null ))) -> ((is_list next7 (get next7 q)) ->
  ((~ (q = p)) -> ((in_ft p (list_ft next7 q)) -> (in_ft p (list_ft next7
  (get next7 q)))))).

Theorem frame_list : forall (next8:(t pointer pointer)) (p:pointer)
  (q:pointer) (v:pointer), (~ (in_ft q (list_ft next8 p))) -> ((is_list next8
  p) -> (is_list (set next8 q v) p)).
(* YOU MAY EDIT THE PROOF BELOW *)
intros.
induction H0.
apply (is_list_null _ _ H0).
apply (is_list_next _ _ H0).
assert (q<>p) by (intro eq;apply H;rewrite eq;clear eq;apply (list_ft_node_next2 _ _ H0 H1)).
rewrite (Select_neq _ _ _ _ _ _ H2).
apply IHis_list.
contradict H.
exact (list_ft_node_next1 _ _ _ H0 H1 H).
Qed.
(* DO NOT EDIT BELOW *)


