(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Definition unit  := unit.

Parameter label : Type.

Parameter at1: forall (a:Type), a -> label  -> a.

Implicit Arguments at1.

Parameter old: forall (a:Type), a  -> a.

Implicit Arguments old.

Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Implicit Arguments mk_ref.

Definition contents (a:Type)(u:(ref a)): a :=
  match u with
  | mk_ref contents1 => contents1
  end.
Implicit Arguments contents.

Parameter map : forall (a:Type) (b:Type), Type.

Parameter get: forall (a:Type) (b:Type), (map a b) -> a  -> b.

Implicit Arguments get.

Parameter set: forall (a:Type) (b:Type), (map a b) -> a -> b  -> (map a b).

Implicit Arguments set.

Axiom Select_eq : forall (a:Type) (b:Type), forall (m:(map a b)),
  forall (a1:a) (a2:a), forall (b1:b), (a1 = a2) -> ((get (set m a1 b1)
  a2) = b1).

Axiom Select_neq : forall (a:Type) (b:Type), forall (m:(map a b)),
  forall (a1:a) (a2:a), forall (b1:b), (~ (a1 = a2)) -> ((get (set m a1 b1)
  a2) = (get m a2)).

Parameter const: forall (b:Type) (a:Type), b  -> (map a b).

Set Contextual Implicit.
Implicit Arguments const.
Unset Contextual Implicit.

Axiom Const : forall (b:Type) (a:Type), forall (b1:b) (a1:a), ((get (const(
  b1):(map a b)) a1) = b1).

Parameter pointer : Type.

Axiom pointer_dec : forall (p1:pointer) (p2:pointer), (p1 = p2) \/
  ~ (p1 = p2).

Definition next  := (map pointer pointer).

Parameter null:  pointer.


Parameter value:  (ref (map pointer Z)).


Parameter next1:  (ref (map pointer pointer)).


Inductive is_list : (map pointer pointer) -> pointer -> Prop :=
  | is_list_null : forall (next2:(map pointer pointer)) (p:pointer),
      (p = (null )) -> (is_list next2 p)
  | is_list_next : forall (next2:(map pointer pointer)) (p:pointer),
      (~ (p = (null ))) -> ((is_list next2 (get next2 p)) -> (is_list next2
      p)).

Parameter ft : forall (a:Type), Type.

Parameter in_ft: pointer -> (ft pointer)  -> Prop.


Axiom set_eq : forall (ft1:(ft pointer)) (ft2:(ft pointer)),
  (forall (q:pointer), (in_ft q ft1) <-> (in_ft q ft2)) -> (ft1 = ft2).

Parameter list_ft: (map pointer pointer) -> pointer  -> (ft pointer).


Axiom list_ft_node_null_cor : forall (next2:(map pointer pointer))
  (q:pointer) (p:pointer), (q = (null )) -> ~ (in_ft p (list_ft next2 q)).

Axiom list_ft_node_next1 : forall (next2:(map pointer pointer)) (q:pointer)
  (p:pointer), (~ (q = (null ))) -> ((is_list next2 (get next2 q)) ->
  ((in_ft p (list_ft next2 (get next2 q))) -> (in_ft p (list_ft next2 q)))).

Axiom list_ft_node_next2 : forall (next2:(map pointer pointer)) (q:pointer),
  (~ (q = (null ))) -> ((is_list next2 (get next2 q)) -> (in_ft q
  (list_ft next2 q))).

Axiom list_ft_node_next_inv : forall (next2:(map pointer pointer))
  (q:pointer) (p:pointer), (~ (q = (null ))) -> ((is_list next2 (get next2
  q)) -> ((~ (q = p)) -> ((in_ft p (list_ft next2 q)) -> (in_ft p
  (list_ft next2 (get next2 q)))))).

Axiom frame_list : forall (next2:(map pointer pointer)) (p:pointer)
  (q:pointer) (v:pointer), (~ (in_ft q (list_ft next2 p))) -> ((is_list next2
  p) -> (is_list (set next2 q v) p)).

Definition sep_node_list(next2:(map pointer pointer)) (p1:pointer)
  (p2:pointer): Prop := ~ (in_ft p1 (list_ft next2 p2)).

Theorem frame_list_ft : forall (next2:(map pointer pointer)) (p:pointer)
  (q:pointer) (v:pointer), (~ (in_ft q (list_ft next2 p))) -> ((is_list next2
  p) -> ((list_ft next2 p) = (list_ft (set next2 q v) p))).
(* YOU MAY EDIT THE PROOF BELOW *)
intros.
apply set_eq.
intros.
split;intro.
(** First part *)
induction H0.
apply (list_ft_node_null_cor _ _ _ H0) in H1;contradiction.
(* some asserts *)
assert (q<>p) by (intro eq;apply H;rewrite eq;clear eq;apply (list_ft_node_next2 _ _ H0 H2)).
assert  (H2' : is_list (set next2 q v) (get (set next2 q v) p))
by (rewrite (Select_neq _ _ _ _ _ v H3);refine (frame_list _ _ _ _ _ H2);contradict H;exact (list_ft_node_next1 _ _ _ H0 H2 H)).
(* *)
destruct (pointer_dec p q0).
rewrite <- H4.
exact (list_ft_node_next2 _ p H0 H2').
(* p <> q0 *)
apply (list_ft_node_next1 _ _ _ H0 H2').
rewrite (Select_neq _ _ _ _ _ _ H3).
apply IHis_list.
contradict H;exact (list_ft_node_next1 _ _ _ H0 H2 H).
exact (list_ft_node_next_inv _ _ _ H0 H2 H4 H1).
(** Second part *)
induction H0.
apply (list_ft_node_null_cor _ _ _ H0) in H1;contradiction.
(* some asserts *)
assert (q<>p) by (intro eq;apply H;rewrite eq;clear eq;apply (list_ft_node_next2 _ _ H0 H2)).
assert  (H2' : is_list (set next2 q v) (get (set next2 q v) p))
by (rewrite (Select_neq _ _ _ _ _ v H3);refine (frame_list _ _ _ _ _ H2);contradict H;exact (list_ft_node_next1 _ _ _ H0 H2 H)).
(* *)
destruct (pointer_dec p q0).
rewrite <- H4.
exact (list_ft_node_next2 _ p H0 H2).
(* p <> q0 *)
apply (list_ft_node_next1 _ _ _ H0 H2).
apply IHis_list.
contradict H;exact (list_ft_node_next1 _ _ _ H0 H2 H).
rewrite <- (Select_neq _ _ _ _ _ v H3).
exact (list_ft_node_next_inv _ _ _ H0 H2' H4 H1).
Qed.
(* DO NOT EDIT BELOW *)


