(* VSTTE'10 competition http://www.macs.hw.ac.uk/vstte10/Competition.html
   Problem 4: N-queens *)

module M

  use import int.Int
  use import module stdlib.Array

  logic consistent_row (board : map int) (pos : int) (q : int) = 
    board[q] <> board[pos] and
    board[q] - board[pos] <> pos - q and
    board[pos] - board[q] <> pos - q

  logic is_consistent (board : map int) (pos : int) =
    forall q:int. 0 <= q < pos -> consistent_row board pos q

  lemma Is_consistent_set :
    forall board : map int, pos q i : int.
    is_consistent board pos -> pos < q -> is_consistent board[q <- i] pos

exception Inconsistent

let check_is_consistent (board : array int) pos =
  { 0 <= pos < length board }
  try
    for q = 0 to pos-1 do
      invariant { forall j:int. 0 <= j < q -> consistent_row board pos j }
      let bq   = board[q]   in
      let bpos = board[pos] in
      if bq = bpos then begin
        assert { not (consistent_row board pos q) }; (* to help the provers *)
	raise Inconsistent 
      end;
      if bq - bpos = pos - q then raise Inconsistent;
      if bpos - bq = pos - q then raise Inconsistent 
    done;
    True
  with Inconsistent ->
    False
  end
  { result=True <-> is_consistent board pos }

  logic is_board (board : map int) (pos : int) =
    forall q:int. 0 <= q < pos -> 0 <= board[q] < length board

  logic solution (board : map int) (pos : int) =
    is_board board pos and
    forall q:int. 0 <= q < pos -> is_consistent board q

  logic eq_board (b1 b2 : map int) (pos : int) =
    forall q:int. 0 <= q < pos -> b1[q] = b2[q]

  lemma eq_board_extension :
    forall b1 b2 : map int, pos : int.
    eq_board b1 b2 pos -> b1[pos] = b2[pos] -> eq_board b1 b2 (pos+1)

  lemma arith1 : forall x y : int. x < y+1 -> x <= y
  lemma arith2 : forall x y : int. x < y -> x+1 <= y

  lemma Is_consistent_eq :
    forall b1 b2 : map int, pos : int.
    eq_board b1 b2 (pos+1) -> is_consistent b1 pos -> is_consistent b2 pos

  lemma Solution_eq_board :
    forall b1 b2 : map int, pos : int. length b1 = length b2 ->
    eq_board b1 b2 pos -> solution b1 pos -> solution b2 pos

  lemma Eq_board_set :
    forall b : map int, pos q i : int.
    pos <= q -> eq_board b b[q <- i] pos

  lemma Eq_board_sym :
    forall b1 b2 : map int, pos : int.
    eq_board b1 b2 pos -> eq_board b2 b1 pos

  lemma Eq_board_trans :
    forall b1 b2 b3 : map int, pos : int.
    eq_board b1 b2 pos -> eq_board b2 b3 pos -> eq_board b1 b3 pos

exception Solution

let rec bt_queens (board : array int) n pos variant { n - pos } =
  { length board = n and 0 <= pos <= n and solution board pos }
  label Init:( (* FIXME *)
  if pos = n then raise Solution;
  for i = 0 to n - 1 do
    invariant { 
      length board = n and eq_board board (at board Init) pos and
      forall b:map int. length b = n -> is_board b n -> 
        eq_board board b pos -> 0 <= b[pos] < i -> not (solution b n) }
    board[pos <- i];
    assert { eq_board board (at board Init) pos };
    if check_is_consistent board pos then bt_queens board n (pos+1)
  done)
  { (* no solution *) 
    length board = n and eq_board board (old board) pos and
    forall b:map int. length b = n -> is_board b n -> 
      eq_board board b pos -> not (solution b n) }
  | Solution -> 
  { (* a solution *)
    solution board n }

let queens (board : array int) n =
  { length board = n }
  bt_queens board n 0
  { forall b:map int. length b = n -> is_board b n -> not (solution b n) }
  | Solution -> { solution board n }

end

(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/vstte10_queens.gui"
End: 
*)
