
(*
   ACM Portugese National Programming Contest (MIUP) 2010

   Given an integer X >= 0, with N digits, and another integer Y > 0,
   find the smallest Z > X such that digit_sum(Z) = Y.

   Ocaml code given at the end of file.
*)

{
  use array.ArrayLength as A
  use import int.MinMax
  use import int.EuclideanDivision
  use import int.Power

  type array 'a = A.t int 'a

  logic (#) (a : array 'a) (i : int) : 'a = A.get a i

  logic sum_digits int : int

  axiom Sum_digits_def : forall n : int. sum_digits n =
    if n <= 0 then 0 else sum_digits (div n 10) + mod n 10

  (* interp x i j is the integer X[j-1]...X[i] *)

  logic interp (array int) int int : int

  axiom Interp_1 : 
    forall x : array int, i j : int. 
    i >= j -> interp x i j = 0
  { A.length !x = m and is_integer !x }

  axiom Interp_2 :
    forall x : array int, i j : int. 
    i < j -> interp x i j = x#i + 10 * interp x (i+1) j

  (* shortcut for sum_digits (interp x i j) *)
  logic sum_digits_a (x : array int) (i j : int) : int =
    sum_digits (interp x i j)

  (* to allow provers to prove that an assignment does not change the
     interpretation on the left (or on the right); requires induction *)
  lemma Interp_eq:
    forall x1 x2 : array int, i j : int. 
    (forall k : int. i <= k < j -> x1#k = x2#k) -> interp x1 i j = interp x2 i j

  lemma Sum_digits_a_eq:
    forall x1 x2 : array int, i j : int. 
    (forall k : int. i <= k < j -> x1#k = x2#k) -> 
    sum_digits_a x1 i j = sum_digits_a x2 i j

  lemma Sum_digits_a_set_eq:
    forall x : array int, i j k v : int.
    (k < i or k >= j) -> sum_digits_a (A.set x k v) i j = sum_digits_a x i j

  lemma Interp_sum_digits_left:
    forall x : array int, i j : int. i < j ->
    sum_digits_a x i j = sum_digits_a x i (j-1) + x#(j-1)

  lemma Interp_sum_digits_right:
    forall x : array int, i j : int. i < j ->
    sum_digits_a x i j = x#i + sum_digits_a x (i+1) j

  lemma Interp_sum_digits_trans:
    forall x : array int, i k j : int. i <= k <= j ->
    sum_digits_a x i j = 
    sum_digits_a x i k + sum_digits_a x k j

  (* interp9 X i j is the j-digit integer obtained by replacing the i least
     significant digits in X by 9, i.e. X[j-1]...X[i]9...9 *)

  logic interp9 (x : array int) (i j : int) : int =
    power 10 i * (interp x i j + 1) - 1

  lemma Interp9_step:
    forall x : array int, i j : int.
    i < j -> interp9 (A.set x i 9) i j = interp9 x (i+1) j

}

let array_get (a : ref (array 'a)) i = 
  { 0 <= i < A.length !a } A.get !a i { result = A.get !a i }

let array_set (a : ref (array 'a)) i v = 
  { 0 <= i < A.length !a } a := A.set !a i v { !a = A.set (old !a) i v }

parameter x : ref (array int)

{ 
  (* the number of digis of X *)
  logic n : int

  (* the target digit sum *)
  logic y : int

  axiom Hypotheses: n >= 0 and y > 0
  
  logic m : int = 1 + max n (div y 9)

}

exception Success

(* 1. Safety: we only prove that array access are within bounds 
   (and termination, implicitely proved since we only have for loops) *)

let search_safety () = 
  { A.length !x = m }
  label Init:
  let s = ref 0 in
  for i = 0 to m - 1 do (* could be n instead of m *)
    s := !s + array_get x i 
  done;
  for d = 0 to m - 1 do
    invariant { A.length !x = m } 
    for c = array_get x d + 1 to 9 do
      invariant { A.length !x = m } 
      let delta = y - !s - c + array_get x d in
      if 0 <= delta && delta <= 9 * d then begin
        array_set x d c;
	let k = div delta 9 in
        for i = 0 to d - 1 do 
          invariant { A.length !x = m } 
          if i < k then array_set x i 9
	  else if i = k then array_set x i (mod delta 9)
          else array_set x i 0
        done;
        raise Success
      end
    done;
    s := !s - array_get x d
  done
  { true } | Success -> { true }

(* 2. Correctness, part 1: when Sucess is raised, x contains an integer
      with digit sum y *)

{
  (* x[0..m-1] is a well-formed integer i.e. has digits in 0..9 *)
  logic is_integer (x : array int) =
    forall k : int. 0 <= k < m -> 0 <= x#k <= 9
}

let search () =
  { A.length !x = m and is_integer !x }
  label Init:
  let s = ref 0 in
  for i = 0 to m - 1 do (* could be n instead of m *)
    invariant { !s = sum_digits_a !x 0 i } 
    s := !s + array_get x i 
  done;
  assert { !s = sum_digits_a !x 0 m };
  for d = 0 to m - 1 do
    invariant { 
      !x = at !x Init and
      !s = sum_digits_a !x d m 
    } 
    for c = array_get x d + 1 to 9 do
      invariant { !x = at !x Init } 
      let delta = y - !s - c + array_get x d in
      if 0 <= delta && delta <= 9 * d then begin
        array_set x d c;
        assert { sum_digits_a !x d m = y - delta };
	let k = div delta 9 in
        assert { k <= d };
        for i = 0 to d - 1 do 
          invariant { A.length !x = m and is_integer !x and
                      sum_digits_a !x d m = y - delta and
                      sum_digits_a !x 0 i = if i <= k then 9*i else delta } 
          if i < k then array_set x i 9
	  else if i = k then array_set x i (mod delta 9)
          else array_set x i 0
        done;
        (* assume { sum_digits_a !x 0 d = delta }; *)
        assert { sum_digits_a !x 0 d = delta };
        raise Success
      end
    done;
    s := !s - array_get x d
  done
  { true } 
  | Success -> { is_integer !x and sum_digits_a !x 0 m = y }

(* 3. Correctness, part 2: we now prove that, on success, x contains the
   smallest integer > old(x) with digit sum y 

   4. Completeness: we always raise the Success exception *)

{
  (* x1 > x2 since x1[d] > x2[d] and x1[d+1..m-1] = x2[d+1..m-1] *)
  logic gt_digit (x1 x2 : array int) (d : int) =
    is_integer x1 and is_integer x2 and 0 <= d < m and 
    x1#d > x2#d and forall k : int. d < k < m -> x1#k = x2#k
    
  lemma Gt_digit_interp:
    forall x1 x2 : array int, d : int.
    gt_digit x1 x2 d -> interp x1 0 m > interp x2 0 m

  lemma Gt_digit_update:
    forall x1 x2 : array int, d i v : int.
    gt_digit x1 x2 d -> 0 <= i < d -> 0 <= v <= 9 ->
    gt_digit (A.set x1 i v) x2 d

  (* the number of digits of a given integer *)
  logic nb_digits int : int

  lemma Nb_digits_0 :
    nb_digits 0 = 0
    
  axiom Nb_digits_def :
    forall y : int. y > 0 -> nb_digits y = 1 + nb_digits (div y 10)

  (* the smallest integer with digit sum y is (y mod 9)9..9
     with exactly floor(y/9) trailing 9s *)

  logic smallest int : array int

  logic smallest_size int : int

  axiom Smallest_size_def0:
    smallest_size 0 = 0

  axiom Smallest_size_def1:
    forall y : int. y > 0 -> 
    smallest_size y = if mod y 9 = 0 then div y 9 else 1 + div y 9

  (* smallest(y) is an integer *)
  axiom Smallest_def1:
    forall y : int. y >= 0 -> 
    forall k : int. 0 <= k < smallest_size y -> 0 <= smallest y # k <= 9

  (* smallest(y) has digit sum y *)
  axiom Smallest_def2:
    forall y : int. y >= 0 -> 
    sum_digits_a (smallest y) 0 (smallest_size y) = y

  (* smallest(y) is the smallest integer with digit sum y *)
  axiom Smallest_def3:
    forall y : int. y >= 0 ->
    forall u : int. 0 <= u < interp (smallest y) 0 (smallest_size y) -> 
    sum_digits u <> y

  lemma Smallest_shape_1:
    forall y : int. y >= 0 -> mod y 9 = 0 ->
    forall k : int. 0 <= k < smallest_size y -> smallest y # k = 9
    
  lemma Smallest_shape_2:
    forall y : int. y >= 0 -> mod y 9 <> 0 ->
    (forall k : int. 0 <= k < smallest_size y - 1 -> smallest y # k = 9) and
    smallest y # (smallest_size y - 1) = mod y 9
    
  lemma Smallest_nb_digits:
    forall y : int. y >= 0 -> 
    nb_digits (interp (smallest y) 0 (smallest_size y)) = smallest_size y

  lemma Any_nb_digits_above_smallest_size:
    forall y : int. y > 0 -> 
    forall d : int. d >= smallest_size y -> 
    exists u : int. nb_digits u = d and digit_sum u = y

  (* TODO: lemma Completeness: there exists an integer u with m digits and
     digit sum y *)

}

let search_smallest () =
  { A.length !x = m and is_integer !x 
    (* FIXME: x has at most n digits *) }
  label Init:
  let s = ref 0 in
  for i = 0 to m - 1 do (* could be n instead of m *)
    invariant { !s = sum_digits_a !x 0 i } 
    s := !s + array_get x i 
  done;
  assert { !s = sum_digits_a !x 0 m };
  for d = 0 to m - 1 do
    invariant { 
      !x = at !x Init and
      !s = sum_digits_a !x d m and
      forall u : int. 
         interp (at !x Init) 0 m < u < interp9 !x d m -> sum_digits u <> y
                           (* FIXME? <= *)
    } 
    for c = array_get x d + 1 to 9 do
      invariant { 
        !x = at !x Init and
	forall c' : int. !x # d < c' < c -> 
          forall u : int. 
          interp (at !x Init) 0 m < u < interp9 (A.set !x d c') d m -> 
                                      (* FIXME? *)
  	  sum_digits u <> y } 
      let delta = y - !s - c + array_get x d in
      if 0 <= delta && delta <= 9 * d then begin
        assert { smallest_size delta <= d };
        array_set x d c;
        assert { sum_digits_a !x d m = y - delta };
        assert { gt_digit !x (at !x Init) d };
	let k = div delta 9 in
        assert { k <= d };
        for i = 0 to d - 1 do 
          invariant { 
	     A.length !x = m and is_integer !x and
             sum_digits_a !x d m = y - delta and
             sum_digits_a !x 0 i = (if i <= k then 9*i else delta) and 
             (forall j : int. 0 <= j < i -> 
                (j <  smallest_size delta -> !x # j = smallest delta # j) and
                (j >= smallest_size delta -> !x # j = 0)) and
             gt_digit !x (at !x Init) d } 
          if i < k then array_set x i 9
	  else if i = k then array_set x i (mod delta 9)
          else array_set x i 0;
          assert { is_integer !x }
        done;
        assert { sum_digits_a !x 0 d = delta };
        assert { interp !x 0 d = interp (smallest delta) 0 d };
        raise Success
      end
    done;
    s := !s - array_get x d
  done
  { false } 
  | Success -> { is_integer !x and sum_digits_a !x 0 m = y and
                 interp !x 0 m > interp (old !x) 0 m and
                 forall u : int. interp (old !x) 0 m < u < interp !x 0 m ->
                                 sum_digits u <> y }


(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/next_digit_sum"
End: 
*)



(*
let ys = Sys.argv.(1)
let zs = Sys.argv.(2)
let n = String.length zs
let y = int_of_string ys

let max_digits = 1 + max n (y / 9)
let x = Array.create max_digits 0
let () = 
  for i = 0 to n - 1 do x.(n - 1 - i) <- Char.code zs.[i] - Char.code '0' done

let () =
  let s = ref 0 in
  for i = 0 to max_digits - 1 do s := !s + x.(i) done;
  for d = 0 to max_digits - 1 do
    (* s is the sum of digits d..n-1 *)
    (* solution with digits > d intacts, and digit d increased by 1 or more *)
    for c = x.(d) + 1 to 9 do
      let delta = y - !s - c + x.(d) in
      if 0 <= delta && delta <= 9 * d then begin
	x.(d) <- c;
	let k = delta / 9 in
	for i = 0 to d-1 do 
	  x.(i) <- if i < k then 9 else if i = k then delta mod 9 else 0
	done;
	for i = max d (n-1) downto 0 do Format.printf "%d" x.(i) done;
	Format.printf "@.";
	exit 0
      end
    done;
    s := !s - x.(d)
  done
*)
