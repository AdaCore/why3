
(*
   ACM Portugese National Programming Contest (MIUP) 2010

   Given an integer X >= 0, with N digits, and another integer Y > 0,
   find the smallest Z > X such that digit_sum(Z) = Y.

   Ocaml code given at the end of file.
*)

{
  use array.ArrayLength as A
  use import int.MinMax
  use import int.EuclideanDivision
  use import int.Power

  type array 'a = A.t int 'a

  logic (#) (a : array 'a) (i : int) : 'a = A.get a i

  logic sum_digits int : int

  axiom Sum_digits_def : forall n : int. sum_digits n =
    if n <= 0 then 0 else sum_digits (div n 10) + mod n 10

  (* interp x i j is the integer X[j-1]...X[i] *)

  logic interp (array int) int int : int

  axiom Interp_1 : 
    forall x : array int, i j : int. 
    i >= j -> interp x i j = 0

  axiom Interp_2 :
    forall x : array int, i j : int. 
    i < j -> interp x i j = x#i + 10 * interp x (i+1) j

  (* shortcut for sum_digits (interp x i j) *)
  logic sum_digits_a (x : array int) (i j : int) : int =
    sum_digits (interp x i j)

  (* interp9 X i j is the j-digit integer obtained by replacing the i least
     significant digits in X by 9, i.e. X[j-1]...X[i]9...9 *)

  logic interp9 (x : array int) (i j : int) : int =
    power 10 i * (interp x i j + 1) - 1

  (* to allow provers to prove that an assignment does not change the
     interpretation on the left (or on the right); requires induction *)
  lemma Interp_eq:
    forall x1 x2 : array int, i j : int. 
    (forall k : int. i <= k < j -> x1#k = x2#k) -> interp x1 i j = interp x2 i j

  lemma Sum_digits_a_eq:
    forall x1 x2 : array int, i j : int. 
    (forall k : int. i <= k < j -> x1#k = x2#k) -> 
    sum_digits_a x1 i j = sum_digits_a x2 i j

  lemma Sum_digits_a_set_eq:
    forall x : array int, i j k v : int.
    (k < i or k >= j) -> sum_digits_a (A.set x k v) i j = sum_digits_a x i j

  lemma Interp_sum_digits_left:
    forall x : array int, i j : int. i < j ->
    sum_digits_a x i j = sum_digits_a x i (j-1) + x#(j-1)

  lemma Interp_sum_digits_right:
    forall x : array int, i j : int. i < j ->
    sum_digits_a x i j = x#i + sum_digits_a x (i+1) j

  lemma Interp_sum_digits_trans:
    forall x : array int, i k j : int. i <= k <= j ->
    sum_digits_a x i j = 
    sum_digits_a x i k + sum_digits_a x k j

}

let array_get (a : ref (array 'a)) i = 
  { 0 <= i < A.length !a } A.get !a i { result = A.get !a i }

let array_set (a : ref (array 'a)) i v = 
  { 0 <= i < A.length !a } a := A.set !a i v { !a = A.set (old !a) i v }

parameter x : ref (array int)

{ 
  (* the number of digis of X *)
  logic n : int

  (* the target digit sum *)
  logic y : int

  axiom Hypotheses: n >= 0 and y > 0
  
  logic m : int = 1 + max n (div y 9)

  (* x[0..m-1] is a well-formed integer i.e. has digits in 0..9 *)
  logic is_integer (x : array int) =
    forall k : int. 0 <= k < m -> 0 <= x#k <= 9

  (* x1 > x2 since x1[d] > x2[d] and x1[d+1..m-1] = x2[d+1..m-1] *)
  logic gt_digit (x1 x2 : array int) (d : int) =
    is_integer x1 and is_integer x2 and 0 <= d < m and 
    x1#d > x2#d and forall k : int. d < k < m -> x1#k = x2#k
    
  lemma Gt_digit_interp:
    forall x1 x2 : array int, d : int.
    gt_digit x1 x2 d -> interp x1 0 m > interp x2 0 m
}

exception Success

(* 1. Safety: we only prove that array access are within bounds 
   (and termination, implicitely proved since we only have for loops) *)

let search_safety () = 
  { A.length !x = m }
  label Init:
  let s = ref 0 in
  for i = 0 to m - 1 do (* could be n instead of m *)
    s := !s + array_get x i 
  done;
  for d = 0 to m - 1 do
    invariant { A.length !x = m } 
    for c = array_get x d + 1 to 9 do
      invariant { A.length !x = m } 
      let delta = y - !s - c + array_get x d in
      if 0 <= delta && delta <= 9 * d then begin
        array_set x d c;
	let k = div delta 9 in
        for i = 0 to d - 1 do 
          invariant { A.length !x = m } 
          if i < k then array_set x i 9
	  else if i = k then array_set x i (mod delta 9)
          else array_set x i 0
        done;
        raise Success
      end
    done;
    s := !s - array_get x d
  done
  { true } | Success -> { true }

(* 2. Correctness, part 1: when Sucess is raised, x contains an integer
      with digit sum y *)

let search () =
  { A.length !x = m and is_integer !x }
  label Init:
  let s = ref 0 in
  for i = 0 to m - 1 do (* could be n instead of m *)
    invariant { !s = sum_digits_a !x 0 i } 
    s := !s + array_get x i 
  done;
  assert { !s = sum_digits_a !x 0 m };
  for d = 0 to m - 1 do
    invariant { 
      !x = at !x Init and
      !s = sum_digits_a !x d m 
    } 
    for c = array_get x d + 1 to 9 do
      invariant { !x = at !x Init } 
      let delta = y - !s - c + array_get x d in
      if 0 <= delta && delta <= 9 * d then begin
        array_set x d c;
        assert { sum_digits_a !x d m = y - delta };
	let k = div delta 9 in
        assert { k <= d };
        for i = 0 to d - 1 do 
          invariant { A.length !x = m and is_integer !x and
                      sum_digits_a !x d m = y - delta and
                      sum_digits_a !x 0 i = if i <= k then 9*i else delta } 
          if i < k then array_set x i 9
	  else if i = k then array_set x i (mod delta 9)
          else array_set x i 0
        done;
        (* assume { sum_digits_a !x 0 d = delta }; *)
        assert { sum_digits_a !x 0 d = delta };
        raise Success
      end
    done;
    s := !s - array_get x d
  done
  { true } 
  | Success -> { is_integer !x and sum_digits_a !x 0 m = y }

(* 3. Correctness, part 2: we now prove that, on success, x contains the
   smallest integer > old(x) with digit sum y *)

let search_smallest () =
  { A.length !x = m and is_integer !x }
  label Init:
  let s = ref 0 in
  for i = 0 to m - 1 do (* could be n instead of m *)
    invariant { !s = sum_digits_a !x 0 i } 
    s := !s + array_get x i 
  done;
  assert { !s = sum_digits_a !x 0 m };
  for d = 0 to m - 1 do
    invariant { 
      !x = at !x Init and
      !s = sum_digits_a !x d m 
    } 
    for c = array_get x d + 1 to 9 do
      invariant { !x = at !x Init } 
      let delta = y - !s - c + array_get x d in
      if 0 <= delta && delta <= 9 * d then begin
        array_set x d c;
        assert { sum_digits_a !x d m = y - delta };
	let k = div delta 9 in
        assert { k <= d };
        for i = 0 to d - 1 do 
          invariant { A.length !x = m and is_integer !x and
                      sum_digits_a !x d m = y - delta and
                      sum_digits_a !x 0 i = (if i <= k then 9*i else delta) and 
                      gt_digit !x (at !x Init) d } 
          if i < k then array_set x i 9
	  else if i = k then array_set x i (mod delta 9)
          else array_set x i 0;
          assert { is_integer !x }
        done;
        assert { sum_digits_a !x 0 d = delta };
        raise Success
      end
    done;
    s := !s - array_get x d
  done
  { true } 
  | Success -> { is_integer !x and sum_digits_a !x 0 m = y and
                 interp !x 0 m > interp (old !x) 0 m }

(* 4. Completeness: we always raise the Success exception *)

(*
    (n = 0 or !x#(n-1) <> 0) and
    (forall i:int. 0 <= i < n -> 0 <= !x#i <= 9) and
    (forall i:int. n <= i < m -> !x#i = 0)
*)


(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/next_digit_sum"
End: 
*)



(*
let ys = Sys.argv.(1)
let zs = Sys.argv.(2)
let n = String.length zs
let y = int_of_string ys

let max_digits = 1 + max n (y / 9)
let x = Array.create max_digits 0
let () = 
  for i = 0 to n - 1 do x.(n - 1 - i) <- Char.code zs.[i] - Char.code '0' done

let () =
  let s = ref 0 in
  for i = 0 to max_digits - 1 do s := !s + x.(i) done;
  for d = 0 to max_digits - 1 do
    (* s is the sum of digits d..n-1 *)
    (* solution with digits > d intacts, and digit d increased by 1 or more *)
    for c = x.(d) + 1 to 9 do
      let delta = y - !s - c + x.(d) in
      if 0 <= delta && delta <= 9 * d then begin
	x.(d) <- c;
	let k = delta / 9 in
	for i = 0 to d-1 do 
	  x.(i) <- if i < k then 9 else if i = k then delta mod 9 else 0
	done;
	for i = max d (n-1) downto 0 do Format.printf "%d" x.(i) done;
	Format.printf "@.";
	exit 0
      end
    done;
    s := !s - x.(d)
  done
*)
