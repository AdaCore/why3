
(*
   ACM Portugese National Programming Contest (MIUP) 2010

   Given an integer X >= 0, with N digits, and another integer Y > 0,
   find the smallest Z > X such that digit_sum(Z) = Y.

   Ocaml code given at the end of file.
*)

{
  use array.ArrayLength as A
  use import int.MinMax
  use import int.EuclideanDivision
  use import int.Power

  type array 'a = A.t int 'a

  logic (#) (a : array 'a) (i : int) : 'a = A.get a i

  logic sum_digits (n:int) : int =
    if n = 0 then 0 else sum_digits (div n 10) + mod n 10

  (* interp x i j is the integer X[j-1]...X[i] *)

  logic interp (array int) int int : int

  axiom Interp_1 : 
    forall x : array int, i j : int. 
    i >= j -> interp x i j = 0

  axiom Interp_2 :
    forall x : array int, i j : int. 
    i < j -> interp x i j = x#i + 10 * interp x (i+1) j

  (* interp9 X i j is the j-digit integer obtained by replacing the i least
     significant digits in X by 9, i.e. X[j-1]...X[i]9...9 *)

  logic interp9 (x : array int) (i j : int) : int =
    power 10 i * (interp x i j + 1) - 1

  (* to allow provers to prove that an assignment does not change the
     interpretation on the left (or on the right); requires induction *)
  lemma Interp_sum_eq:
    forall x1 x2 : array int, i j : int. 
    (forall k : int. i <= k < j -> x1#k = x2#k) -> interp x1 i j = interp x2 i j

  lemma Interp_sum_digit_left:
    forall x : array int, i j : int. i < j ->
    sum_digits (interp x i j) = sum_digits (interp x i (j-1)) + x#(j-1)

  lemma Interp_sum_digit_right:
    forall x : array int, i j : int. i < j ->
    sum_digits (interp x i j) = x#i + sum_digits (interp x (i+1) j)

  lemma Interp_sum_trans:
    forall x : array int, i k j : int. i <= k <= j ->
    sum_digits (interp x i j) = 
    sum_digits (interp x i k) + sum_digits (interp x k j)
}

let array_get (a : ref (array 'a)) i = 
  { 0 <= i < A.length !a } A.get !a i { result = A.get !a i }

let array_set (a : ref (array 'a)) i v = 
  { 0 <= i < A.length !a } a := A.set !a i v { !a = A.set (old !a) i v }

parameter x : ref (array int)

{ 
  logic n : int
  logic y : int
  
  logic m : int = 1 + max n (div y 9)
}

exception Success

let search () =
  { n >= 0 and y > 0 and A.length !x = m and
    (n = 0 or !x#(n-1) <> 0) and
    (forall i:int. 0 <= i < n -> 0 <= !x#i <= 9) and
    (forall i:int. n <= i < m -> !x#i = 0) }
  label Init:
  let s = ref 0 in
  let i = ref 0 in
  while !i < m do (* could be n instead of m *)
    invariant { 0 <= !i <= m and !s = sum_digits (interp !x 0 !i) } 
    variant { m - !i }
    s := !s + array_get x !i; 
    i := !i + 1 
  done;
  assert { !s = sum_digits (interp !x 0 m) };
  let d = ref 0 in
  while !d < m do
    invariant { 
      0 <= !d <= m and !x = at !x Init and
      !s = sum_digits (interp !x !d m) 
    } 
    variant { m - !d }
    let c = ref (array_get x !d) in
    while !c <= 9 do
      invariant { !x # !d <= !c <= 10 and !x = at !x Init } 
      variant { 10 - !c }
      let delta = y - !s - !c + array_get x !d in
      if 0 <= delta && delta <= 9 * !d then begin
        array_set x !d !c;
        assert { sum_digits (interp !x !d m) = y - delta };
	let k = div delta 9 in
        assert { k <= !d };
        i := 0;
	while !i < k do 
 	  invariant { 0 <= !i <= k and A.length !x = m } variant { k - !i }
          array_set x !i 9; i := !i + 1
        done;
        array_set x !i (mod delta 9);
        i := !i + 1;
        while !i < !d do 
          invariant { k+1 <= !i and A.length !x = m } variant { !d - !i }
	  array_set x !i 0; i := !i + 1 
	done;
        assume { sum_digits (interp !x 0 !d) = delta };
        raise Success
      end;
      c := !c + 1
    done;
    s := !s - array_get x !d;
    d := !d + 1
  done
  { true(*false*) } 
  | Success -> 
    { true (*sum_digits (interp !x 0 m) = y*) }

(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/next_digit_sum"
End: 
*)



(*
let s = Sys.argv.(1)
let n = String.length s
let y = int_of_string Sys.argv.(2)

let max_digits = 1 + max n (y / 9)
let x = Array.create max_digits 0
let () = 
  for i = 0 to n - 1 do x.(n - 1 - i) <- Char.code s.[i] - Char.code '0' done

let () =
  let s = ref 0 in
  for i = 0 to max_digits - 1 do s := !s + x.(i) done;
  for d = 0 to max_digits - 1 do
    (* s is the sum of digits d..n-1 *)
    (* solution with digits > d intacts, and digit d increased by 1 or more *)
    for c = x.(d) + 1 to 9 do
      let delta = y - !s - c + x.(d) in
      if 0 <= delta && delta <= 9 * d then begin
	x.(d) <- c;
	let k = delta / 9 in
	for i = 0 to d-1 do 
	  x.(i) <- if i < k then 9 else if i = k then delta mod 9 else 0
	done;
	for i = max d (n-1) downto 0 do printf "%d" x.(i) done;
	printf "@.";
	exit 0
      end
    done;
    s := !s - x.(d)
  done
*)
