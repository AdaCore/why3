module M

  use import module stdlib.Ref

(* Red-black trees *)

  type key = int
  type value = int

  type color = Red | Black

  type tree =
    | Leaf 
    | Node color tree key value tree

  logic memt (t : tree) (k : key) (v : value) = 
    match t with
    | Leaf -> false
    | Node _ l k' v' r -> (k = k' and v = v') or memt l k v or memt r k v
    end

exception Not_found

parameter find :
  t : tree -> k : key -> 
  { }
  value raises Not_found
  { memt t k result } | Not_found -> { forall v : value. not (memt t k v) }

parameter add :
  t : tree -> k : key -> v : value ->
  {}
  tree
  { memt result k v and
    forall k':key, v':value. 
    memt result k' v' <-> if k' = k then v' = v else memt t k' v' }

(* the VACID-0 interface = mutable map with default value*)

  type rbt = (value, tree)

  logic default (r : rbt) : value =
    let (d, _) = r in d

  logic mem (r : rbt) (k : key) (v : value) =
    let (d, t) = r in 
    memt t k v or (v = d and forall v':value. not (memt t k v'))

let create d =
  { }
  let x = (d, Leaf) in ref x (* BUG: ref (d, Leaf) *)
  { default result = d and
    forall k:key, v:value. mem result k v <-> v = d }

let replace (m : ref rbt) k v =
  {} 
  let (d, t) = !m in
  m := (d, add t k v)
  { default m = default (old m) and
    forall k':key, v':value. 
    mem m k' v' <-> if k' = k then v' = v else mem (old m) k' v' }

let lookup (m : ref rbt) k =
  {} 
  let (d, t) = !m in
  try find t k with Not_found -> d end
  { mem m k result }

(* the easy way: implements "remove" using "replace" *)
let remove (m : ref rbt) k =
  { } 
  replace m k (default !m)
  { default m = default (old m) and
    forall k':key, v':value. 
    mem m k' v' <-> if k' = k then v' = default m else mem (old m) k' v' }

end

(*
Local Variables: 
compile-command: "unset LANG; make -C ../.. examples/programs/vacid_0_red_black_trees"
End: 
*)
