
(* Verification of the following 2-lines C program solving the N-queens puzzle:

   t(a,b,c){int d=0,e=a&~b&~c,f=1;if(a)for(f=0;d=(e-=d)&-e;f+=t(a-d,(b+d)*2,(
   c+d)/2));return f;}main(q){scanf("%d",&q);printf("%d\n",t(~(~0<<q),0,0));}
*)

theory BitwiseArithmetic

  use export int.Int

  (* logical and *)
  function (&) int int : int

  (* logical shift left *)
  function (<<) int int : int

  (* logical negation *)
  function (~_) int : int

end

theory Bits "the bits of an integer, as a set of integers"

  use export set.Fsetint

  function bits int : set int

  axiom bits_0:
    forall x: int. is_empty (bits x) <-> x = 0

  axiom bits_remove_singleton:
    forall i a b: int. bits b = singleton i -> mem i (bits a) ->
    bits (a - b) = remove i (bits a)

  axiom bits_add_singleton:
    forall i a b: int. bits b = singleton i -> not (mem i (bits a)) ->
    bits (a + b) = add i (bits a)

  axiom bits_mul2_1:
    forall a i: int. mem (i-1) (bits a) -> mem i (bits (a*2))
  axiom bits_mul2_2:
    forall a i: int. mem i (bits (a*2)) -> i >= 1 -> mem (i-1) (bits a)

  use export int.ComputerDivision

  axiom bits_div2_1:
    forall a i: int. mem (i+1) (bits a) -> i >= 0 -> mem i (bits (div a 2))
  axiom bits_div2_2:
    forall a i: int. mem i (bits (div a 2)) -> mem (i+1) (bits a)

  use export BitwiseArithmetic

  axiom bits_diff:
    forall a b: int. bits (a & ~b) = diff (bits a) (bits b)

  axiom rightmost_bit_trick:
    forall x: int. x <> 0 -> bits (x & -x) = singleton (min_elt (bits x))

  axiom bits_below: forall n: int. n >= 0 -> bits (~(~0<<n)) = below n

end

theory Solution

  use import int.Int
  use export map.Map

  function n : int

  type solution = map int int

  (* solutions t and u have the same prefix [0..i[ *)
  predicate eq_prefix (t u: solution) (i: int) =
    forall k: int. 0 <= k < i -> t[k] = u[k]

  (* s stores a partial solution, for the rows 0..k-1 *)
  predicate partial_solution (k: int) (s: solution) =
    forall i: int. 0 <= i < k ->
      0 <= s[i] < n /\
      (forall j: int. 0 <= j < i -> s[i]      <> s[j] /\
                                    s[i]-s[j] <> i-j /\
                                    s[i]-s[j] <> j-i)

  predicate solution (s: solution) = partial_solution n s

  lemma partial_solution_eq_prefix:
    forall u t: solution, k: int.
    partial_solution k t -> eq_prefix t u k -> partial_solution k u

  predicate lt_sol (s1 s2: solution) =
    exists i: int. 0 <= i < n /\ eq_prefix s1 s2 i /\ s1[i] < s2[i]

  type solutions = map int solution

  (* s[a..b[ is sorted for lt_sol *)
  predicate sorted (s: solutions) (a b: int) =
    forall i j: int. a <= i < j < b -> lt_sol s[i] s[j]

end

module NQueens

  use import Bits
  use import module arith.Int
  use import module ref.Refint
  use import module array.Array

  (* warmup 1: termination of the loop *)
  let rec t1 (a b c : int) =
    if a <> 0 then begin
      let e = ref (a & ~b & ~c) in
      let f = ref 0 in
      while !e <> 0 do variant { cardinal (bits !e) }
        let d = !e & (- !e) in
        f += t1 (a - d) ((b+d) * 2) ((c+d)/2);
        e -= d
      done;
      !f
    end else
      1

  (* warmup 2: termination of the recursive function *)
  let rec t2 (a b c : int) variant { cardinal (bits a) } =
    if a <> 0 then begin
      let e = ref (a & ~b & ~c) in
      let f = ref 0 in
      while !e <> 0 do invariant { subset (bits !e) (bits a) }
        let d = !e & (- !e) in
        assert { bits d = singleton (min_elt (bits !e)) };
        assert { bits (a-d) = remove (min_elt (bits !e)) (bits a) };
        f += t2 (a - d) ((b+d) * 2) ((c+d)/2);
        e -= d
      done;
      !f
    end else
      1

  val min_elt (x: int) : { x <> 0 } int { result = min_elt (bits x) }

  use import Solution

  val sol: ref solutions (* all solutions *)
  val s  : ref int       (* next slot for a solution *)
  val k  : ref int       (* current row in the current solution *)

(****

/*@ requires solution(col)
  @ assigns  s, sol[s][0..N()-1]
  @ ensures  s==\old(s)+1 && eq_sol(sol[\old(s)], col)
  @*/
void store_solution();

/*@ requires
  @   0 <= k && k + card(iset(a)) == N() && 0 <= s &&
  @   pre_a:: (\forall int i; in_(i,iset(a)) <=> 
  @            (0<=i<N() && \forall int j; 0<=j<k => i != col[j])) &&
  @   pre_b:: (\forall int i; i>=0 => (in_(i,iset(b)) <=> 
  @            (\exists int j; 0<=j<k && col[j] == i+j-k))) &&
  @   pre_c:: (\forall int i; i>=0 => (in_(i,iset(c)) <=> 
  @            (\exists int j; 0<=j<k && col[j] == i+k-j))) &&
  @   partial_solution(k, col)
  @ assigns
  @   col[k..], s, k, sol[s..][..]
  @ ensures  
  @   \result == s - \old(s) && \result >= 0 && k == \old(k) &&
  @   sorted(sol, \old(s), s) &&
  @   \forall int* t; ((solution(t) && eq_prefix(col,t,k)) <=>
  @                    (\exists int i; \old(s)<=i<s && eq_sol(t, sol[i])))
  @*/
int t3(int a, int b, int c){
  int d, e=a&~b&~c, f=1;
  //@ label L
  if (a)
    /*@ invariant 
      @   included(iset(e),\at(iset(e),L)) &&
      @   f == s - \at(s,L) && f >= 0 && k == \old(k) && 
      @   partial_solution(k, col) &&
      @   sorted(sol, \at(s,L), s) &&
      @   \forall int *t; 
      @     (solution(t) && 
      @      \exists int di; in_(di, diff(\at(iset(e),L), iset(e))) &&
      @          eq_prefix(col,t,k) && t[k]==di) <=>
      @     (\exists int i; \at(s,L)<=i<s && eq_sol(t, sol[i]))
      @ loop_assigns
      @   col[k..], s, k, sol[s..][..]
      @*/
    for (f=0; d=e&-e; e-=d) {
      //@ assert \exists int x; iset(d) == singleton(x) && in_(x,iset(a)) 
      //@ ghost col[k] = min_elt(d);            // ghost code 
      //@ ghost k++;                            // ghost code
      f += t3(a-d, (b+d)*2, (c+d)/2);
      //@ ghost k--;                            // ghost code
    }
  //@ ghost else 
  //@ ghost   store_solution(); // ghost code
  return f;
}

/*@ requires 
  @   n == N() && s == 0 && k == 0
  @ ensures 
  @   \result == s &&
  @   sorted(sol, 0, s) &&
  @   \forall int* t; 
  @      solution(t) <=> (\exists int i; 0<=i<\result && eq_sol(t,sol[i]))
  @*/
int queens(int n) {
  return t3(~(~0<<n),0,0);
}


*****)

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/queens.gui"
End:
*)
