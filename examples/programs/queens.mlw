
(* Verification of the following 2-lines C program solving the N-queens puzzle:

   t(a,b,c){int d=0,e=a&~b&~c,f=1;if(a)for(f=0;d=(e-=d)&-e;f+=t(a-d,(b+d)*2,(
   c+d)/2));return f;}main(q){scanf("%d",&q);printf("%d\n",t(~(~0<<q),0,0));}
*)

theory S "finite sets of with succ and pred operations"

  use export set.Fsetint

  function succ (set int) : set int

  axiom succ_def_1:
    forall s: set int, i: int. mem (i-1) s -> mem i (succ s)
  axiom succ_def_2:
    forall s: set int, i: int. mem i (succ s) -> i >= 1 -> mem (i-1) s

  function pred (set int) : set int

  axiom pred_def_1:
    forall s: set int, i: int. mem (i+1) s -> i >= 0 -> mem i (pred s)
  axiom pred_def__2:
    forall s: set int, i: int. mem i (pred s) -> mem (i+1) s

end

theory Solution

  use import int.Int
  use export map.Map

  (* the number of queens *)
  function n : int

  type solution = map int int

  (* solutions t and u have the same prefix [0..i[ *)
  predicate eq_prefix (t u: map int 'a) (i: int) =
    forall k: int. 0 <= k < i -> t[k] = u[k]

  predicate eq_sol (t u: solution) = eq_prefix t u n

  (* s stores a partial solution, for the rows 0..k-1 *)
  predicate partial_solution (k: int) (s: solution) =
    forall i: int. 0 <= i < k ->
      0 <= s[i] < n /\
      (forall j: int. 0 <= j < i -> s[i]      <> s[j] /\
                                    s[i]-s[j] <> i-j /\
                                    s[i]-s[j] <> j-i)

  predicate solution (s: solution) = partial_solution n s

  lemma partial_solution_eq_prefix:
    forall u t: solution, k: int.
    partial_solution k t -> eq_prefix t u k -> partial_solution k u

  predicate lt_sol (s1 s2: solution) =
    exists i: int. 0 <= i < n /\ eq_prefix s1 s2 i /\ s1[i] < s2[i]

  type solutions = map int solution

  (* s[a..b[ is sorted for lt_sol *)
  predicate sorted (s: solutions) (a b: int) =
    forall i j: int. a <= i < j < b -> lt_sol s[i] s[j]

end

(* 1. Abstract version of the code using sets (not ints) *******************)

module NQueensSets

  use import S
  use import module ref.Refint
  use import Solution

  val col: ref solution  (* solution under construction *)
  val k  : ref int       (* current row in the current solution *)

  val sol: ref solutions (* all solutions *)
  val s  : ref int       (* next slot for a solution = number of solutions *)

  let store_solution () =
    { solution !col }
    sol := !sol[!s <- !col];
    incr s
    { !s = old !s + 1 /\
      eq_prefix (old !sol) !sol (old !s) /\
      !sol[old !s] = !col }

  let rec t3 (a b c : set int) variant { cardinal a } =
    { 0 <= !k /\ !k + cardinal a = n /\
      "pre_a" (forall i: int. mem i a <->
              (0<=i<n /\ forall j: int. 0 <= j < !k -> i <> !col[j])) /\
      "pre_b" (forall i: int. i>=0 -> mem i b <->
              (exists j: int. 0 <= j < !k /\ !col[j] = i + j - !k)) /\
      "pre_c" (forall i: int. i>=0 -> mem i c <->
              (exists j: int. 0 <= j < !k /\ !col[j] = i + !k - j)) /\
     partial_solution !k !col }
    if not (is_empty a) then begin
      let e = ref (diff (diff a b) c) in
   'L:let f = ref 0 in
      while not (is_empty !e) do
        invariant {
          !f = !s - at !s 'L >= 0 /\ !k = at !k 'L /\
          subset !e (at !e 'L) /\
          partial_solution !k !col /\
          sorted !sol (at !s 'L) !s /\
          (forall t: solution.
            (solution t /\ eq_prefix !col t !k /\
             exists di: int. mem di (diff (at !e 'L) !e) /\ t[!k] = di)
            <->
            (exists i: int. (at !s 'L) <= i < !s /\ eq_sol t !sol[i])) /\
          (* assigns *)
          eq_prefix (at !col 'L) !col (at !k 'L) /\
          eq_prefix (at !sol 'L) !sol (at !s 'L) }
        let d = min_elt !e in
        (* ghost *) col := !col[!k <- d];
        (* ghost *) incr k;
        f += t3 (remove d a) (succ (add d b)) (pred (add d c));
        (* ghost *) decr k;
        e := remove d !e
      done;
      !f
    end else begin
      (* ghost *) store_solution ();
      1
    end
    { result = !s - old !s >= 0 /\ !k = old !k /\
      sorted !sol (old !s) !s /\
      (forall t: solution.
         ((solution t /\ eq_prefix !col t !k) <->
          (exists i: int. old !s <= i < !s /\ eq_sol t !sol[i]))) /\
      (* assigns *)
      eq_prefix (old !col) !col !k /\
      eq_prefix (old !sol) !sol (old !s) }

  let queens3 (q: int) =
    { 0 <= q = n /\ !s = 0 /\ !k = 0 }
    t3 (below q) empty empty
    { result = !s /\ sorted !sol 0 !s /\
      forall t: solution.
        solution t <-> (exists i: int. 0 <= i < result /\ eq_sol t !sol[i]) }

end

(* 2. More realistic code with bitwise operations **************************)

theory BitwiseArithmetic

  use export int.Int

  (* logical and *)
  function (&) int int : int

  (* logical shift left *)
  function (<<) int int : int

  (* logical negation *)
  function (~_) int : int

end

theory Bits "the 1-bits of an integer, as a set of integers"

  use export S

  function bits int : set int

  axiom bits_0:
    forall x: int. is_empty (bits x) <-> x = 0

  axiom bits_remove_singleton:
    forall i a b: int. bits b = singleton i -> mem i (bits a) ->
    bits (a - b) = remove i (bits a)

  axiom bits_add_singleton:
    forall i a b: int. bits b = singleton i -> not (mem i (bits a)) ->
    bits (a + b) = add i (bits a)

  axiom bits_mul2:
    forall a: int. bits (a*2) = succ (bits a)

  use export int.ComputerDivision

  axiom bits_div2:
    forall a: int. bits (div a 2) = pred (bits a)

  use export BitwiseArithmetic

  axiom bits_diff:
    forall a b: int. bits (a & ~b) = diff (bits a) (bits b)

  axiom rightmost_bit_trick:
    forall x: int. x <> 0 -> bits (x & -x) = singleton (min_elt (bits x))

  axiom bits_below: forall n: int. n >= 0 -> bits (~(~0<<n)) = below n

end

module NQueens

  use import Bits
  use import module arith.Int
  use import module ref.Refint

  (* warmup 1: termination of the loop *)
  let rec t1 (a b c : int) =
    if a <> 0 then begin
      let e = ref (a & ~b & ~c) in
      let f = ref 0 in
      while !e <> 0 do variant { cardinal (bits !e) }
        let d = !e & (- !e) in
        f += t1 (a - d) ((b+d) * 2) ((c+d)/2);
        e -= d
      done;
      !f
    end else
      1

  (* warmup 2: termination of the recursive function *)
  let rec t2 (a b c : int) variant { cardinal (bits a) } =
    if a <> 0 then begin
      let e = ref (a & ~b & ~c) in
      let f = ref 0 in
      while !e <> 0 do invariant { subset (bits !e) (bits a) }
        let d = !e & (- !e) in
        assert { bits d = singleton (min_elt (bits !e)) };
        assert { bits (a-d) = remove (min_elt (bits !e)) (bits a) };
        f += t2 (a - d) ((b+d) * 2) ((c+d)/2);
        e -= d
      done;
      !f
    end else
      1

  val min_elt (x: int) : { x <> 0 } int { result = min_elt (bits x) }

  use import Solution

  val col: ref solution  (* solution under construction *)
  val k  : ref int       (* current row in the current solution *)

  val sol: ref solutions (* all solutions *)
  val s  : ref int       (* next slot for a solution = number of solutions *)

  let store_solution () =
    { solution !col }
    sol := !sol[!s <- !col];
    incr s
    { !s = old !s + 1 /\
      eq_prefix (old !sol) !sol (old !s) /\
      !sol[old !s] = !col }

  let rec t3 (a b c : int) =
    { 0 <= !k /\ !k + cardinal (bits a) = n /\ 0 <= !s /\
      "pre_a" (forall i: int. mem i (bits a) <->
              (0<=i< n /\ forall j: int. 0 <= j < !k -> i <> !col[j])) /\
      "pre_b" (forall i: int. i>=0 -> mem i (bits b) <->
              (exists j: int. 0 <= j < !k /\ !col[j] = i + j - !k)) /\
      "pre_c" (forall i: int. i>=0 -> mem i (bits c) <->
              (exists j: int. 0 <= j < !k /\ !col[j] = i + !k - j)) /\
     partial_solution !k !col }
    if a <> 0 then begin
      let e = ref (a & ~b & ~c) in
   'L:let f = ref 0 in
      while !e <> 0 do
        invariant {
          !f = !s - at !s 'L >= 0 /\ !k = at !k 'L /\
          subset (bits !e) (at (bits !e) 'L) /\
          partial_solution !k !col /\
          sorted !sol (at !s 'L) !s /\
          (forall t: solution.
            (solution t /\
             exists di: int. mem di (diff (at (bits !e) 'L) (bits !e)) /\
                eq_prefix !col t !k /\ t[!k] = di)
            <->
            (exists i: int. (at !s 'L) <= i < !s /\ eq_sol t !sol[i])) /\
          (* assigns *)
          eq_prefix (at !col 'L) !col (at !k 'L) /\
          eq_prefix (at !sol 'L) !sol (at !s 'L) }
        let d = !e & (- !e) in
        (* assert \exists int x; iset(d) == singleton(x) && in_(x,iset(a)) *)
        assert { bits d = singleton (min_elt (bits !e)) };
        assert { bits (a-d) = remove (min_elt (bits !e)) (bits a) };
        (* ghost *) col := !col[!k <- min_elt d];
        (* ghost *) incr k;
        f += t3 (a - d) ((b+d) * 2) ((c+d)/2);
        (* ghost *) decr k;
        e -= d
      done;
      !f
    end else begin
      (* ghost *) store_solution ();
      1
    end
    { result = !s - old !s >= 0 /\ !k = old !k /\
      sorted !sol (old !s) !s /\
      (forall t: solution.
         ((solution t /\ eq_prefix !col t !k) <->
          (exists i: int. old !s <= i < !s /\ eq_sol t !sol[i]))) /\
      (* assigns *)
      eq_prefix (old !col) !col !k /\
      eq_prefix (old !sol) !sol (old !s) }

  let queens3 (q: int) =
    { 0 <= q = n /\ !s = 0 /\ !k = 0 }
    t3 (~(~0 << q)) 0 0
    { result = !s /\ sorted !sol 0 !s /\
      forall t: solution.
        solution t <-> (exists i: int. 0 <= i < result /\ eq_sol t !sol[i]) }

end

(*
Local Variables:
compile-command: "unset LANG; make -C ../.. examples/programs/queens.gui"
End:
*)
