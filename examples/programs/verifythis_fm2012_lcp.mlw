(*

Longest Common Prefix (LCP) - 45 minutes

VERIFICATION TASK
-----------------

Longest Common Prefix (LCP) is an algorithm used for text querying. In
the following, we model text as an integer array. You may use other
representations (e.g., Java Strings), if your system supports them.

LCP can be implemented with the pseudocode given below. Formalize and
verify the following informal specification for LCP.

Input:  an integer array a, and two indices x and y into this array
Output: length of the longest common prefix of the subarrays of a
        starting at x and y respectively.

Pseudocode:

    int lcp(int[] a, int x, int y) {
        int l = 0;
        while (x+l<a.length && y+l<a.length && a[x+l]==a[y+l]) {
            l++;
        }
        return l;
    }






ADVANCED
========



BACKGROUND
----------

Together with a suffix array, LCP can be used to solve interesting text
problems, such as finding the longest repeated substring (LRS) in a text.

A suffix array (for a given text) is an array of all suffixes of the
text. For the text [7,8,8,6], the suffix array is
[[7,8,8,6],
   [8,8,6],
     [8,6],
       [6]]

Typically, the suffixes are not stored explicitly as above but
represented as pointers into the original text. The suffixes in a suffix
array  are sorted in lexicographical order. This way, occurrences of
repeated substrings in the original text are neighbors in the suffix
array.

For the above, example (assuming pointers are 0-based integers), the
sorted suffix array is:

[3,0,2,1]


VERIFICATION TASK
-----------------

The attached Java code contains an implementation of a suffix array
(SuffixArray.java), consisting essentially of a lexicographical
comparison on arrays, a sorting routine, and LCP.

The client code (LRS.java) uses these to solve the LRS problem. Verify
that it does so correctly.

*)


module SuffixArray

use import int.Int
use import array.Array

type suffixArray = {
    values : array int;
    suffixes : array int;
}

predicate array_bounded (a:array int) (b:int) =
  forall i:int. 0 <= i < a.length -> 0 <= a[i] < b
  
(*
  use import array.ArraySorted
*)
  use import array.ArrayPermut

  lemma permut_bounded :
    forall a1 a2:array int, n:int.
    a1.length = a2.length /\
    array_bounded a1 n /\ 
    permut_sub a1 a2 0 a1.length -> array_bounded a2 n

predicate inv(s:suffixArray) =
  s.values.length = s.suffixes.length /\
  array_bounded s.suffixes s.values.length

let select (s:suffixArray) (i:int) : int 
  requires { inv s /\ 0 <= i < s.values.length }
  ensures { result = s.suffixes[i] }
  = s.suffixes[i]

use import ref.Refint

let lcp (a:array int) (x y:int) : int 
  requires { 0 <= x < a.length }
  requires { 0 <= y < a.length }
  ensures { 0 <= result /\ x+result <= a.length /\ y+result <= a.length }
  ensures { forall i:int. 0 <= i < result -> a[x+i] = a[y+i] }
  ensures { x+result = a.length \/ y+result = a.length \/ a[x+result] <> a[y+result] }
  = let n = a.length in
    let l = ref 0 in
    while x + !l < n && y + !l < n && a[x + !l] = a[y + !l] do
      invariant { 0 <= !l /\ x + !l <= n /\ y + !l <= n }
      invariant { forall i:int. 0 <= i < !l -> a[x+i] = a[y+i] }
      incr l
    done;
    !l

let test1 () =
  let arr = Array.make 4 0 in
  arr[0]<-1; arr[1]<-2; arr[2]<-2; arr[3]<-5;
  let x = lcp arr 1 2 in
  assert { x = 1 };
  (* int[] brr = {1,2,3,5}; *)
  let brr = Array.make 4 0 in
  brr[0]<-1; brr[1]<-2; brr[2]<-3; brr[3]<-5;
  let x = lcp brr 1 2 in
  assert { x = 0 };
  (* int[] crr = {1,2,3,5}; *)
  let crr = Array.make 4 0 in
  crr[0]<-1; crr[1]<-2; crr[2]<-3; crr[3]<-5;
  let x = lcp crr 2 3 in
  assert { x = 0 };
  (* int[] drr = {1,2,3,3}; *)
  let drr = Array.make 4 0 in
  drr[0]<-1; drr[1]<-2; drr[2]<-3; drr[3]<-3;
  let x = lcp drr 2 3 in
  assert {x = 1}

let compare (a:array int) (x y:int) : int 
  requires { 0 <= x < a.length }
  requires { 0 <= y < a.length }
  =
  if x = y then 0 else
  let n = a.length in
  let l = lcp a x y in
  if x + l = n then -1 else
  if y + l = n then 1 else
  if a[x + l] < a[y + l] then -1 else
  if a[x + l] > a[y + l] then 1 else
  absurd

  let sort (a:array int) (data : array int) 
  requires { array_bounded data a.length }
  =
   'Init:
   for i = 0 to data.length - 1 do
     invariant { permut (at data 'Init) data   }
     invariant { array_bounded data a.length }
     let j = ref i in
     while !j > 0 && compare a data[!j-1] data[!j] > 0 do
       invariant { 0 <= !j <= i }
       invariant { permut (at data 'Init) data   }
       invariant { array_bounded data a.length }
       'L:
       let b = !j - 1 in
       let t = data[!j] in
       data[!j] <- data[b];
       data[b] <- t;
       assert { exchange (at data 'L) data (!j-1) !j };
       decr j
     done
   done

let create (a:array int) : suffixArray 
  requires { a.length >= 0 }
  ensures { result.values.length = a.length /\ inv result }
 =
 let n = a.length in
 let suf = Array.make n 0 in
 for i = 0 to n-1 do 
   invariant { array_bounded suf n }
   suf[i] <- i done;
 sort a suf;
 { values = a; suffixes = suf }

let lcp2 (s:suffixArray) (i:int) : int 
  requires { inv s }
  requires { 0 < i < s.values.length }
  =
   lcp s.values s.suffixes[i] s.suffixes[i-1]


let test2 () =
  let arr = Array.make 4 0 in
  arr[0]<-1; arr[1]<-2; arr[2]<-2; arr[3]<-5;
  let sa = create arr in
  let x = lcp2 sa 1 in
  assert {x = -1 (* TODO *)};
  (* int[] brr = {1,2,3,5}; *)
  let brr = Array.make 4 0 in
  brr[0]<-1; brr[1]<-2; brr[2]<-3; brr[3]<-5;
  let sa = create brr in
  let x = lcp2 sa 1 in
  assert {x = -1 (* TODO *)};
  (* int[] crr = {1,2,3,5}; *)
  let crr = Array.make 4 0 in
  crr[0]<-1; crr[1]<-2; crr[2]<-3; crr[3]<-5;
  let sa = create crr in
  let x = lcp2 sa 2 in
  assert {x = -1 (* TODO *)};
  (* int[] drr = {1,2,3,3}; *)
  let drr = Array.make 4 0 in
  drr[0]<-1; drr[1]<-2; drr[2]<-3; drr[3]<-3;
  let sa = create drr in
  let x = lcp2 sa 2 in
  assert {x = -1 (* TODO *)}

end

module LRS

  use import int.Int
  use import ref.Ref
  use import array.Array
  use SuffixArray

    val solStart : ref int
    val solLength : ref int

    let lrs (a:array int) : unit =
      let sa = SuffixArray.create a in
      solStart := 0;
      solLength := 0;
      for i=1 to a.length - 1 do
         let l = SuffixArray.lcp2 sa i in
         if l > !solLength then begin
            solStart := SuffixArray.select sa i;
            solLength := l
         end
      done

  let test () =
    let arr = Array.make 4 0 in
    arr[0]<-7; arr[1]<-8; arr[2]<-8; arr[3]<-9;
    lrs arr;
    assert { !solStart = 1 };
    assert { !solLength = 1 }

end


(* Based on code by Robert Sedgewick and Kevin Wayne. *)
