(*

Longest Common Prefix (LCP) - 45 minutes

VERIFICATION TASK
-----------------

Longest Common Prefix (LCP) is an algorithm used for text querying. In
the following, we model text as an integer array. You may use other
representations (e.g., Java Strings), if your system supports them.

LCP can be implemented with the pseudocode given below. Formalize and
verify the following informal specification for LCP.

Input:  an integer array a, and two indices x and y into this array
Output: length of the longest common prefix of the subarrays of a
        starting at x and y respectively.

Pseudocode:

    int lcp(int[] a, int x, int y) {
        int l = 0;
        while (x+l<a.length && y+l<a.length && a[x+l]==a[y+l]) {
            l++;
        }
        return l;
    }






ADVANCED
========



BACKGROUND
----------

Together with a suffix array, LCP can be used to solve interesting text
problems, such as finding the longest repeated substring (LRS) in a text.

A suffix array (for a given text) is an array of all suffixes of the
text. For the text [7,8,8,6], the suffix array is
[[7,8,8,6],
   [8,8,6],
     [8,6],
       [6]]

Typically, the suffixes are not stored explicitly as above but
represented as pointers into the original text. The suffixes in a suffix
array  are sorted in lexicographical order. This way, occurrences of
repeated substrings in the original text are neighbors in the suffix
array.

For the above, example (assuming pointers are 0-based integers), the
sorted suffix array is:

[3,0,2,1]


VERIFICATION TASK
-----------------

The attached Java code contains an implementation of a suffix array
(SuffixArray.java), consisting essentially of a lexicographical
comparison on arrays, a sorting routine, and LCP.

The client code (LRS.java) uses these to solve the LRS problem. Verify
that it does so correctly.

*)



module LCP "longest common prefix"

use import int.Int
use import array.Array

(* TODO: dire plus precisement que c'est une permutation de 0..b-1 *)
predicate array_bounded (a:array int) (b:int) =
  forall i:int. 0 <= i < a.length -> 0 <= a[i] < b

(*
  use import array.ArraySorted
*)
  use import array.ArrayPermut

  lemma permut_bounded :
    forall a1 a2:array int, n:int.
    permut a1 a2 /\ array_bounded a1 n -> array_bounded a2 n


predicate is_common_prefix (a:array int) (x y:int) (l:int) =
  0 <= l /\ x+l <= a.length /\ y+l <= a.length /\
  (forall i:int. 0 <= i < l -> a[x+i] = a[y+i])

lemma common_prefix_eq:
  forall a:array int, x:int.
     0 <= x < a.length -> is_common_prefix a x x (a.length - x)

lemma common_prefix_eq2:
  forall a:array int, x:int.
     0 <= x < a.length -> not (is_common_prefix a x x (a.length - x + 1))

lemma not_common_prefix_if_last_different:
  forall a:array int, x y:int, l:int.
    0 < l /\ x+l < a.length /\ y+l < a.length /\ a[x+(l-1)] <> a[y+(l-1)] ->
      not is_common_prefix a x y l

function longest_common_prefix (a:array int) (x y:int) :int

axiom lcp_spec:
  forall a:array int, x y:int, l:int.
  0 <= x < a.length /\ 0 <= y < a.length ->
  (l = longest_common_prefix a x y <->
   is_common_prefix a x y l /\ not is_common_prefix a x y (l+1))

lemma lcp_eq :
  forall a:array int, x:int.
     0 <= x < a.length -> longest_common_prefix a x x = a.length - x


use import ref.Refint

let lcp (a:array int) (x y:int) : int
  requires { 0 <= x < a.length }
  requires { 0 <= y < a.length }
  ensures { result = longest_common_prefix a x y }
  = let n = a.length in
    let l = ref 0 in
    while x + !l < n && y + !l < n && a[x + !l] = a[y + !l] do
      invariant { is_common_prefix a x y !l }
      incr l
    done;
    assert { is_common_prefix a x y !l };
    assert { x + !l < n /\ y + !l < n -> a[x + !l] <> a[y + !l] };
    assert { not is_common_prefix a x y (!l+1) };
    !l

let test1 () =
  let arr = Array.make 4 0 in
  arr[0]<-1; arr[1]<-2; arr[2]<-2; arr[3]<-5;
  let x = lcp arr 1 2 in
  assert { is_common_prefix arr 1 2 1};
  check { x = 1 };
  (* int[] brr = {1,2,3,5}; *)
  let brr = Array.make 4 0 in
  brr[0]<-1; brr[1]<-2; brr[2]<-3; brr[3]<-5;
  let x = lcp brr 1 2 in
  assert { is_common_prefix brr 1 2 0};
  check { x = 0 };
  (* int[] crr = {1,2,3,5}; *)
  let crr = Array.make 4 0 in
  crr[0]<-1; crr[1]<-2; crr[2]<-3; crr[3]<-5;
  let x = lcp crr 2 3 in
  assert { is_common_prefix crr 2 3 0};
  check { x = 0 };
  (* int[] drr = {1,2,3,3}; *)
  let drr = Array.make 4 0 in
  drr[0]<-1; drr[1]<-2; drr[2]<-3; drr[3]<-3;
  let x = lcp drr 2 3 in
  assert { is_common_prefix drr 2 3 1};
  check {x = 1}

  predicate le (a : array int) (x y:int) =
     let n = a.length in
     let l = longest_common_prefix a x y in
     x+l = n \/
     (x+l < n /\ y+l < n /\ a[x+l] <= a[y+l])

  lemma eq_le :
    forall a:array int, x :int.
    0 <= x < a.length -> le a x x

let compare (a:array int) (x y:int) : int
  requires { 0 <= x < a.length }
  requires { 0 <= y < a.length }
  ensures { result <= 0 <-> le a x y }
  =
  if x = y then 0 else
  let n = a.length in
  let l = lcp a x y in
  assert { is_common_prefix a x y l };
  if x + l = n then -1 else
  if y + l = n then 1 else
  if a[x + l] < a[y + l] then -1 else
  if a[x + l] > a[y + l] then 1 else
  absurd

  (* predicate sorted_sub (a : array int) (data:array int) (l u:int) = *)
  (*   forall i1 i2 : int. l <= i1 <= i2 < u -> le a data[i1] data[i2] *)

  let sort (a:array int) (data : array int)
  requires { array_bounded data a.length }
  (* ensures { sorted a data } *)
  ensures { permut (old data) data }
  =
   'Init:
   for i = 0 to data.length - 1 do
     invariant { permut (at data 'Init) data   }
     invariant { array_bounded data a.length }
     let j = ref i in
     while !j > 0 && compare a data[!j-1] data[!j] > 0 do
       invariant { 0 <= !j <= i }
       invariant { permut (at data 'Init) data   }
       invariant { array_bounded data a.length }
       'L:
       let b = !j - 1 in
       let t = data[!j] in
       data[!j] <- data[b];
       data[b] <- t;
       assert { exchange (at data 'L) data (!j-1) !j };
       decr j
     done
   done


end






module SuffixArray

use import int.Int
use import array.Array
use import LCP

type suffixArray = {
    values : array int;
    suffixes : array int;
}

predicate inv(s:suffixArray) =
  s.values.length = s.suffixes.length /\
  array_bounded s.suffixes s.values.length

let select (s:suffixArray) (i:int) : int
  requires { inv s /\ 0 <= i < s.values.length }
  ensures { result = s.suffixes[i] }
  = s.suffixes[i]

let create (a:array int) : suffixArray
  requires { a.length >= 0 }
  ensures { result.values.length = a.length /\ inv result }
 =
 let n = a.length in
 let suf = Array.make n 0 in
 for i = 0 to n-1 do
   invariant { array_bounded suf n }
   suf[i] <- i done;
 sort a suf;
 { values = a; suffixes = suf }

let lcp (s:suffixArray) (i:int) : int
  requires { inv s }
  requires { 0 < i < s.values.length }
  =
   LCP.lcp s.values s.suffixes[i] s.suffixes[i-1]


let test2 () =
  let arr = Array.make 4 0 in
  arr[0]<-1; arr[1]<-2; arr[2]<-2; arr[3]<-5;
  let sa = create arr in
  let x = lcp sa 1 in
  check {x = -1 (* TODO *)};
  (* int[] brr = {1,2,3,5}; *)
  let brr = Array.make 4 0 in
  brr[0]<-1; brr[1]<-2; brr[2]<-3; brr[3]<-5;
  let sa = create brr in
  let x = lcp sa 1 in
  check {x = -1 (* TODO *)};
  (* int[] crr = {1,2,3,5}; *)
  let crr = Array.make 4 0 in
  crr[0]<-1; crr[1]<-2; crr[2]<-3; crr[3]<-5;
  let sa = create crr in
  let x = lcp sa 2 in
  check {x = -1 (* TODO *)};
  (* int[] drr = {1,2,3,3}; *)
  let drr = Array.make 4 0 in
  drr[0]<-1; drr[1]<-2; drr[2]<-3; drr[3]<-3;
  let sa = create drr in
  let x = lcp sa 2 in
  check {x = -1 (* TODO *)}

end





module LRS "longest repeated substring"

  use import int.Int
  use import ref.Ref
  use import array.Array
  use SuffixArray

    val solStart : ref int
    val solLength : ref int

    let lrs (a:array int) : unit
      requires { a.length >= 0 }
    =
      let sa = SuffixArray.create a in
      solStart := 0;
      solLength := 0;
      for i=1 to a.length - 1 do
         let l = SuffixArray.lcp sa i in
         if l > !solLength then begin
            solStart := SuffixArray.select sa i;
            solLength := l
         end
      done

  let test () =
    let arr = Array.make 4 0 in
    arr[0]<-7; arr[1]<-8; arr[2]<-8; arr[3]<-9;
    lrs arr;
    check { !solStart = 1 /\ !solLength = 1 }

end


(* Based on code by Robert Sedgewick and Kevin Wayne. *)
