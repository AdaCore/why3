(*

Longest Common Prefix (LCP) - 45 minutes

VERIFICATION TASK
-----------------

Longest Common Prefix (LCP) is an algorithm used for text querying. In
the following, we model text as an integer array. You may use other
representations (e.g., Java Strings), if your system supports them.

LCP can be implemented with the pseudocode given below. Formalize and
verify the following informal specification for LCP.

Input:  an integer array a, and two indices x and y into this array
Output: length of the longest common prefix of the subarrays of a
        starting at x and y respectively.

Pseudocode:

    int lcp(int[] a, int x, int y) {
        int l = 0;
        while (x+l<a.length && y+l<a.length && a[x+l]==a[y+l]) {
            l++;
        }
        return l;
    }






ADVANCED
========



BACKGROUND
----------

Together with a suffix array, LCP can be used to solve interesting text
problems, such as finding the longest repeated substring (LRS) in a text.

A suffix array (for a given text) is an array of all suffixes of the
text. For the text [7,8,8,6], the suffix array is
[[7,8,8,6],
   [8,8,6],
     [8,6],
       [6]]

Typically, the suffixes are not stored explicitly as above but
represented as pointers into the original text. The suffixes in a suffix
array  are sorted in lexicographical order. This way, occurrences of
repeated substrings in the original text are neighbors in the suffix
array.

For the above, example (assuming pointers are 0-based integers), the
sorted suffix array is:

[3,0,2,1]


VERIFICATION TASK
-----------------

The attached Java code contains an implementation of a suffix array
(SuffixArray.java), consisting essentially of a lexicographical
comparison on arrays, a sorting routine, and LCP.

The client code (LRS.java) uses these to solve the LRS problem. Verify
that it does so correctly.

*)



module LCP "longest common prefix"

use import int.Int
use import array.Array
use import array.ArrayPermut


predicate is_common_prefix (a:array int) (x y:int) (l:int) =
  0 <= l /\ x+l <= a.length /\ y+l <= a.length /\
  (forall i:int. 0 <= i < l -> a[x+i] = a[y+i])

lemma common_prefix_eq:
  forall a:array int, x:int.
     0 <= x <= a.length -> is_common_prefix a x x (a.length - x)

lemma common_prefix_eq2:
  forall a:array int, x:int.
     0 <= x <= a.length -> not (is_common_prefix a x x (a.length - x + 1))

lemma not_common_prefix_if_last_different:
  forall a:array int, x y:int, l:int.
    0 < l /\ x+l < a.length /\ y+l < a.length /\ a[x+(l-1)] <> a[y+(l-1)] ->
      not is_common_prefix a x y l

function longest_common_prefix (a:array int) (x y:int) :int

axiom lcp_spec:
  forall a:array int, x y:int, l:int.
  0 <= x <= a.length /\ 0 <= y <= a.length ->
  (l = longest_common_prefix a x y <->
   is_common_prefix a x y l /\ not is_common_prefix a x y (l+1))

use import ref.Refint

let lcp (a:array int) (x y:int) : int
  requires { 0 <= x <= a.length }
  requires { 0 <= y <= a.length }
  ensures { result = longest_common_prefix a x y }
  = let n = a.length in
    let l = ref 0 in
    while x + !l < n && y + !l < n && a[x + !l] = a[y + !l] do
      invariant { is_common_prefix a x y !l }
      incr l
    done;
    assert { is_common_prefix a x y !l };
    assert { x + !l < n /\ y + !l < n -> a[x + !l] <> a[y + !l] };
    assert { not is_common_prefix a x y (!l+1) };
    !l


lemma lcp_is_cp :
  forall a:array int, x y:int.
     0 <= x <= a.length /\ 0 <= y <= a.length ->
     let l = longest_common_prefix a x y in
     is_common_prefix a x y l

lemma lcp_eq :
  forall a:array int, x y:int.
     0 <= x <= a.length /\ 0 <= y <= a.length ->
     let l = longest_common_prefix a x y in
     forall i:int. 0 <= i < l -> a[x+i] = a[y+i]

lemma lcp_refl :
  forall a:array int, x:int.
     0 <= x <= a.length -> longest_common_prefix a x x = a.length - x

lemma lcp_sym :
  forall a:array int, x y:int.
     0 <= x <= a.length /\ 0 <= y <= a.length ->
       longest_common_prefix a x y = longest_common_prefix a y x

let test1 () =
  let arr = Array.make 4 0 in
  arr[0]<-1; arr[1]<-2; arr[2]<-2; arr[3]<-5;
  let x = lcp arr 1 2 in
  assert { is_common_prefix arr 1 2 1};
  check { x = 1 };
  (* int[] brr = {1,2,3,5}; *)
  let brr = Array.make 4 0 in
  brr[0]<-1; brr[1]<-2; brr[2]<-3; brr[3]<-5;
  let x = lcp brr 1 2 in
  assert { is_common_prefix brr 1 2 0};
  check { x = 0 };
  (* int[] crr = {1,2,3,5}; *)
  let crr = Array.make 4 0 in
  crr[0]<-1; crr[1]<-2; crr[2]<-3; crr[3]<-5;
  let x = lcp crr 2 3 in
  assert { is_common_prefix crr 2 3 0};
  check { x = 0 };
  (* int[] drr = {1,2,3,3}; *)
  let drr = Array.make 4 0 in
  drr[0]<-1; drr[1]<-2; drr[2]<-3; drr[3]<-3;
  let x = lcp drr 2 3 in
  assert { is_common_prefix drr 2 3 1};
  check {x = 1}


  predicate le (a : array int) (x y:int) =
     let n = a.length in
     0 <= x <= n /\ 0 <= y <= n /\
     let l = longest_common_prefix a x y in
     x+l = n \/
     (x+l < n /\ y+l < n /\ a[x+l] <= a[y+l])

  lemma le_refl :
    forall a:array int, x :int.
    0 <= x <= a.length -> le a x x

  lemma le_trans :
    forall a:array int, x y z:int.
    0 <= x <= a.length /\ 0 <= y <= a.length /\
    0 <= z <= a.length /\ le a x y /\ le a y z -> le a x z

  lemma le_asym :
    forall a:array int, x y:int.
    0 <= x <= a.length /\ 0 <= y <= a.length /\ not (le a x y) -> le a y x

let compare (a:array int) (x y:int) : int
  requires { 0 <= x <= a.length }
  requires { 0 <= y <= a.length }
  ensures { result = 0 -> x = y }
  ensures { result < 0 -> le a x y }
  ensures { result > 0 -> le a y x }
  =
  if x = y then 0 else
  let n = a.length in
  let l = lcp a x y in
  assert { is_common_prefix a x y l };
  if x + l = n then -1 else
  if y + l = n then 1 else
  if a[x + l] < a[y + l] then -1 else
  if a[x + l] > a[y + l] then 1 else
  absurd

  predicate sorted_sub (a : array int) (data:array int) (l u:int) =
    forall i1 i2 : int. l <= i1 <= i2 < u -> le a data[i1] data[i2]

(*
  lemma sorted_le:
    forall a data: array int, l u i x:int.
    l <= i < u /\ sorted_sub a data l u /\ le a x data[l] ->
    le a x data[i]

  lemma sorted_ge:
    forall a data: array int, l u i x:int.
    sorted_sub a data l u /\ le a data[u-1] x /\ l <= i < u ->
    le a data[i] x

  lemma sorted_sub_sub:
    forall a data:array int, l u l' u':int.
    l <= l' /\ u' <= u ->
    sorted_sub a data l u ->
    sorted_sub a data l' u'

  lemma sorted_sub_add:
    forall a data:array int, l u:int.
    sorted_sub a data (l+1) u /\ le a data[l] data[l+1] ->
    sorted_sub a data l u

  lemma sorted_sub_concat:
    forall a data:array int, l m u:int.
    l <= m <= u /\ sorted_sub a data l m /\ sorted_sub a data m u /\
    le a data[m-1] data[m] ->
    sorted_sub a data l u

  lemma sorted_sub_set:
    forall a data:array int, l u i v:int.
    sorted_sub a data l u /\ u <= i ->
    sorted_sub a (data[i<-v]) l u

  lemma sorted_sub_set2:
    forall a data:array int, l u i v:int.
    sorted_sub a data l u /\ u <= i ->
    sorted_sub a { length = a.length; elts = Map.set data.elts i v } l u
*)

use map.Map
use map.MapPermut
use map.MapInjection

predicate map_permutation (m:Map.map int int) (u : int) =
  MapInjection.range m u /\
  MapInjection.injective m u

predicate permutation (a:array int) =
  map_permutation a.elts a.length



  predicate sorted (a : array int) (data:array int) =
    sorted_sub a data 0 data.length

  let sort (a:array int) (data : array int)
  requires { data.length = a.length }
  requires { MapInjection.range data.elts data.length }
  ensures { sorted a data }
  ensures { permut (old data) data }
  =
   'Init:
   for i = 0 to data.length - 1 do
     invariant { permut (at data 'Init) data   }
     invariant { sorted_sub a data 0 i  }
     invariant { MapInjection.range data.elts data.length }
     let j = ref i in
     while !j > 0 && compare a data[!j-1] data[!j] > 0 do
       invariant { 0 <= !j <= i }
       invariant { MapInjection.range data.elts data.length }
       invariant { permut (at data 'Init) data   }
       invariant { sorted_sub a data 0 !j }
       invariant { sorted_sub a data !j (i+1) }
       invariant { forall k1 k2:int. 0 <= k1 < !j /\ !j+1 <= k2 <= i ->
                     le a data[k1] data[k2] }
       'L:
(*
       assert { le a data[!j] data[!j-1] };
       assert { forall k:int. !j+1 <= k <= i -> le a data[!j-1] data[k] };
       assert { sorted_sub a data 0 (!j-1) };
       assert { sorted_sub a data (!j+1) (i+1) };
*)
       let b = !j - 1 in
       let t = data[!j] in
       data[!j] <- data[b];
(*
       assert { sorted_sub a data 0 (!j-1) };
       assert { sorted_sub a data (!j+1) (i+1) };
       assert { forall k:int. !j <= k <= i -> le a data[!j] data[k] };
       assert { sorted_sub a data !j (i+1) };
*)
       data[b] <- t;
(*
       assert { le a data[!j-1] data[!j] };
       assert { forall k:int. !j <= k <=i -> le a data[!j] data[k] };
       assert { sorted_sub a data 0 (!j-1) };
       assert { sorted_sub a data !j (i+1) };
*)
       assert { exchange (at data 'L) data (!j-1) !j };
       decr j
     done
(*;
     assert { !j > 0 -> le a data[!j-1] data[!j] }
*)   done


(* additional properties relating le and longest_common_prefix, needed
   for SuffixArray and LRS

*)


(*
lemma map_permut_permutation :
  forall m1 m2:Map.map int int, u:int [MapPermut.permut_sub m1 m2 0 u].
  MapPermut.permut_sub m1 m2 0 u -> map_permutation m1 u -> map_permutation m2 u
*)

lemma permut_permutation :
  forall a1 a2:array int.
  permut a1 a2 -> permutation a1 -> permutation a2

  use import int.MinMax

  lemma lcp_le_le_min:
    forall a:array int, x y z:int [le a x y, le a y z].
     le a x y /\ le a y z ->
     longest_common_prefix a x z =
       min (longest_common_prefix a x y) (longest_common_prefix a y z)

  lemma lcp_le_le:
    forall a:array int, x y z:int.
     le a x y /\ le a y z ->
     longest_common_prefix a x z <= longest_common_prefix a y z

end






module SuffixArray

use import int.Int
use import array.Array
use import LCP

type suffixArray = {
    values : array int;
    suffixes : array int;
}

use map.MapInjection

predicate inv(s:suffixArray) =
  s.values.length = s.suffixes.length /\
  permutation s.suffixes /\
  sorted s.values s.suffixes

let select (s:suffixArray) (i:int) : int
  requires { inv s /\ 0 <= i < s.values.length }
  ensures { result = s.suffixes[i] }
  = s.suffixes[i]

let create (a:array int) : suffixArray
  requires { a.length >= 0 }
  ensures { result.values = a /\ inv result }
 =
 let n = a.length in
 let suf = Array.make n 0 in
 for i = 0 to n-1 do
   invariant { forall j:int. 0 <= j < i -> suf[j] = j }
   suf[i] <- i done;
 sort a suf;
 { values = a; suffixes = suf }

let lcp (s:suffixArray) (i:int) : int
  requires { inv s }
  requires { 0 < i < s.values.length }
  ensures { result =
            longest_common_prefix s.values s.suffixes[i-1] s.suffixes[i] }
  =
   LCP.lcp s.values s.suffixes[i] s.suffixes[i-1]

(*
let test2 () =
  let arr = Array.make 4 0 in
  arr[0]<-1; arr[1]<-2; arr[2]<-2; arr[3]<-5;
  let sa = create arr in
  assert { sa.suffixes[0] = 0 };
  assert { sa.suffixes[1] = 1 };
  assert { sa.suffixes[2] = 2 };
  assert { sa.suffixes[3] = 3 };
  let x = lcp sa 1 in
  check {x = 0};
  (* int[] brr = {1,2,3,5}; *)
  let brr = Array.make 4 0 in
  brr[0]<-1; brr[1]<-2; brr[2]<-3; brr[3]<-5;
  let sa = create brr in
  let x = lcp sa 1 in
  check {x = 0 (* TODO *)};
  (* int[] crr = {1,2,3,5}; *)
  let crr = Array.make 4 0 in
  crr[0]<-1; crr[1]<-2; crr[2]<-3; crr[3]<-5;
  let sa = create crr in
  let x = lcp sa 2 in
  check {x = 0 (* TODO *)};
  (* int[] drr = {1,2,3,3}; *)
  let drr = Array.make 4 0 in
  drr[0]<-1; drr[1]<-2; drr[2]<-3; drr[3]<-3;
  let sa = create drr in
  let x = lcp sa 2 in
  check {x = 0 (* TODO *)}
*)

end





module LRS "longest repeated substring"

  use import int.Int
  use import ref.Ref
  use import array.Array
  use map.MapInjection
  use LCP
  use SuffixArray

    val solStart : ref int
    val solLength : ref int
    val ghost solStart2 : ref int

    let lrs (a:array int) : unit
      requires { a.length > 0 }
      ensures { 0 <= !solLength <= a.length }
      ensures { 0 <= !solStart <= a.length }
      ensures { 0 <= !solStart2 <= a.length /\ !solStart <> !solStart2 /\
                !solLength = LCP.longest_common_prefix a !solStart !solStart2 }
      ensures { forall x y:int.
                  0 <= x < y < a.length ->
                  !solLength >= LCP.longest_common_prefix a x y }
    =
      let sa = SuffixArray.create a in
      assert { LCP.permutation sa.SuffixArray.suffixes };
      solStart := 0;
      solLength := 0;
      solStart2 := a.length;
      for i=1 to a.length - 1 do
        invariant { 0 <= !solLength <= a.length }
        invariant { 0 <= !solStart <= a.length }
        invariant { 
                  0 <= !solStart2 <= a.length /\ !solStart <> !solStart2 /\
                  !solLength = LCP.longest_common_prefix a !solStart !solStart2 }
        invariant { forall j k:int.
                  0 <= j < k < i ->
                  !solLength >= LCP.longest_common_prefix a
                    sa.SuffixArray.suffixes[j] sa.SuffixArray.suffixes[k] }
         let l = SuffixArray.lcp sa i in
         assert { forall j:int. 0 <= j < i ->
                    LCP.le a sa.SuffixArray.suffixes[j]
                             sa.SuffixArray.suffixes[i] };
         assert { forall j:int. 0 <= j < i ->
                    LCP.longest_common_prefix a
                             sa.SuffixArray.suffixes[j]
                             sa.SuffixArray.suffixes[i]
                  <= l };
         assert { forall j k:int. 0 <= j < k  < i-1 ->
                    !solLength >= LCP.longest_common_prefix a
                             sa.SuffixArray.suffixes[j]
                             sa.SuffixArray.suffixes[k] };
         if l > !solLength then begin
            solStart := SuffixArray.select sa i;
            solStart2 := SuffixArray.select sa (i-1);
            solLength := l
         end
      done;
      assert { let s = sa.SuffixArray.suffixes in
               MapInjection.surjective s.elts s.length };
      assert { forall j k:int.
                  0 <= j < a.length /\ 0 <= k < a.length /\ j <> k ->
                  !solLength >= LCP.longest_common_prefix a
                    sa.SuffixArray.suffixes[j] sa.SuffixArray.suffixes[k] };
      assert { forall x y:int.
                  0 <= x < y < a.length ->
                  exists j k : int.
                  0 <= j < a.length /\ 0 <= k < a.length /\ j <> k /\
                  x = sa.SuffixArray.suffixes[j] /\
                  y = sa.SuffixArray.suffixes[k] }

(*
  let test () =
    let arr = Array.make 4 0 in
    arr[0]<-7; arr[1]<-8; arr[2]<-8; arr[3]<-9;
    lrs arr;
    check { !solStart = 1 /\ !solLength = 1 }
*)

end


(* Based on code by Robert Sedgewick and Kevin Wayne. *)
