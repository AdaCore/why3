
(** {1 McCarthy's ``91'' function}

authors: Jean-Christophe Filliâtre, Martin Clochard, Claude Marché
witness: Andrei Paskevich

*)

module McCarthy91

  use import int.Int

  (** {2 Specification} *)

  function spec (x: int) : int = if x <= 100 then 91 else x-10

  (** {2 traditional recursive implementation} *)

  let rec f91 (n:int) : int variant { 101-n }
    ensures { result = spec n }
  = if n <= 100 then
      f91 (f91 (n + 11))
    else
      n - 10

  (** {2 non-recursive implementation using a while loop} *)

  use import ref.Ref

  (* iter k x = f^k(x) *)
  clone import int.Iter with type t = int, function f = spec

  let f91_nonrec (n0: int) ensures { result = spec n0 }
  = let e = ref 1 in
    let n = ref n0 in
    while !e > 0 do
      invariant { !e >= 0 /\ iter !e !n = spec n0 }
      variant   { 101 - !n + 10 * !e, !e }
      if !n > 100 then begin
        n := !n - 10;
        e := !e - 1
      end else begin
        n := !n + 11;
        e := !e + 1
      end
    done;
    !n

  (** {2 irrelevance of control flow}

     We use a 'morally' irrelevant control flow from a recursive function
     to ease proof (the recursive structure does not contribute to the
     program execution). This is a technique for proving derecursified
     programs. See [verifythis_2016_tree_traversal] for a more
     complex example. *)

  exception Stop

  let f91_pseudorec (n0:int) : int
    ensures { result = spec n0 }
  = let e = ref 1 in
    let n = ref n0 in
    let bloc () : unit
      requires { !e >= 0 }
      ensures { !(old e) > 0 }
      ensures { if !(old n) > 100 then !n = !(old n) - 10 /\ !e = !(old e) - 1
        else !n = !(old n) + 11 /\ !e = !(old e) + 1 }
      raises { Stop -> !e = !(old e) = 0 /\ !n = !(old n) }
    = if not (!e > 0) then raise Stop;
      if !n > 100 then begin
        n := !n - 10;
        e := !e - 1
      end else begin
        n := !n + 11;
        e := !e + 1
      end
    in
    let rec aux () : unit
      requires { !e > 0 }
      variant { 101 - !n }
      ensures { !e = !(old e) - 1 /\ !n = spec !(old n) }
      raises { Stop -> false }
    = let u = !n in bloc (); if u <= 100 then (aux (); aux ()) in
    try aux (); bloc (); absurd
    with Stop -> !n end

  (** {2 Variant using a general 'ghost coroutine' approach}

    Yet another variant. Assume we want to prove the imperative code:
{h <pre>
e := 1; r := n;
while e > 0
  if r > 100 then r := r - 10; e := e - 1;
             else r := r + 11; e := e + 1;
end-while
return r
</pre>}
we annotate the various program points:
{h <pre>
{ 0 } e := 1;
{ 1 } r := n;
{ 2 } while e > 0
  { 3 }
  if r > 100 then { 4 } r := r - 10; { 5 } e := e - 1;
             else { 6 } r := r + 11; { 7 } e := e + 1;
end-while
{ 8 }
return r
</pre>}

we define the small-step semantics of this code by the following [step] function

*)

type state = { n:int ; mutable pc : int; mutable e : int ; mutable r : int }

val now : state

val step () : unit
  requires { 0 <= now.pc < 8 }
  writes  { now }
  ensures { old now.pc = 0 -> now = { (old now) with pc = 1 ; e = 1 } }
  ensures { old now.pc = 1 -> now = { (old now) with pc = 2 ; r = old now.n } }
  ensures { old now.pc = 2 /\ old now.e > 0 -> now = { (old now) with pc = 3 } }
  ensures { old now.pc = 2 /\ old now.e <= 0 -> now = { (old now) with pc = 8 } }
  ensures { old now.pc = 3 /\ old now.r > 100 -> now = { (old now) with pc = 4 } }
  ensures { old now.pc = 3 /\ old now.r <= 100 -> now = { (old now) with pc = 6 } }
  ensures { old now.pc = 4 -> now = { (old now) with pc = 5 ; r = old now.r - 10 } }
  ensures { old now.pc = 5 -> now = { (old now) with pc = 2 ; e = old now.e - 1 } }
  ensures { old now.pc = 6 -> now = { (old now) with pc = 7 ; r = old now.r + 11 } }
  ensures { old now.pc = 7 -> now = { (old now) with pc = 2 ; e = old now.e + 1 } }

(** we prove the code by a ghost function that gives back the recursive
  structure of the original recursive definition *)

let rec aux () : unit
  requires { now.pc = 2 /\ now.e > 0 }
  writes  { now }
  variant  { 101 - now.r }
  ensures  { now.pc = 2 /\ now.r = spec(old now.r) /\ now.e = old now.e - 1 }
= let r0 = now.r in
  step (); (* execution of condition of while *)
  step (); (* execution of condition of if *)
  if r0 > 100 then begin
       step (); (* assignment r := r - 10 *)
       step ()  (* assignment e := e - 1  *)
       end
  else (* r0 <= 100 *)
     begin
       step (); (* assignment r := r + 11 *)
       step (); (* assignment e := e + 1 *)
       aux ();
       aux ()
     end

let main () : unit
  requires { now.pc = 0 /\ now.n >= 0 }
  writes  { now }
  ensures { now.pc = 8 /\ now.r = spec now.n }
= step (); (* assignment e := 1 *)
  step (); (* assignment r := n *)
  aux ();
  step() (* loop exit *)

end
