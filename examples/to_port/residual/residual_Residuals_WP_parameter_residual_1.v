(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require list.List.
Require list.Length.
Require int.Int.
Require list.Mem.
Require list.Append.

(* Why3 assumption *)
Definition unit := unit.

Axiom qtmark : Type.
Parameter qtmark_WhyType : WhyType qtmark.
Existing Instance qtmark_WhyType.

Axiom char : Type.
Parameter char_WhyType : WhyType char.
Existing Instance char_WhyType.

(* Why3 assumption *)
Inductive regexp :=
  | Empty : regexp
  | Epsilon : regexp
  | Char : char -> regexp
  | Alt : regexp -> regexp -> regexp
  | Concat : regexp -> regexp -> regexp
  | Star : regexp -> regexp.
Axiom regexp_WhyType : WhyType regexp.
Existing Instance regexp_WhyType.

(* Why3 assumption *)
Definition word := (list char).

(* Why3 assumption *)
Inductive mem: (list char) -> regexp -> Prop :=
  | mem_eps : (mem Init.Datatypes.nil Epsilon)
  | mem_char : forall (c:char), (mem
      (Init.Datatypes.cons c Init.Datatypes.nil) (Char c))
  | mem_altl : forall (w:(list char)) (r1:regexp) (r2:regexp), (mem w r1) ->
      (mem w (Alt r1 r2))
  | mem_altr : forall (w:(list char)) (r1:regexp) (r2:regexp), (mem w r2) ->
      (mem w (Alt r1 r2))
  | mem_concat : forall (w1:(list char)) (w2:(list char)) (r1:regexp)
      (r2:regexp), (mem w1 r1) -> ((mem w2 r2) -> (mem
      (Init.Datatypes.app w1 w2) (Concat r1 r2)))
  | mems1 : forall (r:regexp), (mem Init.Datatypes.nil (Star r))
  | mems2 : forall (w1:(list char)) (w2:(list char)) (r:regexp), (mem w1
      r) -> ((mem w2 (Star r)) -> (mem (Init.Datatypes.app w1 w2) (Star r))).

Axiom inversion_mem_star_gen : forall (c:char) (w:(list char)) (r:regexp)
  (w':(list char)) (r':regexp), ((w' = (Init.Datatypes.cons c w)) /\
  (r' = (Star r))) -> ((mem w' r') -> exists w1:(list char),
  exists w2:(list char), (w = (Init.Datatypes.app w1 w2)) /\ ((mem
  (Init.Datatypes.cons c w1) r) /\ (mem w2 r'))).

Axiom inversion_mem_star : forall (c:char) (w:(list char)) (r:regexp), (mem
  (Init.Datatypes.cons c w) (Star r)) -> exists w1:(list char),
  exists w2:(list char), (w = (Init.Datatypes.app w1 w2)) /\ ((mem
  (Init.Datatypes.cons c w1) r) /\ (mem w2 (Star r))).

(* Why3 goal *)
Theorem WP_parameter_residual : forall (r:regexp) (c:char), forall (x:regexp)
  (x1:regexp), (r = (Concat x x1)) -> forall (result:bool),
  ((result = true) <-> (mem Init.Datatypes.nil x)) -> ((result = true) ->
  forall (o:regexp), (forall (w:(list char)), (mem w o) <-> (mem
  (Init.Datatypes.cons c w) x1)) -> forall (o1:regexp),
  (forall (w:(list char)), (mem w o1) <-> (mem (Init.Datatypes.cons c w)
  x)) -> forall (w:(list char)), (mem w (Alt (Concat o1 x1) o)) <-> (mem
  (Init.Datatypes.cons c w) r)).
intros r c x x1 h1 result h2 h3 o h4 o1 h5 w.
subst.
intuition.

inversion H0; subst; clear H0.
inversion H4; subst; clear H4.
rewrite List.app_comm_cons.
constructor; auto.
now apply h5.
rewrite <- List.app_nil_l with (l:= (c::w)%list).
constructor.
tauto.
now apply h4.

inversion H0; subst; clear H0.
destruct w1.
apply mem_altr.
rewrite h4.
rewrite <- H2.
now simpl.
apply mem_altl.
simpl in H2.
injection H2; intros; subst; clear H2.
constructor.
now rewrite h5.
auto.
Qed.

