
(** Cursors

   TO BE DISCUSSED
   - a [coherent] predicate is also convenient for an immutable collection
   - having [next] raising an exception imposes a try-with around the loop
     it is simpler to have [next] with a precondition together with
     an operation [has_next]

  QUESTION: in IntListCursor, field to_do is no more ghost; will it be
  allowed by refinement? otherwise, simply add a non-ghost field
  identical to to_do
*)

module TestCursor

  use import int.Int
  use import int.Sum
  use import seq.Seq
  use import ref.Refint

  use import cursor.Cursor

  (** sums all the remaining elements in the cursor *)
  let sum (t: t int) (c: cursor int) : int
    requires { permitted c.visited t }
    requires { c.visited = empty }
    requires { c.collection = t }
    ensures  { result = sum (get c.visited) 0 (length c.visited) }
    diverges
  = let s = ref 0 in
    while has_next c do
      invariant { permitted c.visited t }
      invariant { !s = sum (get c.visited) 0 (length c.visited) }
      let x = next c in
      s += x
    done;
    !s

end

(** {2 Iteration over an immuable collection}

    here we choose a list *)

module ListCursor (* : IterableList *)

  use import int.Int
  use import list.List
  use import seq.Seq
  use import seq.OfList

  type cursor 'a = {
    mutable ghost visited: seq 'a;
            ghost collection: {list 'a};
    mutable       cursor: list 'a;
  } invariant { visited ++ cursor = collection }
    by { visited = empty; collection = Nil; cursor = Nil }

  predicate permitted (v: seq 'a) (t: list 'a) =
    length v <= length t /\
    forall i. 0 <= i < length v -> v[i] = t[i]

  predicate complete (v: seq 'a) (c: list 'a) =
    length v = length c

  let lemma snoc_Cons (s: seq 'a) (l: list 'a) (x: 'a)
    ensures { snoc s x ++ l == s ++ Cons x l }
  = ()

  let next (c: cursor 'a) : 'a
    requires { not (complete c.visited c.collection) }
    writes   { c }
    ensures  { c.visited = snoc (old c).visited result }
    ensures  { match (old c).cursor with
               | Nil -> false
               | Cons x r -> c.cursor = r /\ x = result
               end }
  = match c.cursor with
    | Nil -> absurd
    | Cons x r ->
      let ghost v0 = c.visited in
      c.visited <- snoc c.visited x; c.cursor <- r;
      snoc_Cons v0 r x;
      assert { c.cursor == c.collection [length c.visited ..] };
      x
    end

  let has_next (c: cursor 'a) : bool
    ensures { result <-> not (complete c.visited c.collection) }
  = match c.cursor with (* could define a [val eq (l1 l2: list 'a) : bool] *)
    | Nil -> false
    | _   -> true
    end

  let create (t: list 'a) : cursor 'a
    ensures { result.visited = empty }
    ensures { result.collection = t }
    ensures { result.cursor = t }
  = { visited = empty; collection = {t}; cursor = t }

  clone cursor.Cursor with
    type t = list,
    type cursor = cursor,
    predicate permitted = permitted,
    predicate complete = complete,
    val create = create,
    val has_next = has_next,
    val next = next

end

module TestListCursor

  use import int.Int
  use import int.Sum as S
  use import list.List
  use import list.Length
  use import list.Sum
  use import ref.Refint
  use import seq.Seq
  use import seq.OfList
  use import ListCursor

  let list_sum (l: list int) : int
    ensures { result = sum l }
  = let s = ref 0 in
    let c = create l in
    while has_next c do
      invariant { !s = S.sum (get c.visited) 0 (length c.visited) }
      invariant { sum l = !s + sum c.cursor }
      invariant { permitted c.visited l }
      invariant { c.collection = c.visited ++ c.cursor } (* Nooooo !!! *)
      variant   { length c.cursor }
      let x = next c in
      s += x
    done;
    !s

end

(** {2 Iteration over a mutable collection}

    here we choose an array of integers *)

module IntArrayCursor (* : IterableList *)

  use import int.Int
  use import array.Array
  use import list.List
  use import list.Reverse
  use import array.ToList
  use import seq.Seq

  type t 'a = array 'a

  val ghost constant a : {array 'a}
    ensures { Array.length result = 0 }

  type cursor 'a = {
    mutable ghost visited: seq 'a;
            ghost collection: {t 'a};
    mutable       index: int;      (** index of next element *)
  } invariant { 0 <= index <= Array.length collection /\
                index = length visited /\
                forall i. 0 <= i < index ->
                  Array.([]) collection i = visited[i] }
    by { visited = empty; collection = a; index = 0 }

  clone import cursor.Cursor with
    type cursor = cursor,
    type t = t

  (* predicate permitted (v: seq int) (t: t) = *)
  (*   length v <= length t /\ *)
  (*   forall i. 0 <= i *)

  (* let create (t: t) : cursor *)
  (*   ensures { result.done_ = Nil } *)
  (*   ensures { coherent t result } *)
  (* = *)
  (*   { done_ = Nil; to_do = to_list t 0 (length t); index = 0; } *)

  (* let has_next (t: t) (c: cursor) : bool *)
  (*   requires { coherent t c } *)
  (*   ensures  { result <-> c.to_do <> Nil } *)
  (* = *)
  (*   c.index < length t *)

  (* let rec lemma reverse_cons (a: array int) (l u: int) *)
  (*   requires { l <= u } *)
  (*   ensures  { reverse (to_list a l (u+1)) = *)
  (*              Cons a[u] (reverse (to_list a l u)) } *)
  (*   variant  { u - l } *)
  (* = if l < u then reverse_cons a (l+1) u *)

  (* let next (t: t) (c: cursor) : elt *)
  (*   requires { c.to_do <> Nil } *)
  (*   requires { coherent t c } *)
  (*   writes   { c } *)
  (*   ensures  { match old c.to_do with *)
  (*              | Nil -> false *)
  (*              | Cons x l -> result = x /\ c.done_ = Cons x (old c.done_) /\ *)
  (*                            c.to_do = l end } *)
  (*   ensures  { coherent t c } *)
  (* = *)
  (*   match c.to_do with *)
  (*   | Nil -> absurd *)
  (*   | Cons x r -> c.to_do <- r; c.done_ <- Cons x c.done_ *)
  (*   end; *)
  (*   let x = t[c.index] in *)
  (*   c.index <- c.index + 1; *)
  (*   x *)

end

(* module TestArrayCursor *)

(*   use import int.Int *)
(*   use list.Sum as L *)
(*   use list.Length as LL *)
(*   use import array.Array *)
(*   use import array.ArraySum *)
(*   use import array.ToList *)
(*   use import ref.Refint *)
(*   use import IntArrayCursor *)

(*   let rec lemma array_sum_array_to_list (a: array int) (l u: int) : unit *)
(*     ensures { sum a l u = L.sum (to_list a l u) } variant { u-l } *)
(*   = if l < u then array_sum_array_to_list a (l+1) u *)

(*   let array_sum (a: array int) : int *)
(*     ensures { result = sum a 0 (length a) } *)
(*   = *)
(*     let s = ref 0 in *)
(*     let c = create a in *)
(*     while has_next a c do *)
(*       invariant { sum a 0 (length a) = !s + L.sum c.to_do } *)
(*       invariant { coherent a c } *)
(*       variant   { LL.length c.to_do } *)
(*       let x = next a c in *)
(*       s += x *)
(*     done; *)
(*     !s *)

(*   let harness1 () : unit *)
(*   = *)
(*     let a = Array.make 42 0 in *)
(*     let c = create a in *)
(*     let x = next a c in *)
(*     assert { x = 0 } *)

(* (\* *)
(*   let harness2 () : unit *)
(*   = *)
(*     let a = Array.make 42 0 in *)
(*     let c = create a in *)
(*     a[1] <- 17; *)
(*     let x = next a c in *)
(*     assert { x = 0 } *)
(* *\) *)

(* end *)
