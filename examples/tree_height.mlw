
(** Computing the height of a tree in CPS style
    (author: Jean-Christophe Filliâtre) *)

module HeightCPS

  use import int.Int
  use import int.MinMax
  use import bintree.Tree
  use import bintree.Height
  use HighOrd

  function height_cps (t: tree 'a) (k: int -> 'b) : 'b =
    match t with
    | Empty -> k 0
    | Node l _ r ->
        height_cps l (\ hl.
        height_cps r (\ hr.
        k (1 + max hl hr)))
    end

  function height1 (t: tree 'a) : int = height_cps t (\ h. h)

  lemma height_cps_correct:
    forall t: tree 'a, k: int -> 'b. height_cps t k = k (height t)

  lemma height1_correct:
    forall t: tree 'a. height1 t = height t

end

(** Computing the height of a tree with an explicit stack
    (code: Andrei Paskevich / proof: Jean-Christophe Filliâtre) *)

module HeightStack

  use import int.Int
  use import int.MinMax
  use import list.List
  use import bintree.Tree
  use import bintree.Size
  use import bintree.Height

  type stack 'a = list (int, tree 'a)

  function heights (s: stack 'a) : int =
    match s with
    | Nil            -> 0
    | Cons (h, t) s' -> max (h + height t) (heights s')
    end

  function sizes (s: stack 'a) : int =
    match s with
    | Nil            -> 0
    | Cons (_, t) s' -> size t + sizes s'
    end

  lemma sizes_nonneg: forall s: stack 'a. sizes s >= 0

  let rec height_stack (m: int) (s: stack 'a) : int
    requires { m >= 0 }
    variant  { sizes s, s }
    ensures  { result = max m (heights s) }
  = match s with
    | Nil                     -> m
    | Cons (h, Empty) s'      -> height_stack (max m h) s'
    | Cons (h, Node l _ r) s' -> height_stack m (Cons (h+1,l) (Cons (h+1,r) s'))
   end

  let height1 (t: tree 'a) : int
    ensures { result = height t }
  = height_stack 0 (Cons (0, t) Nil)

end
