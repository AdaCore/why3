module Local

  use int.Int

  let c0 () =
    let x = 1 in
    assert { x >= 0 };
    assert { x > 10 }

  predicate p (_: unit) = false

  let c1 () =
    let ref x = () in
    assert { not p x }

  let c2 () =
    let ref x = 1 in
    assert { x >= 0 };
    assert { x > 10 }

  let c_or () =
    assert { 4 >= 3 || 1 < 3 }

  let f2_aux (ref x:int)
    requires { x = 0 }
  =
    for i = 1 to 10 do
      invariant { x = 0 || x = 1 }
      x <- x + 1
    done

  let f2 () =
    let ref z = 42 in f2_aux z

  let f3 () =
    let x = True in assert { x = True }
end

module Global

  use int.Int

  let ref x = 0

  let c2 () =
    assert { x >= 0 };
    assert { x > 10 }

end


module Functions

  use int.Int

  let function fff (x: int): int = x+100

  let ref x = 0

  let f1 () =
    let function ggg (x: int) (_: int) : int = x+200 in
    assert { 101 = fff 1 };
    assert { 200 = ggg 0 1 };
    assert { forall x. ggg x 1 = x };
    assert { fff 0 = ggg 0 1 }

  let f2 () requires { x = 0 } =
    for i = 1 to 10 do
      invariant { 0 < i <= 10 }
    done

  let f3 () requires { x = 0 } =
    for i = 0 to 5 do
      invariant { x = 0 || x = 1 }
      x <- x + 1
    done

  let f4 ()  =
    while x < 10 do
      variant { 10 - x }
      invariant { 5 >= x }
      x <- x + 1
    done;
    assert { x = 100 }

  let f5_aux (y: int) : int
    requires { y > 0 }
    ensures { result = 1 }
  = y

  let f5a () =
    let _ = f5_aux 0 in
    ()

  let f5b () =
    let _ = f5_aux 1 in
    let _ = f5_aux 2 in
    ()

  let f5c () =
    let _ = f5_aux 0 in
    ()

  exception E int

  let f6_aux () : unit raises { E j -> j = x } =
    x <- x + 1;
    raise (E 0)

  let f6 () =
    try f6_aux ()
    with E _ -> () end

  let f7_aux ()
    (* ensures { x = old x } (\* How to recover [old x] in Pinterp? *\) *)
  = x <- x + 1

  let f7 () =
    f7_aux ()

  let f8 () =
    let ref r = 0 in
    assert { r = 1 }

  let f9_aux (ref x: 'a) (y: 'a)
    requires { x <> y }
    ensures { result = y }
  = x <- y;
    x

  let f9 () =
    let ref r = 1 in
    let _ = f9_aux r 42 in
    let _ = f9_aux r 42 in
    ()
end

module Strings
  use string.OCaml
  let test1 () =
    let s = "hello" in
    concat s " world"
end

module PolyRefContracts
  use int.Int
  use ref.Ref

  let f1 () =
    let myref = ref 0 in
    myref := !myref + 1

  let f2_aux (ref argref: 'a) (argx argy: 'a)
    requires { argref <> argx }
    ensures { result = argx }
    ensures { result = argy }
  = argref <- argx;
    argref

  let ref myref = 0

  let f2a () =
    f2_aux myref 1 1 (* OK *)

  let f2b () =
    f2_aux myref 0 1 (* PRE fails *)

  let f2c () =
    f2_aux myref 1 2 (* POST fails *)
end

module RecordMut
  use int.Int

  type t = { mutable f: int -> int }

  let test () =
    let x = { f= fun (x:int) -> x+1 } in
    assert { x.f 1 = 2 };
    let f' = x.f in
    x.f <- (fun x -> if x = 0 then 42 else f' x);
    (* previous x.f is in now the closure of x.f *)
    assert { x.f 0 = 42 };
    assert { x.f 1 = 2 }
end

module RecordMutGhost
  use int.Int

  type t = { mutable f: int -> int; ghost n: int }

  let test () =
    let x = { f= (fun (x:int) -> x); n= 2 } in
    assert { x.n = 2 };
    assert { x.f 3 = 3 };
    let g = x.f in 
    x.f <- (fun (z: int) -> if z = 3 then 42 else g z);
    assert { x.f 3 = 42 };
    1 (* + x.n *) + x.f 3
end

module RecordPoly
  use int.Int
  type t1 'a = { mutable x: 'a }

  let test1 () =
    let r = {x= 1} in
    assert { r.x = 1 };
    r.x <- 100;
    assert { r.x = 100 }

  type t2 'a = { mutable f: int -> 'a }
  let test2 () =
    let r = { f= fun (_: int) -> True } in
    assert { r.f 0 = True };
    assert { r.f 1 = True };
    r.f <- (let f = r.f in (fun (j: int) -> if j = 0 then False else f j));
    assert { r.f 0 = False };
    assert { r.f 1 = True };

  type t3 'a = { mutable elts: int -> 'a; length: int }

  let update (r: t3 'a) (i: int) (x: 'a) : unit
    (* requires { 0 < i < r.length } *)
    (* ensures { forall j. 0 < j < r.length -> j <> i -> r.elts j = old r.elts j } *)
    (* ensures { r.elts i = x } *)
  = r.elts <- let f = r.elts in (fun (j: int) -> if j = i then x else f j)

  use bool.Bool

  let test3 () =
    let r = { length= 5; elts= fun (_:int) -> True } in
    assert { r.elts 3 = True };
    update r 3 False;
    assert { r.elts 3 = False };
    assert { r.elts 2 = True }
end

module Arrays
  use array.Array

  let f1 () =
    let a = make 10 0 in
    let i = a[0] in
    assert { i = 0 };
    a[10]

  let f3 () =
    let a = make 10 0 in
    assert { length a = 10 };
    assert { a[0] = 0 }; (* OK *)
    assert { a[10] = 0 } (* FAILS *)
end


module ArrayExec

  type array = {
      length : int ;
      mutable contents : int -> int ;
    }

  use int.Int

  let make (l: int) (v: int) : array
  = { length= l; contents= fun _ -> v }

  let function map_update (f:int -> int) (x:int) (y:int) =
    fun (z:int) -> if z=x then y else f z

  let function ([]) (a: array) (i: int) : int = a.contents i

  let function ([<-]) (a: array) (i: int) (v: int): array
    = { length = a.length ; contents = map_update a.contents i v }

  let ([]<-) (a: array) (i: int) (v: int) : unit
    = a.contents <- map_update a.contents i v

  let f () =
    let a = make 5 1 in
    let x = a[0] in
    assert { x = 1 }
end


module C
  use int.Int

  type char = < range 0 255 >

  val (<=) (c1 c2: char) : bool
     ensures { result <-> char'int c1 <= char'int c2 }

  val (-) (c1 c2: char) : char
     ensures { char'int result = char'int c1 - char'int c2 }

  let uppercase (c:char) =
     if (97:char) <= c <= (122:char)  then
        c - 32 else c

  let main () : char =
    uppercase 97
end