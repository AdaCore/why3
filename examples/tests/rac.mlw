module Local

  use int.Int

  let test1 () =
    let x = 1 in
    assert { x >= 0 }; (* ok *)
    assert { forall y. y = x -> y = 1 }; (* cannot evaluate *)
    assert { x = 0 } (* failure *)

  predicate p (_: unit) = false

  let test2 () =
    let ref x = () in
    assert { not p x } (* ok *)

  let test3 () =
    let ref x = 1 in
    assert { x >= 0 }; (* ok *)
    assert { x > 10 } (* failure *)

  let test4 () =
    assert { 4 >= 3 || 1 < 3 } (* ok *)

  let test5 () =
    let x = True in
    assert { x = True }
end

module Global

  use int.Int

  val ref x : int

  let test1 () =
    assert { x = 0 }; (* ok *)
    x <- x + 1;
    assert { x = 1 } (* ok *)

  let ref y = 42

  let test2 () =
    assert { y = 42 }; (* ok *)
    ()
end

module Functions

  use int.Int

  let function fff (x: int): int = x+100

  let ref x = 0

  let f1 () =
    let function ggg (x: int) (_: int) : int = x+200 in
    assert { 101 = fff 1 }; (* ok *)
    assert { 200 = ggg 0 1 }; (* ok *)
    assert { fff 0 = ggg 0 1 } (* failure *)

  let f2 () requires { x = 0 } =
    for i = 1 to 10 do
      invariant { 0 < i <= 10 } (* ok *)
    done

  let f3 () requires { x = 0 } =
    for i = 0 to 5 do
      invariant { x = 0 || x = 1 } (* failure when i = 1, x = 2 *)
      x <- x + 1
    done

  let f4 ()  =
    while x < 10 do
      variant { 10 - x }
      invariant { 5 >= x } (* failure when x = 6 *) 
      x <- x + 1
    done;
    assert { x = 100 }

  let f5_aux (y: int) : int
    requires { y > 0 }
    ensures { result = 1 }
  = y

  let f5a () =
    f5_aux 0 (* failure in precondition of f5_aux *)

  let f5b () =
    let _ = f5_aux 1 in (* ok *)
    f5_aux 2 (* failure in postcondition of f5_aux *)

  exception E int

  let f6_aux () : unit
    raises { E j -> j = x }
  = x <- 1;
    raise (E 42)

  let f6 () =
    try f6_aux () (* failure in exceptional postcondition of f6_aux *)
    with E _ -> () end

  let f7_aux ()
    ensures { x = old x }
  = x <- x + 1

  let f7 () =
    f7_aux () (* TODO failure in postcondition in f7_aux *)

  let f8 () =
    let ref r = 0 in
    assert { r = 1 } (* failure *)

  let f9_aux (ref x: 'a) (y: 'a)
    requires { x <> y }
    ensures { result = y }
  = x <- y;
    x

  let f9 () =
    let ref r = 1 in
    let _ = f9_aux r 42 in (* ok *)
    let _ = f9_aux r 42 in (* failure in precondition *)
    ()
end

module Strings
  use string.OCaml
  let test1 () =
    let s = "hello" in
    concat s " world"
end

module PolyRefContracts
  use int.Int
  use ref.Ref

  let f1 () =
    let myref = ref 0 in
    myref := !myref + 1

  let f2_aux (ref argref: 'a) (argx argy: 'a)
    requires { argref <> argx }
    ensures { result = argx }
    ensures { result = argy }
  = argref <- argx;
    argref

  let ref myref = 0

  let f2a () =
    f2_aux myref 1 1 (* OK *)

  let f2b () =
    f2_aux myref 0 1 (* PRE fails *)

  let f2c () =
    f2_aux myref 1 2 (* POST fails *)
end

module RecordMutGhost
  use int.Int

  type t = {mutable f: int -> int; ghost n: int}

  let test () =
    let x = { f= (fun (x:int) -> x); n= 2 } in
    assert { x.n = 2 }; (* ok *)
    assert { x.f 3 = 3 }; (* ok *)
    x.f <- (let g = x.f in (fun (z: int) -> if z = 3 then 42 else g z));
    assert { x.f 3 = 42 }; (* ok *)
    1 (* + x.n *) + x.f 3
end

module RecordPoly
  use int.Int
  type t1 'a = { mutable x: 'a }

  let test1 () =
    let r = {x= 1} in
    assert { r.x = 1 }; (* ok *)
    r.x <- 100;
    assert { r.x = 100 } (* ok *)

  type t2 'a = { mutable f: int -> 'a }
  let test2 () =
    let r = { f= fun (_: int) -> True } in
    assert { r.f 0 = True }; (* ok *)
    assert { r.f 1 = True }; (* ok *)
    r.f <- (let f = r.f in (fun (j: int) -> if j = 0 then False else f j));
    assert { r.f 0 = False }; (* ok *)
    assert { r.f 1 = True }; (* ok *)

  type t3 'a = { mutable elts: int -> 'a; length: int }

  let update (r: t3 'a) (i: int) (x: 'a) : unit
    requires { 0 < i < r.length }
    ensures { forall j. 0 < j < r.length -> j <> i -> r.elts j = old r.elts j }
    ensures { r.elts i = x }
  = r.elts <- let f = r.elts in (fun (j: int) -> if j = i then x else f j)

  use bool.Bool

  let test3 () =
    let r = { length= 5; elts= fun (_:int) -> True } in
    assert { r.elts 3 = True }; (* ok *)
    update r 3 False;
    assert { r.elts 3 = False }; (* ok *)
    assert { r.elts 2 = True }; (* ok *)
    assert { r.elts 1 = False } (* failure *)
end

module PolyFunc
  use int.Int

  let mk v = fun (_: int) -> v

  let test0 () =
      mk 0

  type t 'a = {mutable f: int -> 'a}

  let function map_update (f: int -> 'a) (i: int) (x: 'a) =
    fun (j: int) -> if j = i then x else f j

  let ([]<-) (x: t 'a) (i: int) (v: 'a) : unit =
    x.f <- map_update x.f i v

  let test1 () =
    let x = {f= fun _ -> 0} in
    (* x.f <- map_update x.f 0 111; *)
    x[0] <- 111;
    x.f 0, x.f 1
end


module ArrayExec
  use int.Int

  type array 'a = {length: int; mutable elts: int -> 'a}

  let function make (n: int) (v: 'a) : array 'a
    ensures { result.length = n }
    ensures { forall i. 0 <= i < n -> result.elts i = v }
  = {length= n; elts= fun _ -> v}

  let function map_update (f: int -> 'a) (i: int) (x: 'a) =
    fun (j: int) -> if j = i then x else f j

  let ([]) (a: array 'a) (i: int) : 'a = a.elts i

  let ([]<-) (a: array 'a) (i: int) (v: 'a) : unit
    = a.elts <- map_update a.elts i v

  let test0 () =
    let a = {length= 5; elts= fun (_: int) -> 0} in
    a.elts 0, a.elts 1

  let test1 () =
    let a = {length= 5; elts= fun (_: int) -> 0} in
    a.elts <- (let f = a.elts in (fun (i: int) -> if i = 0 then 11 else f i));
    a.elts 0, a.elts 1

  let test2 () =
    let a = make 10 0 in
    a[0] <- 10;
    a[0], a[1]

  clone export array.Array with
    type array = array,
    val make = make,
    val ([]) = ([]),
    val ([]<-) = ([]<-)
end

module Arrays
  use array.Array

  let test0 () =
    let a = make 10 0 in
    a[0] <- 10;
    a[0], a[1]

  let test1 () =
    let a = make 10 0 in
    assert { length a = 10 };
    assert { a[0] = 0 }; (* ok *)
    a[1] <- 11;
    assert { a[0] = 0 }; (* ok *)
    assert { a[1] = 11 }; (* ok *)
    assert { a[2] = 11 }; (* failure *)
    ()
end

module C
  use int.Int

  type char = < range 0 255 >

  val (<=) (c1 c2: char) : bool
     ensures { result <-> char'int c1 <= char'int c2 }

  val (-) (c1 c2: char) : char
     ensures { char'int result = char'int c1 - char'int c2 }

  let uppercase (c:char) =
     if (97:char) <= c <= (122:char)  then
        c - 32 else c

  let main () : char =
    uppercase 97
end