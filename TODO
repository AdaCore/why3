WhyML
-----

  - currently every unhandled exception has postcondition "true".
    "false" would be a poor choice, as it could introduce inconsistency
    in the WPs of the caller. Should we allow unhandled exceptions at all?

  - should we produce the WPs for the modules loaded from loadpath?

  - should the API ensure that every psymbol resets the new regions?
    Should they be always reset at the last arrow? What if they are
    already reset at some earlier arrows, should we reset them again?

  - in "val" and "any", when a region rho is written into, but some
    subregion rho' of rho is not, should we reset rho' under rho?
    In Mlw_typing or in Mlw_expr?

  - current WP does not respect the lexical scope. In the program

      let r = create 0 in
      let v = !r in
      incr r;
      let () =
        let v = !r in
        ()
      in
      assert { v = 1 }

    the last assert will be proven if the same let_defn [let v = !r]
    and therefore the same pvsymbol v is used in both places (which
    can be done using API). One possible solution is to ensure the
    one-time usage of let_defns and rec_defns in programs.

  - are mutable values worth it? They can only appear as pattern
    variables standing for mutable fields, and allow us to have
    mutable fields in algebraic types. On the other hand, they
    require tedious checks pretty much everywhere in the code,
    and they cannot be translated to OCaml.

syntaxe
-------

  - open

  - infix symbols as constructors, e.g.

       type list 'a = Nil | (::) 'a (list 'a)

  - constants in patterns, e.g.

       match ... with 0 :: r -> ... | ...


sémantique
----------

  - env should not contain theories under the null path.
    The current implementation of Typing.find_theory is potentially broken.

  - should split_goal provide a "right-hand side only split"?

  - produce reparsable tasks in Why3 format: how to preserve information about
    the origins of symbols to be able to use drivers after reparsing?

  - weak memoization in transformations has a disadvantage: if a task or a decl
    is not changed by a transformation, it will stay in the hash table forever,
    since the key is the value. Should we use generation numbers in arguments
    and results of transformations?
     François -- I don't get that point the weak Hashtbl that we use
   are designed to work on this case, even with the identity function.
   What we should do is a way to remove the task from a session when
   they are not needed anymore.

  - uses : pour l'instant, l'ordre des théories dans le fichier est important
    i.e. les théories mentionnées par uses doivent être définies précédemment

  - open (et échouer si "open A" et "open B" avec A et B déclarant un symbole
    de même nom)

error reporting
---------------

  - should we create a common [exception Why.Error of exn] to facilitate
    integration of the library? This would require a special [raise] call:
        why_raise e = raise (Why.Error e)

session
-------
  - save the output of the prover
  - escape the string in the xml
  - the filenames in the location inside a session should be relative
   to the session_dir.

tools
-----

  - the tools should verify that the provers have the same version
   than reported in the configuration
  - Maybe : make something generic for the dialog box with memory.
  - autodetection can be modified now that only name/version/altern
   are taken into account in session.
