WhyML
-----

  - introduce logic predicates for program type invariants:
      predicate <type_name>_invariant (result : <type_name>) = ...
    Should this be just the top invariant, as written by the user,
    or should we also include the invariants for the fields?

  - allow to specify type invariants below a type definition,
    provided there are no program declarations in between.
    This allows us to define auxiliary logical functions and
    predicates that depend on the (pure) type and can be used in
    the invariant. However, the parser must know from the start
    that the type has an invariant, what's the best syntax?

  - type invariants are now assumed/asserted at the function call
    boundaries. We can add a binary flag to Ityapp to allow open
    types in function signatures (must be careful with reg_match!).
    The type cast can then play the role of the "close" instruction.
    Do we need it? What's the good syntax for open types?

  - currently every unhandled exception has postcondition "true".
    "false" would be a poor choice, as it could introduce inconsistency
    in the WPs of the caller. Should we allow unhandled exceptions at all?

  - current WP does not respect the lexical scope. In the program

      let r = create 0 in
      let v = !r in
      incr r;
      let () =
        let v = !r in
        ()
      in
      assert { v = 1 }

    the last assert will be proven if the same let_defn [let v = !r]
    and therefore the same pvsymbol v is used in both places (which
    can be done using API). One possible solution is to ensure the
    one-time usage of let_defns and rec_defns in programs.

  - are mutable values worth it? They can only appear as pattern
    variables standing for mutable fields, and allow us to have
    mutable fields in algebraic types. On the other hand, they
    require tedious checks pretty much everywhere in the code,
    and they cannot be translated to OCaml.

syntaxe
-------

  - open

  - infix symbols as constructors, e.g.

       type list 'a = Nil | (::) 'a (list 'a)

  - constants in patterns, e.g.

       match ... with 0 :: r -> ... | ...


sémantique
----------

  - env should not contain theories under the null path.
    The current implementation of Typing.find_theory is potentially broken.

  - should split_goal provide a "right-hand side only split"?

  - produce reparsable tasks in Why3 format: how to preserve information about
    the origins of symbols to be able to use drivers after reparsing?

  - weak memoization in transformations has a disadvantage: if a task or a decl
    is not changed by a transformation, it will stay in the hash table forever,
    since the key is the value. Should we use generation numbers in arguments
    and results of transformations?
     François -- I don't get that point the weak Hashtbl that we use
   are designed to work on this case, even with the identity function.
   What we should do is a way to remove the task from a session when
   they are not needed anymore.

  - uses : pour l'instant, l'ordre des théories dans le fichier est important
    i.e. les théories mentionnées par uses doivent être définies précédemment

  - open (et échouer si "open A" et "open B" avec A et B déclarant un symbole
    de même nom)

error reporting
---------------

  - should we create a common [exception Why.Error of exn] to facilitate
    integration of the library? This would require a special [raise] call:
        why_raise e = raise (Why.Error e)

session
-------
  - save the output of the prover
  - escape the string in the xml
  - the filenames in the location inside a session should be relative
   to the session_dir.

tools
-----

  - the tools should verify that the provers have the same version
   than reported in the configuration
  - Maybe : make something generic for the dialog box with memory.
  - autodetection can be modified now that only name/version/altern
   are taken into account in session.
