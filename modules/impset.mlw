
(** {1 Imperative sets} *)

module Impset

  use import set.Fset

  type elt

  type t = abstract { mutable contents: set elt }

  val empty () : t
    ensures { is_empty result.contents }

  val is_empty (s: t) : bool
    ensures { result <-> is_empty s.contents }

  val mem (x: elt) (s: t) : bool
    ensures { result <-> mem x s.contents }

  val add (x: elt) (s: t) : unit
    writes  { s }
    ensures { s.contents = add x (old s.contents) }

  val choose (s: t) : elt
    requires { not (is_empty s.contents) }
    ensures  { mem result s.contents }

  val remove (x: elt) (s: t) : unit
    writes   { s }
    ensures  { s.contents = remove x (old s.contents) }

  let choose_and_remove (s: t) : elt
    requires { not (is_empty s.contents) }
    ensures  { mem result (old s.contents) }
    ensures  { s.contents = remove result (old s.contents) }
  = let x = choose s in
    remove x s;
    x

end
