
(* References *)

module Ref

  type ref 'a = {| mutable contents : 'a |}

  parameter ref : v:'a -> {} ref 'a { result=v }

  parameter (!) : r:ref 'a -> {} 'a reads r.contents { result=r }

  parameter (:=) : r:ref 'a -> v:'a -> {} unit writes r.contents { r=v }

end

module Refint

  use export int.Int
  use export module Ref

  parameter incr : r:ref int -> {} unit writes r.contents { r = old r + 1 }

  parameter decr : r:ref int -> {} unit writes r.contents { r = old r - 1 }

end

(* Arrays *)
module Array

  use import int.Int
  use import array.ArrayLength as A
  use import module Ref
  type map 'a = t int 'a

  type array 'a model ref (map 'a)

  logic length (a : array 'a) : int = A.length a
  logic ([]) (a : array 'a) (i : int) : 'a = get a i

  parameter ([]) : a:array 'a -> i:int ->
    { 0 <= i < length a } 'a reads a.contents { result = a[i] }

  parameter set : a:array 'a -> i:int -> v:'a ->
    { 0 <= i < length a } unit writes a.contents { a = (old a)[i <- v] }

  parameter length : a:array 'a -> {} int { result = length a }

  parameter make : n:int -> v:'a -> 
    {} 
    array 'a 
    { length result = n and forall i:int. 0 <= i < n -> result[i] = v}
end

(***
module Array

  use import int.Int
  use import array.Array
  type map 'a = t int 'a

  type array 'a model {| length : int; mutable elts : map 'a |}

  logic ([]) (a : array 'a) (i : int) : 'a = get a.elts i

  parameter ([]) : a:array 'a -> i:int ->
    { 0 <= i < a.length } 'a reads a.elts { result = a[i] }

  parameter set : a:array 'a -> i:int -> v:'a ->
    { 0 <= i < a.length } unit writes a.elts { a.elts = (old a.elts)[i <- v] }

  parameter length : a:array 'a -> {} int { result = a.length }

  parameter make : n:int -> v:'a -> 
    {} 
    array 'a 
    { result.length = n and forall i:int. 0 <= i < n -> result[i] = v}

  parameter append : a1:array 'a -> a2:array 'a ->
    {}
    array 'a
    { length result = length a1 + length a2 and
      (forall i:int. 0 <= i < length a1 -> result[i] = a1[i]) and
      (forall i:int. 0 <= i < length a2 -> result[length a1 + i] = a2[i]) }

  parameter sub : a:array 'a -> ofs:int -> len:int ->
    { 0 <= ofs and ofs + len <= length a }
    array 'a
    { length result = len and
      forall i:int. 0 <= i < len -> result[i] = a[ofs + i] }

  parameter copy : a:array 'a ->
    {}
    array 'a
    { length result = length a and
      forall i:int. 0 <= i < length result -> result[i] = a[i] }

  parameter fill : a:array 'a -> ofs:int -> len:int -> v:'a ->
   { 0 <= ofs and ofs + len <= length a }
   unit
   writes a.elts
   { (forall i:int. 
       (0 <= i < ofs or ofs + len <= i < length a) -> a[i] = (old a)[i]) 
     and 
     (forall i:int.
       ofs <= i < ofs + len -> a[i] = v) }

  parameter blit :
   a1:array 'a -> ofs1:int -> a2:array 'a -> ofs2:int -> len:int ->
   { 0 <= ofs1 and ofs1 + len <= length a1 and
     0 <= ofs2 and ofs2 + len <= length a2 }
   unit
   writes a2.elts
   { (forall i:int. 
       (0 <= i < ofs2 or ofs2 + len <= i < length a2) -> a2[i] = (old a2)[i]) 
     and 
     (forall i:int.
       ofs2 <= i < ofs2 + len -> a2[i] = a1[ofs1 + i - ofs2]) }

  (* TODO?
     - concat : 'a array list -> 'a array
     - to_list
     - of_list
  *)

end

module TestArray

  use import int.Int
  use import module Array

  let test_append () =
    let a1 = make 17 2 in
    assert { a1[3] = 2 };
    set a1 3 4;
    assert { a1[3] = 4 };
    let a2 = make 25 3 in
    assert { a2[0] = 3 }; (* needed to prove a[17]=3 below *)
    let a  = append a1 a2 in
    assert { length a = 42 };
    assert { a[3] = 4 };
    assert { a[17] = 3 };
    ()

  let test_fill () =
    let a = make 17 True in
    fill a 10 4 False;
    assert { a[10] = False }

  let test_blit () =
    let a1 = make 17 True in
    let a2 = make 25 False in
    blit a1 10 a2 17 7;
    assert { a1[10] = True  };
    assert { a2[16] = False };
    assert { a2[17] = True  };
    assert { a2[23] = True  };
    assert { a2[24] = False }

end
***)

(*
Local Variables:
compile-command: "unset LANG; make -C .. modules/stdlib"
End:
*)
