
(** {1 Hash tables}

This module provides Hash tables Ã  la OCaml. Each key is mapped to a {h <b>stack</b>} of values,
   with [add h k v] pushing a new value [v] for key [k],
   and [remove h k] popping a value for key [k].

*)

module Hashtbl

  use import list.List
  use import map.Map

  type key

  type t 'a model { mutable contents: map key (list 'a) }

  function ([]) (h: t 'a) (k: key) : list 'a = Map.([]) h.contents k

  val create (n:int) : t 'a ensures { forall k: key. result[k] = Nil }

  val clear (h: t 'a) : unit writes {h} ensures { forall k: key. h[k] = Nil }

  val add (h: t 'a) (k: key) (v: 'a) : unit writes {h}
    ensures { h[k] = Cons v (old h)[k] }
    ensures { forall k': key. k' <> k -> h[k'] = (old h)[k'] }

  val mem (h: t 'a) (k: key) : bool reads {h}
    ensures { result=True <-> h[k] <> Nil }

  val find (h: t 'a) (k: key) : 'a reads {h}
    requires { h[k] <> Nil }
    ensures  { match h[k] with Nil -> false | Cons v _ -> result = v end }

  val find_all (h: t 'a) (k: key) : list 'a reads {h}
    ensures { result = h[k] }

  exception NotFound

  val defensive_find (h: t 'a) (k: key) : 'a reads {h}
    ensures { match h[k] with Nil -> false | Cons v _ -> result = v end }
    raises  { NotFound -> h[k] = Nil }

  val copy (h: t 'a) : t 'a reads {h}
    ensures { forall k: key. result[k] = h[k] }

  val remove (h: t 'a) (k: key) : unit writes {h}
    ensures { h[k] = match (old h)[k] with Nil -> Nil | Cons _ l -> l end }
    ensures { forall k': key. k' <> k -> h[k'] = (old h)[k'] }

  val replace (h: t 'a) (k: key) (v: 'a) : unit writes {h}
    ensures {
      h[k] = Cons v (match (old h)[k] with Nil -> Nil | Cons _ l -> l end) }
    ensures { forall k': key. k' <> k -> h[k'] = (old h)[k'] }

  (*** TODO
     - val length: t 'a -> int (the number of distinct key)
     - val iter : ('a -> 'b -> unit) -> ('a, 'b) t -> unit
     - val fold : ('a -> 'b -> 'c -> 'c) -> ('a, 'b) t -> 'c -> 'c
  *)

end

module TestHashtbl

  use import int.Int
  use import list.List
  use import Hashtbl

  function k1: key
  function k2: key
  function k3: key
  axiom kdiff : k1 <> k2 /\ k1 <> k3 /\ k2 <> k3

  let test1 () =
    let h = create 17 in
    add h k1 True;
    assert { h[k1] = Cons True Nil };
    assert { h[k2] = Nil };
    let v1 = find h k1 in
    assert { v1 = True };
    add h k1 False;
    assert { h[k1] = Cons False (Cons True Nil) };
    replace h k1 True;
    assert { h[k1] = Cons True (Cons True Nil) }

end

module HashtblImpl

  use import int.Int
  use import int.ComputerDivision
  use import list.List
  use import list.Mem
  use import array.Array

  type key

  function hash key : int

  axiom hash_nonneg: forall k: key. 0 <= hash k

  function bucket (k: key) (n: int) : int = mod (hash k) n

  lemma bucket_bounds:
    forall n: int. 0 < n ->
    forall k: key. 0 <= bucket k n < n

  type t 'a = { mutable size: int; (* total number of elements *)
                mutable data: array (list (key, 'a)); }
    invariant { let n = Array.length self.data in
                0 < n /\
                forall i: int. 0 <= i < n ->
                forall k: key, v: 'a. mem (k,v) self.data[i] -> bucket k n = i }

  function extract (k: key) (l: list (key, 'a)) : list 'a = match l with
    | Nil -> Nil
    | Cons (k', v) r -> if k = k' then Cons v (extract k r) else extract k r
  end

  function ([]) (t: t 'a) (k: key): list 'a =
    extract k (Array.get t.data (bucket k (length t.data)))

  let create (n:int) : t 'a
    requires { 1 <= n }
    ensures  { forall k: key. result[k] = Nil }
  = { size = 0; data = Array.make n Nil }

  let clear (h: t 'a)
    ensures { forall k: key. h[k] = Nil }
  = h.size <- 0;
    Array.fill h.data 0 (Array.length h.data) Nil

  let resize (h: t 'a)
    ensures { forall k: key. h[k] = (old h)[k] }
  = let odata = h.data in
    let osize = Array.length odata in
    let nsize = 2 * osize + 1 in
    let ndata = Array.make nsize Nil in
    let rec rehash l = match l with
      | Nil -> ()
      | Cons (k, v) r ->
          let b = bucket k nsize in
          ndata[b] <- Cons (k, v) (Array.([]) ndata b);
          rehash r
      end
    in
    for i = 0 to osize - 1 do rehash (Array.([]) odata i) done;
    h.data <- ndata

  lemma extract_neq:
    forall k k': key, v: 'a, l: list (key, 'a).
    k <> k' -> extract k' l = extract k' (Cons (k, v) l)

  let add (h: t 'a) (k: key) (v: 'a)
    ensures { h[k] = Cons v (old h)[k] /\
      forall k': key. k' <> k -> h[k'] = (old h)[k'] }
  = let b = bucket k (Array.length h.data) in
    h.data[b] <- Cons (k, v) (Array.([]) h.data b)

(*
  let add (h: t 'a) (k: key) (v: 'a) =
    ensures { h[k] = Cons v (old h)[k] /\
      forall k': key. k' <> k -> h[k'] = (old h)[k'] }
    let b = bucket k (Array.length h.data) in
    h.data[b] <- Cons (k, v) (Array.([]) h.data b);
    if h.size > 2 * Array.length h.data then resize h
*)

end
