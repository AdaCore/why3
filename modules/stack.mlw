
(* Polymorphic mutable stacks *)

module Stack

  use import list.List
  use import list.Length

  mutable type t 'a model list 'a

  parameter create : unit -> {} t 'a { result = Nil }

  parameter push : x:'a -> s:t 'a -> {} unit writes s { s = Cons x (old s) }

  exception Empty

  parameter pop : 
    s:t 'a -> 
    {} 
    'a 
    writes s raises Empty
    { match old s with Nil -> false | Cons x t -> result = x and s = t end } 
    | Empty -> { s = old s = Nil }

  parameter top : 
    s:t 'a -> 
    {} 
    'a 
    reads s raises Empty
    { match s with Nil -> false | Cons x _ -> result = x end } 
    | Empty -> { s = Nil }

  parameter clear : s:t 'a -> {} unit writes s { s = Nil }

  parameter copy : s:t 'a -> {} t 'a { result = s }

  parameter is_empty : s:t 'a -> {} bool reads s { result=True <-> s = Nil }

  parameter length : s:t 'a -> {} int reads s { result = length s }

end

module Test

  use import int.Int
  use import list.List
  use module Stack

  let test0 () =
    let s = Stack.create () : Stack.t 'a in
    assert { s = Nil };
    let b = Stack.is_empty s in
    assert { b = True };
    let n = Stack.length s in
    assert { n = 0 }

  let test1 () =
    let s = Stack.create () in
    Stack.push 1 s;
    let x = Stack.top s in assert { x = 1 };
    Stack.push 2 s;
    let x = Stack.top s in assert { x = 2 };
    ()

end

(*
Local Variables: 
compile-command: "unset LANG; make -C .. modules/stack"
End: 
*)
