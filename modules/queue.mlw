
(* Polymorphic mutable queues *)

module Queue

  use import list.List
  use import list.Append
  use import list.Length

  type t 'a model {| mutable elts: list 'a |}

  val create: unit -> {} t 'a { result.elts = Nil }

  val push:
    x: 'a -> q: t 'a -> {} unit writes q { q.elts = old q.elts ++ Cons x Nil }

  exception Empty

  val pop:
    q: t 'a ->
    {}
    'a
    writes q raises Empty
    { match old q.elts with Nil -> false
                          | Cons x t -> result = x /\ q.elts = t end }
    | Empty -> { q.elts = old q.elts = Nil }

  val peek:
    q: t 'a ->
    {}
    'a
    reads q raises Empty
    { match q.elts with Nil -> false | Cons x _ -> result = x end }
    | Empty -> { q.elts = Nil }

  val clear: q: t 'a -> {} unit writes q {q.elts = Nil }

  val copy: q: t 'a -> {} t 'a reads q { result = q }

  val is_empty:
    q: t 'a -> {} bool reads q { result=True <-> q.elts = Nil }

  val length: q: t 'a -> {} int reads q { result = length q.elts }

end

module Test

  use import int.Int
  use import list.List
  use import module Queue

  let test0 () =
    let s = Queue.create () : Queue.t 'a in
    assert { s.elts = Nil };
    let b = Queue.is_empty s in
    assert { b = True };
    let n = Queue.length s in
    assert { n = 0 }

  let test1 () =
    let s = Queue.create () in
    Queue.push 1 s;
    let x = Queue.peek s in assert { x = 1 };
    Queue.push 2 s;
    let x = Queue.peek s in assert { x = 1 };
    ()

end

(*
Local Variables:
compile-command: "unset LANG; make -C .. modules/queue"
End:
*)
