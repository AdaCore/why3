
(* Polymorphic mutable queues *)

module Queue

  use import list.List
  use import list.Append
  use import list.Length

  mutable type t 'a model list 'a

  parameter create : unit -> {} t 'a { result = Nil }

  parameter push : 
    x:'a -> s:t 'a -> {} unit writes s { s = old s ++ Cons x Nil }

  exception Empty

  parameter pop : 
    s:t 'a -> 
    {} 
    'a 
    writes s raises Empty
    { match old s with Nil -> false | Cons x t -> result = x and s = t end } 
    | Empty -> { s = old s = Nil }

  parameter top : 
    s:t 'a -> 
    {} 
    'a 
    reads s raises Empty
    { match s with Nil -> false | Cons x _ -> result = x end } 
    | Empty -> { s = Nil }

  parameter clear : s:t 'a -> {} unit writes s { s = Nil }

  parameter copy : s:t 'a -> {} t 'a { result = s }

  parameter is_empty : s:t 'a -> {} bool reads s { result=True <-> s = Nil }

  parameter length : s:t 'a -> {} int reads s { result = length s }

end

module Test

  use import int.Int
  use import list.List
  use module Queue

  let test0 () =
    let s = Queue.create () : Queue.t 'a in
    assert { s = Nil };
    let b = Queue.is_empty s in
    assert { b = True };
    let n = Queue.length s in
    assert { n = 0 }

  let test1 () =
    let s = Queue.create () in
    Queue.push 1 s;
    let x = Queue.top s in assert { x = 1 };
    Queue.push 2 s;
    let x = Queue.top s in assert { x = 1 };
    ()

end

(*
Local Variables: 
compile-command: "unset LANG; make -C .. modules/queue"
End: 
*)
