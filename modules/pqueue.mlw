
(** {1 Priority queues} *)

(** {2 Polymorphic mutable priority queues} *)

module Pqueue

  (** {3 Types} *)

  type elt

  (** [elt] is equipped with a total order [rel] *)
  clone export relations.TotalOrder with type t = elt

  (** the priority queue is modeled as a list of elements *)
  use import list.List
  use import list.Mem
  use import list.Permut
  use import list.Length

  type t model { mutable elts: list elt }

  (** {3 Operations} *)

  (** creates a fresh, empty queue *)
  val create () : t ensures { result.elts = Nil }

  (** pushes an element in a queue *)
  val push (x: elt) (q: t) : unit writes {q}
    ensures { q.elts = Cons x (old q.elts) }

  (** exception raised by [pop] and [peek] to signal an empty queue *)
  exception Empty

  (** [pop] and [peek] return the minimal element, defined as follows *)
  predicate minimal_elt (x: elt) (s: list elt) =
     mem x s /\ forall e: elt. mem e s -> rel x e

  (** removes and returns the minimal element *)
  val pop (q: t) : elt writes {q}
    ensures { permut (Cons result q.elts) (old q.elts) }
    ensures { minimal_elt result (old q.elts) }
    raises  { Empty -> q.elts = (old q.elts) = Nil }

  (** returns the minimal element, without modifying the queue *)
  val peek (q: t) : elt reads {q}
    ensures { minimal_elt result q.elts }
    raises  { Empty -> q.elts = Nil }

  (** empties the queue *)
  val clear (q: t) : unit writes {q} ensures { q.elts = Nil }

  (** returns a fresh copy of the queue *)
  val copy (q: t) : t reads {q} ensures { result = q }

  (** checks whether the queue is empty *)
  val is_empty (q: t) : bool reads {q}
    ensures { result = True <-> q.elts = Nil }

  (** returns the number of elements in the queue *)
  val length (q: t) : int reads {q}
    ensures { result = length q.elts }

end

(** {2 Simpler interface}

when duplicate elements are not allowed

*)

module PqueueNoDup

  (** {3 Types} *)

  (** the abstract type of elements *)
  type elt

  (** [elt] is equipped with a total order [rel] *)
  clone export relations.TotalOrder with type t = elt

  (** the priority queue is modeled as a finite set of elements *)
  use import set.Fset

  type t model { mutable elts: set elt }

  (** {3 Operations} *)

  (** creates a fresh, empty queue *)
  val create () : t ensures { result.elts = empty }

  (** pushes an element in a queue *)
  val push (x: elt) (q: t) : unit writes {q}
    ensures { q.elts = add x (old q.elts) }

  (** exception raised by [pop] and [peek] to signal an empty queue *)
  exception Empty

  (** [pop] and [peek] return the minimal element, defined as follows *)
  predicate minimal_elt (x: elt) (s: set elt) =
     mem x s /\ forall e: elt. mem e s -> rel x e

  (** removes and returns the minimal element *)
  val pop (q: t) : elt writes {q}
    ensures { q.elts = remove result (old q.elts) }
    ensures { minimal_elt result (old q.elts) }
    raises  { Empty -> q.elts = (old q.elts) = empty }

  (** returns the minimal element, without modifying the queue *)
  val peek (q: t) : elt reads {q}
    ensures { minimal_elt result q.elts }
    raises  { Empty -> q.elts = empty }

  (** empties the queue *)
  val clear (q: t) : unit writes {q} ensures {q.elts = empty }

  (** returns a fresh copy of the queue *)
  val copy (q: t) : t reads {q} ensures { result = q }

  (** checks whether the queue is empty *)
  val is_empty (q: t) : bool reads {q}
    ensures { result=True <-> q.elts = empty }

  (** returns the number of elements in the queue *)
  val length (q: t) : int reads {q}
    ensures { result = cardinal q.elts }

end
