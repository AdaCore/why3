module C

  use import map.Map
  use import mach.int.Unsigned
  use import mach.int.Int32
  use import mach.int.UInt32
  use import array.Array
  use import int.Int
  predicate in_us_bounds (n:int) = 0 <= n <= max_uint32
  predicate in_bounds (n:int) = min_int32 <= n <= max_int32
  use import ref.Ref

  (* we would like to specify "abstract" here.  but it would prevent
     to give implementations to the following routines
     pb with specifying alias in the surface language
   *)
  type ptr 'a = {
    data : ref (array 'a) ;
    offset : int ;
  }
  (*invariant { in_us_bounds data.length }*)
  (* it is not required the offset is in 0..elts.length *)

  function plength (p:ptr 'a) : int
  = p.data.contents.length

  function pelts (p:ptr 'a) : int -> 'a
  = p.data.contents.elts

  val p2i (n:int32):int
    ensures { result = Int32.to_int n }

  val predicate is_null (p:ptr 'a) : bool
    ensures { result <-> plength p = 0 }

  val null () : ptr 'a
    ensures { plength result = 0 }

  let incr (p:ptr 'a) (ofs:int32) : ptr 'a
    (* TODO: aliases { p, result } *)
    ensures { result.offset = p.offset + Int32.to_int ofs }
    ensures { result.data = p.data }
   =
    { data = p.data; offset = p.offset + p2i ofs }

  val get (p:ptr 'a) : 'a
    requires { 0 <= p.offset < plength p }
    ensures { result = !(p.data)[p.offset] }

  let get_ofs (p:ptr 'a) (ofs:int32) : 'a
    requires { 0 <= p.offset + Int32.to_int ofs < plength p }
    ensures { result = !(p.data)[p.offset + Int32.to_int ofs] }
  = get (incr p ofs)

  val set (p:ptr 'a) (v:'a) : unit
    requires { 0 <= p.offset < plength p }
    ensures { pelts p = Map.set (pelts (old p)) p.offset v }
    writes { p.data.contents.elts }

  let set_ofs (p:ptr 'a) (ofs:int32) (v:'a) : unit
    requires { 0 <= p.offset + Int32.to_int ofs < plength p }
    ensures { pelts p = Map.set (pelts (old p))
              (p.offset + Int32.to_int ofs) v }
    writes { p.data.contents.elts }
 =
    set (incr p ofs) v

  predicate valid_ptr_shift (p:ptr 'a) (i:int) =
    0 <= p.offset + i < plength p

  predicate valid_ptr_itv (p:ptr 'a) (sz:int) =
    in_bounds sz /\ 0 <= sz /\ 0 <= p.offset /\ p.offset + sz <= plength p

  let lemma valid_itv_to_shift (p:ptr 'a) (sz:int)
    requires { valid_ptr_itv p sz }
    ensures { forall i. 0 <= i < sz -> valid_ptr_shift p i }
  = ()

  val malloc (sz:uint32) : ptr 'a
    ensures { plength result = UInt32.to_int sz \/ plength result = 0 }
    ensures { result.offset = 0 }

 (* How to specify that the data array is reset by free/realloc ?*)
(*  let free (p:ptr 'a) : unit
    requires { p.offset = 0 }
    writes { p }
    ensures { p.data.length = 0 }
  =  if is_null p then ()
     else begin
     let c = incr p (Int32.of_int 0) in
     p.data <- Array.make 0 (get p);
     check { c.data.length = 0 }
     end *)
  val free (p:ptr 'a) : unit
    requires { p.offset = 0 }
    (* TODO: resets { p.data } *)
    writes { p.data }
    ensures { plength p = 0 }
 (* = if is_null p then ()
    else begin
   (* let c = incr p (Int32.of_int 0) in*)
    p.data := Array.make 0 (get p);
    (*check { plength c = 0 }*)
    end
  *)

  val realloc (p:ptr 'a) (sz:int32) : ptr 'a
    requires { Int32.to_int sz > 0 } (* for simplicity, though 0 is legal in C *)
    requires { p.offset = 0 }
    writes { p.data }
    ensures { plength result = Int32.to_int sz \/ plength result = 0 }
    ensures { plength result = Int32.to_int sz -> plength p = 0 }
    ensures { plength result = Int32.to_int sz ->
                forall i:int. 0 <= i < plength (old p) /\ i < Int32.to_int sz ->
                  !(result.data)[i] = !((old p).data)[i] }
    ensures { plength result <> Int32.to_int sz -> p = old p }

  (** Printing *)

  val print_space () : unit
  val print_newline () : unit

  val print_uint32 (n:uint32):unit

end
