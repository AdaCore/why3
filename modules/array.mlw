
(* Arrays *)

module Array

  use import int.Int
  use import map.Map as M

  type array 'a model {| length : int; mutable elts : map int 'a |}

  logic get (a: array 'a) (i: int) : 'a = M.get a.elts i

  logic set (a: array 'a) (i: int) (v: 'a) : array 'a =
    {| a with elts = M.set a.elts i v |}

  (* syntactic sugar *)
  logic ([]) (a: array 'a) (i: int) : 'a = get a i
  logic ([<-]) (a: array 'a) (i: int) (v: 'a) : array 'a = set a i v

  parameter ([]) (a:array 'a) (i:int) :
    { 0 <= i < length a } 'a reads a { result = a[i] }

  parameter ([]<-) (a:array 'a) (i:int) (v:'a) :
    { 0 <= i < length a } unit writes a { a.elts = M.set (old a.elts) i v }

  parameter length (a: array 'a) : {} int { result = a.length }

  (* unsafe get/set operations with no precondition *)
  exception OutOfBounds

  let defensive_get (a:array 'a) (i:int) =
    { }
    if i < 0 || i >= length a then raise OutOfBounds;
    a[i]
    { 0 <= i < length a and result = a[i] }
    | OutOfBounds -> { i < 0 or i >= length a }

  let defensive_set (a: array 'a) (i: int) (v: 'a) =
    { }
    if i < 0 || i >= length a then raise OutOfBounds;
    a[i] <- v
    { 0 <= i < length a and a = (old a)[i <- v] }
    | OutOfBounds -> { i < 0 or i >= length a }

  parameter make (n:int) (v:'a) :
    {}
    array 'a
    { result = {| length = n; elts = M.const v |} }
    (* { length result = n and forall i:int. 0 <= i < n -> result[i] = v} *)

  parameter append (a1: array 'a) (a2: array 'a) :
    {}
    array 'a
    { length result = length a1 + length a2 and
      (forall i:int. 0 <= i < length a1 -> result[i] = a1[i]) and
      (forall i:int. 0 <= i < length a2 -> result[length a1 + i] = a2[i]) }

  parameter sub (a:array 'a) (ofs:int) (len:int) :
    { 0 <= ofs and ofs + len <= length a }
    array 'a
    { length result = len and
      forall i:int. 0 <= i < len -> result[i] = a[ofs + i] }

  parameter copy (a:array 'a) :
    {}
    array 'a
    { length result = length a and
      forall i:int. 0 <= i < length result -> result[i] = a[i] }

  let fill (a:array 'a) (ofs:int) (len:int) (v:'a) =
    { 0 <= ofs and ofs + len <= length a }
    label Init:
    for k = 0 to len - 1 do
      invariant {
        (forall i:int.
        (0 <= i < ofs or ofs + len <= i < length a) -> a[i] = (at a Init)[i])
        and
        (forall i:int. ofs <= i < ofs + k -> a[i] = v)
      }
      a[ofs + k] <- v
    done
    { (forall i:int.
        (0 <= i < ofs or ofs + len <= i < length a) -> a[i] = (old a)[i])
      and
      (forall i:int.
        ofs <= i < ofs + len -> a[i] = v) }

  parameter blit (a1:array 'a) (ofs1:int) (a2:array 'a) (ofs2:int) (len:int) :
    { 0 <= ofs1 and ofs1 + len <= length a1 and
      0 <= ofs2 and ofs2 + len <= length a2 }
    unit
    writes a2
    { (forall i:int.
        (0 <= i < ofs2 or ofs2 + len <= i < length a2) -> a2[i] = (old a2)[i])
      and
      (forall i:int.
        ofs2 <= i < ofs2 + len -> a2[i] = a1[ofs1 + i - ofs2]) }

  (* TODO?
     - concat : 'a array list -> 'a array
     - to_list
     - of_list
  *)

end

module ArraySorted

  use import module Array
  clone import map.MapSorted as M with type elt = int

  logic sorted_sub (a : array int) (l u : int) =
    M.sorted_sub a.elts l u

  logic sorted (a : array int) =
    M.sorted_sub a.elts 0 a.length

end

module ArrayEq

  use import module Array
  use import map.MapEq as M

  logic array_eq_sub (a1 a2: array 'a) (l u: int) =
    map_eq_sub a1.elts a2.elts l u

  logic array_eq (a1 a2: array 'a) =
    a1.length = a2.length and
    array_eq_sub a1 a2 0 a1.length

end

module ArrayPermut

  use import module Array
  clone import map.MapPermut as M

  logic exchange (a1 a2: array 'a) (i j: int) =
    M.exchange a1.elts a2.elts i j

  logic permut_sub (a1 a2: array 'a) (l u: int) =
    M.permut_sub a1.elts a2.elts l u

  logic permut (a1 a2: array 'a) =
    a1.length = a2.length and M.permut_sub a1.elts a2.elts 0 a1.length

  use import module ArrayEq

  lemma array_eq_sub_permut:
    forall a1 a2: array 'a, l u: int.
    array_eq_sub a1 a2 l u -> permut_sub a1 a2 l u

  lemma array_eq_permut:
    forall a1 a2: array 'a.
    array_eq a1 a2 -> permut a1 a2

end

module TestArray

  use import int.Int
  use import module Array

  let test_append () =
    let a1 = make 17 2 in
    assert { a1[3] = 2 };
    a1[3] <- 4;
    assert { a1[3] = 4 };
    let a2 = make 25 3 in
    assert { a2[0] = 3 }; (* needed to prove a[17]=3 below *)
    let a  = append a1 a2 in
    assert { length a = 42 };
    assert { a[3] = 4 };
    assert { a[17] = 3 };
    ()

  let test_fill () =
    let a = make 17 True in
    fill a 10 4 False;
    assert { a[9] = True };
    assert { a[10] = False };
    assert { a[14] = True }

  let test_blit () =
    let a1 = make 17 True in
    let a2 = make 25 False in
    blit a1 10 a2 17 7;
    assert { a1[10] = True  };
    assert { a2[16] = False };
    assert { a2[17] = True  };
    assert { a2[23] = True  };
    assert { a2[24] = False }

end

(*
Local Variables:
compile-command: "unset LANG; make -C .. modules/array"
End:
*)
