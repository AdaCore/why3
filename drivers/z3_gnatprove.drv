(** Why3 driver for Z3 >= 4.4 *)

prelude ";; produced by z3_gnatprove.drv ;;"
(* no set-logic for Z3 *)
prelude "(set-info :source |VC generated by SPARK 2014|)"
prelude "(set-info :smt-lib-version 2.0)"
prelude "(set-info :category industrial)"
prelude "(set-info :status unknown)"

import "smt-libv2.drv"
import "smt-libv2-bv.gen"
import "discrimination.gen"

(* Counterexamples: set model parser *)
model_parser "smtv2"

transformation "inline_trivial"
transformation "eliminate_builtin"
transformation "detect_polymorphism"
transformation "eliminate_inductive"
transformation "eliminate_algebraic_if_poly"

transformation "simplify_formula"
(*transformation "simplify_trivial_quantification"*)

(* Prepare for counter-example query: get rid of some quantifiers (makes it
possible to query model values of the variables in premises) and introduce
counter-example projections  *)
transformation "prepare_for_counterexmp"

transformation "discriminate_if_poly"
transformation "encoding_smt_if_poly"

(* remove pointless quantifiers from the goal *)
transformation "introduce_premises"

(** Error messages specific to Z3 *)

outofmemory "(error \".*out of memory\")\\|Cannot allocate memory\\|Maximal allocation counts .* have been exceeded\\|(error \".*number of configured allocations exceeded\")"
timeout "interrupted by timeout"
steps ":rlimit-count.*\\([0-9]+.?[0-9]*\\)" 1

(** Extra theories supported by Z3 *)

(* bitvector modules, is not in smt-libv2.drv since cvc4 and z3 don't
   have the same name for the function to_uint *)
theory bv.BV64
  syntax converter of_int "((_ int2bv 64) %1)"
  syntax function to_uint "(bv2int %1)"
  remove prop to_uint_of_int
  remove prop to_uint_extensionality
  remove prop to_uint_bounds
  remove prop to_int_extensionality

  remove prop to_uint_add
  remove prop to_uint_sub
  remove prop to_uint_neg
  remove prop to_uint_mul
  remove prop to_uint_udiv
  remove prop to_uint_urem
  remove prop to_uint_lsr
  remove prop to_uint_lsl
end

theory bv.BV32
  syntax converter of_int "((_ int2bv 32) %1)"
  syntax function to_uint "(bv2int %1)"
  remove prop to_uint_of_int
  remove prop to_uint_extensionality
  remove prop to_uint_bounds
  remove prop to_int_extensionality

  remove prop to_uint_add
  remove prop to_uint_sub
  remove prop to_uint_neg
  remove prop to_uint_mul
  remove prop to_uint_udiv
  remove prop to_uint_urem
  remove prop to_uint_lsr
  remove prop to_uint_lsl
end

theory bv.BV16
  syntax converter of_int "((_ int2bv 16) %1)"
  syntax function to_uint "(bv2int %1)"
  remove prop to_uint_of_int
  remove prop to_uint_extensionality
  remove prop to_uint_bounds
  remove prop to_int_extensionality

  remove prop to_uint_add
  remove prop to_uint_sub
  remove prop to_uint_neg
  remove prop to_uint_mul
  remove prop to_uint_udiv
  remove prop to_uint_urem
  remove prop to_uint_lsr
  remove prop to_uint_lsl
end

theory bv.BV8
  syntax converter of_int "((_ int2bv 8) %1)"
  syntax function to_uint "(bv2int %1)"
  remove prop to_uint_of_int
  remove prop to_uint_extensionality
  remove prop to_uint_bounds
  remove prop to_int_extensionality

  remove prop to_uint_add
  remove prop to_uint_sub
  remove prop to_uint_neg
  remove prop to_uint_mul
  remove prop to_uint_udiv
  remove prop to_uint_urem
  remove prop to_uint_lsr
  remove prop to_uint_lsl
end

(**********************************************************************
 ***                       gnat2why theories                        ***
 **********************************************************************)

theory _gnatprove_standard_th.Integer
   syntax function bool_eq "(= %1 %2)"
   syntax function bool_ne "(not (= %1 %2))"
   syntax function bool_lt "(< %1 %2)"
   syntax function bool_le "(<= %1 %2)"
   syntax function bool_gt "(> %1 %2)"
   syntax function bool_ge "(>= %1 %2)"

   remove prop bool_eq_axiom
   remove prop bool_ne_axiom
   remove prop bool_lt_axiom
   remove prop bool_int__le_axiom
   remove prop bool_gt_axiom
   remove prop bool_ge_axiom
end

theory _gnatprove_standard_th.Floating_Func
   syntax function bool_eq "(= %1 %2)"
   syntax function bool_neq "(not (= %1 %2))"
   syntax function bool_lt "(< %1 %2)"
   syntax function bool_le "(<= %1 %2)"
   syntax function bool_gt "(> %1 %2)"
   syntax function bool_ge "(>= %1 %2)"

   remove prop Bool_real__lt_axiom
   remove prop Bool_real__le_axiom
   remove prop Bool_real__gt_axiom
   remove prop Bool_real__ge_axiom
   remove prop Bool_real__eq_axiom
   remove prop Bool_real__neq_axiom
end

theory _gnatprove_standard_th.Boolean_Func
   syntax function bool_eq "(= %1 %2)"
end

theory ada__model_th.Discrete_Base_Theory
  syntax function bool_eq "(= %1 %2)"
end

theory ada__model_th.Floating_Point_Theory
  syntax function bool_eq "(= %1 %2)"
end

theory _gnatprove_standard.BVAda
   syntax function bool_eq "(= %1 %2)"
   syntax function bool_ne "(not (= %1 %2))"
   syntax function bool_lt "(bvult %1 %2)"
   syntax function bool_le "(bvule %1 %2)"
   syntax function bool_gt "(bvugt %1 %2)"
   syntax function bool_ge "(bvuge %1 %2)"

   remove prop Power_0
   remove prop Power_1
   remove prop Power_s
   remove prop Power_s_alt
   remove prop Power_sum
   remove prop Power_mult
   remove prop Power_mult2

   remove prop bv_min_to_uint
   remove prop bv_max_to_uint
end
