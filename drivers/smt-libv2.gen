(* Why3 driver for SMT-LIB2 syntax, excluding bit-vectors *)

prelude ";;; generated by SMT-LIB2 driver"

(*

Note: we do not insert any command "set-logic" because its
interpretation is specific to provers

prelude "(set-logic AUFNIRA)"

    A  : Array
    UF : Uninterpreted Function
    DT : Datatypes (not needed at the end ...)
    NIRA : NonLinear Integer Reals Arithmetic

*)

filename "%f-%t-%g.smt2"
unknown "^\\(unknown\\|sat\\|Fail\\)$" "\\1"
unknown "^(:reason-unknown \\([^)]*\\))$" "\\1"
time "why3cpulimit time : %s s"
valid "^unsat$"

theory BuiltIn
  syntax type int   "Int"
  syntax type real  "Real"
  syntax predicate (=)  "(= %1 %2)"

  meta "encoding:kept" type int
  meta "encoding:ignore_polymorphism_ls" predicate (=)
end

theory int.Int

  prelude ";;; SMT-LIB2: integer arithmetic"

  syntax function zero "0"
  syntax function one  "1"

  syntax function (+)  "(+ %1 %2)"
  syntax function (-)  "(- %1 %2)"
  syntax function (*)  "(* %1 %2)"
  syntax function (-_) "(- %1)"

  syntax predicate (<=) "(<= %1 %2)"
  syntax predicate (<)  "(< %1 %2)"
  syntax predicate (>=) "(>= %1 %2)"
  syntax predicate (>)  "(> %1 %2)"

  remove allprops

end

theory real.Real

  prelude ";;; SMT-LIB2: real arithmetic"

  syntax function zero "0.0"
  syntax function one  "1.0"

  syntax function (+)  "(+ %1 %2)"
  syntax function (-)  "(- %1 %2)"
  syntax function (*)  "(* %1 %2)"
  syntax function (/)  "(/ %1 %2)"
  syntax function (-_) "(- %1)"
  syntax function inv  "(/ 1.0 %1)"

  syntax predicate (<=) "(<= %1 %2)"
  syntax predicate (<)  "(< %1 %2)"
  syntax predicate (>=) "(>= %1 %2)"
  syntax predicate (>)  "(> %1 %2)"

  remove allprops

  meta "encoding:kept" type real

end

theory real.Abs
  syntax function abs "(ite (>= %1 0.0) %1 (- %1))"

  remove allprops
end

theory real.MinMax
  syntax function min "(ite (< %1 %2) %1 %2)"
  syntax function max "(ite (< %1 %2) %2 %1)"

  remove allprops
end

theory real.FromInt
  syntax function from_int "(to_real %1)"

  remove allprops
end

theory real.Truncate
  syntax function truncate "(ite (>= %1 0.0)
                                 (to_int %1)
                                 (- (to_int (- %1))))"
  syntax function floor "(to_int %1)"
  syntax function ceil "(- (to_int (- %1)))"

  remove allprops
end

theory Bool
  syntax type     bool  "Bool"
  syntax function True  "true"
  syntax function False "false"

  meta "encoding:kept" type bool
end

theory bool.Bool
  syntax function andb  "(and %1 %2)"
  syntax function orb   "(or %1 %2)"
  syntax function xorb  "(xor %1 %2)"
  syntax function notb  "(not %1)"
  syntax function implb "(=> %1 %2)"
end

theory bool.Ite
  syntax function ite "(ite %1 %2 %3)"
  meta "encoding:lskept" function ite
  meta "encoding:ignore_polymorphism_ls" function ite
end

(* not uniformly interpreted by provers
theory real.Truncate
  syntax function floor "(to_int %1)"
  remove prop Floor_down
  remove prop Floor_monotonic
end
*)

theory HighOrd
  syntax type     (->) "(Array %1 %2)"
  syntax function (@)  "(select %1 %2)"

  meta "encoding:lskept" function (@)
  meta "encoding:ignore_polymorphism_ts" type (->)
  meta "encoding:ignore_polymorphism_ls" function (@)
end

theory map.Map
  syntax function get "(select %1 %2)"
  syntax function set "(store %1 %2 %3)"

  meta "encoding:lskept" function get
  meta "encoding:lskept" function set
  meta "encoding:ignore_polymorphism_ls" function get
  meta "encoding:ignore_polymorphism_ls" function ([])
  meta "encoding:ignore_polymorphism_ls" function set
  meta "encoding:ignore_polymorphism_ls" function ([<-])
end

theory map.Const
  meta "encoding:lskept" function const
(*  syntax function const "(const[%t0] %1)" *)
end
