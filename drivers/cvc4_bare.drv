(* Why driver for SMTLIB2 syntax *)

prelude ";;; this is a prelude for CVC4"
prelude "(set-logic ALL_SUPPORTED)"
(** A    : Arrays
    UF   : Uninterpreted Function
    BV   : Bitvectors
    NIRA : NonLinear Integer Reals Arithmetic
*)

printer "smtv2"
filename "%f-%t-%g.smt2"

valid "^unsat"
invalid "^sat"
unknown "^\\(unknown\\|Fail\\)" ""
outofmemory "(error \".*out of memory\")\\|Cannot allocate memory"
time "why3cpulimit time : %s s"

transformation "inline_trivial"

transformation "eliminate_builtin"
transformation "eliminate_recursion"
transformation "eliminate_inductive"
transformation "eliminate_algebraic"

transformation "simplify_formula"

(* remove pointless quantifiers from the goal *)
transformation "introduce_premises"
transformation "eliminate_bounded_types"

(* For some reason this is commented out in all drivers except gappa
and mathematica. Why? *)
(* transformation "simplify_trivial_quantification" *)

transformation "discriminate"
transformation "encoding_smt"

theory BuiltIn
  syntax type int   "Int"
  syntax type real  "Real"
  syntax predicate (=)  "(= %1 %2)"

  meta "encoding : kept" type int
end

theory algebra.Field
  remove prop add_div
  remove prop sub_div
  remove prop neg_div
  remove prop assoc_mul_div
  remove prop assoc_div_mul
  remove prop assoc_div_div
end

theory algebra.OrderedUnitaryCommutativeRing
  remove prop CompatOrderAdd
  remove prop CompatOrderMult
end

theory algebra.OrderedField
  remove prop CompatOrderAdd
  remove prop CompatOrderMult
end

theory int.Int

  prelude ";;; this is a prelude for CVC4 integer arithmetic"

  syntax function zero "0"
  syntax function one  "1"

  syntax function (+)  "(+ %1 %2)"
  syntax function (-)  "(- %1 %2)"
  syntax function (*)  "(* %1 %2)"
  syntax function (-_) "(- %1)"

  syntax predicate (<=) "(<= %1 %2)"
  syntax predicate (<)  "(< %1 %2)"
  syntax predicate (>=) "(>= %1 %2)"
  syntax predicate (>)  "(> %1 %2)"

  remove prop CommutativeGroup.Comm.Comm
  remove prop CommutativeGroup.Assoc
  remove prop CommutativeGroup.Unit_def_l
  remove prop CommutativeGroup.Unit_def_r
  remove prop CommutativeGroup.Inv_def_l
  remove prop CommutativeGroup.Inv_def_r
  remove prop Assoc.Assoc
  remove prop Mul_distr_l
  remove prop Mul_distr_r
  remove prop Comm.Comm
  remove prop Unitary
  remove prop Refl
  remove prop Trans
  remove prop Antisymm
  remove prop Total
  remove prop NonTrivialRing
  remove prop CompatOrderAdd
  remove prop ZeroLessOne

end


theory real.Real

  prelude ";;; this is a prelude for CVC4 real arithmetic"

  syntax function zero "0.0"
  syntax function one  "1.0"

  syntax function (+)  "(+ %1 %2)"
  syntax function (-)  "(- %1 %2)"
  syntax function (*)  "(* %1 %2)"
  syntax function (/)  "(/ %1 %2)"
  syntax function (-_) "(- %1)"
  syntax function inv  "(/ 1.0 %1)"

  syntax predicate (<=) "(<= %1 %2)"
  syntax predicate (<)  "(< %1 %2)"
  syntax predicate (>=) "(>= %1 %2)"
  syntax predicate (>)  "(> %1 %2)"

  remove prop CommutativeGroup.Comm.Comm
  remove prop CommutativeGroup.Assoc
  remove prop CommutativeGroup.Unit_def_l
  remove prop CommutativeGroup.Unit_def_r
  remove prop CommutativeGroup.Inv_def_l
  remove prop CommutativeGroup.Inv_def_r
  remove prop Assoc.Assoc
  remove prop Mul_distr_l
  remove prop Mul_distr_r
  remove prop Comm.Comm
  remove prop Unitary
  remove prop Inverse
  remove prop Refl
  remove prop Trans
  remove prop Antisymm
  remove prop Total
  remove prop NonTrivialRing
  remove prop CompatOrderAdd
  remove prop ZeroLessOne

  meta "encoding : kept" type real

end

theory real.FromInt
  syntax function from_int "(to_real %1)"

  remove prop Zero
  remove prop One
  remove prop Add
  remove prop Sub
  remove prop Mul
  remove prop Neg
  remove prop Monotonic
end

theory real.Abs
  syntax function abs "(ite (<= 0.0 %1) (- %1) %1)"

  remove prop Abs_le
  remove prop Abs_pos
  (*** remove prop Abs_zero *)
  remove prop Abs_sum
  remove prop Abs_prod
  remove prop triangular_inequality
end

theory bool.Bool
   meta "encoding : kept" type bool
   meta "eliminate_algebraic" "no_inversion"
   meta "eliminate_algebraic" "no_selector"

   syntax type     bool  "Bool"
   syntax function True  "true"
   syntax function False "false"

   syntax function andb  "(and %1 %2)"
   syntax function orb   "(or %1 %2)"
   syntax function xorb  "(xor %1 %2)"
   syntax function notb  "(not %1)"
   syntax function implb "(=> %1 %2)"
end

theory bool.Ite
  syntax function ite "(ite %1 %2 %3)"
  meta "encoding : lskept" function ite
end

theory int.EuclideanDivision
   syntax function div "(div %1 %2)"
   syntax function mod "(mod %1 %2)"

   remove prop Div_mod
   remove prop Div_bound
   remove prop Mod_bound
   remove prop Mod_1
   remove prop Div_1
   remove prop Div_inf
   remove prop Div_inf_neg
   remove prop Mod_0
   remove prop Div_1_left
   remove prop Div_minus1_left
   remove prop Mod_1_left
   remove prop Mod_minus1_left
   remove prop Div_mult
   remove prop Mod_mult
end

theory int.Div2
   remove prop div2
end

theory int.ComputerDivision
   syntax function div "(ite (< %1 0) (ite (< %2 0) (div (- %1) (- %2)) (- (div (- %1) %2))) (div %1 %2))"
   syntax function mod "(ite (< %1 0) (- mod (- x) y) (mod x y))"

   remove prop Div_mod
   remove prop Div_bound
   remove prop Mod_bound
   remove prop Div_sign_pos
   remove prop Div_sign_neg
   remove prop Mod_sign_pos
   remove prop Mod_sign_neg
   remove prop Rounds_toward_zero
   remove prop Mod_1
   remove prop Div_1
   remove prop Div_inf
   remove prop Mod_inf
   remove prop Div_mult
   remove prop Mod_mult
end

(*
theory real.Truncate
  syntax function floor "(to_int %1)"
  remove prop Floor_down
  remove prop Floor_monotonic
end
*)

theory map.Map
  syntax type map "(Array %1 %2)"
  meta "encoding : lskept" function get
  meta "encoding : lskept" function set
  meta "encoding : lskept" function const

  syntax function get   "(select %1 %2)"
  syntax function set   "(store %1 %2 %3)"
end

theory floating_point.Rounding
   meta "encoding : kept" type mode
   meta "eliminate_algebraic" "no_inversion"
   meta "eliminate_algebraic" "no_selector"
   meta "eliminate_algebraic" "no_index"

   syntax function NearestTiesToEven "RNE"
   syntax function NearestTiesToAway "RNA"
   syntax function Up "RTP"
   syntax function Down "RTN"
   syntax function ToZero "RTZ"
end

theory floating_point.GenFloat
   remove prop Bounded_real_no_overflow
   remove prop Round_monotonic
   remove prop Round_idempotent
   remove prop Round_value
   remove prop Bounded_value
   remove prop Exact_rounding_for_integers
   remove prop Round_down_le
   remove prop Round_up_ge
   remove prop Round_down_neg
   remove prop Round_up_neg

   syntax function model "xREMOVEx"
   syntax function exact "xREMOVEx"
   syntax function value "xREMOVEx"
   syntax function round "xREMOVEx"
   syntax function round_logic "xREMOVEx"
   syntax function round_error "xREMOVEx"
   syntax function total_error "xREMOVEx"
   syntax function max "xREMOVEx"
   syntax predicate no_overflow "xREMOVEx"
   syntax function max_representable_integer "xREMOVEx"

end

theory ieee754.Single_RNE
   prelude ";;; this is a prelude for CVC4 32-bit floating point"

   meta "encoding : kept" type single

   syntax type single "(_ FloatingPoint 8 24)"

   syntax function  from_real "((_ to_fp_real 8 24) RNE %1)"
   syntax function  to_real   "((_ fp.to_real 8 24) %1)"

   (* ugh... going through bitvector would be nicer? *)
   syntax function  from_int "((_ to_fp_real 8 24) RNE (to_real %1))"
   syntax function  to_int   "(to_int ((_ fp.to_real 8 24) (roundToIntegral RNA %1)))"

   syntax function  fp_abs  "(fp.abs %1)"
   syntax function  fp_neg  "(fp.neg %1)"
   syntax function  fp_add  "(fp.add RNE %1 %2)"
   syntax function  fp_sub  "(fp.sub RNE %1 %2)"
   syntax function  fp_mul  "(fp.mul RNE %1 %2)"
   syntax function  fp_div  "(fp.div RNE %1 %2)"
   syntax function  fp_fma  "(fp.fma RNE %1 %2 %3)"
   syntax function  fp_sqrt "(fp.sqrt RNE %1)"
   syntax function  fp_rem  "(fp.rem %1 %2)"
   syntax function  fp_min  "(fp.min %1 %2)"
   syntax function  fp_max  "(fp.max %1 %2)"

   syntax function  roundToIntegral_RNE  "(roundToIntegral RNE %1)"
   syntax function  roundToIntegral_RNA  "(roundToIntegral RNA %1)"
   syntax function  roundToIntegral_RTZ  "(roundToIntegral RTZ %1)"

   syntax predicate fp_eq  "(fp.eq %1 %2)"
   syntax predicate fp_neq "(not (fp.eq %1 %2))"
   syntax predicate fp_leq "(fp.leq %1 %2)"
   syntax predicate fp_lt  "(fp.lt %1 %2)"
   syntax predicate fp_geq "(fp.geq %1 %2)"
   syntax predicate fp_gt  "(fp.gt %1 %2)"

   syntax predicate isNormal    "(fp.isNormal %1)"
   syntax predicate isSubnormal "(fp.isSubnormal %1)"
   syntax predicate isSignMinus "(fp.isSignMinus %1)"
   syntax predicate isZero      "(fp.isZero %1)"
   syntax predicate isInfinite  "(fp.isInfinite %1)"
   syntax predicate isNaN       "(fp.isNaN %1)"

   syntax function fp_constant_zero "((_ to_fp_real 8 24) RNE 0.0)"

   syntax function floor   "(roundToIntegral RTN %1)"
   syntax function ceiling "(roundToIntegral RTP %1)"
end

theory ieee754.Double_RNE
   prelude ";;; this is a prelude for CVC4 64-bit floating point"

   meta "encoding : kept" type double

   syntax type double "(_ FloatingPoint 11 53)"

   syntax function  from_real "((_ to_fp_real 11 53) RNE %1)"
   syntax function  to_real   "((_ fp.to_real 11 53) %1)"

   (* ugh... going through bitvector would be nicer? *)
   syntax function  from_int "((_ to_fp_real 11 53) RNE (to_real %1))"
   syntax function  to_int   "(to_int ((_ fp.to_real 11 53) (roundToIntegral RNA %1)))"

   syntax function  fp_abs  "(fp.abs %1)"
   syntax function  fp_neg  "(fp.neg %1)"
   syntax function  fp_add  "(fp.add RNE %1 %2)"
   syntax function  fp_sub  "(fp.sub RNE %1 %2)"
   syntax function  fp_mul  "(fp.mul RNE %1 %2)"
   syntax function  fp_div  "(fp.div RNE %1 %2)"
   syntax function  fp_fma  "(fp.fma RNE %1 %2 %3)"
   syntax function  fp_sqrt "(fp.sqrt RNE %1)"
   syntax function  fp_rem  "(fp.rem %1 %2)"
   syntax function  fp_min  "(fp.min %1 %2)"
   syntax function  fp_max  "(fp.max %1 %2)"

   syntax function  roundToIntegral_RNE  "(roundToIntegral RNE %1)"
   syntax function  roundToIntegral_RNA  "(roundToIntegral RNA %1)"
   syntax function  roundToIntegral_RTZ  "(roundToIntegral RTZ %1)"

   syntax predicate fp_eq  "(fp.eq %1 %2)"
   syntax predicate fp_neq "(not (fp.eq %1 %2))"
   syntax predicate fp_leq "(fp.leq %1 %2)"
   syntax predicate fp_lt  "(fp.lt %1 %2)"
   syntax predicate fp_geq "(fp.geq %1 %2)"
   syntax predicate fp_gt  "(fp.gt %1 %2)"

   syntax predicate isNormal    "(fp.isNormal %1)"
   syntax predicate isSubnormal "(fp.isSubnormal %1)"
   syntax predicate isSignMinus "(fp.isSignMinus %1)"
   syntax predicate isZero      "(fp.isZero %1)"
   syntax predicate isInfinite  "(fp.isInfinite %1)"
   syntax predicate isNaN       "(fp.isNaN %1)"

   syntax function fp_constant_zero "((_ to_fp_real 11 53) RNE 0.0)"

   syntax function floor   "(roundToIntegral RTN %1)"
   syntax function ceiling "(roundToIntegral RTP %1)"
end

theory ieee754.Single_RNE_Conversion

   syntax function to_single_rne "%1"
   syntax function to_double_rne "((_ to_fp_fp 11 53) RNE %1)"

end

theory ieee754.Double_RNE_Conversion

   syntax function to_single_rne "((_ to_fp_fp 8 24) RNE %1)"
   syntax function to_double_rne "%1"

end


(*
Local Variables:
mode: why
compile-command: "unset LANG; make -C .. bench"
End:
*)
