
printer "ocaml"

theory BuiltIn
  syntax type int "Why3__BigInt.t"
  syntax predicate  (=)   "(%1 = %2)"
end

theory HighOrd
  syntax type func "(%1 -> %2)"
  syntax type pred "(%1 -> bool)"
  syntax function (@) "(%1 %2)"
end

theory option.Option
  syntax type     option "(%1 option)"
  syntax function None   "None"
  syntax function Some   "(Some %1)"
end

(* bool *)

theory Bool
  syntax type     bool  "bool"
  syntax function True  "true"
  syntax function False "false"
end

theory bool.Ite
  syntax function ite "(if %1 then %2 else %3)"
end

theory bool.Bool
  syntax function andb  "(%1 && %2)"
  syntax function orb   "(%1 || %2)"
  syntax function xorb  "(%1 <> %2)"
  syntax function notb  "(not %1)"
  syntax function implb "(not %1 || %2)"
end

(* int *)

theory int.Int
  syntax constant zero "Why3__BigInt.zero"
  syntax constant one  "Why3__BigInt.one"

  syntax predicate (<)  "(Why3__BigInt.lt %1 %2)"
  syntax predicate (<=) "(Why3__BigInt.le %1 %2)"
  syntax predicate (>)  "(Why3__BigInt.gt %1 %2)"
  syntax predicate (>=) "(Why3__BigInt.ge %1 %2)"

  syntax function (+)   "(Why3__BigInt.add %1 %2)"
  syntax function (-)   "(Why3__BigInt.sub %1 %2)"
  syntax function ( * ) "(Why3__BigInt.mul %1 %2)"
  syntax function (-_)  "(Why3__BigInt.minus %1)"
end

theory int.Abs
  syntax function abs "(Why3__BigInt.abs %1)"
end

theory int.MinMax
  syntax function min "(Why3__BigInt.min %1 %2)"
  syntax function max "(Why3__BigInt.max %1 %2)"
end

theory int.Lex2
  syntax predicate lt_nat "(Why3__BigInt.lt_nat %1 %2)"
  syntax predicate lex    "(Why3__BigInt.lex %1 %2)"
end

theory int.EuclideanDivision
  syntax function div "(Why3__BigInt.euclidean_div %1 %2)"
  syntax function mod "(Why3__BigInt.euclidean_mod %1 %2)"
end

theory int.ComputerDivision
  syntax function div "(Why3__BigInt.computer_div %1 %2)"
  syntax function mod "(Why3__BigInt.computer_mod %1 %2)"
end

theory int.Power
  syntax function power "(Why3__BigInt.power %1 %2)"
end

theory int.Fact
  syntax function fact "(Why3__BigInt.fact %1)"
end

theory int.Fibonacci
  syntax function fib "(Why3__BigInt.fib %1)"
end

(* TODO number.Gcd *)

(* list *)

theory list.List
  syntax type     list "%1 list"
  syntax function Nil  "[]"
  syntax function Cons "(%1 :: %2)"
end

theory list.Length
  syntax function length "(List.length %1)"
end

theory list.Mem
  syntax predicate mem "(List.mem %1 %2)"
end

theory list.Append
  syntax function (++) "(List.append %1 %2)"
end

theory list.Reverse
  syntax function reverse "(List.rev %1)"
end

theory list.RevAppend
  syntax function rev_append "(List.rev_append %1 %2)"
end

theory list.Combine
  syntax function combine "(List.combine %1 %2)"
end

(* map *)

theory map.Map
  syntax type map "((%1, %2) Why3__Map.map)"
  syntax function const "(Why3__Map.const %1)"
  syntax function ([]) "(Why3__Map.get %1 %2)"
  syntax function get "(Why3__Map.get %1 %2)"
  syntax function ([<-]) "(Why3__Map.set %1 %2 %3)"
  syntax function set "(Why3__Map.set %1 %2 %3)"
end

(* WhyML *)

module ref.Ref
  syntax type     ref      "(%1 Pervasives.ref)"
  syntax function contents "%1.Pervasives.contents"
  syntax val      ref      "Pervasives.ref"
  syntax val      (!_)     "Pervasives.(!)"
  syntax val      (:=)     "Pervasives.(:=)"
end

module array.Array
  syntax type array "(%1 Why3__BigInt.Array.t)"
  syntax function ([]) "(Why3__BigInt.Array.get %1 %2)"
  syntax val ([]) "Why3__BigInt.Array.get"
  syntax val ([]<-) "Why3__BigInt.Array.set"
  syntax val length "Why3__BigInt.Array.length"
  syntax exception OutOfBounds "Why3__BigInt.Array.OutOfBounds"
  syntax val defensive_get "Why3__BigInt.Array.defensive_get"
  syntax val defensive_set "Why3__BigInt.Array.defensive_set"
  syntax val make "Why3__BigInt.Array.make"
  syntax val append "Why3__BigInt.Array.append"
  syntax val sub "Why3__BigInt.Array.sub"
  syntax val copy "Why3__BigInt.Array.copy"
  syntax val fill "Why3__BigInt.Array.fill"
  syntax val blit "Why3__BigInt.Array.blit"
end

module mach.int.Int31
  (* even on a 64-bit machine, it is safe to use type int for 31-bit integers *)
  syntax type     int31     "int"
  syntax constant min_int31 "(- 0x4000_0000)"
  syntax constant max_int31    "0x3fff_ffff"
  syntax val      of_int    "(fun x -> int_of_string (Num.string_of_num x))"
                            (* FIXME: use a realization instead? *)
  syntax val      ( + )     "( + )"
  syntax val      ( - )     "( - )"
  syntax val      (-_)      "( ~- )"
  syntax val      ( * )     "( * )"
  syntax val      ( / )     "( / )"
  syntax val      (<=)      "(<=)"
  syntax val      (<)       "(<)"
  syntax val      (>=)      "(>=)"
  syntax val      (>)       "(>)"
end

module mach.int.Int32
  syntax type     int32     "Int32.t"
  syntax constant min_int32 "Int32.min_int"
  syntax constant max_int32 "Int32.max_int"
  syntax val      of_int    "(fun x -> Int32.of_string (Num.string_of_num x))"
                            (* FIXME: use a realization instead? *)
  syntax val      (+)       "Int32.add"
  syntax val      (-)       "Int32.sub"
  syntax val      (-_)      "Int32.neg"
  syntax val      ( * )     "Int32.mul"
  syntax val      (/)       "Int32.div"
  syntax val      (<=)      "(<=)"
  syntax val      (<)       "(<)"
  syntax val      (>=)      "(>=)"
  syntax val      (>)       "(>)"
end

module mach.int.Int63
  (* only safe on a 64-bit machine *)
  prelude "let () = assert (Sys.word_size = 64)"
  syntax type     int63     "int"
  syntax constant min_int63 "(- 0x4000_0000_0000_0000)"
  syntax constant max_int63    "0x3fff_ffff_ffff_ffff"
  syntax val      of_int    "(fun x -> int_of_string (Num.string_of_num x))"
                            (* FIXME: use a realization instead? *)
  syntax val      ( + )     "( + )"
  syntax val      ( - )     "( - )"
  syntax val      (-_)      "( ~- )"
  syntax val      ( * )     "( * )"
  syntax val      ( / )     "( / )"
  syntax val      (<=)      "(<=)"
  syntax val      (<)       "(<)"
  syntax val      (>=)      "(>=)"
  syntax val      (>)       "(>)"
end

module mach.int.Int64
  syntax type     int64     "Int64.t"
  syntax constant min_int64 "Int64.min_int"
  syntax constant max_int64 "Int64.max_int"
  syntax val      of_int    "(fun x -> Int64.of_string (Num.string_of_num x))"
                            (* FIXME: use a realization instead? *)
  syntax val      (+)       "Int64.add"
  syntax val      (-)       "Int64.sub"
  syntax val      (-_)      "Int64.neg"
  syntax val      ( * )     "Int64.mul"
  syntax val      (/)       "Int64.div"
  syntax val      (<=)      "(<=)"
  syntax val      (<)       "(<)"
  syntax val      (>=)      "(>=)"
  syntax val      (>)       "(>)"
end

module mach.array.Array31
  syntax type array  "array"
  syntax val  make   "Array.make"
  syntax val  ([])   "Array.get"
  syntax val  ([]<-) "Array.set"
  syntax val  length "Array.length"
  syntax val  append "Array.append"
  syntax val  sub    "Array.sub"
  syntax val  copy   "Array.copy"
  syntax val  fill   "Array.fill"
  syntax val  blit   "Array.blit"
  syntax val  self_blit "Array.blit"
end

(* TODO
   - OutOfBounds, defensive_get, defensive_set in mach.array.in Array31
   - mach.array.Array32  -> Bigarray sur 32-bit / Array sur 64-bit ?
*)
