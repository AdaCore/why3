printer "c"

module BuiltIn

  prelude "#include <stdlib.h>"
  prelude "#include <stdint.h>"
  prelude "#include <stdio.h>"

end

module ref.Ref

  syntax type ref "%1"
  syntax val ref "%1"
  syntax val (!_) "%1"
  syntax converter (!_) "%1"
  syntax val (:=) "%1 = %2"

end

module mach.int.Unsigned

  syntax constant zero_unsigned "0"

end

module mach.int.Int32
  syntax val of_int "%1"
  syntax converter of_int "%1"

  syntax type int32  "int32_t"

  syntax val (+)     "%1 + %2"
  syntax val (-)     "%1 - %2"
  syntax val (-_)    "-(%1)"
  syntax val (*)     "%1 * %2"
  syntax val (/)     "%1 / %2"
  syntax val (%)     "%1 % %2"
  syntax val eq      "%1 == %2"
  syntax val (=)     "%1 == %2"
  syntax val ne      "%1 != %2"
  syntax val (<=)    "%1 <= %2"
  syntax val (<)     "%1 < %2"
  syntax val (>=)    "%1 >= %2"
  syntax val (>)     "%1 > %2"
end

module mach.int.UInt32

  prelude

"
#define LOW_MASK 0x00000000FFFFFFFFULL

void add_with_carry(uint32_t * res, uint32_t * carry, uint32_t x, uint32_t y, uint32_t c)
{
  uint64_t r = (uint64_t)x + (uint64_t)y + (uint64_t) c;
  *res = (uint32_t)(r & LOW_MASK);
  *carry = (uint32_t)(r >> 32);
}

void sub_with_borrow(uint32_t * res, uint32_t * borrow, uint32_t x, uint32_t y, uint32_t b)
{
  uint64_t r = (uint64_t)x - (uint64_t)y - (uint64_t) b;
  *res = (uint32_t)(r & LOW_MASK);
  *borrow = (uint32_t)(r >> 63);
}

void mul_double(uint32_t * low, uint32_t * high, uint32_t x, uint32_t y)
{
  uint64_t r = (uint64_t)x * (uint64_t)y;
  *low = (uint32_t)(r & LOW_MASK);
  *high = (uint32_t)(r >> 32);
}

void add3(uint32_t * low, uint32_t * high, uint32_t x, uint32_t y, uint32_t z)
{
  uint64_t r = (uint64_t)x + (uint64_t)y + (uint64_t) z;
  *low = (uint32_t)(r & LOW_MASK);
  *high = (uint32_t)(r >> 32);
}

void lsld(uint32_t * low, uint32_t * high, uint32_t x, uint32_t cnt)
{
  uint64_t r = (uint64_t)x << cnt;
  *low = (uint32_t)(r & LOW_MASK);
  *high = (uint32_t)(r >> 32);
}
"

  syntax converter of_int "%1U"

  syntax type uint32 "uint32_t"

  syntax converter max_uint32 "0xffffffff"

  syntax val (+)     "%1 + %2"
  syntax val (-)     "%1 - %2"
  syntax val (*)     "%1 * %2"
  syntax val (/)     "%1 / %2"
  syntax val (%)     "%1 % %2"
  syntax val eq      "%1 == %2"
  syntax val (=)     "%1 == %2"
  syntax val ne      "%1 != %2"
  syntax val (<=)    "%1 <= %2"
  syntax val (<)     "%1 < %2"
  syntax val (>=)    "%1 >= %2"
  syntax val (>)     "%1 > %2"

  syntax val add_mod "%1 + %2"
  syntax val sub_mod "%1 - %2"
  syntax val mul_mod "%1 * %2"

  syntax val div2by1
         "(uint32_t)(((uint64_t)%1 | ((uint64_t)%2 << 32))/(uint64_t)%3)"

  syntax val lsl "%1 << %2"
  syntax val lsr "%1 >> %2"

  syntax val is_msb_set "%1 & 0x80000000U"

  syntax val count_leading_zeros "__builtin_clz(%1)"

end

module mach.int.UInt64

  prelude

"
void add_with_carry(uint64_t * res, uint64_t * carry, uint64_t x, uint64_t y, uint64_t c)
{
  uint64_t r = x + y + c;
  *res = r;
  if (r < x) *carry = 1;
  else *carry = ((r == x) && c);
}

void sub_with_borrow(uint64_t * res, uint64_t * borrow, uint64_t x, uint64_t y, uint64_t b)
{
  uint64_t r = x - y - b;
  *res = r;
  if (r > x) *borrow = 1;
  else *borrow = ((r == x) && b);
}

void mul_double(uint64_t * low, uint64_t * high, uint64_t x, uint64_t y)
{
  uint64_t h, l;
  asm(\"mulq %3\" : \"=a\"(l),\"=d\"(h) : \"a\"(x), \"g\"(y));
  *high = h;
  *low = l;
}

void add3(uint64_t * low, uint64_t * high, uint64_t x, uint64_t y, uint64_t z)
{
  uint64_t r, c1, c2;
  add_with_carry(&r, &c1, x, y, 0);
  add_with_carry(&r, &c2, r, z, 0);
  *high = c1 + c2;
  *low = r;
}

void lsld(uint64_t * low, uint64_t * high, uint64_t x, uint64_t cnt)
{
  *high = x >> (64 - cnt);
  *low = x << cnt;
}
"

  syntax converter of_int "%1ULL"

  syntax type uint64 "uint64_t"

  syntax converter max_uint64 "0xffffffffffffffff"

  syntax val (+)     "%1 + %2"
  syntax val (-)     "%1 - %2"
  syntax val (*)     "%1 * %2"
  syntax val (/)     "%1 / %2"
  syntax val (%)     "%1 % %2"
  syntax val eq      "%1 == %2"
  syntax val (=)     "%1 == %2"
  syntax val ne      "%1 != %2"
  syntax val (<=)    "%1 <= %2"
  syntax val (<)     "%1 < %2"
  syntax val (>=)    "%1 >= %2"
  syntax val (>)     "%1 > %2"

  syntax val add_mod "%1 + %2"
  syntax val sub_mod "%1 - %2"
  syntax val mul_mod "%1 * %2"

  syntax val div2by1
         "0"

  syntax val lsl "%1 << %2"
  syntax val lsr "%1 >> %2"

  syntax val is_msb_set "%1 & 0x8000000000000000ULL"

  syntax val count_leading_zeros "__builtin_clz(%1)"


end



module mach.c.C

  syntax type ptr "%1 *"

  syntax val malloc "malloc(%1 * sizeof(%v0))"
  syntax val free   "free(%1)"
  syntax val realloc "realloc(%1, %2 * sizeof(%v0))"

  syntax val is_null "%1 == NULL"
  syntax val null "NULL"

  syntax val incr "%1+%2"

  syntax val get "*(%1)"
  syntax val get_ofs "*(%1+%2)"

  syntax val set "*(%1) = %2"
  syntax val set_ofs "*(%1+%2) = %3"

  syntax val p2i "%1"
  syntax converter p2i "%1"

  syntax val print_space "printf(\" \")"
  syntax val print_newline "printf(\"\\n\")"
  syntax val print_uint32 "printf(\"%#010x\",%1)"

end