
(* Why driver for Gappa *)

prelude "# this is a prelude for Gappa"

printer "gappa"
filename "%f-%t-%g.gappa"

valid 0
unknown "no contradiction was found\\|some enclosures were not satisfied" "Unknown"
time "why3cpulimit time : %s s"
fail "Error: \\(.*\\)" "\\1"

(*transformation "simplify_recursive_definition"*)
transformation "inline_trivial"
transformation "eliminate_builtin"
transformation "inline_all"
transformation "eliminate_definition"
transformation "eliminate_inductive"
transformation "eliminate_algebraic_smt"
transformation "eliminate_if"
transformation "eliminate_let"
transformation "simplify_formula"
transformation "simplify_unknown_lsymbols"
transformation "simplify_trivial_quantification"
transformation "introduce_premises"
transformation "instantiate_predicate"
transformation "abstract_unknown_lsymbols"

theory BuiltIn
  syntax type int   "int"
  syntax type real  "real"
  syntax predicate (=)  "dummy"
end

theory int.Int

  prelude "# this is a prelude for Gappa integer arithmetic"

  syntax function zero "0"
  syntax function one  "1"

  syntax function (+)  "(%1 + %2)"
  syntax function (-)  "(%1 - %2)"
  syntax function (*)  "(%1 * %2)"
  syntax function (-_) "(-%1)"

  syntax predicate (<=) "dummy"
  syntax predicate (>=) "dummy"
  syntax predicate (<)  "dummy"
  syntax predicate (>)  "dummy"

  meta "gappa arith" predicate (<=), "", "<=", ">="
  meta "gappa arith" predicate (>=), "", ">=", "<="
  meta "gappa arith" predicate (<), "not ", ">=", "<="
  meta "gappa arith" predicate (>), "not ", "<=", ">="

  meta "inline : no" predicate (<=)
  meta "inline : no" predicate (>=)
  meta "inline : no" predicate (>)

  remove prop CommutativeGroup.Comm.Comm
  remove prop CommutativeGroup.Assoc.Assoc
  remove prop CommutativeGroup.Unit_def
  remove prop CommutativeGroup.Inv_def
  remove prop Assoc.Assoc
  remove prop Mul_distr
  remove prop Comm.Comm
  remove prop Unitary
  remove prop Refl
  remove prop Trans
  remove prop Total
  remove prop Antisymm
  remove prop NonTrivialRing

end

theory int.Abs

  syntax function abs  "| %1 |"

end

theory int.EuclideanDivision

  syntax function div "int<dn>(%1 / %2)"

end

theory int.ComputerDivision

  syntax function div "int<zr>(%1 / %2)"

end

theory real.Real

  prelude "# this is a prelude for Gappa real arithmetic"

  syntax function zero "0.0"
  syntax function one  "1.0"

  syntax function (+)  "(%1 + %2)"
  syntax function (-)  "(%1 - %2)"
  syntax function (*)  "(%1 * %2)"
  syntax function (/)  "(%1 / %2)"
  syntax function (-_) "(-%1)"
  syntax function inv  "(1.0 / %1)"

  syntax predicate (<=) "dummy"
  syntax predicate (>=) "dummy"
  syntax predicate (<)  "dummy"
  syntax predicate (>)  "dummy"

  meta "gappa arith" predicate (<=), "", "<=", ">="
  meta "gappa arith" predicate (>=), "", ">=", "<="
  meta "gappa arith" predicate (<), "not ", ">=", "<="
  meta "gappa arith" predicate (>), "not ", "<=", ">="

  meta "inline : no" predicate (<=)
  meta "inline : no" predicate (>=)
  meta "inline : no" predicate (>)

  remove prop CommutativeGroup.Comm.Comm
  remove prop CommutativeGroup.Assoc.Assoc
  remove prop CommutativeGroup.Unit_def
  remove prop CommutativeGroup.Inv_def
  remove prop Assoc.Assoc
  remove prop Mul_distr
  remove prop Comm.Comm
  remove prop Unitary
  remove prop Refl
  remove prop Trans
  remove prop Total
  remove prop Antisymm
  remove prop Inverse
  remove prop NonTrivialRing

end

theory real.Abs

  syntax function abs  "| %1 |"

end

theory real.Square

  syntax function sqrt  "sqrt(%1)"

end

theory real.Truncate

  syntax function truncate "int<zr>(%1)"
  syntax function floor    "int<dn>(%1)"
  syntax function ceil     "int<up>(%1)"

end

theory real.FromInt

  syntax function from_int "%1"

  remove prop Zero
  remove prop One

end

theory floating_point.Single

  syntax function round "float<ieee_32,%1>(%2)"
  meta "instantiate : auto" prop Bounded_value

end

theory floating_point.Double

  syntax function round "float<ieee_64,%1>(%2)"
  meta "instantiate : auto" prop Bounded_value

end

theory floating_point.Rounding

  syntax function NearestTiesToEven "ne"
  syntax function ToZero "zr"
  syntax function Up "up"
  syntax function Down "dn"
  syntax function NearTiesToAway "na"

end

(*
Local Variables:
mode: why
compile-command: "make -C .. bench"
End:
*)
