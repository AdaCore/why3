
(* Why driver for Simplify *)

prelude ";;; this is a prelude for Simplify"

printer "simplify"
filename "%f-%t-%g.sx"

valid "\\bValid\\b"
unknown "\\bInvalid\\b" "Unknown"

transformation "simplify_recursive_definition"      
transformation "inline_trivial"

transformation "eliminate_builtin"
transformation "eliminate_definition"(*_func"*)
transformation "eliminate_inductive"
transformation "eliminate_algebraic"
transformation "eliminate_if"
transformation "eliminate_let"
transformation "simplify_formula"
transformation "simplify_trivial_quantification"

transformation "remove_triggers"
(*transformation "filter_trigger_no_predicate"*)
(* predicate are *currently* translated to P(\x) = true, thus in a
trigger they can't appear since = can't appear *)
(*transformation "filter_trigger_builtin"*)

(* Add the projections for enumeration types*)
transformation "encoding_enumeration"

(* encode the polymorphism and sort *)
(*transformation "encoding_decorate_mono"*)
transformation "explicit_polymorphism"

theory BuiltIn
  syntax type int   "Int"
  syntax type real  "Real"
  syntax logic (=)  "(EQ %1 %2)"
  syntax logic (<>) "(NEQ %1 %2)"
end

theory int.Int

  prelude ";;; this is a prelude for Simplify, Arithmetic"

  syntax logic zero "0"

  syntax logic (+)  "(+ %1 %2)"
  syntax logic (-)  "(- %1 %2)"
  syntax logic (*)  "(* %1 %2)"
  syntax logic (-_) "(- 0 %1)"

  syntax logic (<=) "(<= %1 %2)"
  syntax logic (<)  "(< %1 %2)"
  syntax logic (>=) "(>= %1 %2)"
  syntax logic (>)  "(> %1 %2)"

  remove prop CommutativeGroup.Comm.Comm
  remove prop CommutativeGroup.Assoc.Assoc
  remove prop CommutativeGroup.Unit_def
  remove prop CommutativeGroup.Inv_def
  remove prop Assoc.Assoc
  remove prop Mul_distr
  remove prop Comm.Comm
  remove prop Unitary
  remove prop Refl
  remove prop Trans
  remove prop Antisymm
  remove prop Total
end

(*
Local Variables: 
mode: why
compile-command: "make -C .. bench"
End: 
*)
